{"ast":null,"code":"/*!\n * ONNX Runtime Web v1.20.1\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nvar Hd = Object.create;\nvar an = Object.defineProperty;\nvar qd = Object.getOwnPropertyDescriptor;\nvar jd = Object.getOwnPropertyNames;\nvar Xd = Object.getPrototypeOf,\n  Kd = Object.prototype.hasOwnProperty;\nvar Co = (i => typeof require < \"u\" ? require : typeof Proxy < \"u\" ? new Proxy(i, {\n  get: (e, o) => (typeof require < \"u\" ? require : e)[o]\n}) : i)(function (i) {\n  if (typeof require < \"u\") return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + i + '\" is not supported');\n});\nvar O = (i, e) => () => (i && (e = i(i = 0)), e);\nvar mt = (i, e) => () => (e || i((e = {\n    exports: {}\n  }).exports, e), e.exports),\n  Or = (i, e) => {\n    for (var o in e) an(i, o, {\n      get: e[o],\n      enumerable: !0\n    });\n  },\n  Qa = (i, e, o, t) => {\n    if (e && typeof e == \"object\" || typeof e == \"function\") for (let r of jd(e)) !Kd.call(i, r) && r !== o && an(i, r, {\n      get: () => e[r],\n      enumerable: !(t = qd(e, r)) || t.enumerable\n    });\n    return i;\n  };\nvar rr = (i, e, o) => (o = i != null ? Hd(Xd(i)) : {}, Qa(e || !i || !i.__esModule ? an(o, \"default\", {\n    value: i,\n    enumerable: !0\n  }) : o, i)),\n  sn = i => Qa(an({}, \"__esModule\", {\n    value: !0\n  }), i);\nvar un,\n  ke,\n  nr,\n  Jd,\n  ln,\n  fn = O(() => {\n    \"use strict\";\n\n    un = new Map(), ke = [], nr = (i, e, o) => {\n      if (e && typeof e.init == \"function\" && typeof e.createInferenceSessionHandler == \"function\") {\n        let t = un.get(i);\n        if (t === void 0) un.set(i, {\n          backend: e,\n          priority: o\n        });else {\n          if (t.priority > o) return;\n          if (t.priority === o && t.backend !== e) throw new Error(`cannot register backend \"${i}\" using priority ${o}`);\n        }\n        if (o >= 0) {\n          let r = ke.indexOf(i);\n          r !== -1 && ke.splice(r, 1);\n          for (let n = 0; n < ke.length; n++) if (un.get(ke[n]).priority <= o) {\n            ke.splice(n, 0, i);\n            return;\n          }\n          ke.push(i);\n        }\n        return;\n      }\n      throw new TypeError(\"not a valid backend\");\n    }, Jd = async i => {\n      let e = un.get(i);\n      if (!e) return \"backend not found.\";\n      if (e.initialized) return e.backend;\n      if (e.aborted) return e.error;\n      {\n        let o = !!e.initPromise;\n        try {\n          return o || (e.initPromise = e.backend.init(i)), await e.initPromise, e.initialized = !0, e.backend;\n        } catch (t) {\n          return o || (e.error = `${t}`, e.aborted = !0), e.error;\n        } finally {\n          delete e.initPromise;\n        }\n      }\n    }, ln = async i => {\n      let e = i.executionProviders || [],\n        o = e.map(u => typeof u == \"string\" ? u : u.name),\n        t = o.length === 0 ? ke : o,\n        r,\n        n = [],\n        s = new Set();\n      for (let u of t) {\n        let l = await Jd(u);\n        typeof l == \"string\" ? n.push({\n          name: u,\n          err: l\n        }) : (r || (r = l), r === l && s.add(u));\n      }\n      if (!r) throw new Error(`no available backend found. ERR: ${n.map(u => `[${u.name}] ${u.err}`).join(\", \")}`);\n      for (let {\n        name: u,\n        err: l\n      } of n) o.includes(u) && console.warn(`removing requested execution provider \"${u}\" from session options because it is not available: ${l}`);\n      let a = e.filter(u => s.has(typeof u == \"string\" ? u : u.name));\n      return [r, new Proxy(i, {\n        get: (u, l) => l === \"executionProviders\" ? a : Reflect.get(u, l)\n      })];\n    };\n  });\nvar ts = O(() => {\n  \"use strict\";\n\n  fn();\n});\nvar es,\n  rs = O(() => {\n    \"use strict\";\n\n    es = \"1.20.1\";\n  });\nvar ns,\n  Gt,\n  No = O(() => {\n    \"use strict\";\n\n    rs();\n    ns = \"warning\", Gt = {\n      wasm: {},\n      webgl: {},\n      webgpu: {},\n      versions: {\n        common: es\n      },\n      set logLevel(i) {\n        if (i !== void 0) {\n          if (typeof i != \"string\" || [\"verbose\", \"info\", \"warning\", \"error\", \"fatal\"].indexOf(i) === -1) throw new Error(`Unsupported logging level: ${i}`);\n          ns = i;\n        }\n      },\n      get logLevel() {\n        return ns;\n      }\n    };\n    Object.defineProperty(Gt, \"logLevel\", {\n      enumerable: !0\n    });\n  });\nvar z,\n  os = O(() => {\n    \"use strict\";\n\n    No();\n    z = Gt;\n  });\nvar is,\n  as,\n  ss = O(() => {\n    \"use strict\";\n\n    is = (i, e) => {\n      let o = typeof document < \"u\" ? document.createElement(\"canvas\") : new OffscreenCanvas(1, 1);\n      o.width = i.dims[3], o.height = i.dims[2];\n      let t = o.getContext(\"2d\");\n      if (t != null) {\n        let r, n;\n        e?.tensorLayout !== void 0 && e.tensorLayout === \"NHWC\" ? (r = i.dims[2], n = i.dims[3]) : (r = i.dims[3], n = i.dims[2]);\n        let s = e?.format !== void 0 ? e.format : \"RGB\",\n          a = e?.norm,\n          u,\n          l;\n        a === void 0 || a.mean === void 0 ? u = [255, 255, 255, 255] : typeof a.mean == \"number\" ? u = [a.mean, a.mean, a.mean, a.mean] : (u = [a.mean[0], a.mean[1], a.mean[2], 0], a.mean[3] !== void 0 && (u[3] = a.mean[3])), a === void 0 || a.bias === void 0 ? l = [0, 0, 0, 0] : typeof a.bias == \"number\" ? l = [a.bias, a.bias, a.bias, a.bias] : (l = [a.bias[0], a.bias[1], a.bias[2], 0], a.bias[3] !== void 0 && (l[3] = a.bias[3]));\n        let f = n * r,\n          p = 0,\n          d = f,\n          y = f * 2,\n          T = -1;\n        s === \"RGBA\" ? (p = 0, d = f, y = f * 2, T = f * 3) : s === \"RGB\" ? (p = 0, d = f, y = f * 2) : s === \"RBG\" && (p = 0, y = f, d = f * 2);\n        for (let v = 0; v < n; v++) for (let S = 0; S < r; S++) {\n          let L = (i.data[p++] - l[0]) * u[0],\n            P = (i.data[d++] - l[1]) * u[1],\n            A = (i.data[y++] - l[2]) * u[2],\n            M = T === -1 ? 255 : (i.data[T++] - l[3]) * u[3];\n          t.fillStyle = \"rgba(\" + L + \",\" + P + \",\" + A + \",\" + M + \")\", t.fillRect(S, v, 1, 1);\n        }\n        if (\"toDataURL\" in o) return o.toDataURL();\n        throw new Error(\"toDataURL is not supported\");\n      } else throw new Error(\"Can not access image data\");\n    }, as = (i, e) => {\n      let o = typeof document < \"u\" ? document.createElement(\"canvas\").getContext(\"2d\") : new OffscreenCanvas(1, 1).getContext(\"2d\"),\n        t;\n      if (o != null) {\n        let r, n, s;\n        e?.tensorLayout !== void 0 && e.tensorLayout === \"NHWC\" ? (r = i.dims[2], n = i.dims[1], s = i.dims[3]) : (r = i.dims[3], n = i.dims[2], s = i.dims[1]);\n        let a = e !== void 0 && e.format !== void 0 ? e.format : \"RGB\",\n          u = e?.norm,\n          l,\n          f;\n        u === void 0 || u.mean === void 0 ? l = [255, 255, 255, 255] : typeof u.mean == \"number\" ? l = [u.mean, u.mean, u.mean, u.mean] : (l = [u.mean[0], u.mean[1], u.mean[2], 255], u.mean[3] !== void 0 && (l[3] = u.mean[3])), u === void 0 || u.bias === void 0 ? f = [0, 0, 0, 0] : typeof u.bias == \"number\" ? f = [u.bias, u.bias, u.bias, u.bias] : (f = [u.bias[0], u.bias[1], u.bias[2], 0], u.bias[3] !== void 0 && (f[3] = u.bias[3]));\n        let p = n * r;\n        if (e !== void 0 && (e.format !== void 0 && s === 4 && e.format !== \"RGBA\" || s === 3 && e.format !== \"RGB\" && e.format !== \"BGR\")) throw new Error(\"Tensor format doesn't match input tensor dims\");\n        let d = 4,\n          y = 0,\n          T = 1,\n          v = 2,\n          S = 3,\n          L = 0,\n          P = p,\n          A = p * 2,\n          M = -1;\n        a === \"RGBA\" ? (L = 0, P = p, A = p * 2, M = p * 3) : a === \"RGB\" ? (L = 0, P = p, A = p * 2) : a === \"RBG\" && (L = 0, A = p, P = p * 2), t = o.createImageData(r, n);\n        for (let V = 0; V < n * r; y += d, T += d, v += d, S += d, V++) t.data[y] = (i.data[L++] - f[0]) * l[0], t.data[T] = (i.data[P++] - f[1]) * l[1], t.data[v] = (i.data[A++] - f[2]) * l[2], t.data[S] = M === -1 ? 255 : (i.data[M++] - f[3]) * l[3];\n      } else throw new Error(\"Can not access image data\");\n      return t;\n    };\n  });\nvar Ro,\n  us,\n  ls,\n  fs,\n  cs,\n  ps,\n  ds = O(() => {\n    \"use strict\";\n\n    cn();\n    Ro = (i, e) => {\n      if (i === void 0) throw new Error(\"Image buffer must be defined\");\n      if (e.height === void 0 || e.width === void 0) throw new Error(\"Image height and width must be defined\");\n      if (e.tensorLayout === \"NHWC\") throw new Error(\"NHWC Tensor layout is not supported yet\");\n      let {\n          height: o,\n          width: t\n        } = e,\n        r = e.norm ?? {\n          mean: 255,\n          bias: 0\n        },\n        n,\n        s;\n      typeof r.mean == \"number\" ? n = [r.mean, r.mean, r.mean, r.mean] : n = [r.mean[0], r.mean[1], r.mean[2], r.mean[3] ?? 255], typeof r.bias == \"number\" ? s = [r.bias, r.bias, r.bias, r.bias] : s = [r.bias[0], r.bias[1], r.bias[2], r.bias[3] ?? 0];\n      let a = e.format !== void 0 ? e.format : \"RGBA\",\n        u = e.tensorFormat !== void 0 && e.tensorFormat !== void 0 ? e.tensorFormat : \"RGB\",\n        l = o * t,\n        f = u === \"RGBA\" ? new Float32Array(l * 4) : new Float32Array(l * 3),\n        p = 4,\n        d = 0,\n        y = 1,\n        T = 2,\n        v = 3,\n        S = 0,\n        L = l,\n        P = l * 2,\n        A = -1;\n      a === \"RGB\" && (p = 3, d = 0, y = 1, T = 2, v = -1), u === \"RGBA\" ? A = l * 3 : u === \"RBG\" ? (S = 0, P = l, L = l * 2) : u === \"BGR\" && (P = 0, L = l, S = l * 2);\n      for (let V = 0; V < l; V++, d += p, T += p, y += p, v += p) f[S++] = (i[d] + s[0]) / n[0], f[L++] = (i[y] + s[1]) / n[1], f[P++] = (i[T] + s[2]) / n[2], A !== -1 && v !== -1 && (f[A++] = (i[v] + s[3]) / n[3]);\n      return u === \"RGBA\" ? new St(\"float32\", f, [1, 4, o, t]) : new St(\"float32\", f, [1, 3, o, t]);\n    }, us = async (i, e) => {\n      let o = typeof HTMLImageElement < \"u\" && i instanceof HTMLImageElement,\n        t = typeof ImageData < \"u\" && i instanceof ImageData,\n        r = typeof ImageBitmap < \"u\" && i instanceof ImageBitmap,\n        n = typeof i == \"string\",\n        s,\n        a = e ?? {},\n        u = () => {\n          if (typeof document < \"u\") return document.createElement(\"canvas\");\n          if (typeof OffscreenCanvas < \"u\") return new OffscreenCanvas(1, 1);\n          throw new Error(\"Canvas is not supported\");\n        },\n        l = f => typeof HTMLCanvasElement < \"u\" && f instanceof HTMLCanvasElement || f instanceof OffscreenCanvas ? f.getContext(\"2d\") : null;\n      if (o) {\n        let f = u();\n        f.width = i.width, f.height = i.height;\n        let p = l(f);\n        if (p != null) {\n          let d = i.height,\n            y = i.width;\n          if (e !== void 0 && e.resizedHeight !== void 0 && e.resizedWidth !== void 0 && (d = e.resizedHeight, y = e.resizedWidth), e !== void 0) {\n            if (a = e, e.tensorFormat !== void 0) throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");\n            a.tensorFormat = \"RGBA\", a.height = d, a.width = y;\n          } else a.tensorFormat = \"RGBA\", a.height = d, a.width = y;\n          p.drawImage(i, 0, 0), s = p.getImageData(0, 0, y, d).data;\n        } else throw new Error(\"Can not access image data\");\n      } else if (t) {\n        let f, p;\n        if (e !== void 0 && e.resizedWidth !== void 0 && e.resizedHeight !== void 0 ? (f = e.resizedHeight, p = e.resizedWidth) : (f = i.height, p = i.width), e !== void 0 && (a = e), a.format = \"RGBA\", a.height = f, a.width = p, e !== void 0) {\n          let d = u();\n          d.width = p, d.height = f;\n          let y = l(d);\n          if (y != null) y.putImageData(i, 0, 0), s = y.getImageData(0, 0, p, f).data;else throw new Error(\"Can not access image data\");\n        } else s = i.data;\n      } else if (r) {\n        if (e === void 0) throw new Error(\"Please provide image config with format for Imagebitmap\");\n        let f = u();\n        f.width = i.width, f.height = i.height;\n        let p = l(f);\n        if (p != null) {\n          let d = i.height,\n            y = i.width;\n          return p.drawImage(i, 0, 0, y, d), s = p.getImageData(0, 0, y, d).data, a.height = d, a.width = y, Ro(s, a);\n        } else throw new Error(\"Can not access image data\");\n      } else {\n        if (n) return new Promise((f, p) => {\n          let d = u(),\n            y = l(d);\n          if (!i || !y) return p();\n          let T = new Image();\n          T.crossOrigin = \"Anonymous\", T.src = i, T.onload = () => {\n            d.width = T.width, d.height = T.height, y.drawImage(T, 0, 0, d.width, d.height);\n            let v = y.getImageData(0, 0, d.width, d.height);\n            a.height = d.height, a.width = d.width, f(Ro(v.data, a));\n          };\n        });\n        throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n      }\n      if (s !== void 0) return Ro(s, a);\n      throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n    }, ls = (i, e) => {\n      let {\n          width: o,\n          height: t,\n          download: r,\n          dispose: n\n        } = e,\n        s = [1, t, o, 4];\n      return new St({\n        location: \"texture\",\n        type: \"float32\",\n        texture: i,\n        dims: s,\n        download: r,\n        dispose: n\n      });\n    }, fs = (i, e) => {\n      let {\n        dataType: o,\n        dims: t,\n        download: r,\n        dispose: n\n      } = e;\n      return new St({\n        location: \"gpu-buffer\",\n        type: o ?? \"float32\",\n        gpuBuffer: i,\n        dims: t,\n        download: r,\n        dispose: n\n      });\n    }, cs = (i, e) => {\n      let {\n        dataType: o,\n        dims: t,\n        download: r,\n        dispose: n\n      } = e;\n      return new St({\n        location: \"ml-tensor\",\n        type: o ?? \"float32\",\n        mlTensor: i,\n        dims: t,\n        download: r,\n        dispose: n\n      });\n    }, ps = (i, e, o) => new St({\n      location: \"cpu-pinned\",\n      type: i,\n      data: e,\n      dims: o ?? [e.length]\n    });\n  });\nvar Be,\n  Sr,\n  hs,\n  ms,\n  bs = O(() => {\n    \"use strict\";\n\n    Be = new Map([[\"float32\", Float32Array], [\"uint8\", Uint8Array], [\"int8\", Int8Array], [\"uint16\", Uint16Array], [\"int16\", Int16Array], [\"int32\", Int32Array], [\"bool\", Uint8Array], [\"float64\", Float64Array], [\"uint32\", Uint32Array], [\"int4\", Uint8Array], [\"uint4\", Uint8Array]]), Sr = new Map([[Float32Array, \"float32\"], [Uint8Array, \"uint8\"], [Int8Array, \"int8\"], [Uint16Array, \"uint16\"], [Int16Array, \"int16\"], [Int32Array, \"int32\"], [Float64Array, \"float64\"], [Uint32Array, \"uint32\"]]), hs = !1, ms = () => {\n      if (!hs) {\n        hs = !0;\n        let i = typeof BigInt64Array < \"u\" && BigInt64Array.from,\n          e = typeof BigUint64Array < \"u\" && BigUint64Array.from,\n          o = typeof Float16Array < \"u\" && Float16Array.from;\n        i && (Be.set(\"int64\", BigInt64Array), Sr.set(BigInt64Array, \"int64\")), e && (Be.set(\"uint64\", BigUint64Array), Sr.set(BigUint64Array, \"uint64\")), o ? (Be.set(\"float16\", Float16Array), Sr.set(Float16Array, \"float16\")) : Be.set(\"float16\", Uint16Array);\n      }\n    };\n  });\nvar gs,\n  ys,\n  xs = O(() => {\n    \"use strict\";\n\n    cn();\n    gs = i => {\n      let e = 1;\n      for (let o = 0; o < i.length; o++) {\n        let t = i[o];\n        if (typeof t != \"number\" || !Number.isSafeInteger(t)) throw new TypeError(`dims[${o}] must be an integer, got: ${t}`);\n        if (t < 0) throw new RangeError(`dims[${o}] must be a non-negative integer, got: ${t}`);\n        e *= t;\n      }\n      return e;\n    }, ys = (i, e) => {\n      switch (i.location) {\n        case \"cpu\":\n          return new St(i.type, i.data, e);\n        case \"cpu-pinned\":\n          return new St({\n            location: \"cpu-pinned\",\n            data: i.data,\n            type: i.type,\n            dims: e\n          });\n        case \"texture\":\n          return new St({\n            location: \"texture\",\n            texture: i.texture,\n            type: i.type,\n            dims: e\n          });\n        case \"gpu-buffer\":\n          return new St({\n            location: \"gpu-buffer\",\n            gpuBuffer: i.gpuBuffer,\n            type: i.type,\n            dims: e\n          });\n        case \"ml-tensor\":\n          return new St({\n            location: \"ml-tensor\",\n            mlTensor: i.mlTensor,\n            type: i.type,\n            dims: e\n          });\n        default:\n          throw new Error(`tensorReshape: tensor location ${i.location} is not supported`);\n      }\n    };\n  });\nvar St,\n  cn = O(() => {\n    \"use strict\";\n\n    ss();\n    ds();\n    bs();\n    xs();\n    St = class {\n      constructor(e, o, t) {\n        ms();\n        let r, n;\n        if (typeof e == \"object\" && \"location\" in e) switch (this.dataLocation = e.location, r = e.type, n = e.dims, e.location) {\n          case \"cpu-pinned\":\n            {\n              let a = Be.get(r);\n              if (!a) throw new TypeError(`unsupported type \"${r}\" to create tensor from pinned buffer`);\n              if (!(e.data instanceof a)) throw new TypeError(`buffer should be of type ${a.name}`);\n              this.cpuData = e.data;\n              break;\n            }\n          case \"texture\":\n            {\n              if (r !== \"float32\") throw new TypeError(`unsupported type \"${r}\" to create tensor from texture`);\n              this.gpuTextureData = e.texture, this.downloader = e.download, this.disposer = e.dispose;\n              break;\n            }\n          case \"gpu-buffer\":\n            {\n              if (r !== \"float32\" && r !== \"float16\" && r !== \"int32\" && r !== \"int64\" && r !== \"uint32\" && r !== \"uint8\" && r !== \"bool\" && r !== \"uint4\" && r !== \"int4\") throw new TypeError(`unsupported type \"${r}\" to create tensor from gpu buffer`);\n              this.gpuBufferData = e.gpuBuffer, this.downloader = e.download, this.disposer = e.dispose;\n              break;\n            }\n          case \"ml-tensor\":\n            {\n              if (r !== \"float32\" && r !== \"float16\" && r !== \"int32\" && r !== \"int64\" && r !== \"uint32\" && r !== \"uint64\" && r !== \"int8\" && r !== \"uint8\" && r !== \"bool\") throw new TypeError(`unsupported type \"${r}\" to create tensor from MLTensor`);\n              this.mlTensorData = e.mlTensor, this.downloader = e.download, this.disposer = e.dispose;\n              break;\n            }\n          default:\n            throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);\n        } else {\n          let a, u;\n          if (typeof e == \"string\") {\n            if (r = e, u = t, e === \"string\") {\n              if (!Array.isArray(o)) throw new TypeError(\"A string tensor's data must be a string array.\");\n              a = o;\n            } else {\n              let l = Be.get(e);\n              if (l === void 0) throw new TypeError(`Unsupported tensor type: ${e}.`);\n              if (Array.isArray(o)) {\n                if (e === \"float16\" && l === Uint16Array || e === \"uint4\" || e === \"int4\") throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${l.name} as data.`);\n                e === \"uint64\" || e === \"int64\" ? a = l.from(o, BigInt) : a = l.from(o);\n              } else if (o instanceof l) a = o;else if (o instanceof Uint8ClampedArray) {\n                if (e === \"uint8\") a = Uint8Array.from(o);else throw new TypeError(\"A Uint8ClampedArray tensor's data must be type of uint8\");\n              } else throw new TypeError(`A ${r} tensor's data must be type of ${l}`);\n            }\n          } else if (u = o, Array.isArray(e)) {\n            if (e.length === 0) throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");\n            let l = typeof e[0];\n            if (l === \"string\") r = \"string\", a = e;else if (l === \"boolean\") r = \"bool\", a = Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${l}.`);\n          } else if (e instanceof Uint8ClampedArray) r = \"uint8\", a = Uint8Array.from(e);else {\n            let l = Sr.get(e.constructor);\n            if (l === void 0) throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);\n            r = l, a = e;\n          }\n          if (u === void 0) u = [a.length];else if (!Array.isArray(u)) throw new TypeError(\"A tensor's dims must be a number array\");\n          n = u, this.cpuData = a, this.dataLocation = \"cpu\";\n        }\n        let s = gs(n);\n        if (this.cpuData && s !== this.cpuData.length && !((r === \"uint4\" || r === \"int4\") && Math.ceil(s / 2) === this.cpuData.length)) throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);\n        this.type = r, this.dims = n, this.size = s;\n      }\n      static async fromImage(e, o) {\n        return us(e, o);\n      }\n      static fromTexture(e, o) {\n        return ls(e, o);\n      }\n      static fromGpuBuffer(e, o) {\n        return fs(e, o);\n      }\n      static fromMLTensor(e, o) {\n        return cs(e, o);\n      }\n      static fromPinnedBuffer(e, o, t) {\n        return ps(e, o, t);\n      }\n      toDataURL(e) {\n        return is(this, e);\n      }\n      toImageData(e) {\n        return as(this, e);\n      }\n      get data() {\n        if (this.ensureValid(), !this.cpuData) throw new Error(\"The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.\");\n        return this.cpuData;\n      }\n      get location() {\n        return this.dataLocation;\n      }\n      get texture() {\n        if (this.ensureValid(), !this.gpuTextureData) throw new Error(\"The data is not stored as a WebGL texture.\");\n        return this.gpuTextureData;\n      }\n      get gpuBuffer() {\n        if (this.ensureValid(), !this.gpuBufferData) throw new Error(\"The data is not stored as a WebGPU buffer.\");\n        return this.gpuBufferData;\n      }\n      get mlTensor() {\n        if (this.ensureValid(), !this.mlTensorData) throw new Error(\"The data is not stored as a WebNN MLTensor.\");\n        return this.mlTensorData;\n      }\n      async getData(e) {\n        switch (this.ensureValid(), this.dataLocation) {\n          case \"cpu\":\n          case \"cpu-pinned\":\n            return this.data;\n          case \"texture\":\n          case \"gpu-buffer\":\n          case \"ml-tensor\":\n            {\n              if (!this.downloader) throw new Error(\"The current tensor is not created with a specified data downloader.\");\n              if (this.isDownloading) throw new Error(\"The current tensor is being downloaded.\");\n              try {\n                this.isDownloading = !0;\n                let o = await this.downloader();\n                return this.downloader = void 0, this.dataLocation = \"cpu\", this.cpuData = o, e && this.disposer && (this.disposer(), this.disposer = void 0), o;\n              } finally {\n                this.isDownloading = !1;\n              }\n            }\n          default:\n            throw new Error(`cannot get data from location: ${this.dataLocation}`);\n        }\n      }\n      dispose() {\n        if (this.isDownloading) throw new Error(\"The current tensor is being downloaded.\");\n        this.disposer && (this.disposer(), this.disposer = void 0), this.cpuData = void 0, this.gpuTextureData = void 0, this.gpuBufferData = void 0, this.mlTensorData = void 0, this.downloader = void 0, this.isDownloading = void 0, this.dataLocation = \"none\";\n      }\n      ensureValid() {\n        if (this.dataLocation === \"none\") throw new Error(\"The tensor is disposed.\");\n      }\n      reshape(e) {\n        if (this.ensureValid(), this.downloader || this.disposer) throw new Error(\"Cannot reshape a tensor that owns GPU resource.\");\n        return ys(this, e);\n      }\n    };\n  });\nvar yt,\n  pn = O(() => {\n    \"use strict\";\n\n    cn();\n    yt = St;\n  });\nvar Ts,\n  ws,\n  Fe,\n  Ce,\n  Go = O(() => {\n    \"use strict\";\n\n    No();\n    Ts = (i, e) => {\n      (typeof Gt.trace > \"u\" ? !Gt.wasm.trace : !Gt.trace) || console.timeStamp(`${i}::ORT::${e}`);\n    }, ws = (i, e) => {\n      let o = new Error().stack?.split(/\\r\\n|\\r|\\n/g) || [],\n        t = !1;\n      for (let r = 0; r < o.length; r++) {\n        if (t && !o[r].includes(\"TRACE_FUNC\")) {\n          let n = `FUNC_${i}::${o[r].trim().split(\" \")[1]}`;\n          e && (n += `::${e}`), Ts(\"CPU\", n);\n          return;\n        }\n        o[r].includes(\"TRACE_FUNC\") && (t = !0);\n      }\n    }, Fe = i => {\n      (typeof Gt.trace > \"u\" ? !Gt.wasm.trace : !Gt.trace) || ws(\"BEGIN\", i);\n    }, Ce = i => {\n      (typeof Gt.trace > \"u\" ? !Gt.wasm.trace : !Gt.trace) || ws(\"END\", i);\n    };\n  });\nvar dn,\n  vs = O(() => {\n    \"use strict\";\n\n    fn();\n    pn();\n    Go();\n    dn = class i {\n      constructor(e) {\n        this.handler = e;\n      }\n      async run(e, o, t) {\n        Fe();\n        let r = {},\n          n = {};\n        if (typeof e != \"object\" || e === null || e instanceof yt || Array.isArray(e)) throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");\n        let s = !0;\n        if (typeof o == \"object\") {\n          if (o === null) throw new TypeError(\"Unexpected argument[1]: cannot be null.\");\n          if (o instanceof yt) throw new TypeError(\"'fetches' cannot be a Tensor\");\n          if (Array.isArray(o)) {\n            if (o.length === 0) throw new TypeError(\"'fetches' cannot be an empty array.\");\n            s = !1;\n            for (let l of o) {\n              if (typeof l != \"string\") throw new TypeError(\"'fetches' must be a string array or an object.\");\n              if (this.outputNames.indexOf(l) === -1) throw new RangeError(`'fetches' contains invalid output name: ${l}.`);\n              r[l] = null;\n            }\n            if (typeof t == \"object\" && t !== null) n = t;else if (typeof t < \"u\") throw new TypeError(\"'options' must be an object.\");\n          } else {\n            let l = !1,\n              f = Object.getOwnPropertyNames(o);\n            for (let p of this.outputNames) if (f.indexOf(p) !== -1) {\n              let d = o[p];\n              (d === null || d instanceof yt) && (l = !0, s = !1, r[p] = d);\n            }\n            if (l) {\n              if (typeof t == \"object\" && t !== null) n = t;else if (typeof t < \"u\") throw new TypeError(\"'options' must be an object.\");\n            } else n = o;\n          }\n        } else if (typeof o < \"u\") throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n        for (let l of this.inputNames) if (typeof e[l] > \"u\") throw new Error(`input '${l}' is missing in 'feeds'.`);\n        if (s) for (let l of this.outputNames) r[l] = null;\n        let a = await this.handler.run(e, r, n),\n          u = {};\n        for (let l in a) if (Object.hasOwnProperty.call(a, l)) {\n          let f = a[l];\n          f instanceof yt ? u[l] = f : u[l] = new yt(f.type, f.data, f.dims);\n        }\n        return Ce(), u;\n      }\n      async release() {\n        return this.handler.dispose();\n      }\n      static async create(e, o, t, r) {\n        Fe();\n        let n,\n          s = {};\n        if (typeof e == \"string\") {\n          if (n = e, typeof o == \"object\" && o !== null) s = o;else if (typeof o < \"u\") throw new TypeError(\"'options' must be an object.\");\n        } else if (e instanceof Uint8Array) {\n          if (n = e, typeof o == \"object\" && o !== null) s = o;else if (typeof o < \"u\") throw new TypeError(\"'options' must be an object.\");\n        } else if (e instanceof ArrayBuffer || typeof SharedArrayBuffer < \"u\" && e instanceof SharedArrayBuffer) {\n          let f = e,\n            p = 0,\n            d = e.byteLength;\n          if (typeof o == \"object\" && o !== null) s = o;else if (typeof o == \"number\") {\n            if (p = o, !Number.isSafeInteger(p)) throw new RangeError(\"'byteOffset' must be an integer.\");\n            if (p < 0 || p >= f.byteLength) throw new RangeError(`'byteOffset' is out of range [0, ${f.byteLength}).`);\n            if (d = e.byteLength - p, typeof t == \"number\") {\n              if (d = t, !Number.isSafeInteger(d)) throw new RangeError(\"'byteLength' must be an integer.\");\n              if (d <= 0 || p + d > f.byteLength) throw new RangeError(`'byteLength' is out of range (0, ${f.byteLength - p}].`);\n              if (typeof r == \"object\" && r !== null) s = r;else if (typeof r < \"u\") throw new TypeError(\"'options' must be an object.\");\n            } else if (typeof t < \"u\") throw new TypeError(\"'byteLength' must be a number.\");\n          } else if (typeof o < \"u\") throw new TypeError(\"'options' must be an object.\");\n          n = new Uint8Array(f, p, d);\n        } else throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");\n        let [a, u] = await ln(s),\n          l = await a.createInferenceSessionHandler(n, u);\n        return Ce(), new i(l);\n      }\n      startProfiling() {\n        this.handler.startProfiling();\n      }\n      endProfiling() {\n        this.handler.endProfiling();\n      }\n      get inputNames() {\n        return this.handler.inputNames;\n      }\n      get outputNames() {\n        return this.handler.outputNames;\n      }\n    };\n  });\nvar Yd,\n  Is = O(() => {\n    \"use strict\";\n\n    vs();\n    Yd = dn;\n  });\nvar _s = O(() => {\n  \"use strict\";\n});\nvar Os = O(() => {\n  \"use strict\";\n});\nvar Ss = O(() => {\n  \"use strict\";\n});\nvar As = O(() => {\n  \"use strict\";\n});\nvar Zd,\n  hn,\n  Ps = O(() => {\n    \"use strict\";\n\n    fn();\n    pn();\n    Zd = \"Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.\", hn = class i {\n      constructor(e, o, t) {\n        this.handler = e, this.hasOptimizerModel = o, this.hasEvalModel = t;\n      }\n      get trainingInputNames() {\n        return this.handler.inputNames;\n      }\n      get trainingOutputNames() {\n        return this.handler.outputNames;\n      }\n      get evalInputNames() {\n        if (this.hasEvalModel) return this.handler.evalInputNames;\n        throw new Error(\"This training session has no evalModel loaded.\");\n      }\n      get evalOutputNames() {\n        if (this.hasEvalModel) return this.handler.evalOutputNames;\n        throw new Error(\"This training session has no evalModel loaded.\");\n      }\n      static async create(e, o) {\n        let t = e.evalModel || \"\",\n          r = e.optimizerModel || \"\",\n          n = o || {},\n          [s, a] = await ln(n);\n        if (s.createTrainingSessionHandler) {\n          let u = await s.createTrainingSessionHandler(e.checkpointState, e.trainModel, t, r, a);\n          return new i(u, !!e.optimizerModel, !!e.evalModel);\n        } else throw new Error(Zd);\n      }\n      typeNarrowingForRunStep(e, o, t, r, n) {\n        let s = {},\n          a = {};\n        if (typeof t != \"object\" || t === null || t instanceof yt || Array.isArray(t)) throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");\n        let u = !0;\n        if (typeof r == \"object\") {\n          if (r === null) throw new TypeError(\"Unexpected argument[1]: cannot be null.\");\n          if (r instanceof yt) throw new TypeError(\"'fetches' cannot be a Tensor\");\n          if (Array.isArray(r)) {\n            if (r.length === 0) throw new TypeError(\"'fetches' cannot be an empty array.\");\n            u = !1;\n            for (let l of r) {\n              if (typeof l != \"string\") throw new TypeError(\"'fetches' must be a string array or an object.\");\n              if (o.indexOf(l) === -1) throw new RangeError(`'fetches' contains invalid output name: ${l}.`);\n              s[l] = null;\n            }\n            if (typeof n == \"object\" && n !== null) a = n;else if (typeof n < \"u\") throw new TypeError(\"'options' must be an object.\");\n          } else {\n            let l = !1,\n              f = Object.getOwnPropertyNames(r);\n            for (let p of o) if (f.indexOf(p) !== -1) {\n              let d = r[p];\n              (d === null || d instanceof yt) && (l = !0, u = !1, s[p] = d);\n            }\n            if (l) {\n              if (typeof n == \"object\" && n !== null) a = n;else if (typeof n < \"u\") throw new TypeError(\"'options' must be an object.\");\n            } else a = r;\n          }\n        } else if (typeof r < \"u\") throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n        for (let l of e) if (typeof t[l] > \"u\") throw new Error(`input '${l}' is missing in 'feeds'.`);\n        if (u) for (let l of o) s[l] = null;\n        return [s, a];\n      }\n      convertHandlerReturnTypeToMapOfTensors(e) {\n        let o = {};\n        for (let t in e) if (Object.hasOwnProperty.call(e, t)) {\n          let r = e[t];\n          r instanceof yt ? o[t] = r : o[t] = new yt(r.type, r.data, r.dims);\n        }\n        return o;\n      }\n      async lazyResetGrad() {\n        await this.handler.lazyResetGrad();\n      }\n      async runTrainStep(e, o, t) {\n        let [r, n] = this.typeNarrowingForRunStep(this.trainingInputNames, this.trainingOutputNames, e, o, t),\n          s = await this.handler.runTrainStep(e, r, n);\n        return this.convertHandlerReturnTypeToMapOfTensors(s);\n      }\n      async runOptimizerStep(e) {\n        if (this.hasOptimizerModel) await this.handler.runOptimizerStep(e || {});else throw new Error(\"This TrainingSession has no OptimizerModel loaded.\");\n      }\n      async runEvalStep(e, o, t) {\n        if (this.hasEvalModel) {\n          let [r, n] = this.typeNarrowingForRunStep(this.evalInputNames, this.evalOutputNames, e, o, t),\n            s = await this.handler.runEvalStep(e, r, n);\n          return this.convertHandlerReturnTypeToMapOfTensors(s);\n        } else throw new Error(\"This TrainingSession has no EvalModel loaded.\");\n      }\n      async getParametersSize(e = !0) {\n        return this.handler.getParametersSize(e);\n      }\n      async loadParametersBuffer(e, o = !0) {\n        let t = await this.getParametersSize(o);\n        if (e.length !== 4 * t) throw new Error(\"Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.\");\n        return this.handler.loadParametersBuffer(e, o);\n      }\n      async getContiguousParameters(e = !0) {\n        return this.handler.getContiguousParameters(e);\n      }\n      async release() {\n        return this.handler.dispose();\n      }\n    };\n  });\nvar Qd,\n  Es = O(() => {\n    \"use strict\";\n\n    Ps();\n    Qd = hn;\n  });\nvar Mo = {};\nOr(Mo, {\n  InferenceSession: () => Yd,\n  TRACE: () => Ts,\n  TRACE_FUNC_BEGIN: () => Fe,\n  TRACE_FUNC_END: () => Ce,\n  Tensor: () => yt,\n  TrainingSession: () => Qd,\n  env: () => z,\n  registerBackend: () => nr\n});\nvar Yt = O(() => {\n  \"use strict\";\n\n  ts();\n  os();\n  Is();\n  pn();\n  _s();\n  Os();\n  Go();\n  Ss();\n  As();\n  Es();\n});\nfunction _e(i, e, o, t) {\n  if (e === void 0) return eh(i);\n  if (o === void 0) mn(i, e, 1);else if (typeof o == \"number\" && t === void 0) mn(i, e, o);else if (typeof o == \"string\" && t === void 0) mn(i, o, 1, e);else if (typeof o == \"string\" && typeof t == \"number\") mn(i, o, t, e);else throw new TypeError(\"input is valid\");\n}\nfunction eh(i) {\n  return {\n    verbose: _e.verbose.bind(null, i),\n    info: _e.info.bind(null, i),\n    warning: _e.warning.bind(null, i),\n    error: _e.error.bind(null, i),\n    fatal: _e.fatal.bind(null, i)\n  };\n}\nfunction mn(i, e, o, t) {\n  let r = Ar[t || \"\"] || Ar[\"\"];\n  Ls[i] < Ls[r.minimalSeverity] || (r.logDateTime && (e = `${new Date().toISOString()}|${e}`), r.logSourceLocation, th[r.provider].log(i, e, t));\n}\nvar Uo,\n  Vo,\n  Ls,\n  th,\n  $s,\n  Ar,\n  tt,\n  gn,\n  yn,\n  xn,\n  bn,\n  Ut = O(() => {\n    \"use strict\";\n\n    Uo = class {\n      log(e, o, t) {}\n    }, Vo = class {\n      log(e, o, t) {\n        console.log(`${this.color(e)} ${t ? \"\\x1B[35m\" + t + \"\\x1B[0m \" : \"\"}${o}`);\n      }\n      color(e) {\n        switch (e) {\n          case \"verbose\":\n            return \"\\x1B[34;40mv\\x1B[0m\";\n          case \"info\":\n            return \"\\x1B[32mi\\x1B[0m\";\n          case \"warning\":\n            return \"\\x1B[30;43mw\\x1B[0m\";\n          case \"error\":\n            return \"\\x1B[31;40me\\x1B[0m\";\n          case \"fatal\":\n            return \"\\x1B[101mf\\x1B[0m\";\n          default:\n            throw new Error(`unsupported severity: ${e}`);\n        }\n      }\n    }, Ls = {\n      verbose: 1e3,\n      info: 2e3,\n      warning: 4e3,\n      error: 5e3,\n      fatal: 6e3\n    }, th = {\n      none: new Uo(),\n      console: new Vo()\n    }, $s = {\n      provider: \"console\",\n      minimalSeverity: \"warning\",\n      logDateTime: !0,\n      logSourceLocation: !1\n    }, Ar = {\n      \"\": $s\n    };\n    (u => {\n      function i(l, f) {\n        u(\"verbose\", l, f);\n      }\n      u.verbose = i;\n      function e(l, f) {\n        u(\"info\", l, f);\n      }\n      u.info = e;\n      function o(l, f) {\n        u(\"warning\", l, f);\n      }\n      u.warning = o;\n      function t(l, f) {\n        u(\"error\", l, f);\n      }\n      u.error = t;\n      function r(l, f) {\n        u(\"fatal\", l, f);\n      }\n      u.fatal = r;\n      function n(l) {\n        Ar = {}, s(\"\", l || {});\n      }\n      u.reset = n;\n      function s(l, f) {\n        if (l === \"*\") n(f);else {\n          let p = Ar[l] || $s;\n          Ar[l] = {\n            provider: f.provider || p.provider,\n            minimalSeverity: f.minimalSeverity || p.minimalSeverity,\n            logDateTime: f.logDateTime === void 0 ? p.logDateTime : f.logDateTime,\n            logSourceLocation: f.logSourceLocation === void 0 ? p.logSourceLocation : f.logSourceLocation\n          };\n        }\n      }\n      u.set = s;\n      function a(l) {\n        let f = {};\n        l.logLevel && (f.minimalSeverity = l.logLevel), s(\"\", f);\n      }\n      u.setWithEnv = a;\n    })(_e ||= {});\n    tt = _e, gn = class {\n      constructor(e, o, t, r, n, s) {\n        this.category = e;\n        this.name = o;\n        this.startTime = t;\n        this.endCallback = r;\n        this.timer = n;\n        this.ctx = s;\n      }\n      async end() {\n        return this.endCallback(this);\n      }\n      async checkTimer() {\n        if (this.ctx === void 0 || this.timer === void 0) throw new Error(\"No webgl timer found\");\n        return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);\n      }\n    }, yn = class {\n      constructor(e, o, t, r) {\n        this.category = e;\n        this.name = o;\n        this.startTime = t;\n        this.endTime = r;\n      }\n    }, xn = class {\n      constructor(e, o, t) {\n        this._started = !1;\n        this._flushPointer = 0;\n        this._started = !1, this._maxNumberEvents = e === void 0 ? 1e4 : e, this._flushBatchSize = o === void 0 ? 10 : o, this._flushIntervalInMilliseconds = t === void 0 ? 5e3 : t;\n      }\n      static create(e) {\n        return e === void 0 ? new this() : new this(e.maxNumberEvents, e.flushBatchSize, e.flushIntervalInMilliseconds);\n      }\n      start() {\n        this._started = !0, this._timingEvents = [], this._flushTime = bn(), this._flushPointer = 0;\n      }\n      stop() {\n        for (this._started = !1; this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);\n      }\n      event(e, o, t, r) {\n        let n = this._started ? this.begin(e, o, r) : void 0,\n          s = !1,\n          a = t();\n        if (a && typeof a.then == \"function\") return s = !0, new Promise((u, l) => {\n          a.then(async f => {\n            n && (await n.end()), u(f);\n          }, async f => {\n            n && (await n.end()), l(f);\n          });\n        });\n        if (!s && n) {\n          let u = n.end();\n          if (u && typeof u.then == \"function\") return new Promise((l, f) => {\n            u.then(() => {\n              l(a);\n            }, p => {\n              f(p);\n            });\n          });\n        }\n        return a;\n      }\n      begin(e, o, t) {\n        if (!this._started) throw new Error(\"profiler is not started yet\");\n        if (t === void 0) {\n          let r = bn();\n          return this.flush(r), new gn(e, o, r, n => this.endSync(n));\n        } else {\n          let r = t.beginTimer();\n          return new gn(e, o, 0, async n => this.end(n), r, t);\n        }\n      }\n      async end(e) {\n        let o = await e.checkTimer();\n        this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new yn(e.category, e.name, e.startTime, o)), this.flush(o));\n      }\n      endSync(e) {\n        let o = bn();\n        this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new yn(e.category, e.name, e.startTime, o)), this.flush(o));\n      }\n      logOneEvent(e) {\n        tt.verbose(`Profiler.${e.category}`, `${(e.endTime - e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`);\n      }\n      flush(e) {\n        if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || e - this._flushTime >= this._flushIntervalInMilliseconds) {\n          for (let o = this._flushPointer; this._flushPointer < o + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);\n          this._flushTime = bn();\n        }\n      }\n      get started() {\n        return this._started;\n      }\n    }, bn = typeof performance < \"u\" && performance.now ? () => performance.now() : Date.now;\n  });\nfunction ks(i, e, o) {\n  for (let t of o) {\n    let r = t[0],\n      n = t[1],\n      s = t[2],\n      a = t[3],\n      u = t[4];\n    if (i.opType === r) {\n      for (let l of e) if ((l.domain === n || l.domain === \"ai.onnx\" && n === \"\") && rh(l.version, s)) return {\n        opImpl: a,\n        opInit: u\n      };\n    }\n  }\n  throw new TypeError(`cannot resolve operator '${i.opType}' with opsets: ${e.map(t => `${t.domain || \"ai.onnx\"} v${t.version}`).join(\", \")}`);\n}\nfunction rh(i, e) {\n  if (e.endsWith(\"+\")) {\n    let o = Number.parseInt(e.substring(0, e.length - 1), 10);\n    return !isNaN(o) && o <= i;\n  } else if (e.split(\"-\").length === 2) {\n    let o = e.split(\"-\"),\n      t = Number.parseInt(o[0], 10),\n      r = Number.parseInt(o[1], 10);\n    return !isNaN(t) && !isNaN(r) && t <= i && i <= r;\n  } else return Number.parseInt(e, 10) === i;\n}\nvar Bs = O(() => {\n  \"use strict\";\n});\nvar Fs = mt(zo => {\n  \"use strict\";\n\n  zo.__esModule = !0;\n  var nh = function () {\n    function i(e) {\n      if (!e) throw new TypeError(\"Invalid argument; `value` has no value.\");\n      this.value = i.EMPTY, e && i.isGuid(e) && (this.value = e);\n    }\n    return i.isGuid = function (e) {\n      var o = e.toString();\n      return e && (e instanceof i || i.validator.test(o));\n    }, i.create = function () {\n      return new i([i.gen(2), i.gen(1), i.gen(1), i.gen(1), i.gen(3)].join(\"-\"));\n    }, i.createEmpty = function () {\n      return new i(\"emptyguid\");\n    }, i.parse = function (e) {\n      return new i(e);\n    }, i.raw = function () {\n      return [i.gen(2), i.gen(1), i.gen(1), i.gen(1), i.gen(3)].join(\"-\");\n    }, i.gen = function (e) {\n      for (var o = \"\", t = 0; t < e; t++) o += ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);\n      return o;\n    }, i.prototype.equals = function (e) {\n      return i.isGuid(e) && this.value === e.toString();\n    }, i.prototype.isEmpty = function () {\n      return this.value === i.EMPTY;\n    }, i.prototype.toString = function () {\n      return this.value;\n    }, i.prototype.toJSON = function () {\n      return {\n        value: this.value\n      };\n    }, i.validator = new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\", \"i\"), i.EMPTY = \"00000000-0000-0000-0000-000000000000\", i;\n  }();\n  zo.Guid = nh;\n});\nfunction rt(i, e, o) {\n  this.low = i | 0, this.high = e | 0, this.unsigned = !!o;\n}\nfunction Et(i) {\n  return (i && i.__isLong__) === !0;\n}\nfunction Cs(i) {\n  var e = Math.clz32(i & -i);\n  return i ? 31 - e : e;\n}\nfunction Ne(i, e) {\n  var o, t, r;\n  return e ? (i >>>= 0, (r = 0 <= i && i < 256) && (t = Rs[i], t) ? t : (o = J(i, 0, !0), r && (Rs[i] = o), o)) : (i |= 0, (r = -128 <= i && i < 128) && (t = Ns[i], t) ? t : (o = J(i, i < 0 ? -1 : 0, !1), r && (Ns[i] = o), o));\n}\nfunction zt(i, e) {\n  if (isNaN(i)) return e ? ye : Zt;\n  if (e) {\n    if (i < 0) return ye;\n    if (i >= Vs) return Hs;\n  } else {\n    if (i <= -Ms) return Ct;\n    if (i + 1 >= Ms) return Ws;\n  }\n  return i < 0 ? zt(-i, e).neg() : J(i % ir | 0, i / ir | 0, e);\n}\nfunction J(i, e, o) {\n  return new rt(i, e, o);\n}\nfunction Ho(i, e, o) {\n  if (i.length === 0) throw Error(\"empty string\");\n  if (typeof e == \"number\" ? (o = e, e = !1) : e = !!e, i === \"NaN\" || i === \"Infinity\" || i === \"+Infinity\" || i === \"-Infinity\") return e ? ye : Zt;\n  if (o = o || 10, o < 2 || 36 < o) throw RangeError(\"radix\");\n  var t;\n  if ((t = i.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n  if (t === 0) return Ho(i.substring(1), e, o).neg();\n  for (var r = zt(Tn(o, 8)), n = Zt, s = 0; s < i.length; s += 8) {\n    var a = Math.min(8, i.length - s),\n      u = parseInt(i.substring(s, s + a), o);\n    if (a < 8) {\n      var l = zt(Tn(o, a));\n      n = n.mul(l).add(zt(u));\n    } else n = n.mul(r), n = n.add(zt(u));\n  }\n  return n.unsigned = e, n;\n}\nfunction Qt(i, e) {\n  return typeof i == \"number\" ? zt(i, e) : typeof i == \"string\" ? Ho(i, e) : J(i.low, i.high, typeof e == \"boolean\" ? e : i.unsigned);\n}\nvar Vt,\n  Ns,\n  Rs,\n  Tn,\n  Gs,\n  oh,\n  ir,\n  Vs,\n  Ms,\n  Us,\n  Zt,\n  ye,\n  or,\n  zs,\n  Wo,\n  Ws,\n  Hs,\n  Ct,\n  D,\n  xe,\n  qo = O(() => {\n    Vt = null;\n    try {\n      Vt = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n    } catch {}\n    rt.prototype.__isLong__;\n    Object.defineProperty(rt.prototype, \"__isLong__\", {\n      value: !0\n    });\n    rt.isLong = Et;\n    Ns = {}, Rs = {};\n    rt.fromInt = Ne;\n    rt.fromNumber = zt;\n    rt.fromBits = J;\n    Tn = Math.pow;\n    rt.fromString = Ho;\n    rt.fromValue = Qt;\n    Gs = 65536, oh = 1 << 24, ir = Gs * Gs, Vs = ir * ir, Ms = Vs / 2, Us = Ne(oh), Zt = Ne(0);\n    rt.ZERO = Zt;\n    ye = Ne(0, !0);\n    rt.UZERO = ye;\n    or = Ne(1);\n    rt.ONE = or;\n    zs = Ne(1, !0);\n    rt.UONE = zs;\n    Wo = Ne(-1);\n    rt.NEG_ONE = Wo;\n    Ws = J(-1, 2147483647, !1);\n    rt.MAX_VALUE = Ws;\n    Hs = J(-1, -1, !0);\n    rt.MAX_UNSIGNED_VALUE = Hs;\n    Ct = J(0, -2147483648, !1);\n    rt.MIN_VALUE = Ct;\n    D = rt.prototype;\n    D.toInt = function () {\n      return this.unsigned ? this.low >>> 0 : this.low;\n    };\n    D.toNumber = function () {\n      return this.unsigned ? (this.high >>> 0) * ir + (this.low >>> 0) : this.high * ir + (this.low >>> 0);\n    };\n    D.toString = function (e) {\n      if (e = e || 10, e < 2 || 36 < e) throw RangeError(\"radix\");\n      if (this.isZero()) return \"0\";\n      if (this.isNegative()) if (this.eq(Ct)) {\n        var o = zt(e),\n          t = this.div(o),\n          r = t.mul(o).sub(this);\n        return t.toString(e) + r.toInt().toString(e);\n      } else return \"-\" + this.neg().toString(e);\n      for (var n = zt(Tn(e, 6), this.unsigned), s = this, a = \"\";;) {\n        var u = s.div(n),\n          l = s.sub(u.mul(n)).toInt() >>> 0,\n          f = l.toString(e);\n        if (s = u, s.isZero()) return f + a;\n        for (; f.length < 6;) f = \"0\" + f;\n        a = \"\" + f + a;\n      }\n    };\n    D.getHighBits = function () {\n      return this.high;\n    };\n    D.getHighBitsUnsigned = function () {\n      return this.high >>> 0;\n    };\n    D.getLowBits = function () {\n      return this.low;\n    };\n    D.getLowBitsUnsigned = function () {\n      return this.low >>> 0;\n    };\n    D.getNumBitsAbs = function () {\n      if (this.isNegative()) return this.eq(Ct) ? 64 : this.neg().getNumBitsAbs();\n      for (var e = this.high != 0 ? this.high : this.low, o = 31; o > 0 && !(e & 1 << o); o--);\n      return this.high != 0 ? o + 33 : o + 1;\n    };\n    D.isZero = function () {\n      return this.high === 0 && this.low === 0;\n    };\n    D.eqz = D.isZero;\n    D.isNegative = function () {\n      return !this.unsigned && this.high < 0;\n    };\n    D.isPositive = function () {\n      return this.unsigned || this.high >= 0;\n    };\n    D.isOdd = function () {\n      return (this.low & 1) === 1;\n    };\n    D.isEven = function () {\n      return (this.low & 1) === 0;\n    };\n    D.equals = function (e) {\n      return Et(e) || (e = Qt(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;\n    };\n    D.eq = D.equals;\n    D.notEquals = function (e) {\n      return !this.eq(e);\n    };\n    D.neq = D.notEquals;\n    D.ne = D.notEquals;\n    D.lessThan = function (e) {\n      return this.comp(e) < 0;\n    };\n    D.lt = D.lessThan;\n    D.lessThanOrEqual = function (e) {\n      return this.comp(e) <= 0;\n    };\n    D.lte = D.lessThanOrEqual;\n    D.le = D.lessThanOrEqual;\n    D.greaterThan = function (e) {\n      return this.comp(e) > 0;\n    };\n    D.gt = D.greaterThan;\n    D.greaterThanOrEqual = function (e) {\n      return this.comp(e) >= 0;\n    };\n    D.gte = D.greaterThanOrEqual;\n    D.ge = D.greaterThanOrEqual;\n    D.compare = function (e) {\n      if (Et(e) || (e = Qt(e)), this.eq(e)) return 0;\n      var o = this.isNegative(),\n        t = e.isNegative();\n      return o && !t ? -1 : !o && t ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;\n    };\n    D.comp = D.compare;\n    D.negate = function () {\n      return !this.unsigned && this.eq(Ct) ? Ct : this.not().add(or);\n    };\n    D.neg = D.negate;\n    D.add = function (e) {\n      Et(e) || (e = Qt(e));\n      var o = this.high >>> 16,\n        t = this.high & 65535,\n        r = this.low >>> 16,\n        n = this.low & 65535,\n        s = e.high >>> 16,\n        a = e.high & 65535,\n        u = e.low >>> 16,\n        l = e.low & 65535,\n        f = 0,\n        p = 0,\n        d = 0,\n        y = 0;\n      return y += n + l, d += y >>> 16, y &= 65535, d += r + u, p += d >>> 16, d &= 65535, p += t + a, f += p >>> 16, p &= 65535, f += o + s, f &= 65535, J(d << 16 | y, f << 16 | p, this.unsigned);\n    };\n    D.subtract = function (e) {\n      return Et(e) || (e = Qt(e)), this.add(e.neg());\n    };\n    D.sub = D.subtract;\n    D.multiply = function (e) {\n      if (this.isZero()) return this;\n      if (Et(e) || (e = Qt(e)), Vt) {\n        var o = Vt.mul(this.low, this.high, e.low, e.high);\n        return J(o, Vt.get_high(), this.unsigned);\n      }\n      if (e.isZero()) return this.unsigned ? ye : Zt;\n      if (this.eq(Ct)) return e.isOdd() ? Ct : Zt;\n      if (e.eq(Ct)) return this.isOdd() ? Ct : Zt;\n      if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();\n      if (e.isNegative()) return this.mul(e.neg()).neg();\n      if (this.lt(Us) && e.lt(Us)) return zt(this.toNumber() * e.toNumber(), this.unsigned);\n      var t = this.high >>> 16,\n        r = this.high & 65535,\n        n = this.low >>> 16,\n        s = this.low & 65535,\n        a = e.high >>> 16,\n        u = e.high & 65535,\n        l = e.low >>> 16,\n        f = e.low & 65535,\n        p = 0,\n        d = 0,\n        y = 0,\n        T = 0;\n      return T += s * f, y += T >>> 16, T &= 65535, y += n * f, d += y >>> 16, y &= 65535, y += s * l, d += y >>> 16, y &= 65535, d += r * f, p += d >>> 16, d &= 65535, d += n * l, p += d >>> 16, d &= 65535, d += s * u, p += d >>> 16, d &= 65535, p += t * f + r * l + n * u + s * a, p &= 65535, J(y << 16 | T, p << 16 | d, this.unsigned);\n    };\n    D.mul = D.multiply;\n    D.divide = function (e) {\n      if (Et(e) || (e = Qt(e)), e.isZero()) throw Error(\"division by zero\");\n      if (Vt) {\n        if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1) return this;\n        var o = (this.unsigned ? Vt.div_u : Vt.div_s)(this.low, this.high, e.low, e.high);\n        return J(o, Vt.get_high(), this.unsigned);\n      }\n      if (this.isZero()) return this.unsigned ? ye : Zt;\n      var t, r, n;\n      if (this.unsigned) {\n        if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return ye;\n        if (e.gt(this.shru(1))) return zs;\n        n = ye;\n      } else {\n        if (this.eq(Ct)) {\n          if (e.eq(or) || e.eq(Wo)) return Ct;\n          if (e.eq(Ct)) return or;\n          var s = this.shr(1);\n          return t = s.div(e).shl(1), t.eq(Zt) ? e.isNegative() ? or : Wo : (r = this.sub(e.mul(t)), n = t.add(r.div(e)), n);\n        } else if (e.eq(Ct)) return this.unsigned ? ye : Zt;\n        if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();\n        if (e.isNegative()) return this.div(e.neg()).neg();\n        n = Zt;\n      }\n      for (r = this; r.gte(e);) {\n        t = Math.max(1, Math.floor(r.toNumber() / e.toNumber()));\n        for (var a = Math.ceil(Math.log(t) / Math.LN2), u = a <= 48 ? 1 : Tn(2, a - 48), l = zt(t), f = l.mul(e); f.isNegative() || f.gt(r);) t -= u, l = zt(t, this.unsigned), f = l.mul(e);\n        l.isZero() && (l = or), n = n.add(l), r = r.sub(f);\n      }\n      return n;\n    };\n    D.div = D.divide;\n    D.modulo = function (e) {\n      if (Et(e) || (e = Qt(e)), Vt) {\n        var o = (this.unsigned ? Vt.rem_u : Vt.rem_s)(this.low, this.high, e.low, e.high);\n        return J(o, Vt.get_high(), this.unsigned);\n      }\n      return this.sub(this.div(e).mul(e));\n    };\n    D.mod = D.modulo;\n    D.rem = D.modulo;\n    D.not = function () {\n      return J(~this.low, ~this.high, this.unsigned);\n    };\n    D.countLeadingZeros = function () {\n      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n    };\n    D.clz = D.countLeadingZeros;\n    D.countTrailingZeros = function () {\n      return this.low ? Cs(this.low) : Cs(this.high) + 32;\n    };\n    D.ctz = D.countTrailingZeros;\n    D.and = function (e) {\n      return Et(e) || (e = Qt(e)), J(this.low & e.low, this.high & e.high, this.unsigned);\n    };\n    D.or = function (e) {\n      return Et(e) || (e = Qt(e)), J(this.low | e.low, this.high | e.high, this.unsigned);\n    };\n    D.xor = function (e) {\n      return Et(e) || (e = Qt(e)), J(this.low ^ e.low, this.high ^ e.high, this.unsigned);\n    };\n    D.shiftLeft = function (e) {\n      return Et(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? J(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : J(0, this.low << e - 32, this.unsigned);\n    };\n    D.shl = D.shiftLeft;\n    D.shiftRight = function (e) {\n      return Et(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? J(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : J(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    };\n    D.shr = D.shiftRight;\n    D.shiftRightUnsigned = function (e) {\n      return Et(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? J(this.low >>> e | this.high << 32 - e, this.high >>> e, this.unsigned) : e === 32 ? J(this.high, 0, this.unsigned) : J(this.high >>> e - 32, 0, this.unsigned);\n    };\n    D.shru = D.shiftRightUnsigned;\n    D.shr_u = D.shiftRightUnsigned;\n    D.rotateLeft = function (e) {\n      var o;\n      return Et(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? J(this.high, this.low, this.unsigned) : e < 32 ? (o = 32 - e, J(this.low << e | this.high >>> o, this.high << e | this.low >>> o, this.unsigned)) : (e -= 32, o = 32 - e, J(this.high << e | this.low >>> o, this.low << e | this.high >>> o, this.unsigned));\n    };\n    D.rotl = D.rotateLeft;\n    D.rotateRight = function (e) {\n      var o;\n      return Et(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? J(this.high, this.low, this.unsigned) : e < 32 ? (o = 32 - e, J(this.high << o | this.low >>> e, this.low << o | this.high >>> e, this.unsigned)) : (e -= 32, o = 32 - e, J(this.low << o | this.high >>> e, this.high << o | this.low >>> e, this.unsigned));\n    };\n    D.rotr = D.rotateRight;\n    D.toSigned = function () {\n      return this.unsigned ? J(this.low, this.high, !1) : this;\n    };\n    D.toUnsigned = function () {\n      return this.unsigned ? this : J(this.low, this.high, !0);\n    };\n    D.toBytes = function (e) {\n      return e ? this.toBytesLE() : this.toBytesBE();\n    };\n    D.toBytesLE = function () {\n      var e = this.high,\n        o = this.low;\n      return [o & 255, o >>> 8 & 255, o >>> 16 & 255, o >>> 24, e & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];\n    };\n    D.toBytesBE = function () {\n      var e = this.high,\n        o = this.low;\n      return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, e & 255, o >>> 24, o >>> 16 & 255, o >>> 8 & 255, o & 255];\n    };\n    rt.fromBytes = function (e, o, t) {\n      return t ? rt.fromBytesLE(e, o) : rt.fromBytesBE(e, o);\n    };\n    rt.fromBytesLE = function (e, o) {\n      return new rt(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, o);\n    };\n    rt.fromBytesBE = function (e, o) {\n      return new rt(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], o);\n    };\n    xe = rt;\n  });\nvar w,\n  wn = O(() => {\n    w = {};\n    w.Offset;\n    w.Table;\n    w.SIZEOF_SHORT = 2;\n    w.SIZEOF_INT = 4;\n    w.FILE_IDENTIFIER_LENGTH = 4;\n    w.SIZE_PREFIX_LENGTH = 4;\n    w.Encoding = {\n      UTF8_BYTES: 1,\n      UTF16_STRING: 2\n    };\n    w.int32 = new Int32Array(2);\n    w.float32 = new Float32Array(w.int32.buffer);\n    w.float64 = new Float64Array(w.int32.buffer);\n    w.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n    w.Long = function (i, e) {\n      this.low = i | 0, this.high = e | 0;\n    };\n    w.Long.create = function (i, e) {\n      return i == 0 && e == 0 ? w.Long.ZERO : new w.Long(i, e);\n    };\n    w.Long.prototype.toFloat64 = function () {\n      return (this.low >>> 0) + this.high * 4294967296;\n    };\n    w.Long.prototype.equals = function (i) {\n      return this.low == i.low && this.high == i.high;\n    };\n    w.Long.ZERO = new w.Long(0, 0);\n    w.Builder = function (i) {\n      if (i) var e = i;else var e = 1024;\n      this.bb = w.ByteBuffer.allocate(e), this.space = e, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;\n    };\n    w.Builder.prototype.clear = function () {\n      this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;\n    };\n    w.Builder.prototype.forceDefaults = function (i) {\n      this.force_defaults = i;\n    };\n    w.Builder.prototype.dataBuffer = function () {\n      return this.bb;\n    };\n    w.Builder.prototype.asUint8Array = function () {\n      return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n    };\n    w.Builder.prototype.prep = function (i, e) {\n      i > this.minalign && (this.minalign = i);\n      for (var o = ~(this.bb.capacity() - this.space + e) + 1 & i - 1; this.space < o + i + e;) {\n        var t = this.bb.capacity();\n        this.bb = w.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - t;\n      }\n      this.pad(o);\n    };\n    w.Builder.prototype.pad = function (i) {\n      for (var e = 0; e < i; e++) this.bb.writeInt8(--this.space, 0);\n    };\n    w.Builder.prototype.writeInt8 = function (i) {\n      this.bb.writeInt8(this.space -= 1, i);\n    };\n    w.Builder.prototype.writeInt16 = function (i) {\n      this.bb.writeInt16(this.space -= 2, i);\n    };\n    w.Builder.prototype.writeInt32 = function (i) {\n      this.bb.writeInt32(this.space -= 4, i);\n    };\n    w.Builder.prototype.writeInt64 = function (i) {\n      this.bb.writeInt64(this.space -= 8, i);\n    };\n    w.Builder.prototype.writeFloat32 = function (i) {\n      this.bb.writeFloat32(this.space -= 4, i);\n    };\n    w.Builder.prototype.writeFloat64 = function (i) {\n      this.bb.writeFloat64(this.space -= 8, i);\n    };\n    w.Builder.prototype.addInt8 = function (i) {\n      this.prep(1, 0), this.writeInt8(i);\n    };\n    w.Builder.prototype.addInt16 = function (i) {\n      this.prep(2, 0), this.writeInt16(i);\n    };\n    w.Builder.prototype.addInt32 = function (i) {\n      this.prep(4, 0), this.writeInt32(i);\n    };\n    w.Builder.prototype.addInt64 = function (i) {\n      this.prep(8, 0), this.writeInt64(i);\n    };\n    w.Builder.prototype.addFloat32 = function (i) {\n      this.prep(4, 0), this.writeFloat32(i);\n    };\n    w.Builder.prototype.addFloat64 = function (i) {\n      this.prep(8, 0), this.writeFloat64(i);\n    };\n    w.Builder.prototype.addFieldInt8 = function (i, e, o) {\n      (this.force_defaults || e != o) && (this.addInt8(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldInt16 = function (i, e, o) {\n      (this.force_defaults || e != o) && (this.addInt16(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldInt32 = function (i, e, o) {\n      (this.force_defaults || e != o) && (this.addInt32(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldInt64 = function (i, e, o) {\n      (this.force_defaults || !e.equals(o)) && (this.addInt64(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldFloat32 = function (i, e, o) {\n      (this.force_defaults || e != o) && (this.addFloat32(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldFloat64 = function (i, e, o) {\n      (this.force_defaults || e != o) && (this.addFloat64(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldOffset = function (i, e, o) {\n      (this.force_defaults || e != o) && (this.addOffset(e), this.slot(i));\n    };\n    w.Builder.prototype.addFieldStruct = function (i, e, o) {\n      e != o && (this.nested(e), this.slot(i));\n    };\n    w.Builder.prototype.nested = function (i) {\n      if (i != this.offset()) throw new Error(\"FlatBuffers: struct must be serialized inline.\");\n    };\n    w.Builder.prototype.notNested = function () {\n      if (this.isNested) throw new Error(\"FlatBuffers: object serialization must not be nested.\");\n    };\n    w.Builder.prototype.slot = function (i) {\n      this.vtable[i] = this.offset();\n    };\n    w.Builder.prototype.offset = function () {\n      return this.bb.capacity() - this.space;\n    };\n    w.Builder.growByteBuffer = function (i) {\n      var e = i.capacity();\n      if (e & 3221225472) throw new Error(\"FlatBuffers: cannot grow buffer beyond 2 gigabytes.\");\n      var o = e << 1,\n        t = w.ByteBuffer.allocate(o);\n      return t.setPosition(o - e), t.bytes().set(i.bytes(), o - e), t;\n    };\n    w.Builder.prototype.addOffset = function (i) {\n      this.prep(w.SIZEOF_INT, 0), this.writeInt32(this.offset() - i + w.SIZEOF_INT);\n    };\n    w.Builder.prototype.startObject = function (i) {\n      this.notNested(), this.vtable == null && (this.vtable = []), this.vtable_in_use = i;\n      for (var e = 0; e < i; e++) this.vtable[e] = 0;\n      this.isNested = !0, this.object_start = this.offset();\n    };\n    w.Builder.prototype.endObject = function () {\n      if (this.vtable == null || !this.isNested) throw new Error(\"FlatBuffers: endObject called without startObject\");\n      this.addInt32(0);\n      for (var i = this.offset(), e = this.vtable_in_use - 1; e >= 0 && this.vtable[e] == 0; e--);\n      for (var o = e + 1; e >= 0; e--) this.addInt16(this.vtable[e] != 0 ? i - this.vtable[e] : 0);\n      var t = 2;\n      this.addInt16(i - this.object_start);\n      var r = (o + t) * w.SIZEOF_SHORT;\n      this.addInt16(r);\n      var n = 0,\n        s = this.space;\n      t: for (e = 0; e < this.vtables.length; e++) {\n        var a = this.bb.capacity() - this.vtables[e];\n        if (r == this.bb.readInt16(a)) {\n          for (var u = w.SIZEOF_SHORT; u < r; u += w.SIZEOF_SHORT) if (this.bb.readInt16(s + u) != this.bb.readInt16(a + u)) continue t;\n          n = this.vtables[e];\n          break;\n        }\n      }\n      return n ? (this.space = this.bb.capacity() - i, this.bb.writeInt32(this.space, n - i)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - i, this.offset() - i)), this.isNested = !1, i;\n    };\n    w.Builder.prototype.finish = function (i, e, o) {\n      var t = o ? w.SIZE_PREFIX_LENGTH : 0;\n      if (e) {\n        var r = e;\n        if (this.prep(this.minalign, w.SIZEOF_INT + w.FILE_IDENTIFIER_LENGTH + t), r.length != w.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: file identifier must be length \" + w.FILE_IDENTIFIER_LENGTH);\n        for (var n = w.FILE_IDENTIFIER_LENGTH - 1; n >= 0; n--) this.writeInt8(r.charCodeAt(n));\n      }\n      this.prep(this.minalign, w.SIZEOF_INT + t), this.addOffset(i), t && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);\n    };\n    w.Builder.prototype.finishSizePrefixed = function (i, e) {\n      this.finish(i, e, !0);\n    };\n    w.Builder.prototype.requiredField = function (i, e) {\n      var o = this.bb.capacity() - i,\n        t = o - this.bb.readInt32(o),\n        r = this.bb.readInt16(t + e) != 0;\n      if (!r) throw new Error(\"FlatBuffers: field \" + e + \" must be set\");\n    };\n    w.Builder.prototype.startVector = function (i, e, o) {\n      this.notNested(), this.vector_num_elems = e, this.prep(w.SIZEOF_INT, i * e), this.prep(o, i * e);\n    };\n    w.Builder.prototype.endVector = function () {\n      return this.writeInt32(this.vector_num_elems), this.offset();\n    };\n    w.Builder.prototype.createString = function (i) {\n      if (i instanceof Uint8Array) var e = i;else for (var e = [], o = 0; o < i.length;) {\n        var t,\n          r = i.charCodeAt(o++);\n        if (r < 55296 || r >= 56320) t = r;else {\n          var n = i.charCodeAt(o++);\n          t = (r << 10) + n + (65536 - 56623104 - 56320);\n        }\n        t < 128 ? e.push(t) : (t < 2048 ? e.push(t >> 6 & 31 | 192) : (t < 65536 ? e.push(t >> 12 & 15 | 224) : e.push(t >> 18 & 7 | 240, t >> 12 & 63 | 128), e.push(t >> 6 & 63 | 128)), e.push(t & 63 | 128));\n      }\n      this.addInt8(0), this.startVector(1, e.length, 1), this.bb.setPosition(this.space -= e.length);\n      for (var o = 0, s = this.space, a = this.bb.bytes(); o < e.length; o++) a[s++] = e[o];\n      return this.endVector();\n    };\n    w.Builder.prototype.createLong = function (i, e) {\n      return w.Long.create(i, e);\n    };\n    w.ByteBuffer = function (i) {\n      this.bytes_ = i, this.position_ = 0;\n    };\n    w.ByteBuffer.allocate = function (i) {\n      return new w.ByteBuffer(new Uint8Array(i));\n    };\n    w.ByteBuffer.prototype.clear = function () {\n      this.position_ = 0;\n    };\n    w.ByteBuffer.prototype.bytes = function () {\n      return this.bytes_;\n    };\n    w.ByteBuffer.prototype.position = function () {\n      return this.position_;\n    };\n    w.ByteBuffer.prototype.setPosition = function (i) {\n      this.position_ = i;\n    };\n    w.ByteBuffer.prototype.capacity = function () {\n      return this.bytes_.length;\n    };\n    w.ByteBuffer.prototype.readInt8 = function (i) {\n      return this.readUint8(i) << 24 >> 24;\n    };\n    w.ByteBuffer.prototype.readUint8 = function (i) {\n      return this.bytes_[i];\n    };\n    w.ByteBuffer.prototype.readInt16 = function (i) {\n      return this.readUint16(i) << 16 >> 16;\n    };\n    w.ByteBuffer.prototype.readUint16 = function (i) {\n      return this.bytes_[i] | this.bytes_[i + 1] << 8;\n    };\n    w.ByteBuffer.prototype.readInt32 = function (i) {\n      return this.bytes_[i] | this.bytes_[i + 1] << 8 | this.bytes_[i + 2] << 16 | this.bytes_[i + 3] << 24;\n    };\n    w.ByteBuffer.prototype.readUint32 = function (i) {\n      return this.readInt32(i) >>> 0;\n    };\n    w.ByteBuffer.prototype.readInt64 = function (i) {\n      return new w.Long(this.readInt32(i), this.readInt32(i + 4));\n    };\n    w.ByteBuffer.prototype.readUint64 = function (i) {\n      return new w.Long(this.readUint32(i), this.readUint32(i + 4));\n    };\n    w.ByteBuffer.prototype.readFloat32 = function (i) {\n      return w.int32[0] = this.readInt32(i), w.float32[0];\n    };\n    w.ByteBuffer.prototype.readFloat64 = function (i) {\n      return w.int32[w.isLittleEndian ? 0 : 1] = this.readInt32(i), w.int32[w.isLittleEndian ? 1 : 0] = this.readInt32(i + 4), w.float64[0];\n    };\n    w.ByteBuffer.prototype.writeInt8 = function (i, e) {\n      this.bytes_[i] = e;\n    };\n    w.ByteBuffer.prototype.writeUint8 = function (i, e) {\n      this.bytes_[i] = e;\n    };\n    w.ByteBuffer.prototype.writeInt16 = function (i, e) {\n      this.bytes_[i] = e, this.bytes_[i + 1] = e >> 8;\n    };\n    w.ByteBuffer.prototype.writeUint16 = function (i, e) {\n      this.bytes_[i] = e, this.bytes_[i + 1] = e >> 8;\n    };\n    w.ByteBuffer.prototype.writeInt32 = function (i, e) {\n      this.bytes_[i] = e, this.bytes_[i + 1] = e >> 8, this.bytes_[i + 2] = e >> 16, this.bytes_[i + 3] = e >> 24;\n    };\n    w.ByteBuffer.prototype.writeUint32 = function (i, e) {\n      this.bytes_[i] = e, this.bytes_[i + 1] = e >> 8, this.bytes_[i + 2] = e >> 16, this.bytes_[i + 3] = e >> 24;\n    };\n    w.ByteBuffer.prototype.writeInt64 = function (i, e) {\n      this.writeInt32(i, e.low), this.writeInt32(i + 4, e.high);\n    };\n    w.ByteBuffer.prototype.writeUint64 = function (i, e) {\n      this.writeUint32(i, e.low), this.writeUint32(i + 4, e.high);\n    };\n    w.ByteBuffer.prototype.writeFloat32 = function (i, e) {\n      w.float32[0] = e, this.writeInt32(i, w.int32[0]);\n    };\n    w.ByteBuffer.prototype.writeFloat64 = function (i, e) {\n      w.float64[0] = e, this.writeInt32(i, w.int32[w.isLittleEndian ? 0 : 1]), this.writeInt32(i + 4, w.int32[w.isLittleEndian ? 1 : 0]);\n    };\n    w.ByteBuffer.prototype.getBufferIdentifier = function () {\n      if (this.bytes_.length < this.position_ + w.SIZEOF_INT + w.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: ByteBuffer is too short to contain an identifier.\");\n      for (var i = \"\", e = 0; e < w.FILE_IDENTIFIER_LENGTH; e++) i += String.fromCharCode(this.readInt8(this.position_ + w.SIZEOF_INT + e));\n      return i;\n    };\n    w.ByteBuffer.prototype.__offset = function (i, e) {\n      var o = i - this.readInt32(i);\n      return e < this.readInt16(o) ? this.readInt16(o + e) : 0;\n    };\n    w.ByteBuffer.prototype.__union = function (i, e) {\n      return i.bb_pos = e + this.readInt32(e), i.bb = this, i;\n    };\n    w.ByteBuffer.prototype.__string = function (i, e) {\n      i += this.readInt32(i);\n      var o = this.readInt32(i),\n        t = \"\",\n        r = 0;\n      if (i += w.SIZEOF_INT, e === w.Encoding.UTF8_BYTES) return this.bytes_.subarray(i, i + o);\n      for (; r < o;) {\n        var n,\n          s = this.readUint8(i + r++);\n        if (s < 192) n = s;else {\n          var a = this.readUint8(i + r++);\n          if (s < 224) n = (s & 31) << 6 | a & 63;else {\n            var u = this.readUint8(i + r++);\n            if (s < 240) n = (s & 15) << 12 | (a & 63) << 6 | u & 63;else {\n              var l = this.readUint8(i + r++);\n              n = (s & 7) << 18 | (a & 63) << 12 | (u & 63) << 6 | l & 63;\n            }\n          }\n        }\n        n < 65536 ? t += String.fromCharCode(n) : (n -= 65536, t += String.fromCharCode((n >> 10) + 55296, (n & 1024 - 1) + 56320));\n      }\n      return t;\n    };\n    w.ByteBuffer.prototype.__indirect = function (i) {\n      return i + this.readInt32(i);\n    };\n    w.ByteBuffer.prototype.__vector = function (i) {\n      return i + this.readInt32(i) + w.SIZEOF_INT;\n    };\n    w.ByteBuffer.prototype.__vector_len = function (i) {\n      return this.readInt32(i + this.readInt32(i));\n    };\n    w.ByteBuffer.prototype.__has_identifier = function (i) {\n      if (i.length != w.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: file identifier must be length \" + w.FILE_IDENTIFIER_LENGTH);\n      for (var e = 0; e < w.FILE_IDENTIFIER_LENGTH; e++) if (i.charCodeAt(e) != this.readInt8(this.position_ + w.SIZEOF_INT + e)) return !1;\n      return !0;\n    };\n    w.ByteBuffer.prototype.createLong = function (i, e) {\n      return w.Long.create(i, e);\n    };\n  });\nvar F,\n  Pr = O(() => {\n    \"use strict\";\n\n    wn();\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          let r;\n          (A => (A[A.UNDEFINED = 0] = \"UNDEFINED\", A[A.FLOAT = 1] = \"FLOAT\", A[A.INT = 2] = \"INT\", A[A.STRING = 3] = \"STRING\", A[A.TENSOR = 4] = \"TENSOR\", A[A.GRAPH = 5] = \"GRAPH\", A[A.FLOATS = 6] = \"FLOATS\", A[A.INTS = 7] = \"INTS\", A[A.STRINGS = 8] = \"STRINGS\", A[A.TENSORS = 9] = \"TENSORS\", A[A.GRAPHS = 10] = \"GRAPHS\", A[A.SPARSE_TENSOR = 11] = \"SPARSE_TENSOR\", A[A.SPARSE_TENSORS = 12] = \"SPARSE_TENSORS\"))(r = n.AttributeType ||= {});\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          let r;\n          (l => (l[l.UNKNOWN = 0] = \"UNKNOWN\", l[l.VALUE = 1] = \"VALUE\", l[l.PARAM = 2] = \"PARAM\"))(r = n.DimensionValueType ||= {});\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          let r;\n          (C => (C[C.UNDEFINED = 0] = \"UNDEFINED\", C[C.FLOAT = 1] = \"FLOAT\", C[C.UINT8 = 2] = \"UINT8\", C[C.INT8 = 3] = \"INT8\", C[C.UINT16 = 4] = \"UINT16\", C[C.INT16 = 5] = \"INT16\", C[C.INT32 = 6] = \"INT32\", C[C.INT64 = 7] = \"INT64\", C[C.STRING = 8] = \"STRING\", C[C.BOOL = 9] = \"BOOL\", C[C.FLOAT16 = 10] = \"FLOAT16\", C[C.DOUBLE = 11] = \"DOUBLE\", C[C.UINT32 = 12] = \"UINT32\", C[C.UINT64 = 13] = \"UINT64\", C[C.COMPLEX64 = 14] = \"COMPLEX64\", C[C.COMPLEX128 = 15] = \"COMPLEX128\", C[C.BFLOAT16 = 16] = \"BFLOAT16\", C[C.FLOAT8E4M3FN = 17] = \"FLOAT8E4M3FN\", C[C.FLOAT8E4M3FNUZ = 18] = \"FLOAT8E4M3FNUZ\", C[C.FLOAT8E5M2 = 19] = \"FLOAT8E5M2\", C[C.FLOAT8E5M2FNUZ = 20] = \"FLOAT8E5M2FNUZ\"))(r = n.TensorDataType ||= {});\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          let r;\n          (u => (u[u.Primitive = 0] = \"Primitive\", u[u.Fused = 1] = \"Fused\"))(r = n.NodeType ||= {});\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          let r;\n          (f => (f[f.NONE = 0] = \"NONE\", f[f.tensor_type = 1] = \"tensor_type\", f[f.sequence_type = 2] = \"sequence_type\", f[f.map_type = 3] = \"map_type\"))(r = n.TypeInfoValue ||= {});\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsShape(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsShape(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            dim(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 4);\n              return l ? (u || new e.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            dimLength() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startShape(a) {\n              a.startObject(1);\n            }\n            static addDim(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static createDimVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startDimVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static endShape(a) {\n              return a.endObject();\n            }\n            static createShape(a, u) {\n              return r.startShape(a), r.addDim(a, u), r.endShape(a);\n            }\n          }\n          n.Shape = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsDimension(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsDimension(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            value(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? (a || new e.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            denotation(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            static startDimension(a) {\n              a.startObject(2);\n            }\n            static addValue(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addDenotation(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static endDimension(a) {\n              return a.endObject();\n            }\n            static createDimension(a, u, l) {\n              return r.startDimension(a), r.addValue(a, u), r.addDenotation(a, l), r.endDimension(a);\n            }\n          }\n          n.Dimension = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsDimensionValue(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsDimensionValue(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            dimType() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.readInt8(this.bb_pos + a) : 0;\n            }\n            dimValue() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.readInt64(this.bb_pos + a) : this.bb.createLong(0, 0);\n            }\n            dimParam(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            static startDimensionValue(a) {\n              a.startObject(3);\n            }\n            static addDimType(a, u) {\n              a.addFieldInt8(0, u, 0);\n            }\n            static addDimValue(a, u) {\n              a.addFieldInt64(1, u, a.createLong(0, 0));\n            }\n            static addDimParam(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static endDimensionValue(a) {\n              return a.endObject();\n            }\n            static createDimensionValue(a, u, l, f) {\n              return r.startDimensionValue(a), r.addDimType(a, u), r.addDimValue(a, l), r.addDimParam(a, f), r.endDimensionValue(a);\n            }\n          }\n          n.DimensionValue = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsTensorTypeAndShape(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsTensorTypeAndShape(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            elemType() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.readInt32(this.bb_pos + a) : 0;\n            }\n            shape(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? (a || new e.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            static startTensorTypeAndShape(a) {\n              a.startObject(2);\n            }\n            static addElemType(a, u) {\n              a.addFieldInt32(0, u, 0);\n            }\n            static addShape(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static endTensorTypeAndShape(a) {\n              return a.endObject();\n            }\n            static createTensorTypeAndShape(a, u, l) {\n              return r.startTensorTypeAndShape(a), r.addElemType(a, u), r.addShape(a, l), r.endTensorTypeAndShape(a);\n            }\n          }\n          n.TensorTypeAndShape = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsMapType(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsMapType(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            keyType() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.readInt32(this.bb_pos + a) : 0;\n            }\n            valueType(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? (a || new e.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            static startMapType(a) {\n              a.startObject(2);\n            }\n            static addKeyType(a, u) {\n              a.addFieldInt32(0, u, 0);\n            }\n            static addValueType(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static endMapType(a) {\n              return a.endObject();\n            }\n            static createMapType(a, u, l) {\n              return r.startMapType(a), r.addKeyType(a, u), r.addValueType(a, l), r.endMapType(a);\n            }\n          }\n          n.MapType = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsSequenceType(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsSequenceType(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            elemType(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? (a || new e.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            static startSequenceType(a) {\n              a.startObject(1);\n            }\n            static addElemType(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static endSequenceType(a) {\n              return a.endObject();\n            }\n            static createSequenceType(a, u) {\n              return r.startSequenceType(a), r.addElemType(a, u), r.endSequenceType(a);\n            }\n          }\n          n.SequenceType = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            nodeIndex() {\n              return this.bb.readUint32(this.bb_pos);\n            }\n            srcArgIndex() {\n              return this.bb.readInt32(this.bb_pos + 4);\n            }\n            dstArgIndex() {\n              return this.bb.readInt32(this.bb_pos + 8);\n            }\n            static createEdgeEnd(a, u, l, f) {\n              return a.prep(4, 12), a.writeInt32(f), a.writeInt32(l), a.writeInt32(u), a.offset();\n            }\n          }\n          n.EdgeEnd = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsNodeEdge(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsNodeEdge(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            nodeIndex() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.readUint32(this.bb_pos + a) : 0;\n            }\n            inputEdges(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 6);\n              return l ? (u || new e.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + l) + a * 12, this.bb) : null;\n            }\n            inputEdgesLength() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            outputEdges(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 8);\n              return l ? (u || new e.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + l) + a * 12, this.bb) : null;\n            }\n            outputEdgesLength() {\n              let a = this.bb.__offset(this.bb_pos, 8);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startNodeEdge(a) {\n              a.startObject(3);\n            }\n            static addNodeIndex(a, u) {\n              a.addFieldInt32(0, u, 0);\n            }\n            static addInputEdges(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static startInputEdgesVector(a, u) {\n              a.startVector(12, u, 4);\n            }\n            static addOutputEdges(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static startOutputEdgesVector(a, u) {\n              a.startVector(12, u, 4);\n            }\n            static endNodeEdge(a) {\n              return a.endObject();\n            }\n            static createNodeEdge(a, u, l, f) {\n              return r.startNodeEdge(a), r.addNodeIndex(a, u), r.addInputEdges(a, l), r.addOutputEdges(a, f), r.endNodeEdge(a);\n            }\n          }\n          n.NodeEdge = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsNode(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsNode(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            name(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            docString(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            domain(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            sinceVersion() {\n              let a = this.bb.__offset(this.bb_pos, 10);\n              return a ? this.bb.readInt32(this.bb_pos + a) : 0;\n            }\n            index() {\n              let a = this.bb.__offset(this.bb_pos, 12);\n              return a ? this.bb.readUint32(this.bb_pos + a) : 0;\n            }\n            opType(a) {\n              let u = this.bb.__offset(this.bb_pos, 14);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            type() {\n              let a = this.bb.__offset(this.bb_pos, 16);\n              return a ? this.bb.readInt32(this.bb_pos + a) : 0;\n            }\n            executionProviderType(a) {\n              let u = this.bb.__offset(this.bb_pos, 18);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            inputs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 20);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            inputsLength() {\n              let a = this.bb.__offset(this.bb_pos, 20);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            outputs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 22);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            outputsLength() {\n              let a = this.bb.__offset(this.bb_pos, 22);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            attributes(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 24);\n              return l ? (u || new e.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            attributesLength() {\n              let a = this.bb.__offset(this.bb_pos, 24);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            inputArgCounts(a) {\n              let u = this.bb.__offset(this.bb_pos, 26);\n              return u ? this.bb.readInt32(this.bb.__vector(this.bb_pos + u) + a * 4) : 0;\n            }\n            inputArgCountsLength() {\n              let a = this.bb.__offset(this.bb_pos, 26);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            inputArgCountsArray() {\n              let a = this.bb.__offset(this.bb_pos, 26);\n              return a ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + a), this.bb.__vector_len(this.bb_pos + a)) : null;\n            }\n            implicitInputs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 28);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            implicitInputsLength() {\n              let a = this.bb.__offset(this.bb_pos, 28);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startNode(a) {\n              a.startObject(13);\n            }\n            static addName(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addDocString(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static addDomain(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static addSinceVersion(a, u) {\n              a.addFieldInt32(3, u, 0);\n            }\n            static addIndex(a, u) {\n              a.addFieldInt32(4, u, 0);\n            }\n            static addOpType(a, u) {\n              a.addFieldOffset(5, u, 0);\n            }\n            static addType(a, u) {\n              a.addFieldInt32(6, u, 0);\n            }\n            static addExecutionProviderType(a, u) {\n              a.addFieldOffset(7, u, 0);\n            }\n            static addInputs(a, u) {\n              a.addFieldOffset(8, u, 0);\n            }\n            static createInputsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startInputsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addOutputs(a, u) {\n              a.addFieldOffset(9, u, 0);\n            }\n            static createOutputsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startOutputsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addAttributes(a, u) {\n              a.addFieldOffset(10, u, 0);\n            }\n            static createAttributesVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startAttributesVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addInputArgCounts(a, u) {\n              a.addFieldOffset(11, u, 0);\n            }\n            static createInputArgCountsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt32(u[l]);\n              return a.endVector();\n            }\n            static startInputArgCountsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addImplicitInputs(a, u) {\n              a.addFieldOffset(12, u, 0);\n            }\n            static createImplicitInputsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startImplicitInputsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static endNode(a) {\n              return a.endObject();\n            }\n            static createNode(a, u, l, f, p, d, y, T, v, S, L, P, A, M) {\n              return r.startNode(a), r.addName(a, u), r.addDocString(a, l), r.addDomain(a, f), r.addSinceVersion(a, p), r.addIndex(a, d), r.addOpType(a, y), r.addType(a, T), r.addExecutionProviderType(a, v), r.addInputs(a, S), r.addOutputs(a, L), r.addAttributes(a, P), r.addInputArgCounts(a, A), r.addImplicitInputs(a, M), r.endNode(a);\n            }\n          }\n          n.Node = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsValueInfo(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsValueInfo(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            name(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            docString(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            type(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? (a || new e.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            static startValueInfo(a) {\n              a.startObject(3);\n            }\n            static addName(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addDocString(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static addType(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static endValueInfo(a) {\n              return a.endObject();\n            }\n            static createValueInfo(a, u, l, f) {\n              return r.startValueInfo(a), r.addName(a, u), r.addDocString(a, l), r.addType(a, f), r.endValueInfo(a);\n            }\n          }\n          n.ValueInfo = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsTypeInfo(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsTypeInfo(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            denotation(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            valueType() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.readUint8(this.bb_pos + a) : 0;\n            }\n            value(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? this.bb.__union(a, this.bb_pos + u) : null;\n            }\n            static startTypeInfo(a) {\n              a.startObject(3);\n            }\n            static addDenotation(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addValueType(a, u) {\n              a.addFieldInt8(1, u, 0);\n            }\n            static addValue(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static endTypeInfo(a) {\n              return a.endObject();\n            }\n            static createTypeInfo(a, u, l, f) {\n              return r.startTypeInfo(a), r.addDenotation(a, u), r.addValueType(a, l), r.addValue(a, f), r.endTypeInfo(a);\n            }\n          }\n          n.TypeInfo = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsOperatorSetId(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsOperatorSetId(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            domain(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            version() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.readInt64(this.bb_pos + a) : this.bb.createLong(0, 0);\n            }\n            static startOperatorSetId(a) {\n              a.startObject(2);\n            }\n            static addDomain(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addVersion(a, u) {\n              a.addFieldInt64(1, u, a.createLong(0, 0));\n            }\n            static endOperatorSetId(a) {\n              return a.endObject();\n            }\n            static createOperatorSetId(a, u, l) {\n              return r.startOperatorSetId(a), r.addDomain(a, u), r.addVersion(a, l), r.endOperatorSetId(a);\n            }\n          }\n          n.OperatorSetId = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsTensor(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsTensor(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            name(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            docString(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            dims(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? this.bb.readInt64(this.bb.__vector(this.bb_pos + u) + a * 8) : this.bb.createLong(0, 0);\n            }\n            dimsLength() {\n              let a = this.bb.__offset(this.bb_pos, 8);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            dataType() {\n              let a = this.bb.__offset(this.bb_pos, 10);\n              return a ? this.bb.readInt32(this.bb_pos + a) : 0;\n            }\n            rawData(a) {\n              let u = this.bb.__offset(this.bb_pos, 12);\n              return u ? this.bb.readUint8(this.bb.__vector(this.bb_pos + u) + a) : 0;\n            }\n            rawDataLength() {\n              let a = this.bb.__offset(this.bb_pos, 12);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            rawDataArray() {\n              let a = this.bb.__offset(this.bb_pos, 12);\n              return a ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + a), this.bb.__vector_len(this.bb_pos + a)) : null;\n            }\n            stringData(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 14);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            stringDataLength() {\n              let a = this.bb.__offset(this.bb_pos, 14);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startTensor(a) {\n              a.startObject(6);\n            }\n            static addName(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addDocString(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static addDims(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static createDimsVector(a, u) {\n              a.startVector(8, u.length, 8);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt64(u[l]);\n              return a.endVector();\n            }\n            static startDimsVector(a, u) {\n              a.startVector(8, u, 8);\n            }\n            static addDataType(a, u) {\n              a.addFieldInt32(3, u, 0);\n            }\n            static addRawData(a, u) {\n              a.addFieldOffset(4, u, 0);\n            }\n            static createRawDataVector(a, u) {\n              a.startVector(1, u.length, 1);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt8(u[l]);\n              return a.endVector();\n            }\n            static startRawDataVector(a, u) {\n              a.startVector(1, u, 1);\n            }\n            static addStringData(a, u) {\n              a.addFieldOffset(5, u, 0);\n            }\n            static createStringDataVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startStringDataVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static endTensor(a) {\n              return a.endObject();\n            }\n            static createTensor(a, u, l, f, p, d, y) {\n              return r.startTensor(a), r.addName(a, u), r.addDocString(a, l), r.addDims(a, f), r.addDataType(a, p), r.addRawData(a, d), r.addStringData(a, y), r.endTensor(a);\n            }\n          }\n          n.Tensor = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsSparseTensor(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsSparseTensor(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            values(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? (a || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            indices(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? (a || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            dims(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? this.bb.readInt64(this.bb.__vector(this.bb_pos + u) + a * 8) : this.bb.createLong(0, 0);\n            }\n            dimsLength() {\n              let a = this.bb.__offset(this.bb_pos, 8);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startSparseTensor(a) {\n              a.startObject(3);\n            }\n            static addValues(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addIndices(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static addDims(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static createDimsVector(a, u) {\n              a.startVector(8, u.length, 8);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt64(u[l]);\n              return a.endVector();\n            }\n            static startDimsVector(a, u) {\n              a.startVector(8, u, 8);\n            }\n            static endSparseTensor(a) {\n              return a.endObject();\n            }\n            static createSparseTensor(a, u, l, f) {\n              return r.startSparseTensor(a), r.addValues(a, u), r.addIndices(a, l), r.addDims(a, f), r.endSparseTensor(a);\n            }\n          }\n          n.SparseTensor = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsAttribute(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsAttribute(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            name(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            docString(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            type() {\n              let a = this.bb.__offset(this.bb_pos, 8);\n              return a ? this.bb.readInt32(this.bb_pos + a) : 0;\n            }\n            f() {\n              let a = this.bb.__offset(this.bb_pos, 10);\n              return a ? this.bb.readFloat32(this.bb_pos + a) : 0;\n            }\n            i() {\n              let a = this.bb.__offset(this.bb_pos, 12);\n              return a ? this.bb.readInt64(this.bb_pos + a) : this.bb.createLong(0, 0);\n            }\n            s(a) {\n              let u = this.bb.__offset(this.bb_pos, 14);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            t(a) {\n              let u = this.bb.__offset(this.bb_pos, 16);\n              return u ? (a || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            g(a) {\n              let u = this.bb.__offset(this.bb_pos, 18);\n              return u ? (a || new e.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            floats(a) {\n              let u = this.bb.__offset(this.bb_pos, 20);\n              return u ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + u) + a * 4) : 0;\n            }\n            floatsLength() {\n              let a = this.bb.__offset(this.bb_pos, 20);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            floatsArray() {\n              let a = this.bb.__offset(this.bb_pos, 20);\n              return a ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + a), this.bb.__vector_len(this.bb_pos + a)) : null;\n            }\n            ints(a) {\n              let u = this.bb.__offset(this.bb_pos, 22);\n              return u ? this.bb.readInt64(this.bb.__vector(this.bb_pos + u) + a * 8) : this.bb.createLong(0, 0);\n            }\n            intsLength() {\n              let a = this.bb.__offset(this.bb_pos, 22);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            strings(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 24);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            stringsLength() {\n              let a = this.bb.__offset(this.bb_pos, 24);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            tensors(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 26);\n              return l ? (u || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            tensorsLength() {\n              let a = this.bb.__offset(this.bb_pos, 26);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            graphs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 28);\n              return l ? (u || new e.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            graphsLength() {\n              let a = this.bb.__offset(this.bb_pos, 28);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startAttribute(a) {\n              a.startObject(13);\n            }\n            static addName(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addDocString(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static addType(a, u) {\n              a.addFieldInt32(2, u, 0);\n            }\n            static addF(a, u) {\n              a.addFieldFloat32(3, u, 0);\n            }\n            static addI(a, u) {\n              a.addFieldInt64(4, u, a.createLong(0, 0));\n            }\n            static addS(a, u) {\n              a.addFieldOffset(5, u, 0);\n            }\n            static addT(a, u) {\n              a.addFieldOffset(6, u, 0);\n            }\n            static addG(a, u) {\n              a.addFieldOffset(7, u, 0);\n            }\n            static addFloats(a, u) {\n              a.addFieldOffset(8, u, 0);\n            }\n            static createFloatsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addFloat32(u[l]);\n              return a.endVector();\n            }\n            static startFloatsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addInts(a, u) {\n              a.addFieldOffset(9, u, 0);\n            }\n            static createIntsVector(a, u) {\n              a.startVector(8, u.length, 8);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt64(u[l]);\n              return a.endVector();\n            }\n            static startIntsVector(a, u) {\n              a.startVector(8, u, 8);\n            }\n            static addStrings(a, u) {\n              a.addFieldOffset(10, u, 0);\n            }\n            static createStringsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startStringsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addTensors(a, u) {\n              a.addFieldOffset(11, u, 0);\n            }\n            static createTensorsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startTensorsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addGraphs(a, u) {\n              a.addFieldOffset(12, u, 0);\n            }\n            static createGraphsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startGraphsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static endAttribute(a) {\n              return a.endObject();\n            }\n            static createAttribute(a, u, l, f, p, d, y, T, v, S, L, P, A, M) {\n              return r.startAttribute(a), r.addName(a, u), r.addDocString(a, l), r.addType(a, f), r.addF(a, p), r.addI(a, d), r.addS(a, y), r.addT(a, T), r.addG(a, v), r.addFloats(a, S), r.addInts(a, L), r.addStrings(a, P), r.addTensors(a, A), r.addGraphs(a, M), r.endAttribute(a);\n            }\n          }\n          n.Attribute = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsGraph(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsGraph(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            initializers(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 4);\n              return l ? (u || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            initializersLength() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            nodeArgs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 6);\n              return l ? (u || new e.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            nodeArgsLength() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            nodes(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 8);\n              return l ? (u || new e.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            nodesLength() {\n              let a = this.bb.__offset(this.bb_pos, 8);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            maxNodeIndex() {\n              let a = this.bb.__offset(this.bb_pos, 10);\n              return a ? this.bb.readUint32(this.bb_pos + a) : 0;\n            }\n            nodeEdges(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 12);\n              return l ? (u || new e.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            nodeEdgesLength() {\n              let a = this.bb.__offset(this.bb_pos, 12);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            inputs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 14);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            inputsLength() {\n              let a = this.bb.__offset(this.bb_pos, 14);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            outputs(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 16);\n              return l ? this.bb.__string(this.bb.__vector(this.bb_pos + l) + a * 4, u) : null;\n            }\n            outputsLength() {\n              let a = this.bb.__offset(this.bb_pos, 16);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            sparseInitializers(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 18);\n              return l ? (u || new e.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            sparseInitializersLength() {\n              let a = this.bb.__offset(this.bb_pos, 18);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startGraph(a) {\n              a.startObject(8);\n            }\n            static addInitializers(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static createInitializersVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startInitializersVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addNodeArgs(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static createNodeArgsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startNodeArgsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addNodes(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static createNodesVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startNodesVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addMaxNodeIndex(a, u) {\n              a.addFieldInt32(3, u, 0);\n            }\n            static addNodeEdges(a, u) {\n              a.addFieldOffset(4, u, 0);\n            }\n            static createNodeEdgesVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startNodeEdgesVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addInputs(a, u) {\n              a.addFieldOffset(5, u, 0);\n            }\n            static createInputsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startInputsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addOutputs(a, u) {\n              a.addFieldOffset(6, u, 0);\n            }\n            static createOutputsVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startOutputsVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addSparseInitializers(a, u) {\n              a.addFieldOffset(7, u, 0);\n            }\n            static createSparseInitializersVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startSparseInitializersVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static endGraph(a) {\n              return a.endObject();\n            }\n            static createGraph(a, u, l, f, p, d, y, T, v) {\n              return r.startGraph(a), r.addInitializers(a, u), r.addNodeArgs(a, l), r.addNodes(a, f), r.addMaxNodeIndex(a, p), r.addNodeEdges(a, d), r.addInputs(a, y), r.addOutputs(a, T), r.addSparseInitializers(a, v), r.endGraph(a);\n            }\n          }\n          n.Graph = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsModel(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsModel(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            irVersion() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.readInt64(this.bb_pos + a) : this.bb.createLong(0, 0);\n            }\n            opsetImport(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 6);\n              return l ? (u || new e.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            opsetImportLength() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            producerName(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            producerVersion(a) {\n              let u = this.bb.__offset(this.bb_pos, 10);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            domain(a) {\n              let u = this.bb.__offset(this.bb_pos, 12);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            modelVersion() {\n              let a = this.bb.__offset(this.bb_pos, 14);\n              return a ? this.bb.readInt64(this.bb_pos + a) : this.bb.createLong(0, 0);\n            }\n            docString(a) {\n              let u = this.bb.__offset(this.bb_pos, 16);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            graph(a) {\n              let u = this.bb.__offset(this.bb_pos, 18);\n              return u ? (a || new e.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            graphDocString(a) {\n              let u = this.bb.__offset(this.bb_pos, 20);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            static startModel(a) {\n              a.startObject(9);\n            }\n            static addIrVersion(a, u) {\n              a.addFieldInt64(0, u, a.createLong(0, 0));\n            }\n            static addOpsetImport(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static createOpsetImportVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startOpsetImportVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addProducerName(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static addProducerVersion(a, u) {\n              a.addFieldOffset(3, u, 0);\n            }\n            static addDomain(a, u) {\n              a.addFieldOffset(4, u, 0);\n            }\n            static addModelVersion(a, u) {\n              a.addFieldInt64(5, u, a.createLong(0, 0));\n            }\n            static addDocString(a, u) {\n              a.addFieldOffset(6, u, 0);\n            }\n            static addGraph(a, u) {\n              a.addFieldOffset(7, u, 0);\n            }\n            static addGraphDocString(a, u) {\n              a.addFieldOffset(8, u, 0);\n            }\n            static endModel(a) {\n              return a.endObject();\n            }\n            static createModel(a, u, l, f, p, d, y, T, v, S) {\n              return r.startModel(a), r.addIrVersion(a, u), r.addOpsetImport(a, l), r.addProducerName(a, f), r.addProducerVersion(a, p), r.addDomain(a, d), r.addModelVersion(a, y), r.addDocString(a, T), r.addGraph(a, v), r.addGraphDocString(a, S), r.endModel(a);\n            }\n          }\n          n.Model = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsKernelCreateInfos(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsKernelCreateInfos(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            nodeIndices(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.readUint32(this.bb.__vector(this.bb_pos + u) + a * 4) : 0;\n            }\n            nodeIndicesLength() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            nodeIndicesArray() {\n              let a = this.bb.__offset(this.bb_pos, 4);\n              return a ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + a), this.bb.__vector_len(this.bb_pos + a)) : null;\n            }\n            kernelDefHashes(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? this.bb.readUint64(this.bb.__vector(this.bb_pos + u) + a * 8) : this.bb.createLong(0, 0);\n            }\n            kernelDefHashesLength() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startKernelCreateInfos(a) {\n              a.startObject(2);\n            }\n            static addNodeIndices(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static createNodeIndicesVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt32(u[l]);\n              return a.endVector();\n            }\n            static startNodeIndicesVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static addKernelDefHashes(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static createKernelDefHashesVector(a, u) {\n              a.startVector(8, u.length, 8);\n              for (let l = u.length - 1; l >= 0; l--) a.addInt64(u[l]);\n              return a.endVector();\n            }\n            static startKernelDefHashesVector(a, u) {\n              a.startVector(8, u, 8);\n            }\n            static endKernelCreateInfos(a) {\n              return a.endObject();\n            }\n            static createKernelCreateInfos(a, u, l) {\n              return r.startKernelCreateInfos(a), r.addNodeIndices(a, u), r.addKernelDefHashes(a, l), r.endKernelCreateInfos(a);\n            }\n          }\n          n.KernelCreateInfos = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsSubGraphSessionState(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsSubGraphSessionState(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            graphId(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            sessionState(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? (a || new e.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            static startSubGraphSessionState(a) {\n              a.startObject(2);\n            }\n            static addGraphId(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addSessionState(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static endSubGraphSessionState(a) {\n              let u = a.endObject();\n              return a.requiredField(u, 4), u;\n            }\n            static createSubGraphSessionState(a, u, l) {\n              return r.startSubGraphSessionState(a), r.addGraphId(a, u), r.addSessionState(a, l), r.endSubGraphSessionState(a);\n            }\n          }\n          n.SubGraphSessionState = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsSessionState(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsSessionState(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            kernels(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? (a || new e.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            subGraphSessionStates(a, u) {\n              let l = this.bb.__offset(this.bb_pos, 6);\n              return l ? (u || new e.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l) + a * 4), this.bb) : null;\n            }\n            subGraphSessionStatesLength() {\n              let a = this.bb.__offset(this.bb_pos, 6);\n              return a ? this.bb.__vector_len(this.bb_pos + a) : 0;\n            }\n            static startSessionState(a) {\n              a.startObject(2);\n            }\n            static addKernels(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addSubGraphSessionStates(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static createSubGraphSessionStatesVector(a, u) {\n              a.startVector(4, u.length, 4);\n              for (let l = u.length - 1; l >= 0; l--) a.addOffset(u[l]);\n              return a.endVector();\n            }\n            static startSubGraphSessionStatesVector(a, u) {\n              a.startVector(4, u, 4);\n            }\n            static endSessionState(a) {\n              return a.endObject();\n            }\n            static createSessionState(a, u, l) {\n              return r.startSessionState(a), r.addKernels(a, u), r.addSubGraphSessionStates(a, l), r.endSessionState(a);\n            }\n          }\n          n.SessionState = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n    (e => {\n      let i;\n      (t => {\n        let o;\n        (n => {\n          class r {\n            constructor() {\n              this.bb = null;\n              this.bb_pos = 0;\n            }\n            __init(a, u) {\n              return this.bb_pos = a, this.bb = u, this;\n            }\n            static getRootAsInferenceSession(a, u) {\n              return (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static getSizePrefixedRootAsInferenceSession(a, u) {\n              return a.setPosition(a.position() + w.SIZE_PREFIX_LENGTH), (u || new r()).__init(a.readInt32(a.position()) + a.position(), a);\n            }\n            static bufferHasIdentifier(a) {\n              return a.__has_identifier(\"ORTM\");\n            }\n            ortVersion(a) {\n              let u = this.bb.__offset(this.bb_pos, 4);\n              return u ? this.bb.__string(this.bb_pos + u, a) : null;\n            }\n            model(a) {\n              let u = this.bb.__offset(this.bb_pos, 6);\n              return u ? (a || new e.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            sessionState(a) {\n              let u = this.bb.__offset(this.bb_pos, 8);\n              return u ? (a || new e.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + u), this.bb) : null;\n            }\n            static startInferenceSession(a) {\n              a.startObject(3);\n            }\n            static addOrtVersion(a, u) {\n              a.addFieldOffset(0, u, 0);\n            }\n            static addModel(a, u) {\n              a.addFieldOffset(1, u, 0);\n            }\n            static addSessionState(a, u) {\n              a.addFieldOffset(2, u, 0);\n            }\n            static endInferenceSession(a) {\n              return a.endObject();\n            }\n            static finishInferenceSessionBuffer(a, u) {\n              a.finish(u, \"ORTM\");\n            }\n            static finishSizePrefixedInferenceSessionBuffer(a, u) {\n              a.finish(u, \"ORTM\", !0);\n            }\n            static createInferenceSession(a, u, l, f) {\n              return r.startInferenceSession(a), r.addOrtVersion(a, u), r.addModel(a, l), r.addSessionState(a, f), r.endInferenceSession(a);\n            }\n          }\n          n.InferenceSession = r;\n        })(o = t.fbs ||= {});\n      })(i = e.experimental ||= {});\n    })(F ||= {});\n  });\nvar js = mt((Vy, qs) => {\n  \"use strict\";\n\n  qs.exports = ih;\n  function ih(i, e) {\n    for (var o = new Array(arguments.length - 1), t = 0, r = 2, n = !0; r < arguments.length;) o[t++] = arguments[r++];\n    return new Promise(function (a, u) {\n      o[t] = function (f) {\n        if (n) if (n = !1, f) u(f);else {\n          for (var p = new Array(arguments.length - 1), d = 0; d < p.length;) p[d++] = arguments[d];\n          a.apply(null, p);\n        }\n      };\n      try {\n        i.apply(e || null, o);\n      } catch (l) {\n        n && (n = !1, u(l));\n      }\n    });\n  }\n});\nvar Ys = mt(Js => {\n  \"use strict\";\n\n  var vn = Js;\n  vn.length = function (e) {\n    var o = e.length;\n    if (!o) return 0;\n    for (var t = 0; --o % 4 > 1 && e.charAt(o) === \"=\";) ++t;\n    return Math.ceil(e.length * 3) / 4 - t;\n  };\n  var ar = new Array(64),\n    Ks = new Array(123);\n  for (te = 0; te < 64;) Ks[ar[te] = te < 26 ? te + 65 : te < 52 ? te + 71 : te < 62 ? te - 4 : te - 59 | 43] = te++;\n  var te;\n  vn.encode = function (e, o, t) {\n    for (var r = null, n = [], s = 0, a = 0, u; o < t;) {\n      var l = e[o++];\n      switch (a) {\n        case 0:\n          n[s++] = ar[l >> 2], u = (l & 3) << 4, a = 1;\n          break;\n        case 1:\n          n[s++] = ar[u | l >> 4], u = (l & 15) << 2, a = 2;\n          break;\n        case 2:\n          n[s++] = ar[u | l >> 6], n[s++] = ar[l & 63], a = 0;\n          break;\n      }\n      s > 8191 && ((r || (r = [])).push(String.fromCharCode.apply(String, n)), s = 0);\n    }\n    return a && (n[s++] = ar[u], n[s++] = 61, a === 1 && (n[s++] = 61)), r ? (s && r.push(String.fromCharCode.apply(String, n.slice(0, s))), r.join(\"\")) : String.fromCharCode.apply(String, n.slice(0, s));\n  };\n  var Xs = \"invalid encoding\";\n  vn.decode = function (e, o, t) {\n    for (var r = t, n = 0, s, a = 0; a < e.length;) {\n      var u = e.charCodeAt(a++);\n      if (u === 61 && n > 1) break;\n      if ((u = Ks[u]) === void 0) throw Error(Xs);\n      switch (n) {\n        case 0:\n          s = u, n = 1;\n          break;\n        case 1:\n          o[t++] = s << 2 | (u & 48) >> 4, s = u, n = 2;\n          break;\n        case 2:\n          o[t++] = (s & 15) << 4 | (u & 60) >> 2, s = u, n = 3;\n          break;\n        case 3:\n          o[t++] = (s & 3) << 6 | u, n = 0;\n          break;\n      }\n    }\n    if (n === 1) throw Error(Xs);\n    return t - r;\n  };\n  vn.test = function (e) {\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e);\n  };\n});\nvar Qs = mt((Wy, Zs) => {\n  \"use strict\";\n\n  Zs.exports = In;\n  function In() {\n    this._listeners = {};\n  }\n  In.prototype.on = function (e, o, t) {\n    return (this._listeners[e] || (this._listeners[e] = [])).push({\n      fn: o,\n      ctx: t || this\n    }), this;\n  };\n  In.prototype.off = function (e, o) {\n    if (e === void 0) this._listeners = {};else if (o === void 0) this._listeners[e] = [];else for (var t = this._listeners[e], r = 0; r < t.length;) t[r].fn === o ? t.splice(r, 1) : ++r;\n    return this;\n  };\n  In.prototype.emit = function (e) {\n    var o = this._listeners[e];\n    if (o) {\n      for (var t = [], r = 1; r < arguments.length;) t.push(arguments[r++]);\n      for (r = 0; r < o.length;) o[r].fn.apply(o[r++].ctx, t);\n    }\n    return this;\n  };\n});\nvar au = mt((Hy, iu) => {\n  \"use strict\";\n\n  iu.exports = tu(tu);\n  function tu(i) {\n    return typeof Float32Array < \"u\" ? function () {\n      var e = new Float32Array([-0]),\n        o = new Uint8Array(e.buffer),\n        t = o[3] === 128;\n      function r(u, l, f) {\n        e[0] = u, l[f] = o[0], l[f + 1] = o[1], l[f + 2] = o[2], l[f + 3] = o[3];\n      }\n      function n(u, l, f) {\n        e[0] = u, l[f] = o[3], l[f + 1] = o[2], l[f + 2] = o[1], l[f + 3] = o[0];\n      }\n      i.writeFloatLE = t ? r : n, i.writeFloatBE = t ? n : r;\n      function s(u, l) {\n        return o[0] = u[l], o[1] = u[l + 1], o[2] = u[l + 2], o[3] = u[l + 3], e[0];\n      }\n      function a(u, l) {\n        return o[3] = u[l], o[2] = u[l + 1], o[1] = u[l + 2], o[0] = u[l + 3], e[0];\n      }\n      i.readFloatLE = t ? s : a, i.readFloatBE = t ? a : s;\n    }() : function () {\n      function e(t, r, n, s) {\n        var a = r < 0 ? 1 : 0;\n        if (a && (r = -r), r === 0) t(1 / r > 0 ? 0 : 2147483648, n, s);else if (isNaN(r)) t(2143289344, n, s);else if (r > 34028234663852886e22) t((a << 31 | 2139095040) >>> 0, n, s);else if (r < 11754943508222875e-54) t((a << 31 | Math.round(r / 1401298464324817e-60)) >>> 0, n, s);else {\n          var u = Math.floor(Math.log(r) / Math.LN2),\n            l = Math.round(r * Math.pow(2, -u) * 8388608) & 8388607;\n          t((a << 31 | u + 127 << 23 | l) >>> 0, n, s);\n        }\n      }\n      i.writeFloatLE = e.bind(null, eu), i.writeFloatBE = e.bind(null, ru);\n      function o(t, r, n) {\n        var s = t(r, n),\n          a = (s >> 31) * 2 + 1,\n          u = s >>> 23 & 255,\n          l = s & 8388607;\n        return u === 255 ? l ? NaN : a * (1 / 0) : u === 0 ? a * 1401298464324817e-60 * l : a * Math.pow(2, u - 150) * (l + 8388608);\n      }\n      i.readFloatLE = o.bind(null, nu), i.readFloatBE = o.bind(null, ou);\n    }(), typeof Float64Array < \"u\" ? function () {\n      var e = new Float64Array([-0]),\n        o = new Uint8Array(e.buffer),\n        t = o[7] === 128;\n      function r(u, l, f) {\n        e[0] = u, l[f] = o[0], l[f + 1] = o[1], l[f + 2] = o[2], l[f + 3] = o[3], l[f + 4] = o[4], l[f + 5] = o[5], l[f + 6] = o[6], l[f + 7] = o[7];\n      }\n      function n(u, l, f) {\n        e[0] = u, l[f] = o[7], l[f + 1] = o[6], l[f + 2] = o[5], l[f + 3] = o[4], l[f + 4] = o[3], l[f + 5] = o[2], l[f + 6] = o[1], l[f + 7] = o[0];\n      }\n      i.writeDoubleLE = t ? r : n, i.writeDoubleBE = t ? n : r;\n      function s(u, l) {\n        return o[0] = u[l], o[1] = u[l + 1], o[2] = u[l + 2], o[3] = u[l + 3], o[4] = u[l + 4], o[5] = u[l + 5], o[6] = u[l + 6], o[7] = u[l + 7], e[0];\n      }\n      function a(u, l) {\n        return o[7] = u[l], o[6] = u[l + 1], o[5] = u[l + 2], o[4] = u[l + 3], o[3] = u[l + 4], o[2] = u[l + 5], o[1] = u[l + 6], o[0] = u[l + 7], e[0];\n      }\n      i.readDoubleLE = t ? s : a, i.readDoubleBE = t ? a : s;\n    }() : function () {\n      function e(t, r, n, s, a, u) {\n        var l = s < 0 ? 1 : 0;\n        if (l && (s = -s), s === 0) t(0, a, u + r), t(1 / s > 0 ? 0 : 2147483648, a, u + n);else if (isNaN(s)) t(0, a, u + r), t(2146959360, a, u + n);else if (s > 17976931348623157e292) t(0, a, u + r), t((l << 31 | 2146435072) >>> 0, a, u + n);else {\n          var f;\n          if (s < 22250738585072014e-324) f = s / 5e-324, t(f >>> 0, a, u + r), t((l << 31 | f / 4294967296) >>> 0, a, u + n);else {\n            var p = Math.floor(Math.log(s) / Math.LN2);\n            p === 1024 && (p = 1023), f = s * Math.pow(2, -p), t(f * 4503599627370496 >>> 0, a, u + r), t((l << 31 | p + 1023 << 20 | f * 1048576 & 1048575) >>> 0, a, u + n);\n          }\n        }\n      }\n      i.writeDoubleLE = e.bind(null, eu, 0, 4), i.writeDoubleBE = e.bind(null, ru, 4, 0);\n      function o(t, r, n, s, a) {\n        var u = t(s, a + r),\n          l = t(s, a + n),\n          f = (l >> 31) * 2 + 1,\n          p = l >>> 20 & 2047,\n          d = 4294967296 * (l & 1048575) + u;\n        return p === 2047 ? d ? NaN : f * (1 / 0) : p === 0 ? f * 5e-324 * d : f * Math.pow(2, p - 1075) * (d + 4503599627370496);\n      }\n      i.readDoubleLE = o.bind(null, nu, 0, 4), i.readDoubleBE = o.bind(null, ou, 4, 0);\n    }(), i;\n  }\n  function eu(i, e, o) {\n    e[o] = i & 255, e[o + 1] = i >>> 8 & 255, e[o + 2] = i >>> 16 & 255, e[o + 3] = i >>> 24;\n  }\n  function ru(i, e, o) {\n    e[o] = i >>> 24, e[o + 1] = i >>> 16 & 255, e[o + 2] = i >>> 8 & 255, e[o + 3] = i & 255;\n  }\n  function nu(i, e) {\n    return (i[e] | i[e + 1] << 8 | i[e + 2] << 16 | i[e + 3] << 24) >>> 0;\n  }\n  function ou(i, e) {\n    return (i[e] << 24 | i[e + 1] << 16 | i[e + 2] << 8 | i[e + 3]) >>> 0;\n  }\n});\nvar su = mt((exports, module) => {\n  \"use strict\";\n\n  module.exports = inquire;\n  function inquire(moduleName) {\n    try {\n      var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n      if (mod && (mod.length || Object.keys(mod).length)) return mod;\n    } catch (i) {}\n    return null;\n  }\n});\nvar lu = mt(uu => {\n  \"use strict\";\n\n  var jo = uu;\n  jo.length = function (e) {\n    for (var o = 0, t = 0, r = 0; r < e.length; ++r) t = e.charCodeAt(r), t < 128 ? o += 1 : t < 2048 ? o += 2 : (t & 64512) === 55296 && (e.charCodeAt(r + 1) & 64512) === 56320 ? (++r, o += 4) : o += 3;\n    return o;\n  };\n  jo.read = function (e, o, t) {\n    var r = t - o;\n    if (r < 1) return \"\";\n    for (var n = null, s = [], a = 0, u; o < t;) u = e[o++], u < 128 ? s[a++] = u : u > 191 && u < 224 ? s[a++] = (u & 31) << 6 | e[o++] & 63 : u > 239 && u < 365 ? (u = ((u & 7) << 18 | (e[o++] & 63) << 12 | (e[o++] & 63) << 6 | e[o++] & 63) - 65536, s[a++] = 55296 + (u >> 10), s[a++] = 56320 + (u & 1023)) : s[a++] = (u & 15) << 12 | (e[o++] & 63) << 6 | e[o++] & 63, a > 8191 && ((n || (n = [])).push(String.fromCharCode.apply(String, s)), a = 0);\n    return n ? (a && n.push(String.fromCharCode.apply(String, s.slice(0, a))), n.join(\"\")) : String.fromCharCode.apply(String, s.slice(0, a));\n  };\n  jo.write = function (e, o, t) {\n    for (var r = t, n, s, a = 0; a < e.length; ++a) n = e.charCodeAt(a), n < 128 ? o[t++] = n : n < 2048 ? (o[t++] = n >> 6 | 192, o[t++] = n & 63 | 128) : (n & 64512) === 55296 && ((s = e.charCodeAt(a + 1)) & 64512) === 56320 ? (n = 65536 + ((n & 1023) << 10) + (s & 1023), ++a, o[t++] = n >> 18 | 240, o[t++] = n >> 12 & 63 | 128, o[t++] = n >> 6 & 63 | 128, o[t++] = n & 63 | 128) : (o[t++] = n >> 12 | 224, o[t++] = n >> 6 & 63 | 128, o[t++] = n & 63 | 128);\n    return t - r;\n  };\n});\nvar cu = mt((jy, fu) => {\n  \"use strict\";\n\n  fu.exports = ah;\n  function ah(i, e, o) {\n    var t = o || 8192,\n      r = t >>> 1,\n      n = null,\n      s = t;\n    return function (u) {\n      if (u < 1 || u > r) return i(u);\n      s + u > t && (n = i(t), s = 0);\n      var l = e.call(n, s, s += u);\n      return s & 7 && (s = (s | 7) + 1), l;\n    };\n  }\n});\nvar du = mt((Xy, pu) => {\n  \"use strict\";\n\n  pu.exports = vt;\n  var Er = Se();\n  function vt(i, e) {\n    this.lo = i >>> 0, this.hi = e >>> 0;\n  }\n  var Re = vt.zero = new vt(0, 0);\n  Re.toNumber = function () {\n    return 0;\n  };\n  Re.zzEncode = Re.zzDecode = function () {\n    return this;\n  };\n  Re.length = function () {\n    return 1;\n  };\n  var sh = vt.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n  vt.fromNumber = function (e) {\n    if (e === 0) return Re;\n    var o = e < 0;\n    o && (e = -e);\n    var t = e >>> 0,\n      r = (e - t) / 4294967296 >>> 0;\n    return o && (r = ~r >>> 0, t = ~t >>> 0, ++t > 4294967295 && (t = 0, ++r > 4294967295 && (r = 0))), new vt(t, r);\n  };\n  vt.from = function (e) {\n    if (typeof e == \"number\") return vt.fromNumber(e);\n    if (Er.isString(e)) if (Er.Long) e = Er.Long.fromString(e);else return vt.fromNumber(parseInt(e, 10));\n    return e.low || e.high ? new vt(e.low >>> 0, e.high >>> 0) : Re;\n  };\n  vt.prototype.toNumber = function (e) {\n    if (!e && this.hi >>> 31) {\n      var o = ~this.lo + 1 >>> 0,\n        t = ~this.hi >>> 0;\n      return o || (t = t + 1 >>> 0), -(o + t * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n  };\n  vt.prototype.toLong = function (e) {\n    return Er.Long ? new Er.Long(this.lo | 0, this.hi | 0, !!e) : {\n      low: this.lo | 0,\n      high: this.hi | 0,\n      unsigned: !!e\n    };\n  };\n  var Oe = String.prototype.charCodeAt;\n  vt.fromHash = function (e) {\n    return e === sh ? Re : new vt((Oe.call(e, 0) | Oe.call(e, 1) << 8 | Oe.call(e, 2) << 16 | Oe.call(e, 3) << 24) >>> 0, (Oe.call(e, 4) | Oe.call(e, 5) << 8 | Oe.call(e, 6) << 16 | Oe.call(e, 7) << 24) >>> 0);\n  };\n  vt.prototype.toHash = function () {\n    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n  };\n  vt.prototype.zzEncode = function () {\n    var e = this.hi >> 31;\n    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;\n  };\n  vt.prototype.zzDecode = function () {\n    var e = -(this.lo & 1);\n    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;\n  };\n  vt.prototype.length = function () {\n    var e = this.lo,\n      o = (this.lo >>> 28 | this.hi << 4) >>> 0,\n      t = this.hi >>> 24;\n    return t === 0 ? o === 0 ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : o < 16384 ? o < 128 ? 5 : 6 : o < 2097152 ? 7 : 8 : t < 128 ? 9 : 10;\n  };\n});\nvar Se = mt(Xo => {\n  \"use strict\";\n\n  var N = Xo;\n  N.asPromise = js();\n  N.base64 = Ys();\n  N.EventEmitter = Qs();\n  N.float = au();\n  N.inquire = su();\n  N.utf8 = lu();\n  N.pool = cu();\n  N.LongBits = du();\n  N.isNode = !!(typeof global < \"u\" && global && global.process && global.process.versions && global.process.versions.node);\n  N.global = N.isNode && global || typeof window < \"u\" && window || typeof self < \"u\" && self || Xo;\n  N.emptyArray = Object.freeze ? Object.freeze([]) : [];\n  N.emptyObject = Object.freeze ? Object.freeze({}) : {};\n  N.isInteger = Number.isInteger || function (e) {\n    return typeof e == \"number\" && isFinite(e) && Math.floor(e) === e;\n  };\n  N.isString = function (e) {\n    return typeof e == \"string\" || e instanceof String;\n  };\n  N.isObject = function (e) {\n    return e && typeof e == \"object\";\n  };\n  N.isset = N.isSet = function (e, o) {\n    var t = e[o];\n    return t != null && e.hasOwnProperty(o) ? typeof t != \"object\" || (Array.isArray(t) ? t.length : Object.keys(t).length) > 0 : !1;\n  };\n  N.Buffer = function () {\n    try {\n      var i = N.inquire(\"buffer\").Buffer;\n      return i.prototype.utf8Write ? i : null;\n    } catch {\n      return null;\n    }\n  }();\n  N._Buffer_from = null;\n  N._Buffer_allocUnsafe = null;\n  N.newBuffer = function (e) {\n    return typeof e == \"number\" ? N.Buffer ? N._Buffer_allocUnsafe(e) : new N.Array(e) : N.Buffer ? N._Buffer_from(e) : typeof Uint8Array > \"u\" ? e : new Uint8Array(e);\n  };\n  N.Array = typeof Uint8Array < \"u\" ? Uint8Array : Array;\n  N.Long = N.global.dcodeIO && N.global.dcodeIO.Long || N.global.Long || N.inquire(\"long\");\n  N.key2Re = /^true|false|0|1$/;\n  N.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n  N.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n  N.longToHash = function (e) {\n    return e ? N.LongBits.from(e).toHash() : N.LongBits.zeroHash;\n  };\n  N.longFromHash = function (e, o) {\n    var t = N.LongBits.fromHash(e);\n    return N.Long ? N.Long.fromBits(t.lo, t.hi, o) : t.toNumber(!!o);\n  };\n  function hu(i, e, o) {\n    for (var t = Object.keys(e), r = 0; r < t.length; ++r) (i[t[r]] === void 0 || !o) && (i[t[r]] = e[t[r]]);\n    return i;\n  }\n  N.merge = hu;\n  N.lcFirst = function (e) {\n    return e.charAt(0).toLowerCase() + e.substring(1);\n  };\n  function mu(i) {\n    function e(o, t) {\n      if (!(this instanceof e)) return new e(o, t);\n      Object.defineProperty(this, \"message\", {\n        get: function () {\n          return o;\n        }\n      }), Error.captureStackTrace ? Error.captureStackTrace(this, e) : Object.defineProperty(this, \"stack\", {\n        value: new Error().stack || \"\"\n      }), t && hu(this, t);\n    }\n    return e.prototype = Object.create(Error.prototype, {\n      constructor: {\n        value: e,\n        writable: !0,\n        enumerable: !1,\n        configurable: !0\n      },\n      name: {\n        get: function () {\n          return i;\n        },\n        set: void 0,\n        enumerable: !1,\n        configurable: !0\n      },\n      toString: {\n        value: function () {\n          return this.name + \": \" + this.message;\n        },\n        writable: !0,\n        enumerable: !1,\n        configurable: !0\n      }\n    }), e;\n  }\n  N.newError = mu;\n  N.ProtocolError = mu(\"ProtocolError\");\n  N.oneOfGetter = function (e) {\n    for (var o = {}, t = 0; t < e.length; ++t) o[e[t]] = 1;\n    return function () {\n      for (var r = Object.keys(this), n = r.length - 1; n > -1; --n) if (o[r[n]] === 1 && this[r[n]] !== void 0 && this[r[n]] !== null) return r[n];\n    };\n  };\n  N.oneOfSetter = function (e) {\n    return function (o) {\n      for (var t = 0; t < e.length; ++t) e[t] !== o && delete this[e[t]];\n    };\n  };\n  N.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: !0\n  };\n  N._configure = function () {\n    var i = N.Buffer;\n    if (!i) {\n      N._Buffer_from = N._Buffer_allocUnsafe = null;\n      return;\n    }\n    N._Buffer_from = i.from !== Uint8Array.from && i.from || function (o, t) {\n      return new i(o, t);\n    }, N._Buffer_allocUnsafe = i.allocUnsafe || function (o) {\n      return new i(o);\n    };\n  };\n});\nvar ei = mt((Jy, xu) => {\n  \"use strict\";\n\n  xu.exports = X;\n  var Wt = Se(),\n    Ko,\n    _n = Wt.LongBits,\n    bu = Wt.base64,\n    gu = Wt.utf8;\n  function Dr(i, e, o) {\n    this.fn = i, this.len = e, this.next = void 0, this.val = o;\n  }\n  function Yo() {}\n  function uh(i) {\n    this.head = i.head, this.tail = i.tail, this.len = i.len, this.next = i.states;\n  }\n  function X() {\n    this.len = 0, this.head = new Dr(Yo, 0, 0), this.tail = this.head, this.states = null;\n  }\n  var yu = function () {\n    return Wt.Buffer ? function () {\n      return (X.create = function () {\n        return new Ko();\n      })();\n    } : function () {\n      return new X();\n    };\n  };\n  X.create = yu();\n  X.alloc = function (e) {\n    return new Wt.Array(e);\n  };\n  Wt.Array !== Array && (X.alloc = Wt.pool(X.alloc, Wt.Array.prototype.subarray));\n  X.prototype._push = function (e, o, t) {\n    return this.tail = this.tail.next = new Dr(e, o, t), this.len += o, this;\n  };\n  function Zo(i, e, o) {\n    e[o] = i & 255;\n  }\n  function lh(i, e, o) {\n    for (; i > 127;) e[o++] = i & 127 | 128, i >>>= 7;\n    e[o] = i;\n  }\n  function Qo(i, e) {\n    this.len = i, this.next = void 0, this.val = e;\n  }\n  Qo.prototype = Object.create(Dr.prototype);\n  Qo.prototype.fn = lh;\n  X.prototype.uint32 = function (e) {\n    return this.len += (this.tail = this.tail.next = new Qo((e = e >>> 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;\n  };\n  X.prototype.int32 = function (e) {\n    return e < 0 ? this._push(ti, 10, _n.fromNumber(e)) : this.uint32(e);\n  };\n  X.prototype.sint32 = function (e) {\n    return this.uint32((e << 1 ^ e >> 31) >>> 0);\n  };\n  function ti(i, e, o) {\n    for (; i.hi;) e[o++] = i.lo & 127 | 128, i.lo = (i.lo >>> 7 | i.hi << 25) >>> 0, i.hi >>>= 7;\n    for (; i.lo > 127;) e[o++] = i.lo & 127 | 128, i.lo = i.lo >>> 7;\n    e[o++] = i.lo;\n  }\n  X.prototype.uint64 = function (e) {\n    var o = _n.from(e);\n    return this._push(ti, o.length(), o);\n  };\n  X.prototype.int64 = X.prototype.uint64;\n  X.prototype.sint64 = function (e) {\n    var o = _n.from(e).zzEncode();\n    return this._push(ti, o.length(), o);\n  };\n  X.prototype.bool = function (e) {\n    return this._push(Zo, 1, e ? 1 : 0);\n  };\n  function Jo(i, e, o) {\n    e[o] = i & 255, e[o + 1] = i >>> 8 & 255, e[o + 2] = i >>> 16 & 255, e[o + 3] = i >>> 24;\n  }\n  X.prototype.fixed32 = function (e) {\n    return this._push(Jo, 4, e >>> 0);\n  };\n  X.prototype.sfixed32 = X.prototype.fixed32;\n  X.prototype.fixed64 = function (e) {\n    var o = _n.from(e);\n    return this._push(Jo, 4, o.lo)._push(Jo, 4, o.hi);\n  };\n  X.prototype.sfixed64 = X.prototype.fixed64;\n  X.prototype.float = function (e) {\n    return this._push(Wt.float.writeFloatLE, 4, e);\n  };\n  X.prototype.double = function (e) {\n    return this._push(Wt.float.writeDoubleLE, 8, e);\n  };\n  var fh = Wt.Array.prototype.set ? function (e, o, t) {\n    o.set(e, t);\n  } : function (e, o, t) {\n    for (var r = 0; r < e.length; ++r) o[t + r] = e[r];\n  };\n  X.prototype.bytes = function (e) {\n    var o = e.length >>> 0;\n    if (!o) return this._push(Zo, 1, 0);\n    if (Wt.isString(e)) {\n      var t = X.alloc(o = bu.length(e));\n      bu.decode(e, t, 0), e = t;\n    }\n    return this.uint32(o)._push(fh, o, e);\n  };\n  X.prototype.string = function (e) {\n    var o = gu.length(e);\n    return o ? this.uint32(o)._push(gu.write, o, e) : this._push(Zo, 1, 0);\n  };\n  X.prototype.fork = function () {\n    return this.states = new uh(this), this.head = this.tail = new Dr(Yo, 0, 0), this.len = 0, this;\n  };\n  X.prototype.reset = function () {\n    return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Dr(Yo, 0, 0), this.len = 0), this;\n  };\n  X.prototype.ldelim = function () {\n    var e = this.head,\n      o = this.tail,\n      t = this.len;\n    return this.reset().uint32(t), t && (this.tail.next = e.next, this.tail = o, this.len += t), this;\n  };\n  X.prototype.finish = function () {\n    for (var e = this.head.next, o = this.constructor.alloc(this.len), t = 0; e;) e.fn(e.val, o, t), t += e.len, e = e.next;\n    return o;\n  };\n  X._configure = function (i) {\n    Ko = i, X.create = yu(), Ko._configure();\n  };\n});\nvar vu = mt((Yy, wu) => {\n  \"use strict\";\n\n  wu.exports = ce;\n  var Tu = ei();\n  (ce.prototype = Object.create(Tu.prototype)).constructor = ce;\n  var Ae = Se();\n  function ce() {\n    Tu.call(this);\n  }\n  ce._configure = function () {\n    ce.alloc = Ae._Buffer_allocUnsafe, ce.writeBytesBuffer = Ae.Buffer && Ae.Buffer.prototype instanceof Uint8Array && Ae.Buffer.prototype.set.name === \"set\" ? function (e, o, t) {\n      o.set(e, t);\n    } : function (e, o, t) {\n      if (e.copy) e.copy(o, t, 0, e.length);else for (var r = 0; r < e.length;) o[t++] = e[r++];\n    };\n  };\n  ce.prototype.bytes = function (e) {\n    Ae.isString(e) && (e = Ae._Buffer_from(e, \"base64\"));\n    var o = e.length >>> 0;\n    return this.uint32(o), o && this._push(ce.writeBytesBuffer, o, e), this;\n  };\n  function ch(i, e, o) {\n    i.length < 40 ? Ae.utf8.write(i, e, o) : e.utf8Write ? e.utf8Write(i, o) : e.write(i, o);\n  }\n  ce.prototype.string = function (e) {\n    var o = Ae.Buffer.byteLength(e);\n    return this.uint32(o), o && this._push(ch, o, e), this;\n  };\n  ce._configure();\n});\nvar oi = mt((Zy, Au) => {\n  \"use strict\";\n\n  Au.exports = ct;\n  var ee = Se(),\n    ni,\n    Ou = ee.LongBits,\n    ph = ee.utf8;\n  function re(i, e) {\n    return RangeError(\"index out of range: \" + i.pos + \" + \" + (e || 1) + \" > \" + i.len);\n  }\n  function ct(i) {\n    this.buf = i, this.pos = 0, this.len = i.length;\n  }\n  var Iu = typeof Uint8Array < \"u\" ? function (e) {\n      if (e instanceof Uint8Array || Array.isArray(e)) return new ct(e);\n      throw Error(\"illegal buffer\");\n    } : function (e) {\n      if (Array.isArray(e)) return new ct(e);\n      throw Error(\"illegal buffer\");\n    },\n    Su = function () {\n      return ee.Buffer ? function (o) {\n        return (ct.create = function (r) {\n          return ee.Buffer.isBuffer(r) ? new ni(r) : Iu(r);\n        })(o);\n      } : Iu;\n    };\n  ct.create = Su();\n  ct.prototype._slice = ee.Array.prototype.subarray || ee.Array.prototype.slice;\n  ct.prototype.uint32 = function () {\n    var e = 4294967295;\n    return function () {\n      if (e = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (e = (e | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128)) return e;\n      if ((this.pos += 5) > this.len) throw this.pos = this.len, re(this, 10);\n      return e;\n    };\n  }();\n  ct.prototype.int32 = function () {\n    return this.uint32() | 0;\n  };\n  ct.prototype.sint32 = function () {\n    var e = this.uint32();\n    return e >>> 1 ^ -(e & 1) | 0;\n  };\n  function ri() {\n    var i = new Ou(0, 0),\n      e = 0;\n    if (this.len - this.pos > 4) {\n      for (; e < 4; ++e) if (i.lo = (i.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128) return i;\n      if (i.lo = (i.lo | (this.buf[this.pos] & 127) << 28) >>> 0, i.hi = (i.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128) return i;\n      e = 0;\n    } else {\n      for (; e < 3; ++e) {\n        if (this.pos >= this.len) throw re(this);\n        if (i.lo = (i.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128) return i;\n      }\n      return i.lo = (i.lo | (this.buf[this.pos++] & 127) << e * 7) >>> 0, i;\n    }\n    if (this.len - this.pos > 4) {\n      for (; e < 5; ++e) if (i.hi = (i.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return i;\n    } else for (; e < 5; ++e) {\n      if (this.pos >= this.len) throw re(this);\n      if (i.hi = (i.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return i;\n    }\n    throw Error(\"invalid varint encoding\");\n  }\n  ct.prototype.bool = function () {\n    return this.uint32() !== 0;\n  };\n  function On(i, e) {\n    return (i[e - 4] | i[e - 3] << 8 | i[e - 2] << 16 | i[e - 1] << 24) >>> 0;\n  }\n  ct.prototype.fixed32 = function () {\n    if (this.pos + 4 > this.len) throw re(this, 4);\n    return On(this.buf, this.pos += 4);\n  };\n  ct.prototype.sfixed32 = function () {\n    if (this.pos + 4 > this.len) throw re(this, 4);\n    return On(this.buf, this.pos += 4) | 0;\n  };\n  function _u() {\n    if (this.pos + 8 > this.len) throw re(this, 8);\n    return new Ou(On(this.buf, this.pos += 4), On(this.buf, this.pos += 4));\n  }\n  ct.prototype.float = function () {\n    if (this.pos + 4 > this.len) throw re(this, 4);\n    var e = ee.float.readFloatLE(this.buf, this.pos);\n    return this.pos += 4, e;\n  };\n  ct.prototype.double = function () {\n    if (this.pos + 8 > this.len) throw re(this, 4);\n    var e = ee.float.readDoubleLE(this.buf, this.pos);\n    return this.pos += 8, e;\n  };\n  ct.prototype.bytes = function () {\n    var e = this.uint32(),\n      o = this.pos,\n      t = this.pos + e;\n    if (t > this.len) throw re(this, e);\n    if (this.pos += e, Array.isArray(this.buf)) return this.buf.slice(o, t);\n    if (o === t) {\n      var r = ee.Buffer;\n      return r ? r.alloc(0) : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, o, t);\n  };\n  ct.prototype.string = function () {\n    var e = this.bytes();\n    return ph.read(e, 0, e.length);\n  };\n  ct.prototype.skip = function (e) {\n    if (typeof e == \"number\") {\n      if (this.pos + e > this.len) throw re(this, e);\n      this.pos += e;\n    } else do if (this.pos >= this.len) throw re(this); while (this.buf[this.pos++] & 128);\n    return this;\n  };\n  ct.prototype.skipType = function (i) {\n    switch (i) {\n      case 0:\n        this.skip();\n        break;\n      case 1:\n        this.skip(8);\n        break;\n      case 2:\n        this.skip(this.uint32());\n        break;\n      case 3:\n        for (; (i = this.uint32() & 7) !== 4;) this.skipType(i);\n        break;\n      case 5:\n        this.skip(4);\n        break;\n      default:\n        throw Error(\"invalid wire type \" + i + \" at offset \" + this.pos);\n    }\n    return this;\n  };\n  ct._configure = function (i) {\n    ni = i, ct.create = Su(), ni._configure();\n    var e = ee.Long ? \"toLong\" : \"toNumber\";\n    ee.merge(ct.prototype, {\n      int64: function () {\n        return ri.call(this)[e](!1);\n      },\n      uint64: function () {\n        return ri.call(this)[e](!0);\n      },\n      sint64: function () {\n        return ri.call(this).zzDecode()[e](!1);\n      },\n      fixed64: function () {\n        return _u.call(this)[e](!0);\n      },\n      sfixed64: function () {\n        return _u.call(this)[e](!1);\n      }\n    });\n  };\n});\nvar Lu = mt((Qy, Du) => {\n  \"use strict\";\n\n  Du.exports = Ge;\n  var Eu = oi();\n  (Ge.prototype = Object.create(Eu.prototype)).constructor = Ge;\n  var Pu = Se();\n  function Ge(i) {\n    Eu.call(this, i);\n  }\n  Ge._configure = function () {\n    Pu.Buffer && (Ge.prototype._slice = Pu.Buffer.prototype.slice);\n  };\n  Ge.prototype.string = function () {\n    var e = this.uint32();\n    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + e, this.len));\n  };\n  Ge._configure();\n});\nvar ku = mt((tx, $u) => {\n  \"use strict\";\n\n  $u.exports = Lr;\n  var ii = Se();\n  (Lr.prototype = Object.create(ii.EventEmitter.prototype)).constructor = Lr;\n  function Lr(i, e, o) {\n    if (typeof i != \"function\") throw TypeError(\"rpcImpl must be a function\");\n    ii.EventEmitter.call(this), this.rpcImpl = i, this.requestDelimited = !!e, this.responseDelimited = !!o;\n  }\n  Lr.prototype.rpcCall = function i(e, o, t, r, n) {\n    if (!r) throw TypeError(\"request must be specified\");\n    var s = this;\n    if (!n) return ii.asPromise(i, s, e, o, t, r);\n    if (!s.rpcImpl) {\n      setTimeout(function () {\n        n(Error(\"already ended\"));\n      }, 0);\n      return;\n    }\n    try {\n      return s.rpcImpl(e, o[s.requestDelimited ? \"encodeDelimited\" : \"encode\"](r).finish(), function (u, l) {\n        if (u) return s.emit(\"error\", u, e), n(u);\n        if (l === null) {\n          s.end(!0);\n          return;\n        }\n        if (!(l instanceof t)) try {\n          l = t[s.responseDelimited ? \"decodeDelimited\" : \"decode\"](l);\n        } catch (f) {\n          return s.emit(\"error\", f, e), n(f);\n        }\n        return s.emit(\"data\", l, e), n(null, l);\n      });\n    } catch (a) {\n      s.emit(\"error\", a, e), setTimeout(function () {\n        n(a);\n      }, 0);\n      return;\n    }\n  };\n  Lr.prototype.end = function (e) {\n    return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit(\"end\").off()), this;\n  };\n});\nvar Fu = mt(Bu => {\n  \"use strict\";\n\n  var dh = Bu;\n  dh.Service = ku();\n});\nvar Nu = mt((rx, Cu) => {\n  \"use strict\";\n\n  Cu.exports = {};\n});\nvar Mu = mt(Gu => {\n  \"use strict\";\n\n  var Nt = Gu;\n  Nt.build = \"minimal\";\n  Nt.Writer = ei();\n  Nt.BufferWriter = vu();\n  Nt.Reader = oi();\n  Nt.BufferReader = Lu();\n  Nt.util = Se();\n  Nt.rpc = Fu();\n  Nt.roots = Nu();\n  Nt.configure = Ru;\n  function Ru() {\n    Nt.util._configure(), Nt.Writer._configure(Nt.BufferWriter), Nt.Reader._configure(Nt.BufferReader);\n  }\n  Ru();\n});\nvar Vu = mt((ox, Uu) => {\n  \"use strict\";\n\n  Uu.exports = Mu();\n});\nvar sr = mt((ix, zu) => {\n  \"use strict\";\n\n  var nt = Vu(),\n    $ = nt.Reader,\n    pt = nt.Writer,\n    b = nt.util,\n    h = nt.roots.default || (nt.roots.default = {});\n  h.onnx = function () {\n    var i = {};\n    return i.Version = function () {\n      var e = {},\n        o = Object.create(e);\n      return o[e[0] = \"_START_VERSION\"] = 0, o[e[1] = \"IR_VERSION_2017_10_10\"] = 1, o[e[2] = \"IR_VERSION_2017_10_30\"] = 2, o[e[3] = \"IR_VERSION_2017_11_3\"] = 3, o[e[4] = \"IR_VERSION_2019_1_22\"] = 4, o[e[5] = \"IR_VERSION_2019_3_18\"] = 5, o[e[6] = \"IR_VERSION_2019_9_19\"] = 6, o[e[7] = \"IR_VERSION_2020_5_8\"] = 7, o[e[8] = \"IR_VERSION_2021_7_30\"] = 8, o[e[9] = \"IR_VERSION\"] = 9, o;\n    }(), i.AttributeProto = function () {\n      function e(o) {\n        if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], this.sparseTensors = [], this.typeProtos = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.name = \"\", e.prototype.refAttrName = \"\", e.prototype.docString = \"\", e.prototype.type = 0, e.prototype.f = 0, e.prototype.i = b.Long ? b.Long.fromBits(0, 0, !1) : 0, e.prototype.s = b.newBuffer([]), e.prototype.t = null, e.prototype.g = null, e.prototype.sparseTensor = null, e.prototype.tp = null, e.prototype.floats = b.emptyArray, e.prototype.ints = b.emptyArray, e.prototype.strings = b.emptyArray, e.prototype.tensors = b.emptyArray, e.prototype.graphs = b.emptyArray, e.prototype.sparseTensors = b.emptyArray, e.prototype.typeProtos = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.name != null && Object.hasOwnProperty.call(t, \"name\") && r.uint32(10).string(t.name), t.f != null && Object.hasOwnProperty.call(t, \"f\") && r.uint32(21).float(t.f), t.i != null && Object.hasOwnProperty.call(t, \"i\") && r.uint32(24).int64(t.i), t.s != null && Object.hasOwnProperty.call(t, \"s\") && r.uint32(34).bytes(t.s), t.t != null && Object.hasOwnProperty.call(t, \"t\") && h.onnx.TensorProto.encode(t.t, r.uint32(42).fork()).ldelim(), t.g != null && Object.hasOwnProperty.call(t, \"g\") && h.onnx.GraphProto.encode(t.g, r.uint32(50).fork()).ldelim(), t.floats != null && t.floats.length) {\n          r.uint32(58).fork();\n          for (var n = 0; n < t.floats.length; ++n) r.float(t.floats[n]);\n          r.ldelim();\n        }\n        if (t.ints != null && t.ints.length) {\n          r.uint32(66).fork();\n          for (var n = 0; n < t.ints.length; ++n) r.int64(t.ints[n]);\n          r.ldelim();\n        }\n        if (t.strings != null && t.strings.length) for (var n = 0; n < t.strings.length; ++n) r.uint32(74).bytes(t.strings[n]);\n        if (t.tensors != null && t.tensors.length) for (var n = 0; n < t.tensors.length; ++n) h.onnx.TensorProto.encode(t.tensors[n], r.uint32(82).fork()).ldelim();\n        if (t.graphs != null && t.graphs.length) for (var n = 0; n < t.graphs.length; ++n) h.onnx.GraphProto.encode(t.graphs[n], r.uint32(90).fork()).ldelim();\n        if (t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(106).string(t.docString), t.tp != null && Object.hasOwnProperty.call(t, \"tp\") && h.onnx.TypeProto.encode(t.tp, r.uint32(114).fork()).ldelim(), t.typeProtos != null && t.typeProtos.length) for (var n = 0; n < t.typeProtos.length; ++n) h.onnx.TypeProto.encode(t.typeProtos[n], r.uint32(122).fork()).ldelim();\n        if (t.type != null && Object.hasOwnProperty.call(t, \"type\") && r.uint32(160).int32(t.type), t.refAttrName != null && Object.hasOwnProperty.call(t, \"refAttrName\") && r.uint32(170).string(t.refAttrName), t.sparseTensor != null && Object.hasOwnProperty.call(t, \"sparseTensor\") && h.onnx.SparseTensorProto.encode(t.sparseTensor, r.uint32(178).fork()).ldelim(), t.sparseTensors != null && t.sparseTensors.length) for (var n = 0; n < t.sparseTensors.length; ++n) h.onnx.SparseTensorProto.encode(t.sparseTensors[n], r.uint32(186).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.AttributeProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.name = t.string();\n                break;\n              }\n            case 21:\n              {\n                s.refAttrName = t.string();\n                break;\n              }\n            case 13:\n              {\n                s.docString = t.string();\n                break;\n              }\n            case 20:\n              {\n                s.type = t.int32();\n                break;\n              }\n            case 2:\n              {\n                s.f = t.float();\n                break;\n              }\n            case 3:\n              {\n                s.i = t.int64();\n                break;\n              }\n            case 4:\n              {\n                s.s = t.bytes();\n                break;\n              }\n            case 5:\n              {\n                s.t = h.onnx.TensorProto.decode(t, t.uint32());\n                break;\n              }\n            case 6:\n              {\n                s.g = h.onnx.GraphProto.decode(t, t.uint32());\n                break;\n              }\n            case 22:\n              {\n                s.sparseTensor = h.onnx.SparseTensorProto.decode(t, t.uint32());\n                break;\n              }\n            case 14:\n              {\n                s.tp = h.onnx.TypeProto.decode(t, t.uint32());\n                break;\n              }\n            case 7:\n              {\n                if (s.floats && s.floats.length || (s.floats = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.floats.push(t.float());else s.floats.push(t.float());\n                break;\n              }\n            case 8:\n              {\n                if (s.ints && s.ints.length || (s.ints = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.ints.push(t.int64());else s.ints.push(t.int64());\n                break;\n              }\n            case 9:\n              {\n                s.strings && s.strings.length || (s.strings = []), s.strings.push(t.bytes());\n                break;\n              }\n            case 10:\n              {\n                s.tensors && s.tensors.length || (s.tensors = []), s.tensors.push(h.onnx.TensorProto.decode(t, t.uint32()));\n                break;\n              }\n            case 11:\n              {\n                s.graphs && s.graphs.length || (s.graphs = []), s.graphs.push(h.onnx.GraphProto.decode(t, t.uint32()));\n                break;\n              }\n            case 23:\n              {\n                s.sparseTensors && s.sparseTensors.length || (s.sparseTensors = []), s.sparseTensors.push(h.onnx.SparseTensorProto.decode(t, t.uint32()));\n                break;\n              }\n            case 15:\n              {\n                s.typeProtos && s.typeProtos.length || (s.typeProtos = []), s.typeProtos.push(h.onnx.TypeProto.decode(t, t.uint32()));\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.name != null && t.hasOwnProperty(\"name\") && !b.isString(t.name)) return \"name: string expected\";\n        if (t.refAttrName != null && t.hasOwnProperty(\"refAttrName\") && !b.isString(t.refAttrName)) return \"refAttrName: string expected\";\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString)) return \"docString: string expected\";\n        if (t.type != null && t.hasOwnProperty(\"type\")) switch (t.type) {\n          default:\n            return \"type: enum value expected\";\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 11:\n          case 13:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 12:\n          case 14:\n            break;\n        }\n        if (t.f != null && t.hasOwnProperty(\"f\") && typeof t.f != \"number\") return \"f: number expected\";\n        if (t.i != null && t.hasOwnProperty(\"i\") && !b.isInteger(t.i) && !(t.i && b.isInteger(t.i.low) && b.isInteger(t.i.high))) return \"i: integer|Long expected\";\n        if (t.s != null && t.hasOwnProperty(\"s\") && !(t.s && typeof t.s.length == \"number\" || b.isString(t.s))) return \"s: buffer expected\";\n        if (t.t != null && t.hasOwnProperty(\"t\")) {\n          var r = h.onnx.TensorProto.verify(t.t);\n          if (r) return \"t.\" + r;\n        }\n        if (t.g != null && t.hasOwnProperty(\"g\")) {\n          var r = h.onnx.GraphProto.verify(t.g);\n          if (r) return \"g.\" + r;\n        }\n        if (t.sparseTensor != null && t.hasOwnProperty(\"sparseTensor\")) {\n          var r = h.onnx.SparseTensorProto.verify(t.sparseTensor);\n          if (r) return \"sparseTensor.\" + r;\n        }\n        if (t.tp != null && t.hasOwnProperty(\"tp\")) {\n          var r = h.onnx.TypeProto.verify(t.tp);\n          if (r) return \"tp.\" + r;\n        }\n        if (t.floats != null && t.hasOwnProperty(\"floats\")) {\n          if (!Array.isArray(t.floats)) return \"floats: array expected\";\n          for (var n = 0; n < t.floats.length; ++n) if (typeof t.floats[n] != \"number\") return \"floats: number[] expected\";\n        }\n        if (t.ints != null && t.hasOwnProperty(\"ints\")) {\n          if (!Array.isArray(t.ints)) return \"ints: array expected\";\n          for (var n = 0; n < t.ints.length; ++n) if (!b.isInteger(t.ints[n]) && !(t.ints[n] && b.isInteger(t.ints[n].low) && b.isInteger(t.ints[n].high))) return \"ints: integer|Long[] expected\";\n        }\n        if (t.strings != null && t.hasOwnProperty(\"strings\")) {\n          if (!Array.isArray(t.strings)) return \"strings: array expected\";\n          for (var n = 0; n < t.strings.length; ++n) if (!(t.strings[n] && typeof t.strings[n].length == \"number\" || b.isString(t.strings[n]))) return \"strings: buffer[] expected\";\n        }\n        if (t.tensors != null && t.hasOwnProperty(\"tensors\")) {\n          if (!Array.isArray(t.tensors)) return \"tensors: array expected\";\n          for (var n = 0; n < t.tensors.length; ++n) {\n            var r = h.onnx.TensorProto.verify(t.tensors[n]);\n            if (r) return \"tensors.\" + r;\n          }\n        }\n        if (t.graphs != null && t.hasOwnProperty(\"graphs\")) {\n          if (!Array.isArray(t.graphs)) return \"graphs: array expected\";\n          for (var n = 0; n < t.graphs.length; ++n) {\n            var r = h.onnx.GraphProto.verify(t.graphs[n]);\n            if (r) return \"graphs.\" + r;\n          }\n        }\n        if (t.sparseTensors != null && t.hasOwnProperty(\"sparseTensors\")) {\n          if (!Array.isArray(t.sparseTensors)) return \"sparseTensors: array expected\";\n          for (var n = 0; n < t.sparseTensors.length; ++n) {\n            var r = h.onnx.SparseTensorProto.verify(t.sparseTensors[n]);\n            if (r) return \"sparseTensors.\" + r;\n          }\n        }\n        if (t.typeProtos != null && t.hasOwnProperty(\"typeProtos\")) {\n          if (!Array.isArray(t.typeProtos)) return \"typeProtos: array expected\";\n          for (var n = 0; n < t.typeProtos.length; ++n) {\n            var r = h.onnx.TypeProto.verify(t.typeProtos[n]);\n            if (r) return \"typeProtos.\" + r;\n          }\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.AttributeProto) return t;\n        var r = new h.onnx.AttributeProto();\n        switch (t.name != null && (r.name = String(t.name)), t.refAttrName != null && (r.refAttrName = String(t.refAttrName)), t.docString != null && (r.docString = String(t.docString)), t.type) {\n          default:\n            if (typeof t.type == \"number\") {\n              r.type = t.type;\n              break;\n            }\n            break;\n          case \"UNDEFINED\":\n          case 0:\n            r.type = 0;\n            break;\n          case \"FLOAT\":\n          case 1:\n            r.type = 1;\n            break;\n          case \"INT\":\n          case 2:\n            r.type = 2;\n            break;\n          case \"STRING\":\n          case 3:\n            r.type = 3;\n            break;\n          case \"TENSOR\":\n          case 4:\n            r.type = 4;\n            break;\n          case \"GRAPH\":\n          case 5:\n            r.type = 5;\n            break;\n          case \"SPARSE_TENSOR\":\n          case 11:\n            r.type = 11;\n            break;\n          case \"TYPE_PROTO\":\n          case 13:\n            r.type = 13;\n            break;\n          case \"FLOATS\":\n          case 6:\n            r.type = 6;\n            break;\n          case \"INTS\":\n          case 7:\n            r.type = 7;\n            break;\n          case \"STRINGS\":\n          case 8:\n            r.type = 8;\n            break;\n          case \"TENSORS\":\n          case 9:\n            r.type = 9;\n            break;\n          case \"GRAPHS\":\n          case 10:\n            r.type = 10;\n            break;\n          case \"SPARSE_TENSORS\":\n          case 12:\n            r.type = 12;\n            break;\n          case \"TYPE_PROTOS\":\n          case 14:\n            r.type = 14;\n            break;\n        }\n        if (t.f != null && (r.f = Number(t.f)), t.i != null && (b.Long ? (r.i = b.Long.fromValue(t.i)).unsigned = !1 : typeof t.i == \"string\" ? r.i = parseInt(t.i, 10) : typeof t.i == \"number\" ? r.i = t.i : typeof t.i == \"object\" && (r.i = new b.LongBits(t.i.low >>> 0, t.i.high >>> 0).toNumber())), t.s != null && (typeof t.s == \"string\" ? b.base64.decode(t.s, r.s = b.newBuffer(b.base64.length(t.s)), 0) : t.s.length >= 0 && (r.s = t.s)), t.t != null) {\n          if (typeof t.t != \"object\") throw TypeError(\".onnx.AttributeProto.t: object expected\");\n          r.t = h.onnx.TensorProto.fromObject(t.t);\n        }\n        if (t.g != null) {\n          if (typeof t.g != \"object\") throw TypeError(\".onnx.AttributeProto.g: object expected\");\n          r.g = h.onnx.GraphProto.fromObject(t.g);\n        }\n        if (t.sparseTensor != null) {\n          if (typeof t.sparseTensor != \"object\") throw TypeError(\".onnx.AttributeProto.sparseTensor: object expected\");\n          r.sparseTensor = h.onnx.SparseTensorProto.fromObject(t.sparseTensor);\n        }\n        if (t.tp != null) {\n          if (typeof t.tp != \"object\") throw TypeError(\".onnx.AttributeProto.tp: object expected\");\n          r.tp = h.onnx.TypeProto.fromObject(t.tp);\n        }\n        if (t.floats) {\n          if (!Array.isArray(t.floats)) throw TypeError(\".onnx.AttributeProto.floats: array expected\");\n          r.floats = [];\n          for (var n = 0; n < t.floats.length; ++n) r.floats[n] = Number(t.floats[n]);\n        }\n        if (t.ints) {\n          if (!Array.isArray(t.ints)) throw TypeError(\".onnx.AttributeProto.ints: array expected\");\n          r.ints = [];\n          for (var n = 0; n < t.ints.length; ++n) b.Long ? (r.ints[n] = b.Long.fromValue(t.ints[n])).unsigned = !1 : typeof t.ints[n] == \"string\" ? r.ints[n] = parseInt(t.ints[n], 10) : typeof t.ints[n] == \"number\" ? r.ints[n] = t.ints[n] : typeof t.ints[n] == \"object\" && (r.ints[n] = new b.LongBits(t.ints[n].low >>> 0, t.ints[n].high >>> 0).toNumber());\n        }\n        if (t.strings) {\n          if (!Array.isArray(t.strings)) throw TypeError(\".onnx.AttributeProto.strings: array expected\");\n          r.strings = [];\n          for (var n = 0; n < t.strings.length; ++n) typeof t.strings[n] == \"string\" ? b.base64.decode(t.strings[n], r.strings[n] = b.newBuffer(b.base64.length(t.strings[n])), 0) : t.strings[n].length >= 0 && (r.strings[n] = t.strings[n]);\n        }\n        if (t.tensors) {\n          if (!Array.isArray(t.tensors)) throw TypeError(\".onnx.AttributeProto.tensors: array expected\");\n          r.tensors = [];\n          for (var n = 0; n < t.tensors.length; ++n) {\n            if (typeof t.tensors[n] != \"object\") throw TypeError(\".onnx.AttributeProto.tensors: object expected\");\n            r.tensors[n] = h.onnx.TensorProto.fromObject(t.tensors[n]);\n          }\n        }\n        if (t.graphs) {\n          if (!Array.isArray(t.graphs)) throw TypeError(\".onnx.AttributeProto.graphs: array expected\");\n          r.graphs = [];\n          for (var n = 0; n < t.graphs.length; ++n) {\n            if (typeof t.graphs[n] != \"object\") throw TypeError(\".onnx.AttributeProto.graphs: object expected\");\n            r.graphs[n] = h.onnx.GraphProto.fromObject(t.graphs[n]);\n          }\n        }\n        if (t.sparseTensors) {\n          if (!Array.isArray(t.sparseTensors)) throw TypeError(\".onnx.AttributeProto.sparseTensors: array expected\");\n          r.sparseTensors = [];\n          for (var n = 0; n < t.sparseTensors.length; ++n) {\n            if (typeof t.sparseTensors[n] != \"object\") throw TypeError(\".onnx.AttributeProto.sparseTensors: object expected\");\n            r.sparseTensors[n] = h.onnx.SparseTensorProto.fromObject(t.sparseTensors[n]);\n          }\n        }\n        if (t.typeProtos) {\n          if (!Array.isArray(t.typeProtos)) throw TypeError(\".onnx.AttributeProto.typeProtos: array expected\");\n          r.typeProtos = [];\n          for (var n = 0; n < t.typeProtos.length; ++n) {\n            if (typeof t.typeProtos[n] != \"object\") throw TypeError(\".onnx.AttributeProto.typeProtos: object expected\");\n            r.typeProtos[n] = h.onnx.TypeProto.fromObject(t.typeProtos[n]);\n          }\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.floats = [], n.ints = [], n.strings = [], n.tensors = [], n.graphs = [], n.typeProtos = [], n.sparseTensors = []), r.defaults) {\n          if (n.name = \"\", n.f = 0, b.Long) {\n            var s = new b.Long(0, 0, !1);\n            n.i = r.longs === String ? s.toString() : r.longs === Number ? s.toNumber() : s;\n          } else n.i = r.longs === String ? \"0\" : 0;\n          r.bytes === String ? n.s = \"\" : (n.s = [], r.bytes !== Array && (n.s = b.newBuffer(n.s))), n.t = null, n.g = null, n.docString = \"\", n.tp = null, n.type = r.enums === String ? \"UNDEFINED\" : 0, n.refAttrName = \"\", n.sparseTensor = null;\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && (n.name = t.name), t.f != null && t.hasOwnProperty(\"f\") && (n.f = r.json && !isFinite(t.f) ? String(t.f) : t.f), t.i != null && t.hasOwnProperty(\"i\") && (typeof t.i == \"number\" ? n.i = r.longs === String ? String(t.i) : t.i : n.i = r.longs === String ? b.Long.prototype.toString.call(t.i) : r.longs === Number ? new b.LongBits(t.i.low >>> 0, t.i.high >>> 0).toNumber() : t.i), t.s != null && t.hasOwnProperty(\"s\") && (n.s = r.bytes === String ? b.base64.encode(t.s, 0, t.s.length) : r.bytes === Array ? Array.prototype.slice.call(t.s) : t.s), t.t != null && t.hasOwnProperty(\"t\") && (n.t = h.onnx.TensorProto.toObject(t.t, r)), t.g != null && t.hasOwnProperty(\"g\") && (n.g = h.onnx.GraphProto.toObject(t.g, r)), t.floats && t.floats.length) {\n          n.floats = [];\n          for (var a = 0; a < t.floats.length; ++a) n.floats[a] = r.json && !isFinite(t.floats[a]) ? String(t.floats[a]) : t.floats[a];\n        }\n        if (t.ints && t.ints.length) {\n          n.ints = [];\n          for (var a = 0; a < t.ints.length; ++a) typeof t.ints[a] == \"number\" ? n.ints[a] = r.longs === String ? String(t.ints[a]) : t.ints[a] : n.ints[a] = r.longs === String ? b.Long.prototype.toString.call(t.ints[a]) : r.longs === Number ? new b.LongBits(t.ints[a].low >>> 0, t.ints[a].high >>> 0).toNumber() : t.ints[a];\n        }\n        if (t.strings && t.strings.length) {\n          n.strings = [];\n          for (var a = 0; a < t.strings.length; ++a) n.strings[a] = r.bytes === String ? b.base64.encode(t.strings[a], 0, t.strings[a].length) : r.bytes === Array ? Array.prototype.slice.call(t.strings[a]) : t.strings[a];\n        }\n        if (t.tensors && t.tensors.length) {\n          n.tensors = [];\n          for (var a = 0; a < t.tensors.length; ++a) n.tensors[a] = h.onnx.TensorProto.toObject(t.tensors[a], r);\n        }\n        if (t.graphs && t.graphs.length) {\n          n.graphs = [];\n          for (var a = 0; a < t.graphs.length; ++a) n.graphs[a] = h.onnx.GraphProto.toObject(t.graphs[a], r);\n        }\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.tp != null && t.hasOwnProperty(\"tp\") && (n.tp = h.onnx.TypeProto.toObject(t.tp, r)), t.typeProtos && t.typeProtos.length) {\n          n.typeProtos = [];\n          for (var a = 0; a < t.typeProtos.length; ++a) n.typeProtos[a] = h.onnx.TypeProto.toObject(t.typeProtos[a], r);\n        }\n        if (t.type != null && t.hasOwnProperty(\"type\") && (n.type = r.enums === String ? h.onnx.AttributeProto.AttributeType[t.type] === void 0 ? t.type : h.onnx.AttributeProto.AttributeType[t.type] : t.type), t.refAttrName != null && t.hasOwnProperty(\"refAttrName\") && (n.refAttrName = t.refAttrName), t.sparseTensor != null && t.hasOwnProperty(\"sparseTensor\") && (n.sparseTensor = h.onnx.SparseTensorProto.toObject(t.sparseTensor, r)), t.sparseTensors && t.sparseTensors.length) {\n          n.sparseTensors = [];\n          for (var a = 0; a < t.sparseTensors.length; ++a) n.sparseTensors[a] = h.onnx.SparseTensorProto.toObject(t.sparseTensors[a], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.AttributeProto\";\n      }, e.AttributeType = function () {\n        var o = {},\n          t = Object.create(o);\n        return t[o[0] = \"UNDEFINED\"] = 0, t[o[1] = \"FLOAT\"] = 1, t[o[2] = \"INT\"] = 2, t[o[3] = \"STRING\"] = 3, t[o[4] = \"TENSOR\"] = 4, t[o[5] = \"GRAPH\"] = 5, t[o[11] = \"SPARSE_TENSOR\"] = 11, t[o[13] = \"TYPE_PROTO\"] = 13, t[o[6] = \"FLOATS\"] = 6, t[o[7] = \"INTS\"] = 7, t[o[8] = \"STRINGS\"] = 8, t[o[9] = \"TENSORS\"] = 9, t[o[10] = \"GRAPHS\"] = 10, t[o[12] = \"SPARSE_TENSORS\"] = 12, t[o[14] = \"TYPE_PROTOS\"] = 14, t;\n      }(), e;\n    }(), i.ValueInfoProto = function () {\n      function e(o) {\n        if (o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.name = \"\", e.prototype.type = null, e.prototype.docString = \"\", e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        return r || (r = pt.create()), t.name != null && Object.hasOwnProperty.call(t, \"name\") && r.uint32(10).string(t.name), t.type != null && Object.hasOwnProperty.call(t, \"type\") && h.onnx.TypeProto.encode(t.type, r.uint32(18).fork()).ldelim(), t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(26).string(t.docString), r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.ValueInfoProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.name = t.string();\n                break;\n              }\n            case 2:\n              {\n                s.type = h.onnx.TypeProto.decode(t, t.uint32());\n                break;\n              }\n            case 3:\n              {\n                s.docString = t.string();\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.name != null && t.hasOwnProperty(\"name\") && !b.isString(t.name)) return \"name: string expected\";\n        if (t.type != null && t.hasOwnProperty(\"type\")) {\n          var r = h.onnx.TypeProto.verify(t.type);\n          if (r) return \"type.\" + r;\n        }\n        return t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString) ? \"docString: string expected\" : null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.ValueInfoProto) return t;\n        var r = new h.onnx.ValueInfoProto();\n        if (t.name != null && (r.name = String(t.name)), t.type != null) {\n          if (typeof t.type != \"object\") throw TypeError(\".onnx.ValueInfoProto.type: object expected\");\n          r.type = h.onnx.TypeProto.fromObject(t.type);\n        }\n        return t.docString != null && (r.docString = String(t.docString)), r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        return r.defaults && (n.name = \"\", n.type = null, n.docString = \"\"), t.name != null && t.hasOwnProperty(\"name\") && (n.name = t.name), t.type != null && t.hasOwnProperty(\"type\") && (n.type = h.onnx.TypeProto.toObject(t.type, r)), t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.ValueInfoProto\";\n      }, e;\n    }(), i.NodeProto = function () {\n      function e(o) {\n        if (this.input = [], this.output = [], this.attribute = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.input = b.emptyArray, e.prototype.output = b.emptyArray, e.prototype.name = \"\", e.prototype.opType = \"\", e.prototype.domain = \"\", e.prototype.attribute = b.emptyArray, e.prototype.docString = \"\", e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.input != null && t.input.length) for (var n = 0; n < t.input.length; ++n) r.uint32(10).string(t.input[n]);\n        if (t.output != null && t.output.length) for (var n = 0; n < t.output.length; ++n) r.uint32(18).string(t.output[n]);\n        if (t.name != null && Object.hasOwnProperty.call(t, \"name\") && r.uint32(26).string(t.name), t.opType != null && Object.hasOwnProperty.call(t, \"opType\") && r.uint32(34).string(t.opType), t.attribute != null && t.attribute.length) for (var n = 0; n < t.attribute.length; ++n) h.onnx.AttributeProto.encode(t.attribute[n], r.uint32(42).fork()).ldelim();\n        return t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(50).string(t.docString), t.domain != null && Object.hasOwnProperty.call(t, \"domain\") && r.uint32(58).string(t.domain), r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.NodeProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.input && s.input.length || (s.input = []), s.input.push(t.string());\n                break;\n              }\n            case 2:\n              {\n                s.output && s.output.length || (s.output = []), s.output.push(t.string());\n                break;\n              }\n            case 3:\n              {\n                s.name = t.string();\n                break;\n              }\n            case 4:\n              {\n                s.opType = t.string();\n                break;\n              }\n            case 7:\n              {\n                s.domain = t.string();\n                break;\n              }\n            case 5:\n              {\n                s.attribute && s.attribute.length || (s.attribute = []), s.attribute.push(h.onnx.AttributeProto.decode(t, t.uint32()));\n                break;\n              }\n            case 6:\n              {\n                s.docString = t.string();\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.input != null && t.hasOwnProperty(\"input\")) {\n          if (!Array.isArray(t.input)) return \"input: array expected\";\n          for (var r = 0; r < t.input.length; ++r) if (!b.isString(t.input[r])) return \"input: string[] expected\";\n        }\n        if (t.output != null && t.hasOwnProperty(\"output\")) {\n          if (!Array.isArray(t.output)) return \"output: array expected\";\n          for (var r = 0; r < t.output.length; ++r) if (!b.isString(t.output[r])) return \"output: string[] expected\";\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && !b.isString(t.name)) return \"name: string expected\";\n        if (t.opType != null && t.hasOwnProperty(\"opType\") && !b.isString(t.opType)) return \"opType: string expected\";\n        if (t.domain != null && t.hasOwnProperty(\"domain\") && !b.isString(t.domain)) return \"domain: string expected\";\n        if (t.attribute != null && t.hasOwnProperty(\"attribute\")) {\n          if (!Array.isArray(t.attribute)) return \"attribute: array expected\";\n          for (var r = 0; r < t.attribute.length; ++r) {\n            var n = h.onnx.AttributeProto.verify(t.attribute[r]);\n            if (n) return \"attribute.\" + n;\n          }\n        }\n        return t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString) ? \"docString: string expected\" : null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.NodeProto) return t;\n        var r = new h.onnx.NodeProto();\n        if (t.input) {\n          if (!Array.isArray(t.input)) throw TypeError(\".onnx.NodeProto.input: array expected\");\n          r.input = [];\n          for (var n = 0; n < t.input.length; ++n) r.input[n] = String(t.input[n]);\n        }\n        if (t.output) {\n          if (!Array.isArray(t.output)) throw TypeError(\".onnx.NodeProto.output: array expected\");\n          r.output = [];\n          for (var n = 0; n < t.output.length; ++n) r.output[n] = String(t.output[n]);\n        }\n        if (t.name != null && (r.name = String(t.name)), t.opType != null && (r.opType = String(t.opType)), t.domain != null && (r.domain = String(t.domain)), t.attribute) {\n          if (!Array.isArray(t.attribute)) throw TypeError(\".onnx.NodeProto.attribute: array expected\");\n          r.attribute = [];\n          for (var n = 0; n < t.attribute.length; ++n) {\n            if (typeof t.attribute[n] != \"object\") throw TypeError(\".onnx.NodeProto.attribute: object expected\");\n            r.attribute[n] = h.onnx.AttributeProto.fromObject(t.attribute[n]);\n          }\n        }\n        return t.docString != null && (r.docString = String(t.docString)), r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.input = [], n.output = [], n.attribute = []), r.defaults && (n.name = \"\", n.opType = \"\", n.docString = \"\", n.domain = \"\"), t.input && t.input.length) {\n          n.input = [];\n          for (var s = 0; s < t.input.length; ++s) n.input[s] = t.input[s];\n        }\n        if (t.output && t.output.length) {\n          n.output = [];\n          for (var s = 0; s < t.output.length; ++s) n.output[s] = t.output[s];\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && (n.name = t.name), t.opType != null && t.hasOwnProperty(\"opType\") && (n.opType = t.opType), t.attribute && t.attribute.length) {\n          n.attribute = [];\n          for (var s = 0; s < t.attribute.length; ++s) n.attribute[s] = h.onnx.AttributeProto.toObject(t.attribute[s], r);\n        }\n        return t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.domain != null && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.NodeProto\";\n      }, e;\n    }(), i.TrainingInfoProto = function () {\n      function e(o) {\n        if (this.initializationBinding = [], this.updateBinding = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.initialization = null, e.prototype.algorithm = null, e.prototype.initializationBinding = b.emptyArray, e.prototype.updateBinding = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.initialization != null && Object.hasOwnProperty.call(t, \"initialization\") && h.onnx.GraphProto.encode(t.initialization, r.uint32(10).fork()).ldelim(), t.algorithm != null && Object.hasOwnProperty.call(t, \"algorithm\") && h.onnx.GraphProto.encode(t.algorithm, r.uint32(18).fork()).ldelim(), t.initializationBinding != null && t.initializationBinding.length) for (var n = 0; n < t.initializationBinding.length; ++n) h.onnx.StringStringEntryProto.encode(t.initializationBinding[n], r.uint32(26).fork()).ldelim();\n        if (t.updateBinding != null && t.updateBinding.length) for (var n = 0; n < t.updateBinding.length; ++n) h.onnx.StringStringEntryProto.encode(t.updateBinding[n], r.uint32(34).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.TrainingInfoProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.initialization = h.onnx.GraphProto.decode(t, t.uint32());\n                break;\n              }\n            case 2:\n              {\n                s.algorithm = h.onnx.GraphProto.decode(t, t.uint32());\n                break;\n              }\n            case 3:\n              {\n                s.initializationBinding && s.initializationBinding.length || (s.initializationBinding = []), s.initializationBinding.push(h.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                break;\n              }\n            case 4:\n              {\n                s.updateBinding && s.updateBinding.length || (s.updateBinding = []), s.updateBinding.push(h.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.initialization != null && t.hasOwnProperty(\"initialization\")) {\n          var r = h.onnx.GraphProto.verify(t.initialization);\n          if (r) return \"initialization.\" + r;\n        }\n        if (t.algorithm != null && t.hasOwnProperty(\"algorithm\")) {\n          var r = h.onnx.GraphProto.verify(t.algorithm);\n          if (r) return \"algorithm.\" + r;\n        }\n        if (t.initializationBinding != null && t.hasOwnProperty(\"initializationBinding\")) {\n          if (!Array.isArray(t.initializationBinding)) return \"initializationBinding: array expected\";\n          for (var n = 0; n < t.initializationBinding.length; ++n) {\n            var r = h.onnx.StringStringEntryProto.verify(t.initializationBinding[n]);\n            if (r) return \"initializationBinding.\" + r;\n          }\n        }\n        if (t.updateBinding != null && t.hasOwnProperty(\"updateBinding\")) {\n          if (!Array.isArray(t.updateBinding)) return \"updateBinding: array expected\";\n          for (var n = 0; n < t.updateBinding.length; ++n) {\n            var r = h.onnx.StringStringEntryProto.verify(t.updateBinding[n]);\n            if (r) return \"updateBinding.\" + r;\n          }\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.TrainingInfoProto) return t;\n        var r = new h.onnx.TrainingInfoProto();\n        if (t.initialization != null) {\n          if (typeof t.initialization != \"object\") throw TypeError(\".onnx.TrainingInfoProto.initialization: object expected\");\n          r.initialization = h.onnx.GraphProto.fromObject(t.initialization);\n        }\n        if (t.algorithm != null) {\n          if (typeof t.algorithm != \"object\") throw TypeError(\".onnx.TrainingInfoProto.algorithm: object expected\");\n          r.algorithm = h.onnx.GraphProto.fromObject(t.algorithm);\n        }\n        if (t.initializationBinding) {\n          if (!Array.isArray(t.initializationBinding)) throw TypeError(\".onnx.TrainingInfoProto.initializationBinding: array expected\");\n          r.initializationBinding = [];\n          for (var n = 0; n < t.initializationBinding.length; ++n) {\n            if (typeof t.initializationBinding[n] != \"object\") throw TypeError(\".onnx.TrainingInfoProto.initializationBinding: object expected\");\n            r.initializationBinding[n] = h.onnx.StringStringEntryProto.fromObject(t.initializationBinding[n]);\n          }\n        }\n        if (t.updateBinding) {\n          if (!Array.isArray(t.updateBinding)) throw TypeError(\".onnx.TrainingInfoProto.updateBinding: array expected\");\n          r.updateBinding = [];\n          for (var n = 0; n < t.updateBinding.length; ++n) {\n            if (typeof t.updateBinding[n] != \"object\") throw TypeError(\".onnx.TrainingInfoProto.updateBinding: object expected\");\n            r.updateBinding[n] = h.onnx.StringStringEntryProto.fromObject(t.updateBinding[n]);\n          }\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.initializationBinding = [], n.updateBinding = []), r.defaults && (n.initialization = null, n.algorithm = null), t.initialization != null && t.hasOwnProperty(\"initialization\") && (n.initialization = h.onnx.GraphProto.toObject(t.initialization, r)), t.algorithm != null && t.hasOwnProperty(\"algorithm\") && (n.algorithm = h.onnx.GraphProto.toObject(t.algorithm, r)), t.initializationBinding && t.initializationBinding.length) {\n          n.initializationBinding = [];\n          for (var s = 0; s < t.initializationBinding.length; ++s) n.initializationBinding[s] = h.onnx.StringStringEntryProto.toObject(t.initializationBinding[s], r);\n        }\n        if (t.updateBinding && t.updateBinding.length) {\n          n.updateBinding = [];\n          for (var s = 0; s < t.updateBinding.length; ++s) n.updateBinding[s] = h.onnx.StringStringEntryProto.toObject(t.updateBinding[s], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.TrainingInfoProto\";\n      }, e;\n    }(), i.ModelProto = function () {\n      function e(o) {\n        if (this.opsetImport = [], this.metadataProps = [], this.trainingInfo = [], this.functions = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.irVersion = b.Long ? b.Long.fromBits(0, 0, !1) : 0, e.prototype.opsetImport = b.emptyArray, e.prototype.producerName = \"\", e.prototype.producerVersion = \"\", e.prototype.domain = \"\", e.prototype.modelVersion = b.Long ? b.Long.fromBits(0, 0, !1) : 0, e.prototype.docString = \"\", e.prototype.graph = null, e.prototype.metadataProps = b.emptyArray, e.prototype.trainingInfo = b.emptyArray, e.prototype.functions = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.irVersion != null && Object.hasOwnProperty.call(t, \"irVersion\") && r.uint32(8).int64(t.irVersion), t.producerName != null && Object.hasOwnProperty.call(t, \"producerName\") && r.uint32(18).string(t.producerName), t.producerVersion != null && Object.hasOwnProperty.call(t, \"producerVersion\") && r.uint32(26).string(t.producerVersion), t.domain != null && Object.hasOwnProperty.call(t, \"domain\") && r.uint32(34).string(t.domain), t.modelVersion != null && Object.hasOwnProperty.call(t, \"modelVersion\") && r.uint32(40).int64(t.modelVersion), t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(50).string(t.docString), t.graph != null && Object.hasOwnProperty.call(t, \"graph\") && h.onnx.GraphProto.encode(t.graph, r.uint32(58).fork()).ldelim(), t.opsetImport != null && t.opsetImport.length) for (var n = 0; n < t.opsetImport.length; ++n) h.onnx.OperatorSetIdProto.encode(t.opsetImport[n], r.uint32(66).fork()).ldelim();\n        if (t.metadataProps != null && t.metadataProps.length) for (var n = 0; n < t.metadataProps.length; ++n) h.onnx.StringStringEntryProto.encode(t.metadataProps[n], r.uint32(114).fork()).ldelim();\n        if (t.trainingInfo != null && t.trainingInfo.length) for (var n = 0; n < t.trainingInfo.length; ++n) h.onnx.TrainingInfoProto.encode(t.trainingInfo[n], r.uint32(162).fork()).ldelim();\n        if (t.functions != null && t.functions.length) for (var n = 0; n < t.functions.length; ++n) h.onnx.FunctionProto.encode(t.functions[n], r.uint32(202).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.ModelProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.irVersion = t.int64();\n                break;\n              }\n            case 8:\n              {\n                s.opsetImport && s.opsetImport.length || (s.opsetImport = []), s.opsetImport.push(h.onnx.OperatorSetIdProto.decode(t, t.uint32()));\n                break;\n              }\n            case 2:\n              {\n                s.producerName = t.string();\n                break;\n              }\n            case 3:\n              {\n                s.producerVersion = t.string();\n                break;\n              }\n            case 4:\n              {\n                s.domain = t.string();\n                break;\n              }\n            case 5:\n              {\n                s.modelVersion = t.int64();\n                break;\n              }\n            case 6:\n              {\n                s.docString = t.string();\n                break;\n              }\n            case 7:\n              {\n                s.graph = h.onnx.GraphProto.decode(t, t.uint32());\n                break;\n              }\n            case 14:\n              {\n                s.metadataProps && s.metadataProps.length || (s.metadataProps = []), s.metadataProps.push(h.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                break;\n              }\n            case 20:\n              {\n                s.trainingInfo && s.trainingInfo.length || (s.trainingInfo = []), s.trainingInfo.push(h.onnx.TrainingInfoProto.decode(t, t.uint32()));\n                break;\n              }\n            case 25:\n              {\n                s.functions && s.functions.length || (s.functions = []), s.functions.push(h.onnx.FunctionProto.decode(t, t.uint32()));\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.irVersion != null && t.hasOwnProperty(\"irVersion\") && !b.isInteger(t.irVersion) && !(t.irVersion && b.isInteger(t.irVersion.low) && b.isInteger(t.irVersion.high))) return \"irVersion: integer|Long expected\";\n        if (t.opsetImport != null && t.hasOwnProperty(\"opsetImport\")) {\n          if (!Array.isArray(t.opsetImport)) return \"opsetImport: array expected\";\n          for (var r = 0; r < t.opsetImport.length; ++r) {\n            var n = h.onnx.OperatorSetIdProto.verify(t.opsetImport[r]);\n            if (n) return \"opsetImport.\" + n;\n          }\n        }\n        if (t.producerName != null && t.hasOwnProperty(\"producerName\") && !b.isString(t.producerName)) return \"producerName: string expected\";\n        if (t.producerVersion != null && t.hasOwnProperty(\"producerVersion\") && !b.isString(t.producerVersion)) return \"producerVersion: string expected\";\n        if (t.domain != null && t.hasOwnProperty(\"domain\") && !b.isString(t.domain)) return \"domain: string expected\";\n        if (t.modelVersion != null && t.hasOwnProperty(\"modelVersion\") && !b.isInteger(t.modelVersion) && !(t.modelVersion && b.isInteger(t.modelVersion.low) && b.isInteger(t.modelVersion.high))) return \"modelVersion: integer|Long expected\";\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString)) return \"docString: string expected\";\n        if (t.graph != null && t.hasOwnProperty(\"graph\")) {\n          var n = h.onnx.GraphProto.verify(t.graph);\n          if (n) return \"graph.\" + n;\n        }\n        if (t.metadataProps != null && t.hasOwnProperty(\"metadataProps\")) {\n          if (!Array.isArray(t.metadataProps)) return \"metadataProps: array expected\";\n          for (var r = 0; r < t.metadataProps.length; ++r) {\n            var n = h.onnx.StringStringEntryProto.verify(t.metadataProps[r]);\n            if (n) return \"metadataProps.\" + n;\n          }\n        }\n        if (t.trainingInfo != null && t.hasOwnProperty(\"trainingInfo\")) {\n          if (!Array.isArray(t.trainingInfo)) return \"trainingInfo: array expected\";\n          for (var r = 0; r < t.trainingInfo.length; ++r) {\n            var n = h.onnx.TrainingInfoProto.verify(t.trainingInfo[r]);\n            if (n) return \"trainingInfo.\" + n;\n          }\n        }\n        if (t.functions != null && t.hasOwnProperty(\"functions\")) {\n          if (!Array.isArray(t.functions)) return \"functions: array expected\";\n          for (var r = 0; r < t.functions.length; ++r) {\n            var n = h.onnx.FunctionProto.verify(t.functions[r]);\n            if (n) return \"functions.\" + n;\n          }\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.ModelProto) return t;\n        var r = new h.onnx.ModelProto();\n        if (t.irVersion != null && (b.Long ? (r.irVersion = b.Long.fromValue(t.irVersion)).unsigned = !1 : typeof t.irVersion == \"string\" ? r.irVersion = parseInt(t.irVersion, 10) : typeof t.irVersion == \"number\" ? r.irVersion = t.irVersion : typeof t.irVersion == \"object\" && (r.irVersion = new b.LongBits(t.irVersion.low >>> 0, t.irVersion.high >>> 0).toNumber())), t.opsetImport) {\n          if (!Array.isArray(t.opsetImport)) throw TypeError(\".onnx.ModelProto.opsetImport: array expected\");\n          r.opsetImport = [];\n          for (var n = 0; n < t.opsetImport.length; ++n) {\n            if (typeof t.opsetImport[n] != \"object\") throw TypeError(\".onnx.ModelProto.opsetImport: object expected\");\n            r.opsetImport[n] = h.onnx.OperatorSetIdProto.fromObject(t.opsetImport[n]);\n          }\n        }\n        if (t.producerName != null && (r.producerName = String(t.producerName)), t.producerVersion != null && (r.producerVersion = String(t.producerVersion)), t.domain != null && (r.domain = String(t.domain)), t.modelVersion != null && (b.Long ? (r.modelVersion = b.Long.fromValue(t.modelVersion)).unsigned = !1 : typeof t.modelVersion == \"string\" ? r.modelVersion = parseInt(t.modelVersion, 10) : typeof t.modelVersion == \"number\" ? r.modelVersion = t.modelVersion : typeof t.modelVersion == \"object\" && (r.modelVersion = new b.LongBits(t.modelVersion.low >>> 0, t.modelVersion.high >>> 0).toNumber())), t.docString != null && (r.docString = String(t.docString)), t.graph != null) {\n          if (typeof t.graph != \"object\") throw TypeError(\".onnx.ModelProto.graph: object expected\");\n          r.graph = h.onnx.GraphProto.fromObject(t.graph);\n        }\n        if (t.metadataProps) {\n          if (!Array.isArray(t.metadataProps)) throw TypeError(\".onnx.ModelProto.metadataProps: array expected\");\n          r.metadataProps = [];\n          for (var n = 0; n < t.metadataProps.length; ++n) {\n            if (typeof t.metadataProps[n] != \"object\") throw TypeError(\".onnx.ModelProto.metadataProps: object expected\");\n            r.metadataProps[n] = h.onnx.StringStringEntryProto.fromObject(t.metadataProps[n]);\n          }\n        }\n        if (t.trainingInfo) {\n          if (!Array.isArray(t.trainingInfo)) throw TypeError(\".onnx.ModelProto.trainingInfo: array expected\");\n          r.trainingInfo = [];\n          for (var n = 0; n < t.trainingInfo.length; ++n) {\n            if (typeof t.trainingInfo[n] != \"object\") throw TypeError(\".onnx.ModelProto.trainingInfo: object expected\");\n            r.trainingInfo[n] = h.onnx.TrainingInfoProto.fromObject(t.trainingInfo[n]);\n          }\n        }\n        if (t.functions) {\n          if (!Array.isArray(t.functions)) throw TypeError(\".onnx.ModelProto.functions: array expected\");\n          r.functions = [];\n          for (var n = 0; n < t.functions.length; ++n) {\n            if (typeof t.functions[n] != \"object\") throw TypeError(\".onnx.ModelProto.functions: object expected\");\n            r.functions[n] = h.onnx.FunctionProto.fromObject(t.functions[n]);\n          }\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.opsetImport = [], n.metadataProps = [], n.trainingInfo = [], n.functions = []), r.defaults) {\n          if (b.Long) {\n            var s = new b.Long(0, 0, !1);\n            n.irVersion = r.longs === String ? s.toString() : r.longs === Number ? s.toNumber() : s;\n          } else n.irVersion = r.longs === String ? \"0\" : 0;\n          if (n.producerName = \"\", n.producerVersion = \"\", n.domain = \"\", b.Long) {\n            var s = new b.Long(0, 0, !1);\n            n.modelVersion = r.longs === String ? s.toString() : r.longs === Number ? s.toNumber() : s;\n          } else n.modelVersion = r.longs === String ? \"0\" : 0;\n          n.docString = \"\", n.graph = null;\n        }\n        if (t.irVersion != null && t.hasOwnProperty(\"irVersion\") && (typeof t.irVersion == \"number\" ? n.irVersion = r.longs === String ? String(t.irVersion) : t.irVersion : n.irVersion = r.longs === String ? b.Long.prototype.toString.call(t.irVersion) : r.longs === Number ? new b.LongBits(t.irVersion.low >>> 0, t.irVersion.high >>> 0).toNumber() : t.irVersion), t.producerName != null && t.hasOwnProperty(\"producerName\") && (n.producerName = t.producerName), t.producerVersion != null && t.hasOwnProperty(\"producerVersion\") && (n.producerVersion = t.producerVersion), t.domain != null && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), t.modelVersion != null && t.hasOwnProperty(\"modelVersion\") && (typeof t.modelVersion == \"number\" ? n.modelVersion = r.longs === String ? String(t.modelVersion) : t.modelVersion : n.modelVersion = r.longs === String ? b.Long.prototype.toString.call(t.modelVersion) : r.longs === Number ? new b.LongBits(t.modelVersion.low >>> 0, t.modelVersion.high >>> 0).toNumber() : t.modelVersion), t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.graph != null && t.hasOwnProperty(\"graph\") && (n.graph = h.onnx.GraphProto.toObject(t.graph, r)), t.opsetImport && t.opsetImport.length) {\n          n.opsetImport = [];\n          for (var a = 0; a < t.opsetImport.length; ++a) n.opsetImport[a] = h.onnx.OperatorSetIdProto.toObject(t.opsetImport[a], r);\n        }\n        if (t.metadataProps && t.metadataProps.length) {\n          n.metadataProps = [];\n          for (var a = 0; a < t.metadataProps.length; ++a) n.metadataProps[a] = h.onnx.StringStringEntryProto.toObject(t.metadataProps[a], r);\n        }\n        if (t.trainingInfo && t.trainingInfo.length) {\n          n.trainingInfo = [];\n          for (var a = 0; a < t.trainingInfo.length; ++a) n.trainingInfo[a] = h.onnx.TrainingInfoProto.toObject(t.trainingInfo[a], r);\n        }\n        if (t.functions && t.functions.length) {\n          n.functions = [];\n          for (var a = 0; a < t.functions.length; ++a) n.functions[a] = h.onnx.FunctionProto.toObject(t.functions[a], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.ModelProto\";\n      }, e;\n    }(), i.StringStringEntryProto = function () {\n      function e(o) {\n        if (o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.key = \"\", e.prototype.value = \"\", e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        return r || (r = pt.create()), t.key != null && Object.hasOwnProperty.call(t, \"key\") && r.uint32(10).string(t.key), t.value != null && Object.hasOwnProperty.call(t, \"value\") && r.uint32(18).string(t.value), r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.StringStringEntryProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.key = t.string();\n                break;\n              }\n            case 2:\n              {\n                s.value = t.string();\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        return typeof t != \"object\" || t === null ? \"object expected\" : t.key != null && t.hasOwnProperty(\"key\") && !b.isString(t.key) ? \"key: string expected\" : t.value != null && t.hasOwnProperty(\"value\") && !b.isString(t.value) ? \"value: string expected\" : null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.StringStringEntryProto) return t;\n        var r = new h.onnx.StringStringEntryProto();\n        return t.key != null && (r.key = String(t.key)), t.value != null && (r.value = String(t.value)), r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        return r.defaults && (n.key = \"\", n.value = \"\"), t.key != null && t.hasOwnProperty(\"key\") && (n.key = t.key), t.value != null && t.hasOwnProperty(\"value\") && (n.value = t.value), n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.StringStringEntryProto\";\n      }, e;\n    }(), i.TensorAnnotation = function () {\n      function e(o) {\n        if (this.quantParameterTensorNames = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.tensorName = \"\", e.prototype.quantParameterTensorNames = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.tensorName != null && Object.hasOwnProperty.call(t, \"tensorName\") && r.uint32(10).string(t.tensorName), t.quantParameterTensorNames != null && t.quantParameterTensorNames.length) for (var n = 0; n < t.quantParameterTensorNames.length; ++n) h.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[n], r.uint32(18).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.TensorAnnotation(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.tensorName = t.string();\n                break;\n              }\n            case 2:\n              {\n                s.quantParameterTensorNames && s.quantParameterTensorNames.length || (s.quantParameterTensorNames = []), s.quantParameterTensorNames.push(h.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.tensorName != null && t.hasOwnProperty(\"tensorName\") && !b.isString(t.tensorName)) return \"tensorName: string expected\";\n        if (t.quantParameterTensorNames != null && t.hasOwnProperty(\"quantParameterTensorNames\")) {\n          if (!Array.isArray(t.quantParameterTensorNames)) return \"quantParameterTensorNames: array expected\";\n          for (var r = 0; r < t.quantParameterTensorNames.length; ++r) {\n            var n = h.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[r]);\n            if (n) return \"quantParameterTensorNames.\" + n;\n          }\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.TensorAnnotation) return t;\n        var r = new h.onnx.TensorAnnotation();\n        if (t.tensorName != null && (r.tensorName = String(t.tensorName)), t.quantParameterTensorNames) {\n          if (!Array.isArray(t.quantParameterTensorNames)) throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: array expected\");\n          r.quantParameterTensorNames = [];\n          for (var n = 0; n < t.quantParameterTensorNames.length; ++n) {\n            if (typeof t.quantParameterTensorNames[n] != \"object\") throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: object expected\");\n            r.quantParameterTensorNames[n] = h.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[n]);\n          }\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.quantParameterTensorNames = []), r.defaults && (n.tensorName = \"\"), t.tensorName != null && t.hasOwnProperty(\"tensorName\") && (n.tensorName = t.tensorName), t.quantParameterTensorNames && t.quantParameterTensorNames.length) {\n          n.quantParameterTensorNames = [];\n          for (var s = 0; s < t.quantParameterTensorNames.length; ++s) n.quantParameterTensorNames[s] = h.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[s], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.TensorAnnotation\";\n      }, e;\n    }(), i.GraphProto = function () {\n      function e(o) {\n        if (this.node = [], this.initializer = [], this.sparseInitializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.node = b.emptyArray, e.prototype.name = \"\", e.prototype.initializer = b.emptyArray, e.prototype.sparseInitializer = b.emptyArray, e.prototype.docString = \"\", e.prototype.input = b.emptyArray, e.prototype.output = b.emptyArray, e.prototype.valueInfo = b.emptyArray, e.prototype.quantizationAnnotation = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.node != null && t.node.length) for (var n = 0; n < t.node.length; ++n) h.onnx.NodeProto.encode(t.node[n], r.uint32(10).fork()).ldelim();\n        if (t.name != null && Object.hasOwnProperty.call(t, \"name\") && r.uint32(18).string(t.name), t.initializer != null && t.initializer.length) for (var n = 0; n < t.initializer.length; ++n) h.onnx.TensorProto.encode(t.initializer[n], r.uint32(42).fork()).ldelim();\n        if (t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(82).string(t.docString), t.input != null && t.input.length) for (var n = 0; n < t.input.length; ++n) h.onnx.ValueInfoProto.encode(t.input[n], r.uint32(90).fork()).ldelim();\n        if (t.output != null && t.output.length) for (var n = 0; n < t.output.length; ++n) h.onnx.ValueInfoProto.encode(t.output[n], r.uint32(98).fork()).ldelim();\n        if (t.valueInfo != null && t.valueInfo.length) for (var n = 0; n < t.valueInfo.length; ++n) h.onnx.ValueInfoProto.encode(t.valueInfo[n], r.uint32(106).fork()).ldelim();\n        if (t.quantizationAnnotation != null && t.quantizationAnnotation.length) for (var n = 0; n < t.quantizationAnnotation.length; ++n) h.onnx.TensorAnnotation.encode(t.quantizationAnnotation[n], r.uint32(114).fork()).ldelim();\n        if (t.sparseInitializer != null && t.sparseInitializer.length) for (var n = 0; n < t.sparseInitializer.length; ++n) h.onnx.SparseTensorProto.encode(t.sparseInitializer[n], r.uint32(122).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.GraphProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.node && s.node.length || (s.node = []), s.node.push(h.onnx.NodeProto.decode(t, t.uint32()));\n                break;\n              }\n            case 2:\n              {\n                s.name = t.string();\n                break;\n              }\n            case 5:\n              {\n                s.initializer && s.initializer.length || (s.initializer = []), s.initializer.push(h.onnx.TensorProto.decode(t, t.uint32()));\n                break;\n              }\n            case 15:\n              {\n                s.sparseInitializer && s.sparseInitializer.length || (s.sparseInitializer = []), s.sparseInitializer.push(h.onnx.SparseTensorProto.decode(t, t.uint32()));\n                break;\n              }\n            case 10:\n              {\n                s.docString = t.string();\n                break;\n              }\n            case 11:\n              {\n                s.input && s.input.length || (s.input = []), s.input.push(h.onnx.ValueInfoProto.decode(t, t.uint32()));\n                break;\n              }\n            case 12:\n              {\n                s.output && s.output.length || (s.output = []), s.output.push(h.onnx.ValueInfoProto.decode(t, t.uint32()));\n                break;\n              }\n            case 13:\n              {\n                s.valueInfo && s.valueInfo.length || (s.valueInfo = []), s.valueInfo.push(h.onnx.ValueInfoProto.decode(t, t.uint32()));\n                break;\n              }\n            case 14:\n              {\n                s.quantizationAnnotation && s.quantizationAnnotation.length || (s.quantizationAnnotation = []), s.quantizationAnnotation.push(h.onnx.TensorAnnotation.decode(t, t.uint32()));\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.node != null && t.hasOwnProperty(\"node\")) {\n          if (!Array.isArray(t.node)) return \"node: array expected\";\n          for (var r = 0; r < t.node.length; ++r) {\n            var n = h.onnx.NodeProto.verify(t.node[r]);\n            if (n) return \"node.\" + n;\n          }\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && !b.isString(t.name)) return \"name: string expected\";\n        if (t.initializer != null && t.hasOwnProperty(\"initializer\")) {\n          if (!Array.isArray(t.initializer)) return \"initializer: array expected\";\n          for (var r = 0; r < t.initializer.length; ++r) {\n            var n = h.onnx.TensorProto.verify(t.initializer[r]);\n            if (n) return \"initializer.\" + n;\n          }\n        }\n        if (t.sparseInitializer != null && t.hasOwnProperty(\"sparseInitializer\")) {\n          if (!Array.isArray(t.sparseInitializer)) return \"sparseInitializer: array expected\";\n          for (var r = 0; r < t.sparseInitializer.length; ++r) {\n            var n = h.onnx.SparseTensorProto.verify(t.sparseInitializer[r]);\n            if (n) return \"sparseInitializer.\" + n;\n          }\n        }\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString)) return \"docString: string expected\";\n        if (t.input != null && t.hasOwnProperty(\"input\")) {\n          if (!Array.isArray(t.input)) return \"input: array expected\";\n          for (var r = 0; r < t.input.length; ++r) {\n            var n = h.onnx.ValueInfoProto.verify(t.input[r]);\n            if (n) return \"input.\" + n;\n          }\n        }\n        if (t.output != null && t.hasOwnProperty(\"output\")) {\n          if (!Array.isArray(t.output)) return \"output: array expected\";\n          for (var r = 0; r < t.output.length; ++r) {\n            var n = h.onnx.ValueInfoProto.verify(t.output[r]);\n            if (n) return \"output.\" + n;\n          }\n        }\n        if (t.valueInfo != null && t.hasOwnProperty(\"valueInfo\")) {\n          if (!Array.isArray(t.valueInfo)) return \"valueInfo: array expected\";\n          for (var r = 0; r < t.valueInfo.length; ++r) {\n            var n = h.onnx.ValueInfoProto.verify(t.valueInfo[r]);\n            if (n) return \"valueInfo.\" + n;\n          }\n        }\n        if (t.quantizationAnnotation != null && t.hasOwnProperty(\"quantizationAnnotation\")) {\n          if (!Array.isArray(t.quantizationAnnotation)) return \"quantizationAnnotation: array expected\";\n          for (var r = 0; r < t.quantizationAnnotation.length; ++r) {\n            var n = h.onnx.TensorAnnotation.verify(t.quantizationAnnotation[r]);\n            if (n) return \"quantizationAnnotation.\" + n;\n          }\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.GraphProto) return t;\n        var r = new h.onnx.GraphProto();\n        if (t.node) {\n          if (!Array.isArray(t.node)) throw TypeError(\".onnx.GraphProto.node: array expected\");\n          r.node = [];\n          for (var n = 0; n < t.node.length; ++n) {\n            if (typeof t.node[n] != \"object\") throw TypeError(\".onnx.GraphProto.node: object expected\");\n            r.node[n] = h.onnx.NodeProto.fromObject(t.node[n]);\n          }\n        }\n        if (t.name != null && (r.name = String(t.name)), t.initializer) {\n          if (!Array.isArray(t.initializer)) throw TypeError(\".onnx.GraphProto.initializer: array expected\");\n          r.initializer = [];\n          for (var n = 0; n < t.initializer.length; ++n) {\n            if (typeof t.initializer[n] != \"object\") throw TypeError(\".onnx.GraphProto.initializer: object expected\");\n            r.initializer[n] = h.onnx.TensorProto.fromObject(t.initializer[n]);\n          }\n        }\n        if (t.sparseInitializer) {\n          if (!Array.isArray(t.sparseInitializer)) throw TypeError(\".onnx.GraphProto.sparseInitializer: array expected\");\n          r.sparseInitializer = [];\n          for (var n = 0; n < t.sparseInitializer.length; ++n) {\n            if (typeof t.sparseInitializer[n] != \"object\") throw TypeError(\".onnx.GraphProto.sparseInitializer: object expected\");\n            r.sparseInitializer[n] = h.onnx.SparseTensorProto.fromObject(t.sparseInitializer[n]);\n          }\n        }\n        if (t.docString != null && (r.docString = String(t.docString)), t.input) {\n          if (!Array.isArray(t.input)) throw TypeError(\".onnx.GraphProto.input: array expected\");\n          r.input = [];\n          for (var n = 0; n < t.input.length; ++n) {\n            if (typeof t.input[n] != \"object\") throw TypeError(\".onnx.GraphProto.input: object expected\");\n            r.input[n] = h.onnx.ValueInfoProto.fromObject(t.input[n]);\n          }\n        }\n        if (t.output) {\n          if (!Array.isArray(t.output)) throw TypeError(\".onnx.GraphProto.output: array expected\");\n          r.output = [];\n          for (var n = 0; n < t.output.length; ++n) {\n            if (typeof t.output[n] != \"object\") throw TypeError(\".onnx.GraphProto.output: object expected\");\n            r.output[n] = h.onnx.ValueInfoProto.fromObject(t.output[n]);\n          }\n        }\n        if (t.valueInfo) {\n          if (!Array.isArray(t.valueInfo)) throw TypeError(\".onnx.GraphProto.valueInfo: array expected\");\n          r.valueInfo = [];\n          for (var n = 0; n < t.valueInfo.length; ++n) {\n            if (typeof t.valueInfo[n] != \"object\") throw TypeError(\".onnx.GraphProto.valueInfo: object expected\");\n            r.valueInfo[n] = h.onnx.ValueInfoProto.fromObject(t.valueInfo[n]);\n          }\n        }\n        if (t.quantizationAnnotation) {\n          if (!Array.isArray(t.quantizationAnnotation)) throw TypeError(\".onnx.GraphProto.quantizationAnnotation: array expected\");\n          r.quantizationAnnotation = [];\n          for (var n = 0; n < t.quantizationAnnotation.length; ++n) {\n            if (typeof t.quantizationAnnotation[n] != \"object\") throw TypeError(\".onnx.GraphProto.quantizationAnnotation: object expected\");\n            r.quantizationAnnotation[n] = h.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[n]);\n          }\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.node = [], n.initializer = [], n.input = [], n.output = [], n.valueInfo = [], n.quantizationAnnotation = [], n.sparseInitializer = []), r.defaults && (n.name = \"\", n.docString = \"\"), t.node && t.node.length) {\n          n.node = [];\n          for (var s = 0; s < t.node.length; ++s) n.node[s] = h.onnx.NodeProto.toObject(t.node[s], r);\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && (n.name = t.name), t.initializer && t.initializer.length) {\n          n.initializer = [];\n          for (var s = 0; s < t.initializer.length; ++s) n.initializer[s] = h.onnx.TensorProto.toObject(t.initializer[s], r);\n        }\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.input && t.input.length) {\n          n.input = [];\n          for (var s = 0; s < t.input.length; ++s) n.input[s] = h.onnx.ValueInfoProto.toObject(t.input[s], r);\n        }\n        if (t.output && t.output.length) {\n          n.output = [];\n          for (var s = 0; s < t.output.length; ++s) n.output[s] = h.onnx.ValueInfoProto.toObject(t.output[s], r);\n        }\n        if (t.valueInfo && t.valueInfo.length) {\n          n.valueInfo = [];\n          for (var s = 0; s < t.valueInfo.length; ++s) n.valueInfo[s] = h.onnx.ValueInfoProto.toObject(t.valueInfo[s], r);\n        }\n        if (t.quantizationAnnotation && t.quantizationAnnotation.length) {\n          n.quantizationAnnotation = [];\n          for (var s = 0; s < t.quantizationAnnotation.length; ++s) n.quantizationAnnotation[s] = h.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[s], r);\n        }\n        if (t.sparseInitializer && t.sparseInitializer.length) {\n          n.sparseInitializer = [];\n          for (var s = 0; s < t.sparseInitializer.length; ++s) n.sparseInitializer[s] = h.onnx.SparseTensorProto.toObject(t.sparseInitializer[s], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.GraphProto\";\n      }, e;\n    }(), i.TensorProto = function () {\n      function e(o) {\n        if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.dims = b.emptyArray, e.prototype.dataType = 0, e.prototype.segment = null, e.prototype.floatData = b.emptyArray, e.prototype.int32Data = b.emptyArray, e.prototype.stringData = b.emptyArray, e.prototype.int64Data = b.emptyArray, e.prototype.name = \"\", e.prototype.docString = \"\", e.prototype.rawData = b.newBuffer([]), e.prototype.externalData = b.emptyArray, e.prototype.dataLocation = 0, e.prototype.doubleData = b.emptyArray, e.prototype.uint64Data = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.dims != null && t.dims.length) {\n          r.uint32(10).fork();\n          for (var n = 0; n < t.dims.length; ++n) r.int64(t.dims[n]);\n          r.ldelim();\n        }\n        if (t.dataType != null && Object.hasOwnProperty.call(t, \"dataType\") && r.uint32(16).int32(t.dataType), t.segment != null && Object.hasOwnProperty.call(t, \"segment\") && h.onnx.TensorProto.Segment.encode(t.segment, r.uint32(26).fork()).ldelim(), t.floatData != null && t.floatData.length) {\n          r.uint32(34).fork();\n          for (var n = 0; n < t.floatData.length; ++n) r.float(t.floatData[n]);\n          r.ldelim();\n        }\n        if (t.int32Data != null && t.int32Data.length) {\n          r.uint32(42).fork();\n          for (var n = 0; n < t.int32Data.length; ++n) r.int32(t.int32Data[n]);\n          r.ldelim();\n        }\n        if (t.stringData != null && t.stringData.length) for (var n = 0; n < t.stringData.length; ++n) r.uint32(50).bytes(t.stringData[n]);\n        if (t.int64Data != null && t.int64Data.length) {\n          r.uint32(58).fork();\n          for (var n = 0; n < t.int64Data.length; ++n) r.int64(t.int64Data[n]);\n          r.ldelim();\n        }\n        if (t.name != null && Object.hasOwnProperty.call(t, \"name\") && r.uint32(66).string(t.name), t.rawData != null && Object.hasOwnProperty.call(t, \"rawData\") && r.uint32(74).bytes(t.rawData), t.doubleData != null && t.doubleData.length) {\n          r.uint32(82).fork();\n          for (var n = 0; n < t.doubleData.length; ++n) r.double(t.doubleData[n]);\n          r.ldelim();\n        }\n        if (t.uint64Data != null && t.uint64Data.length) {\n          r.uint32(90).fork();\n          for (var n = 0; n < t.uint64Data.length; ++n) r.uint64(t.uint64Data[n]);\n          r.ldelim();\n        }\n        if (t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(98).string(t.docString), t.externalData != null && t.externalData.length) for (var n = 0; n < t.externalData.length; ++n) h.onnx.StringStringEntryProto.encode(t.externalData[n], r.uint32(106).fork()).ldelim();\n        return t.dataLocation != null && Object.hasOwnProperty.call(t, \"dataLocation\") && r.uint32(112).int32(t.dataLocation), r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.TensorProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                if (s.dims && s.dims.length || (s.dims = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.dims.push(t.int64());else s.dims.push(t.int64());\n                break;\n              }\n            case 2:\n              {\n                s.dataType = t.int32();\n                break;\n              }\n            case 3:\n              {\n                s.segment = h.onnx.TensorProto.Segment.decode(t, t.uint32());\n                break;\n              }\n            case 4:\n              {\n                if (s.floatData && s.floatData.length || (s.floatData = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.floatData.push(t.float());else s.floatData.push(t.float());\n                break;\n              }\n            case 5:\n              {\n                if (s.int32Data && s.int32Data.length || (s.int32Data = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.int32Data.push(t.int32());else s.int32Data.push(t.int32());\n                break;\n              }\n            case 6:\n              {\n                s.stringData && s.stringData.length || (s.stringData = []), s.stringData.push(t.bytes());\n                break;\n              }\n            case 7:\n              {\n                if (s.int64Data && s.int64Data.length || (s.int64Data = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.int64Data.push(t.int64());else s.int64Data.push(t.int64());\n                break;\n              }\n            case 8:\n              {\n                s.name = t.string();\n                break;\n              }\n            case 12:\n              {\n                s.docString = t.string();\n                break;\n              }\n            case 9:\n              {\n                s.rawData = t.bytes();\n                break;\n              }\n            case 13:\n              {\n                s.externalData && s.externalData.length || (s.externalData = []), s.externalData.push(h.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                break;\n              }\n            case 14:\n              {\n                s.dataLocation = t.int32();\n                break;\n              }\n            case 10:\n              {\n                if (s.doubleData && s.doubleData.length || (s.doubleData = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.doubleData.push(t.double());else s.doubleData.push(t.double());\n                break;\n              }\n            case 11:\n              {\n                if (s.uint64Data && s.uint64Data.length || (s.uint64Data = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.uint64Data.push(t.uint64());else s.uint64Data.push(t.uint64());\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.dims != null && t.hasOwnProperty(\"dims\")) {\n          if (!Array.isArray(t.dims)) return \"dims: array expected\";\n          for (var r = 0; r < t.dims.length; ++r) if (!b.isInteger(t.dims[r]) && !(t.dims[r] && b.isInteger(t.dims[r].low) && b.isInteger(t.dims[r].high))) return \"dims: integer|Long[] expected\";\n        }\n        if (t.dataType != null && t.hasOwnProperty(\"dataType\") && !b.isInteger(t.dataType)) return \"dataType: integer expected\";\n        if (t.segment != null && t.hasOwnProperty(\"segment\")) {\n          var n = h.onnx.TensorProto.Segment.verify(t.segment);\n          if (n) return \"segment.\" + n;\n        }\n        if (t.floatData != null && t.hasOwnProperty(\"floatData\")) {\n          if (!Array.isArray(t.floatData)) return \"floatData: array expected\";\n          for (var r = 0; r < t.floatData.length; ++r) if (typeof t.floatData[r] != \"number\") return \"floatData: number[] expected\";\n        }\n        if (t.int32Data != null && t.hasOwnProperty(\"int32Data\")) {\n          if (!Array.isArray(t.int32Data)) return \"int32Data: array expected\";\n          for (var r = 0; r < t.int32Data.length; ++r) if (!b.isInteger(t.int32Data[r])) return \"int32Data: integer[] expected\";\n        }\n        if (t.stringData != null && t.hasOwnProperty(\"stringData\")) {\n          if (!Array.isArray(t.stringData)) return \"stringData: array expected\";\n          for (var r = 0; r < t.stringData.length; ++r) if (!(t.stringData[r] && typeof t.stringData[r].length == \"number\" || b.isString(t.stringData[r]))) return \"stringData: buffer[] expected\";\n        }\n        if (t.int64Data != null && t.hasOwnProperty(\"int64Data\")) {\n          if (!Array.isArray(t.int64Data)) return \"int64Data: array expected\";\n          for (var r = 0; r < t.int64Data.length; ++r) if (!b.isInteger(t.int64Data[r]) && !(t.int64Data[r] && b.isInteger(t.int64Data[r].low) && b.isInteger(t.int64Data[r].high))) return \"int64Data: integer|Long[] expected\";\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && !b.isString(t.name)) return \"name: string expected\";\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString)) return \"docString: string expected\";\n        if (t.rawData != null && t.hasOwnProperty(\"rawData\") && !(t.rawData && typeof t.rawData.length == \"number\" || b.isString(t.rawData))) return \"rawData: buffer expected\";\n        if (t.externalData != null && t.hasOwnProperty(\"externalData\")) {\n          if (!Array.isArray(t.externalData)) return \"externalData: array expected\";\n          for (var r = 0; r < t.externalData.length; ++r) {\n            var n = h.onnx.StringStringEntryProto.verify(t.externalData[r]);\n            if (n) return \"externalData.\" + n;\n          }\n        }\n        if (t.dataLocation != null && t.hasOwnProperty(\"dataLocation\")) switch (t.dataLocation) {\n          default:\n            return \"dataLocation: enum value expected\";\n          case 0:\n          case 1:\n            break;\n        }\n        if (t.doubleData != null && t.hasOwnProperty(\"doubleData\")) {\n          if (!Array.isArray(t.doubleData)) return \"doubleData: array expected\";\n          for (var r = 0; r < t.doubleData.length; ++r) if (typeof t.doubleData[r] != \"number\") return \"doubleData: number[] expected\";\n        }\n        if (t.uint64Data != null && t.hasOwnProperty(\"uint64Data\")) {\n          if (!Array.isArray(t.uint64Data)) return \"uint64Data: array expected\";\n          for (var r = 0; r < t.uint64Data.length; ++r) if (!b.isInteger(t.uint64Data[r]) && !(t.uint64Data[r] && b.isInteger(t.uint64Data[r].low) && b.isInteger(t.uint64Data[r].high))) return \"uint64Data: integer|Long[] expected\";\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.TensorProto) return t;\n        var r = new h.onnx.TensorProto();\n        if (t.dims) {\n          if (!Array.isArray(t.dims)) throw TypeError(\".onnx.TensorProto.dims: array expected\");\n          r.dims = [];\n          for (var n = 0; n < t.dims.length; ++n) b.Long ? (r.dims[n] = b.Long.fromValue(t.dims[n])).unsigned = !1 : typeof t.dims[n] == \"string\" ? r.dims[n] = parseInt(t.dims[n], 10) : typeof t.dims[n] == \"number\" ? r.dims[n] = t.dims[n] : typeof t.dims[n] == \"object\" && (r.dims[n] = new b.LongBits(t.dims[n].low >>> 0, t.dims[n].high >>> 0).toNumber());\n        }\n        if (t.dataType != null && (r.dataType = t.dataType | 0), t.segment != null) {\n          if (typeof t.segment != \"object\") throw TypeError(\".onnx.TensorProto.segment: object expected\");\n          r.segment = h.onnx.TensorProto.Segment.fromObject(t.segment);\n        }\n        if (t.floatData) {\n          if (!Array.isArray(t.floatData)) throw TypeError(\".onnx.TensorProto.floatData: array expected\");\n          r.floatData = [];\n          for (var n = 0; n < t.floatData.length; ++n) r.floatData[n] = Number(t.floatData[n]);\n        }\n        if (t.int32Data) {\n          if (!Array.isArray(t.int32Data)) throw TypeError(\".onnx.TensorProto.int32Data: array expected\");\n          r.int32Data = [];\n          for (var n = 0; n < t.int32Data.length; ++n) r.int32Data[n] = t.int32Data[n] | 0;\n        }\n        if (t.stringData) {\n          if (!Array.isArray(t.stringData)) throw TypeError(\".onnx.TensorProto.stringData: array expected\");\n          r.stringData = [];\n          for (var n = 0; n < t.stringData.length; ++n) typeof t.stringData[n] == \"string\" ? b.base64.decode(t.stringData[n], r.stringData[n] = b.newBuffer(b.base64.length(t.stringData[n])), 0) : t.stringData[n].length >= 0 && (r.stringData[n] = t.stringData[n]);\n        }\n        if (t.int64Data) {\n          if (!Array.isArray(t.int64Data)) throw TypeError(\".onnx.TensorProto.int64Data: array expected\");\n          r.int64Data = [];\n          for (var n = 0; n < t.int64Data.length; ++n) b.Long ? (r.int64Data[n] = b.Long.fromValue(t.int64Data[n])).unsigned = !1 : typeof t.int64Data[n] == \"string\" ? r.int64Data[n] = parseInt(t.int64Data[n], 10) : typeof t.int64Data[n] == \"number\" ? r.int64Data[n] = t.int64Data[n] : typeof t.int64Data[n] == \"object\" && (r.int64Data[n] = new b.LongBits(t.int64Data[n].low >>> 0, t.int64Data[n].high >>> 0).toNumber());\n        }\n        if (t.name != null && (r.name = String(t.name)), t.docString != null && (r.docString = String(t.docString)), t.rawData != null && (typeof t.rawData == \"string\" ? b.base64.decode(t.rawData, r.rawData = b.newBuffer(b.base64.length(t.rawData)), 0) : t.rawData.length >= 0 && (r.rawData = t.rawData)), t.externalData) {\n          if (!Array.isArray(t.externalData)) throw TypeError(\".onnx.TensorProto.externalData: array expected\");\n          r.externalData = [];\n          for (var n = 0; n < t.externalData.length; ++n) {\n            if (typeof t.externalData[n] != \"object\") throw TypeError(\".onnx.TensorProto.externalData: object expected\");\n            r.externalData[n] = h.onnx.StringStringEntryProto.fromObject(t.externalData[n]);\n          }\n        }\n        switch (t.dataLocation) {\n          default:\n            if (typeof t.dataLocation == \"number\") {\n              r.dataLocation = t.dataLocation;\n              break;\n            }\n            break;\n          case \"DEFAULT\":\n          case 0:\n            r.dataLocation = 0;\n            break;\n          case \"EXTERNAL\":\n          case 1:\n            r.dataLocation = 1;\n            break;\n        }\n        if (t.doubleData) {\n          if (!Array.isArray(t.doubleData)) throw TypeError(\".onnx.TensorProto.doubleData: array expected\");\n          r.doubleData = [];\n          for (var n = 0; n < t.doubleData.length; ++n) r.doubleData[n] = Number(t.doubleData[n]);\n        }\n        if (t.uint64Data) {\n          if (!Array.isArray(t.uint64Data)) throw TypeError(\".onnx.TensorProto.uint64Data: array expected\");\n          r.uint64Data = [];\n          for (var n = 0; n < t.uint64Data.length; ++n) b.Long ? (r.uint64Data[n] = b.Long.fromValue(t.uint64Data[n])).unsigned = !0 : typeof t.uint64Data[n] == \"string\" ? r.uint64Data[n] = parseInt(t.uint64Data[n], 10) : typeof t.uint64Data[n] == \"number\" ? r.uint64Data[n] = t.uint64Data[n] : typeof t.uint64Data[n] == \"object\" && (r.uint64Data[n] = new b.LongBits(t.uint64Data[n].low >>> 0, t.uint64Data[n].high >>> 0).toNumber(!0));\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.dims = [], n.floatData = [], n.int32Data = [], n.stringData = [], n.int64Data = [], n.doubleData = [], n.uint64Data = [], n.externalData = []), r.defaults && (n.dataType = 0, n.segment = null, n.name = \"\", r.bytes === String ? n.rawData = \"\" : (n.rawData = [], r.bytes !== Array && (n.rawData = b.newBuffer(n.rawData))), n.docString = \"\", n.dataLocation = r.enums === String ? \"DEFAULT\" : 0), t.dims && t.dims.length) {\n          n.dims = [];\n          for (var s = 0; s < t.dims.length; ++s) typeof t.dims[s] == \"number\" ? n.dims[s] = r.longs === String ? String(t.dims[s]) : t.dims[s] : n.dims[s] = r.longs === String ? b.Long.prototype.toString.call(t.dims[s]) : r.longs === Number ? new b.LongBits(t.dims[s].low >>> 0, t.dims[s].high >>> 0).toNumber() : t.dims[s];\n        }\n        if (t.dataType != null && t.hasOwnProperty(\"dataType\") && (n.dataType = t.dataType), t.segment != null && t.hasOwnProperty(\"segment\") && (n.segment = h.onnx.TensorProto.Segment.toObject(t.segment, r)), t.floatData && t.floatData.length) {\n          n.floatData = [];\n          for (var s = 0; s < t.floatData.length; ++s) n.floatData[s] = r.json && !isFinite(t.floatData[s]) ? String(t.floatData[s]) : t.floatData[s];\n        }\n        if (t.int32Data && t.int32Data.length) {\n          n.int32Data = [];\n          for (var s = 0; s < t.int32Data.length; ++s) n.int32Data[s] = t.int32Data[s];\n        }\n        if (t.stringData && t.stringData.length) {\n          n.stringData = [];\n          for (var s = 0; s < t.stringData.length; ++s) n.stringData[s] = r.bytes === String ? b.base64.encode(t.stringData[s], 0, t.stringData[s].length) : r.bytes === Array ? Array.prototype.slice.call(t.stringData[s]) : t.stringData[s];\n        }\n        if (t.int64Data && t.int64Data.length) {\n          n.int64Data = [];\n          for (var s = 0; s < t.int64Data.length; ++s) typeof t.int64Data[s] == \"number\" ? n.int64Data[s] = r.longs === String ? String(t.int64Data[s]) : t.int64Data[s] : n.int64Data[s] = r.longs === String ? b.Long.prototype.toString.call(t.int64Data[s]) : r.longs === Number ? new b.LongBits(t.int64Data[s].low >>> 0, t.int64Data[s].high >>> 0).toNumber() : t.int64Data[s];\n        }\n        if (t.name != null && t.hasOwnProperty(\"name\") && (n.name = t.name), t.rawData != null && t.hasOwnProperty(\"rawData\") && (n.rawData = r.bytes === String ? b.base64.encode(t.rawData, 0, t.rawData.length) : r.bytes === Array ? Array.prototype.slice.call(t.rawData) : t.rawData), t.doubleData && t.doubleData.length) {\n          n.doubleData = [];\n          for (var s = 0; s < t.doubleData.length; ++s) n.doubleData[s] = r.json && !isFinite(t.doubleData[s]) ? String(t.doubleData[s]) : t.doubleData[s];\n        }\n        if (t.uint64Data && t.uint64Data.length) {\n          n.uint64Data = [];\n          for (var s = 0; s < t.uint64Data.length; ++s) typeof t.uint64Data[s] == \"number\" ? n.uint64Data[s] = r.longs === String ? String(t.uint64Data[s]) : t.uint64Data[s] : n.uint64Data[s] = r.longs === String ? b.Long.prototype.toString.call(t.uint64Data[s]) : r.longs === Number ? new b.LongBits(t.uint64Data[s].low >>> 0, t.uint64Data[s].high >>> 0).toNumber(!0) : t.uint64Data[s];\n        }\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.externalData && t.externalData.length) {\n          n.externalData = [];\n          for (var s = 0; s < t.externalData.length; ++s) n.externalData[s] = h.onnx.StringStringEntryProto.toObject(t.externalData[s], r);\n        }\n        return t.dataLocation != null && t.hasOwnProperty(\"dataLocation\") && (n.dataLocation = r.enums === String ? h.onnx.TensorProto.DataLocation[t.dataLocation] === void 0 ? t.dataLocation : h.onnx.TensorProto.DataLocation[t.dataLocation] : t.dataLocation), n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.TensorProto\";\n      }, e.DataType = function () {\n        var o = {},\n          t = Object.create(o);\n        return t[o[0] = \"UNDEFINED\"] = 0, t[o[1] = \"FLOAT\"] = 1, t[o[2] = \"UINT8\"] = 2, t[o[3] = \"INT8\"] = 3, t[o[4] = \"UINT16\"] = 4, t[o[5] = \"INT16\"] = 5, t[o[6] = \"INT32\"] = 6, t[o[7] = \"INT64\"] = 7, t[o[8] = \"STRING\"] = 8, t[o[9] = \"BOOL\"] = 9, t[o[10] = \"FLOAT16\"] = 10, t[o[11] = \"DOUBLE\"] = 11, t[o[12] = \"UINT32\"] = 12, t[o[13] = \"UINT64\"] = 13, t[o[14] = \"COMPLEX64\"] = 14, t[o[15] = \"COMPLEX128\"] = 15, t[o[16] = \"BFLOAT16\"] = 16, t[o[17] = \"FLOAT8E4M3FN\"] = 17, t[o[18] = \"FLOAT8E4M3FNUZ\"] = 18, t[o[19] = \"FLOAT8E5M2\"] = 19, t[o[20] = \"FLOAT8E5M2FNUZ\"] = 20, t;\n      }(), e.Segment = function () {\n        function o(t) {\n          if (t) for (var r = Object.keys(t), n = 0; n < r.length; ++n) t[r[n]] != null && (this[r[n]] = t[r[n]]);\n        }\n        return o.prototype.begin = b.Long ? b.Long.fromBits(0, 0, !1) : 0, o.prototype.end = b.Long ? b.Long.fromBits(0, 0, !1) : 0, o.create = function (r) {\n          return new o(r);\n        }, o.encode = function (r, n) {\n          return n || (n = pt.create()), r.begin != null && Object.hasOwnProperty.call(r, \"begin\") && n.uint32(8).int64(r.begin), r.end != null && Object.hasOwnProperty.call(r, \"end\") && n.uint32(16).int64(r.end), n;\n        }, o.encodeDelimited = function (r, n) {\n          return this.encode(r, n).ldelim();\n        }, o.decode = function (r, n) {\n          r instanceof $ || (r = $.create(r));\n          for (var s = n === void 0 ? r.len : r.pos + n, a = new h.onnx.TensorProto.Segment(); r.pos < s;) {\n            var u = r.uint32();\n            switch (u >>> 3) {\n              case 1:\n                {\n                  a.begin = r.int64();\n                  break;\n                }\n              case 2:\n                {\n                  a.end = r.int64();\n                  break;\n                }\n              default:\n                r.skipType(u & 7);\n                break;\n            }\n          }\n          return a;\n        }, o.decodeDelimited = function (r) {\n          return r instanceof $ || (r = new $(r)), this.decode(r, r.uint32());\n        }, o.verify = function (r) {\n          return typeof r != \"object\" || r === null ? \"object expected\" : r.begin != null && r.hasOwnProperty(\"begin\") && !b.isInteger(r.begin) && !(r.begin && b.isInteger(r.begin.low) && b.isInteger(r.begin.high)) ? \"begin: integer|Long expected\" : r.end != null && r.hasOwnProperty(\"end\") && !b.isInteger(r.end) && !(r.end && b.isInteger(r.end.low) && b.isInteger(r.end.high)) ? \"end: integer|Long expected\" : null;\n        }, o.fromObject = function (r) {\n          if (r instanceof h.onnx.TensorProto.Segment) return r;\n          var n = new h.onnx.TensorProto.Segment();\n          return r.begin != null && (b.Long ? (n.begin = b.Long.fromValue(r.begin)).unsigned = !1 : typeof r.begin == \"string\" ? n.begin = parseInt(r.begin, 10) : typeof r.begin == \"number\" ? n.begin = r.begin : typeof r.begin == \"object\" && (n.begin = new b.LongBits(r.begin.low >>> 0, r.begin.high >>> 0).toNumber())), r.end != null && (b.Long ? (n.end = b.Long.fromValue(r.end)).unsigned = !1 : typeof r.end == \"string\" ? n.end = parseInt(r.end, 10) : typeof r.end == \"number\" ? n.end = r.end : typeof r.end == \"object\" && (n.end = new b.LongBits(r.end.low >>> 0, r.end.high >>> 0).toNumber())), n;\n        }, o.toObject = function (r, n) {\n          n || (n = {});\n          var s = {};\n          if (n.defaults) {\n            if (b.Long) {\n              var a = new b.Long(0, 0, !1);\n              s.begin = n.longs === String ? a.toString() : n.longs === Number ? a.toNumber() : a;\n            } else s.begin = n.longs === String ? \"0\" : 0;\n            if (b.Long) {\n              var a = new b.Long(0, 0, !1);\n              s.end = n.longs === String ? a.toString() : n.longs === Number ? a.toNumber() : a;\n            } else s.end = n.longs === String ? \"0\" : 0;\n          }\n          return r.begin != null && r.hasOwnProperty(\"begin\") && (typeof r.begin == \"number\" ? s.begin = n.longs === String ? String(r.begin) : r.begin : s.begin = n.longs === String ? b.Long.prototype.toString.call(r.begin) : n.longs === Number ? new b.LongBits(r.begin.low >>> 0, r.begin.high >>> 0).toNumber() : r.begin), r.end != null && r.hasOwnProperty(\"end\") && (typeof r.end == \"number\" ? s.end = n.longs === String ? String(r.end) : r.end : s.end = n.longs === String ? b.Long.prototype.toString.call(r.end) : n.longs === Number ? new b.LongBits(r.end.low >>> 0, r.end.high >>> 0).toNumber() : r.end), s;\n        }, o.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, o.getTypeUrl = function (r) {\n          return r === void 0 && (r = \"type.googleapis.com\"), r + \"/onnx.TensorProto.Segment\";\n        }, o;\n      }(), e.DataLocation = function () {\n        var o = {},\n          t = Object.create(o);\n        return t[o[0] = \"DEFAULT\"] = 0, t[o[1] = \"EXTERNAL\"] = 1, t;\n      }(), e;\n    }(), i.SparseTensorProto = function () {\n      function e(o) {\n        if (this.dims = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.values = null, e.prototype.indices = null, e.prototype.dims = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.values != null && Object.hasOwnProperty.call(t, \"values\") && h.onnx.TensorProto.encode(t.values, r.uint32(10).fork()).ldelim(), t.indices != null && Object.hasOwnProperty.call(t, \"indices\") && h.onnx.TensorProto.encode(t.indices, r.uint32(18).fork()).ldelim(), t.dims != null && t.dims.length) {\n          r.uint32(26).fork();\n          for (var n = 0; n < t.dims.length; ++n) r.int64(t.dims[n]);\n          r.ldelim();\n        }\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.SparseTensorProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.values = h.onnx.TensorProto.decode(t, t.uint32());\n                break;\n              }\n            case 2:\n              {\n                s.indices = h.onnx.TensorProto.decode(t, t.uint32());\n                break;\n              }\n            case 3:\n              {\n                if (s.dims && s.dims.length || (s.dims = []), (a & 7) === 2) for (var u = t.uint32() + t.pos; t.pos < u;) s.dims.push(t.int64());else s.dims.push(t.int64());\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.values != null && t.hasOwnProperty(\"values\")) {\n          var r = h.onnx.TensorProto.verify(t.values);\n          if (r) return \"values.\" + r;\n        }\n        if (t.indices != null && t.hasOwnProperty(\"indices\")) {\n          var r = h.onnx.TensorProto.verify(t.indices);\n          if (r) return \"indices.\" + r;\n        }\n        if (t.dims != null && t.hasOwnProperty(\"dims\")) {\n          if (!Array.isArray(t.dims)) return \"dims: array expected\";\n          for (var n = 0; n < t.dims.length; ++n) if (!b.isInteger(t.dims[n]) && !(t.dims[n] && b.isInteger(t.dims[n].low) && b.isInteger(t.dims[n].high))) return \"dims: integer|Long[] expected\";\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.SparseTensorProto) return t;\n        var r = new h.onnx.SparseTensorProto();\n        if (t.values != null) {\n          if (typeof t.values != \"object\") throw TypeError(\".onnx.SparseTensorProto.values: object expected\");\n          r.values = h.onnx.TensorProto.fromObject(t.values);\n        }\n        if (t.indices != null) {\n          if (typeof t.indices != \"object\") throw TypeError(\".onnx.SparseTensorProto.indices: object expected\");\n          r.indices = h.onnx.TensorProto.fromObject(t.indices);\n        }\n        if (t.dims) {\n          if (!Array.isArray(t.dims)) throw TypeError(\".onnx.SparseTensorProto.dims: array expected\");\n          r.dims = [];\n          for (var n = 0; n < t.dims.length; ++n) b.Long ? (r.dims[n] = b.Long.fromValue(t.dims[n])).unsigned = !1 : typeof t.dims[n] == \"string\" ? r.dims[n] = parseInt(t.dims[n], 10) : typeof t.dims[n] == \"number\" ? r.dims[n] = t.dims[n] : typeof t.dims[n] == \"object\" && (r.dims[n] = new b.LongBits(t.dims[n].low >>> 0, t.dims[n].high >>> 0).toNumber());\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.dims = []), r.defaults && (n.values = null, n.indices = null), t.values != null && t.hasOwnProperty(\"values\") && (n.values = h.onnx.TensorProto.toObject(t.values, r)), t.indices != null && t.hasOwnProperty(\"indices\") && (n.indices = h.onnx.TensorProto.toObject(t.indices, r)), t.dims && t.dims.length) {\n          n.dims = [];\n          for (var s = 0; s < t.dims.length; ++s) typeof t.dims[s] == \"number\" ? n.dims[s] = r.longs === String ? String(t.dims[s]) : t.dims[s] : n.dims[s] = r.longs === String ? b.Long.prototype.toString.call(t.dims[s]) : r.longs === Number ? new b.LongBits(t.dims[s].low >>> 0, t.dims[s].high >>> 0).toNumber() : t.dims[s];\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.SparseTensorProto\";\n      }, e;\n    }(), i.TensorShapeProto = function () {\n      function e(o) {\n        if (this.dim = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.dim = b.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.dim != null && t.dim.length) for (var n = 0; n < t.dim.length; ++n) h.onnx.TensorShapeProto.Dimension.encode(t.dim[n], r.uint32(10).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.TensorShapeProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.dim && s.dim.length || (s.dim = []), s.dim.push(h.onnx.TensorShapeProto.Dimension.decode(t, t.uint32()));\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.dim != null && t.hasOwnProperty(\"dim\")) {\n          if (!Array.isArray(t.dim)) return \"dim: array expected\";\n          for (var r = 0; r < t.dim.length; ++r) {\n            var n = h.onnx.TensorShapeProto.Dimension.verify(t.dim[r]);\n            if (n) return \"dim.\" + n;\n          }\n        }\n        return null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.TensorShapeProto) return t;\n        var r = new h.onnx.TensorShapeProto();\n        if (t.dim) {\n          if (!Array.isArray(t.dim)) throw TypeError(\".onnx.TensorShapeProto.dim: array expected\");\n          r.dim = [];\n          for (var n = 0; n < t.dim.length; ++n) {\n            if (typeof t.dim[n] != \"object\") throw TypeError(\".onnx.TensorShapeProto.dim: object expected\");\n            r.dim[n] = h.onnx.TensorShapeProto.Dimension.fromObject(t.dim[n]);\n          }\n        }\n        return r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.dim = []), t.dim && t.dim.length) {\n          n.dim = [];\n          for (var s = 0; s < t.dim.length; ++s) n.dim[s] = h.onnx.TensorShapeProto.Dimension.toObject(t.dim[s], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.TensorShapeProto\";\n      }, e.Dimension = function () {\n        function o(r) {\n          if (r) for (var n = Object.keys(r), s = 0; s < n.length; ++s) r[n[s]] != null && (this[n[s]] = r[n[s]]);\n        }\n        o.prototype.dimValue = null, o.prototype.dimParam = null, o.prototype.denotation = \"\";\n        var t;\n        return Object.defineProperty(o.prototype, \"value\", {\n          get: b.oneOfGetter(t = [\"dimValue\", \"dimParam\"]),\n          set: b.oneOfSetter(t)\n        }), o.create = function (n) {\n          return new o(n);\n        }, o.encode = function (n, s) {\n          return s || (s = pt.create()), n.dimValue != null && Object.hasOwnProperty.call(n, \"dimValue\") && s.uint32(8).int64(n.dimValue), n.dimParam != null && Object.hasOwnProperty.call(n, \"dimParam\") && s.uint32(18).string(n.dimParam), n.denotation != null && Object.hasOwnProperty.call(n, \"denotation\") && s.uint32(26).string(n.denotation), s;\n        }, o.encodeDelimited = function (n, s) {\n          return this.encode(n, s).ldelim();\n        }, o.decode = function (n, s) {\n          n instanceof $ || (n = $.create(n));\n          for (var a = s === void 0 ? n.len : n.pos + s, u = new h.onnx.TensorShapeProto.Dimension(); n.pos < a;) {\n            var l = n.uint32();\n            switch (l >>> 3) {\n              case 1:\n                {\n                  u.dimValue = n.int64();\n                  break;\n                }\n              case 2:\n                {\n                  u.dimParam = n.string();\n                  break;\n                }\n              case 3:\n                {\n                  u.denotation = n.string();\n                  break;\n                }\n              default:\n                n.skipType(l & 7);\n                break;\n            }\n          }\n          return u;\n        }, o.decodeDelimited = function (n) {\n          return n instanceof $ || (n = new $(n)), this.decode(n, n.uint32());\n        }, o.verify = function (n) {\n          if (typeof n != \"object\" || n === null) return \"object expected\";\n          var s = {};\n          if (n.dimValue != null && n.hasOwnProperty(\"dimValue\") && (s.value = 1, !b.isInteger(n.dimValue) && !(n.dimValue && b.isInteger(n.dimValue.low) && b.isInteger(n.dimValue.high)))) return \"dimValue: integer|Long expected\";\n          if (n.dimParam != null && n.hasOwnProperty(\"dimParam\")) {\n            if (s.value === 1) return \"value: multiple values\";\n            if (s.value = 1, !b.isString(n.dimParam)) return \"dimParam: string expected\";\n          }\n          return n.denotation != null && n.hasOwnProperty(\"denotation\") && !b.isString(n.denotation) ? \"denotation: string expected\" : null;\n        }, o.fromObject = function (n) {\n          if (n instanceof h.onnx.TensorShapeProto.Dimension) return n;\n          var s = new h.onnx.TensorShapeProto.Dimension();\n          return n.dimValue != null && (b.Long ? (s.dimValue = b.Long.fromValue(n.dimValue)).unsigned = !1 : typeof n.dimValue == \"string\" ? s.dimValue = parseInt(n.dimValue, 10) : typeof n.dimValue == \"number\" ? s.dimValue = n.dimValue : typeof n.dimValue == \"object\" && (s.dimValue = new b.LongBits(n.dimValue.low >>> 0, n.dimValue.high >>> 0).toNumber())), n.dimParam != null && (s.dimParam = String(n.dimParam)), n.denotation != null && (s.denotation = String(n.denotation)), s;\n        }, o.toObject = function (n, s) {\n          s || (s = {});\n          var a = {};\n          return s.defaults && (a.denotation = \"\"), n.dimValue != null && n.hasOwnProperty(\"dimValue\") && (typeof n.dimValue == \"number\" ? a.dimValue = s.longs === String ? String(n.dimValue) : n.dimValue : a.dimValue = s.longs === String ? b.Long.prototype.toString.call(n.dimValue) : s.longs === Number ? new b.LongBits(n.dimValue.low >>> 0, n.dimValue.high >>> 0).toNumber() : n.dimValue, s.oneofs && (a.value = \"dimValue\")), n.dimParam != null && n.hasOwnProperty(\"dimParam\") && (a.dimParam = n.dimParam, s.oneofs && (a.value = \"dimParam\")), n.denotation != null && n.hasOwnProperty(\"denotation\") && (a.denotation = n.denotation), a;\n        }, o.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, o.getTypeUrl = function (n) {\n          return n === void 0 && (n = \"type.googleapis.com\"), n + \"/onnx.TensorShapeProto.Dimension\";\n        }, o;\n      }(), e;\n    }(), i.TypeProto = function () {\n      function e(t) {\n        if (t) for (var r = Object.keys(t), n = 0; n < r.length; ++n) t[r[n]] != null && (this[r[n]] = t[r[n]]);\n      }\n      e.prototype.tensorType = null, e.prototype.sequenceType = null, e.prototype.mapType = null, e.prototype.optionalType = null, e.prototype.sparseTensorType = null, e.prototype.denotation = \"\";\n      var o;\n      return Object.defineProperty(e.prototype, \"value\", {\n        get: b.oneOfGetter(o = [\"tensorType\", \"sequenceType\", \"mapType\", \"optionalType\", \"sparseTensorType\"]),\n        set: b.oneOfSetter(o)\n      }), e.create = function (r) {\n        return new e(r);\n      }, e.encode = function (r, n) {\n        return n || (n = pt.create()), r.tensorType != null && Object.hasOwnProperty.call(r, \"tensorType\") && h.onnx.TypeProto.Tensor.encode(r.tensorType, n.uint32(10).fork()).ldelim(), r.sequenceType != null && Object.hasOwnProperty.call(r, \"sequenceType\") && h.onnx.TypeProto.Sequence.encode(r.sequenceType, n.uint32(34).fork()).ldelim(), r.mapType != null && Object.hasOwnProperty.call(r, \"mapType\") && h.onnx.TypeProto.Map.encode(r.mapType, n.uint32(42).fork()).ldelim(), r.denotation != null && Object.hasOwnProperty.call(r, \"denotation\") && n.uint32(50).string(r.denotation), r.sparseTensorType != null && Object.hasOwnProperty.call(r, \"sparseTensorType\") && h.onnx.TypeProto.SparseTensor.encode(r.sparseTensorType, n.uint32(66).fork()).ldelim(), r.optionalType != null && Object.hasOwnProperty.call(r, \"optionalType\") && h.onnx.TypeProto.Optional.encode(r.optionalType, n.uint32(74).fork()).ldelim(), n;\n      }, e.encodeDelimited = function (r, n) {\n        return this.encode(r, n).ldelim();\n      }, e.decode = function (r, n) {\n        r instanceof $ || (r = $.create(r));\n        for (var s = n === void 0 ? r.len : r.pos + n, a = new h.onnx.TypeProto(); r.pos < s;) {\n          var u = r.uint32();\n          switch (u >>> 3) {\n            case 1:\n              {\n                a.tensorType = h.onnx.TypeProto.Tensor.decode(r, r.uint32());\n                break;\n              }\n            case 4:\n              {\n                a.sequenceType = h.onnx.TypeProto.Sequence.decode(r, r.uint32());\n                break;\n              }\n            case 5:\n              {\n                a.mapType = h.onnx.TypeProto.Map.decode(r, r.uint32());\n                break;\n              }\n            case 9:\n              {\n                a.optionalType = h.onnx.TypeProto.Optional.decode(r, r.uint32());\n                break;\n              }\n            case 8:\n              {\n                a.sparseTensorType = h.onnx.TypeProto.SparseTensor.decode(r, r.uint32());\n                break;\n              }\n            case 6:\n              {\n                a.denotation = r.string();\n                break;\n              }\n            default:\n              r.skipType(u & 7);\n              break;\n          }\n        }\n        return a;\n      }, e.decodeDelimited = function (r) {\n        return r instanceof $ || (r = new $(r)), this.decode(r, r.uint32());\n      }, e.verify = function (r) {\n        if (typeof r != \"object\" || r === null) return \"object expected\";\n        var n = {};\n        if (r.tensorType != null && r.hasOwnProperty(\"tensorType\")) {\n          n.value = 1;\n          {\n            var s = h.onnx.TypeProto.Tensor.verify(r.tensorType);\n            if (s) return \"tensorType.\" + s;\n          }\n        }\n        if (r.sequenceType != null && r.hasOwnProperty(\"sequenceType\")) {\n          if (n.value === 1) return \"value: multiple values\";\n          n.value = 1;\n          {\n            var s = h.onnx.TypeProto.Sequence.verify(r.sequenceType);\n            if (s) return \"sequenceType.\" + s;\n          }\n        }\n        if (r.mapType != null && r.hasOwnProperty(\"mapType\")) {\n          if (n.value === 1) return \"value: multiple values\";\n          n.value = 1;\n          {\n            var s = h.onnx.TypeProto.Map.verify(r.mapType);\n            if (s) return \"mapType.\" + s;\n          }\n        }\n        if (r.optionalType != null && r.hasOwnProperty(\"optionalType\")) {\n          if (n.value === 1) return \"value: multiple values\";\n          n.value = 1;\n          {\n            var s = h.onnx.TypeProto.Optional.verify(r.optionalType);\n            if (s) return \"optionalType.\" + s;\n          }\n        }\n        if (r.sparseTensorType != null && r.hasOwnProperty(\"sparseTensorType\")) {\n          if (n.value === 1) return \"value: multiple values\";\n          n.value = 1;\n          {\n            var s = h.onnx.TypeProto.SparseTensor.verify(r.sparseTensorType);\n            if (s) return \"sparseTensorType.\" + s;\n          }\n        }\n        return r.denotation != null && r.hasOwnProperty(\"denotation\") && !b.isString(r.denotation) ? \"denotation: string expected\" : null;\n      }, e.fromObject = function (r) {\n        if (r instanceof h.onnx.TypeProto) return r;\n        var n = new h.onnx.TypeProto();\n        if (r.tensorType != null) {\n          if (typeof r.tensorType != \"object\") throw TypeError(\".onnx.TypeProto.tensorType: object expected\");\n          n.tensorType = h.onnx.TypeProto.Tensor.fromObject(r.tensorType);\n        }\n        if (r.sequenceType != null) {\n          if (typeof r.sequenceType != \"object\") throw TypeError(\".onnx.TypeProto.sequenceType: object expected\");\n          n.sequenceType = h.onnx.TypeProto.Sequence.fromObject(r.sequenceType);\n        }\n        if (r.mapType != null) {\n          if (typeof r.mapType != \"object\") throw TypeError(\".onnx.TypeProto.mapType: object expected\");\n          n.mapType = h.onnx.TypeProto.Map.fromObject(r.mapType);\n        }\n        if (r.optionalType != null) {\n          if (typeof r.optionalType != \"object\") throw TypeError(\".onnx.TypeProto.optionalType: object expected\");\n          n.optionalType = h.onnx.TypeProto.Optional.fromObject(r.optionalType);\n        }\n        if (r.sparseTensorType != null) {\n          if (typeof r.sparseTensorType != \"object\") throw TypeError(\".onnx.TypeProto.sparseTensorType: object expected\");\n          n.sparseTensorType = h.onnx.TypeProto.SparseTensor.fromObject(r.sparseTensorType);\n        }\n        return r.denotation != null && (n.denotation = String(r.denotation)), n;\n      }, e.toObject = function (r, n) {\n        n || (n = {});\n        var s = {};\n        return n.defaults && (s.denotation = \"\"), r.tensorType != null && r.hasOwnProperty(\"tensorType\") && (s.tensorType = h.onnx.TypeProto.Tensor.toObject(r.tensorType, n), n.oneofs && (s.value = \"tensorType\")), r.sequenceType != null && r.hasOwnProperty(\"sequenceType\") && (s.sequenceType = h.onnx.TypeProto.Sequence.toObject(r.sequenceType, n), n.oneofs && (s.value = \"sequenceType\")), r.mapType != null && r.hasOwnProperty(\"mapType\") && (s.mapType = h.onnx.TypeProto.Map.toObject(r.mapType, n), n.oneofs && (s.value = \"mapType\")), r.denotation != null && r.hasOwnProperty(\"denotation\") && (s.denotation = r.denotation), r.sparseTensorType != null && r.hasOwnProperty(\"sparseTensorType\") && (s.sparseTensorType = h.onnx.TypeProto.SparseTensor.toObject(r.sparseTensorType, n), n.oneofs && (s.value = \"sparseTensorType\")), r.optionalType != null && r.hasOwnProperty(\"optionalType\") && (s.optionalType = h.onnx.TypeProto.Optional.toObject(r.optionalType, n), n.oneofs && (s.value = \"optionalType\")), s;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (r) {\n        return r === void 0 && (r = \"type.googleapis.com\"), r + \"/onnx.TypeProto\";\n      }, e.Tensor = function () {\n        function t(r) {\n          if (r) for (var n = Object.keys(r), s = 0; s < n.length; ++s) r[n[s]] != null && (this[n[s]] = r[n[s]]);\n        }\n        return t.prototype.elemType = 0, t.prototype.shape = null, t.create = function (n) {\n          return new t(n);\n        }, t.encode = function (n, s) {\n          return s || (s = pt.create()), n.elemType != null && Object.hasOwnProperty.call(n, \"elemType\") && s.uint32(8).int32(n.elemType), n.shape != null && Object.hasOwnProperty.call(n, \"shape\") && h.onnx.TensorShapeProto.encode(n.shape, s.uint32(18).fork()).ldelim(), s;\n        }, t.encodeDelimited = function (n, s) {\n          return this.encode(n, s).ldelim();\n        }, t.decode = function (n, s) {\n          n instanceof $ || (n = $.create(n));\n          for (var a = s === void 0 ? n.len : n.pos + s, u = new h.onnx.TypeProto.Tensor(); n.pos < a;) {\n            var l = n.uint32();\n            switch (l >>> 3) {\n              case 1:\n                {\n                  u.elemType = n.int32();\n                  break;\n                }\n              case 2:\n                {\n                  u.shape = h.onnx.TensorShapeProto.decode(n, n.uint32());\n                  break;\n                }\n              default:\n                n.skipType(l & 7);\n                break;\n            }\n          }\n          return u;\n        }, t.decodeDelimited = function (n) {\n          return n instanceof $ || (n = new $(n)), this.decode(n, n.uint32());\n        }, t.verify = function (n) {\n          if (typeof n != \"object\" || n === null) return \"object expected\";\n          if (n.elemType != null && n.hasOwnProperty(\"elemType\") && !b.isInteger(n.elemType)) return \"elemType: integer expected\";\n          if (n.shape != null && n.hasOwnProperty(\"shape\")) {\n            var s = h.onnx.TensorShapeProto.verify(n.shape);\n            if (s) return \"shape.\" + s;\n          }\n          return null;\n        }, t.fromObject = function (n) {\n          if (n instanceof h.onnx.TypeProto.Tensor) return n;\n          var s = new h.onnx.TypeProto.Tensor();\n          if (n.elemType != null && (s.elemType = n.elemType | 0), n.shape != null) {\n            if (typeof n.shape != \"object\") throw TypeError(\".onnx.TypeProto.Tensor.shape: object expected\");\n            s.shape = h.onnx.TensorShapeProto.fromObject(n.shape);\n          }\n          return s;\n        }, t.toObject = function (n, s) {\n          s || (s = {});\n          var a = {};\n          return s.defaults && (a.elemType = 0, a.shape = null), n.elemType != null && n.hasOwnProperty(\"elemType\") && (a.elemType = n.elemType), n.shape != null && n.hasOwnProperty(\"shape\") && (a.shape = h.onnx.TensorShapeProto.toObject(n.shape, s)), a;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, t.getTypeUrl = function (n) {\n          return n === void 0 && (n = \"type.googleapis.com\"), n + \"/onnx.TypeProto.Tensor\";\n        }, t;\n      }(), e.Sequence = function () {\n        function t(r) {\n          if (r) for (var n = Object.keys(r), s = 0; s < n.length; ++s) r[n[s]] != null && (this[n[s]] = r[n[s]]);\n        }\n        return t.prototype.elemType = null, t.create = function (n) {\n          return new t(n);\n        }, t.encode = function (n, s) {\n          return s || (s = pt.create()), n.elemType != null && Object.hasOwnProperty.call(n, \"elemType\") && h.onnx.TypeProto.encode(n.elemType, s.uint32(10).fork()).ldelim(), s;\n        }, t.encodeDelimited = function (n, s) {\n          return this.encode(n, s).ldelim();\n        }, t.decode = function (n, s) {\n          n instanceof $ || (n = $.create(n));\n          for (var a = s === void 0 ? n.len : n.pos + s, u = new h.onnx.TypeProto.Sequence(); n.pos < a;) {\n            var l = n.uint32();\n            switch (l >>> 3) {\n              case 1:\n                {\n                  u.elemType = h.onnx.TypeProto.decode(n, n.uint32());\n                  break;\n                }\n              default:\n                n.skipType(l & 7);\n                break;\n            }\n          }\n          return u;\n        }, t.decodeDelimited = function (n) {\n          return n instanceof $ || (n = new $(n)), this.decode(n, n.uint32());\n        }, t.verify = function (n) {\n          if (typeof n != \"object\" || n === null) return \"object expected\";\n          if (n.elemType != null && n.hasOwnProperty(\"elemType\")) {\n            var s = h.onnx.TypeProto.verify(n.elemType);\n            if (s) return \"elemType.\" + s;\n          }\n          return null;\n        }, t.fromObject = function (n) {\n          if (n instanceof h.onnx.TypeProto.Sequence) return n;\n          var s = new h.onnx.TypeProto.Sequence();\n          if (n.elemType != null) {\n            if (typeof n.elemType != \"object\") throw TypeError(\".onnx.TypeProto.Sequence.elemType: object expected\");\n            s.elemType = h.onnx.TypeProto.fromObject(n.elemType);\n          }\n          return s;\n        }, t.toObject = function (n, s) {\n          s || (s = {});\n          var a = {};\n          return s.defaults && (a.elemType = null), n.elemType != null && n.hasOwnProperty(\"elemType\") && (a.elemType = h.onnx.TypeProto.toObject(n.elemType, s)), a;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, t.getTypeUrl = function (n) {\n          return n === void 0 && (n = \"type.googleapis.com\"), n + \"/onnx.TypeProto.Sequence\";\n        }, t;\n      }(), e.Map = function () {\n        function t(r) {\n          if (r) for (var n = Object.keys(r), s = 0; s < n.length; ++s) r[n[s]] != null && (this[n[s]] = r[n[s]]);\n        }\n        return t.prototype.keyType = 0, t.prototype.valueType = null, t.create = function (n) {\n          return new t(n);\n        }, t.encode = function (n, s) {\n          return s || (s = pt.create()), n.keyType != null && Object.hasOwnProperty.call(n, \"keyType\") && s.uint32(8).int32(n.keyType), n.valueType != null && Object.hasOwnProperty.call(n, \"valueType\") && h.onnx.TypeProto.encode(n.valueType, s.uint32(18).fork()).ldelim(), s;\n        }, t.encodeDelimited = function (n, s) {\n          return this.encode(n, s).ldelim();\n        }, t.decode = function (n, s) {\n          n instanceof $ || (n = $.create(n));\n          for (var a = s === void 0 ? n.len : n.pos + s, u = new h.onnx.TypeProto.Map(); n.pos < a;) {\n            var l = n.uint32();\n            switch (l >>> 3) {\n              case 1:\n                {\n                  u.keyType = n.int32();\n                  break;\n                }\n              case 2:\n                {\n                  u.valueType = h.onnx.TypeProto.decode(n, n.uint32());\n                  break;\n                }\n              default:\n                n.skipType(l & 7);\n                break;\n            }\n          }\n          return u;\n        }, t.decodeDelimited = function (n) {\n          return n instanceof $ || (n = new $(n)), this.decode(n, n.uint32());\n        }, t.verify = function (n) {\n          if (typeof n != \"object\" || n === null) return \"object expected\";\n          if (n.keyType != null && n.hasOwnProperty(\"keyType\") && !b.isInteger(n.keyType)) return \"keyType: integer expected\";\n          if (n.valueType != null && n.hasOwnProperty(\"valueType\")) {\n            var s = h.onnx.TypeProto.verify(n.valueType);\n            if (s) return \"valueType.\" + s;\n          }\n          return null;\n        }, t.fromObject = function (n) {\n          if (n instanceof h.onnx.TypeProto.Map) return n;\n          var s = new h.onnx.TypeProto.Map();\n          if (n.keyType != null && (s.keyType = n.keyType | 0), n.valueType != null) {\n            if (typeof n.valueType != \"object\") throw TypeError(\".onnx.TypeProto.Map.valueType: object expected\");\n            s.valueType = h.onnx.TypeProto.fromObject(n.valueType);\n          }\n          return s;\n        }, t.toObject = function (n, s) {\n          s || (s = {});\n          var a = {};\n          return s.defaults && (a.keyType = 0, a.valueType = null), n.keyType != null && n.hasOwnProperty(\"keyType\") && (a.keyType = n.keyType), n.valueType != null && n.hasOwnProperty(\"valueType\") && (a.valueType = h.onnx.TypeProto.toObject(n.valueType, s)), a;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, t.getTypeUrl = function (n) {\n          return n === void 0 && (n = \"type.googleapis.com\"), n + \"/onnx.TypeProto.Map\";\n        }, t;\n      }(), e.Optional = function () {\n        function t(r) {\n          if (r) for (var n = Object.keys(r), s = 0; s < n.length; ++s) r[n[s]] != null && (this[n[s]] = r[n[s]]);\n        }\n        return t.prototype.elemType = null, t.create = function (n) {\n          return new t(n);\n        }, t.encode = function (n, s) {\n          return s || (s = pt.create()), n.elemType != null && Object.hasOwnProperty.call(n, \"elemType\") && h.onnx.TypeProto.encode(n.elemType, s.uint32(10).fork()).ldelim(), s;\n        }, t.encodeDelimited = function (n, s) {\n          return this.encode(n, s).ldelim();\n        }, t.decode = function (n, s) {\n          n instanceof $ || (n = $.create(n));\n          for (var a = s === void 0 ? n.len : n.pos + s, u = new h.onnx.TypeProto.Optional(); n.pos < a;) {\n            var l = n.uint32();\n            switch (l >>> 3) {\n              case 1:\n                {\n                  u.elemType = h.onnx.TypeProto.decode(n, n.uint32());\n                  break;\n                }\n              default:\n                n.skipType(l & 7);\n                break;\n            }\n          }\n          return u;\n        }, t.decodeDelimited = function (n) {\n          return n instanceof $ || (n = new $(n)), this.decode(n, n.uint32());\n        }, t.verify = function (n) {\n          if (typeof n != \"object\" || n === null) return \"object expected\";\n          if (n.elemType != null && n.hasOwnProperty(\"elemType\")) {\n            var s = h.onnx.TypeProto.verify(n.elemType);\n            if (s) return \"elemType.\" + s;\n          }\n          return null;\n        }, t.fromObject = function (n) {\n          if (n instanceof h.onnx.TypeProto.Optional) return n;\n          var s = new h.onnx.TypeProto.Optional();\n          if (n.elemType != null) {\n            if (typeof n.elemType != \"object\") throw TypeError(\".onnx.TypeProto.Optional.elemType: object expected\");\n            s.elemType = h.onnx.TypeProto.fromObject(n.elemType);\n          }\n          return s;\n        }, t.toObject = function (n, s) {\n          s || (s = {});\n          var a = {};\n          return s.defaults && (a.elemType = null), n.elemType != null && n.hasOwnProperty(\"elemType\") && (a.elemType = h.onnx.TypeProto.toObject(n.elemType, s)), a;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, t.getTypeUrl = function (n) {\n          return n === void 0 && (n = \"type.googleapis.com\"), n + \"/onnx.TypeProto.Optional\";\n        }, t;\n      }(), e.SparseTensor = function () {\n        function t(r) {\n          if (r) for (var n = Object.keys(r), s = 0; s < n.length; ++s) r[n[s]] != null && (this[n[s]] = r[n[s]]);\n        }\n        return t.prototype.elemType = 0, t.prototype.shape = null, t.create = function (n) {\n          return new t(n);\n        }, t.encode = function (n, s) {\n          return s || (s = pt.create()), n.elemType != null && Object.hasOwnProperty.call(n, \"elemType\") && s.uint32(8).int32(n.elemType), n.shape != null && Object.hasOwnProperty.call(n, \"shape\") && h.onnx.TensorShapeProto.encode(n.shape, s.uint32(18).fork()).ldelim(), s;\n        }, t.encodeDelimited = function (n, s) {\n          return this.encode(n, s).ldelim();\n        }, t.decode = function (n, s) {\n          n instanceof $ || (n = $.create(n));\n          for (var a = s === void 0 ? n.len : n.pos + s, u = new h.onnx.TypeProto.SparseTensor(); n.pos < a;) {\n            var l = n.uint32();\n            switch (l >>> 3) {\n              case 1:\n                {\n                  u.elemType = n.int32();\n                  break;\n                }\n              case 2:\n                {\n                  u.shape = h.onnx.TensorShapeProto.decode(n, n.uint32());\n                  break;\n                }\n              default:\n                n.skipType(l & 7);\n                break;\n            }\n          }\n          return u;\n        }, t.decodeDelimited = function (n) {\n          return n instanceof $ || (n = new $(n)), this.decode(n, n.uint32());\n        }, t.verify = function (n) {\n          if (typeof n != \"object\" || n === null) return \"object expected\";\n          if (n.elemType != null && n.hasOwnProperty(\"elemType\") && !b.isInteger(n.elemType)) return \"elemType: integer expected\";\n          if (n.shape != null && n.hasOwnProperty(\"shape\")) {\n            var s = h.onnx.TensorShapeProto.verify(n.shape);\n            if (s) return \"shape.\" + s;\n          }\n          return null;\n        }, t.fromObject = function (n) {\n          if (n instanceof h.onnx.TypeProto.SparseTensor) return n;\n          var s = new h.onnx.TypeProto.SparseTensor();\n          if (n.elemType != null && (s.elemType = n.elemType | 0), n.shape != null) {\n            if (typeof n.shape != \"object\") throw TypeError(\".onnx.TypeProto.SparseTensor.shape: object expected\");\n            s.shape = h.onnx.TensorShapeProto.fromObject(n.shape);\n          }\n          return s;\n        }, t.toObject = function (n, s) {\n          s || (s = {});\n          var a = {};\n          return s.defaults && (a.elemType = 0, a.shape = null), n.elemType != null && n.hasOwnProperty(\"elemType\") && (a.elemType = n.elemType), n.shape != null && n.hasOwnProperty(\"shape\") && (a.shape = h.onnx.TensorShapeProto.toObject(n.shape, s)), a;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, nt.util.toJSONOptions);\n        }, t.getTypeUrl = function (n) {\n          return n === void 0 && (n = \"type.googleapis.com\"), n + \"/onnx.TypeProto.SparseTensor\";\n        }, t;\n      }(), e;\n    }(), i.OperatorSetIdProto = function () {\n      function e(o) {\n        if (o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.domain = \"\", e.prototype.version = b.Long ? b.Long.fromBits(0, 0, !1) : 0, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        return r || (r = pt.create()), t.domain != null && Object.hasOwnProperty.call(t, \"domain\") && r.uint32(10).string(t.domain), t.version != null && Object.hasOwnProperty.call(t, \"version\") && r.uint32(16).int64(t.version), r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.OperatorSetIdProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.domain = t.string();\n                break;\n              }\n            case 2:\n              {\n                s.version = t.int64();\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        return typeof t != \"object\" || t === null ? \"object expected\" : t.domain != null && t.hasOwnProperty(\"domain\") && !b.isString(t.domain) ? \"domain: string expected\" : t.version != null && t.hasOwnProperty(\"version\") && !b.isInteger(t.version) && !(t.version && b.isInteger(t.version.low) && b.isInteger(t.version.high)) ? \"version: integer|Long expected\" : null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.OperatorSetIdProto) return t;\n        var r = new h.onnx.OperatorSetIdProto();\n        return t.domain != null && (r.domain = String(t.domain)), t.version != null && (b.Long ? (r.version = b.Long.fromValue(t.version)).unsigned = !1 : typeof t.version == \"string\" ? r.version = parseInt(t.version, 10) : typeof t.version == \"number\" ? r.version = t.version : typeof t.version == \"object\" && (r.version = new b.LongBits(t.version.low >>> 0, t.version.high >>> 0).toNumber())), r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if (r.defaults) if (n.domain = \"\", b.Long) {\n          var s = new b.Long(0, 0, !1);\n          n.version = r.longs === String ? s.toString() : r.longs === Number ? s.toNumber() : s;\n        } else n.version = r.longs === String ? \"0\" : 0;\n        return t.domain != null && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), t.version != null && t.hasOwnProperty(\"version\") && (typeof t.version == \"number\" ? n.version = r.longs === String ? String(t.version) : t.version : n.version = r.longs === String ? b.Long.prototype.toString.call(t.version) : r.longs === Number ? new b.LongBits(t.version.low >>> 0, t.version.high >>> 0).toNumber() : t.version), n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.OperatorSetIdProto\";\n      }, e;\n    }(), i.OperatorStatus = function () {\n      var e = {},\n        o = Object.create(e);\n      return o[e[0] = \"EXPERIMENTAL\"] = 0, o[e[1] = \"STABLE\"] = 1, o;\n    }(), i.FunctionProto = function () {\n      function e(o) {\n        if (this.input = [], this.output = [], this.attribute = [], this.attributeProto = [], this.node = [], this.opsetImport = [], o) for (var t = Object.keys(o), r = 0; r < t.length; ++r) o[t[r]] != null && (this[t[r]] = o[t[r]]);\n      }\n      return e.prototype.name = \"\", e.prototype.input = b.emptyArray, e.prototype.output = b.emptyArray, e.prototype.attribute = b.emptyArray, e.prototype.attributeProto = b.emptyArray, e.prototype.node = b.emptyArray, e.prototype.docString = \"\", e.prototype.opsetImport = b.emptyArray, e.prototype.domain = \"\", e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (t, r) {\n        if (r || (r = pt.create()), t.name != null && Object.hasOwnProperty.call(t, \"name\") && r.uint32(10).string(t.name), t.input != null && t.input.length) for (var n = 0; n < t.input.length; ++n) r.uint32(34).string(t.input[n]);\n        if (t.output != null && t.output.length) for (var n = 0; n < t.output.length; ++n) r.uint32(42).string(t.output[n]);\n        if (t.attribute != null && t.attribute.length) for (var n = 0; n < t.attribute.length; ++n) r.uint32(50).string(t.attribute[n]);\n        if (t.node != null && t.node.length) for (var n = 0; n < t.node.length; ++n) h.onnx.NodeProto.encode(t.node[n], r.uint32(58).fork()).ldelim();\n        if (t.docString != null && Object.hasOwnProperty.call(t, \"docString\") && r.uint32(66).string(t.docString), t.opsetImport != null && t.opsetImport.length) for (var n = 0; n < t.opsetImport.length; ++n) h.onnx.OperatorSetIdProto.encode(t.opsetImport[n], r.uint32(74).fork()).ldelim();\n        if (t.domain != null && Object.hasOwnProperty.call(t, \"domain\") && r.uint32(82).string(t.domain), t.attributeProto != null && t.attributeProto.length) for (var n = 0; n < t.attributeProto.length; ++n) h.onnx.AttributeProto.encode(t.attributeProto[n], r.uint32(90).fork()).ldelim();\n        return r;\n      }, e.encodeDelimited = function (t, r) {\n        return this.encode(t, r).ldelim();\n      }, e.decode = function (t, r) {\n        t instanceof $ || (t = $.create(t));\n        for (var n = r === void 0 ? t.len : t.pos + r, s = new h.onnx.FunctionProto(); t.pos < n;) {\n          var a = t.uint32();\n          switch (a >>> 3) {\n            case 1:\n              {\n                s.name = t.string();\n                break;\n              }\n            case 4:\n              {\n                s.input && s.input.length || (s.input = []), s.input.push(t.string());\n                break;\n              }\n            case 5:\n              {\n                s.output && s.output.length || (s.output = []), s.output.push(t.string());\n                break;\n              }\n            case 6:\n              {\n                s.attribute && s.attribute.length || (s.attribute = []), s.attribute.push(t.string());\n                break;\n              }\n            case 11:\n              {\n                s.attributeProto && s.attributeProto.length || (s.attributeProto = []), s.attributeProto.push(h.onnx.AttributeProto.decode(t, t.uint32()));\n                break;\n              }\n            case 7:\n              {\n                s.node && s.node.length || (s.node = []), s.node.push(h.onnx.NodeProto.decode(t, t.uint32()));\n                break;\n              }\n            case 8:\n              {\n                s.docString = t.string();\n                break;\n              }\n            case 9:\n              {\n                s.opsetImport && s.opsetImport.length || (s.opsetImport = []), s.opsetImport.push(h.onnx.OperatorSetIdProto.decode(t, t.uint32()));\n                break;\n              }\n            case 10:\n              {\n                s.domain = t.string();\n                break;\n              }\n            default:\n              t.skipType(a & 7);\n              break;\n          }\n        }\n        return s;\n      }, e.decodeDelimited = function (t) {\n        return t instanceof $ || (t = new $(t)), this.decode(t, t.uint32());\n      }, e.verify = function (t) {\n        if (typeof t != \"object\" || t === null) return \"object expected\";\n        if (t.name != null && t.hasOwnProperty(\"name\") && !b.isString(t.name)) return \"name: string expected\";\n        if (t.input != null && t.hasOwnProperty(\"input\")) {\n          if (!Array.isArray(t.input)) return \"input: array expected\";\n          for (var r = 0; r < t.input.length; ++r) if (!b.isString(t.input[r])) return \"input: string[] expected\";\n        }\n        if (t.output != null && t.hasOwnProperty(\"output\")) {\n          if (!Array.isArray(t.output)) return \"output: array expected\";\n          for (var r = 0; r < t.output.length; ++r) if (!b.isString(t.output[r])) return \"output: string[] expected\";\n        }\n        if (t.attribute != null && t.hasOwnProperty(\"attribute\")) {\n          if (!Array.isArray(t.attribute)) return \"attribute: array expected\";\n          for (var r = 0; r < t.attribute.length; ++r) if (!b.isString(t.attribute[r])) return \"attribute: string[] expected\";\n        }\n        if (t.attributeProto != null && t.hasOwnProperty(\"attributeProto\")) {\n          if (!Array.isArray(t.attributeProto)) return \"attributeProto: array expected\";\n          for (var r = 0; r < t.attributeProto.length; ++r) {\n            var n = h.onnx.AttributeProto.verify(t.attributeProto[r]);\n            if (n) return \"attributeProto.\" + n;\n          }\n        }\n        if (t.node != null && t.hasOwnProperty(\"node\")) {\n          if (!Array.isArray(t.node)) return \"node: array expected\";\n          for (var r = 0; r < t.node.length; ++r) {\n            var n = h.onnx.NodeProto.verify(t.node[r]);\n            if (n) return \"node.\" + n;\n          }\n        }\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && !b.isString(t.docString)) return \"docString: string expected\";\n        if (t.opsetImport != null && t.hasOwnProperty(\"opsetImport\")) {\n          if (!Array.isArray(t.opsetImport)) return \"opsetImport: array expected\";\n          for (var r = 0; r < t.opsetImport.length; ++r) {\n            var n = h.onnx.OperatorSetIdProto.verify(t.opsetImport[r]);\n            if (n) return \"opsetImport.\" + n;\n          }\n        }\n        return t.domain != null && t.hasOwnProperty(\"domain\") && !b.isString(t.domain) ? \"domain: string expected\" : null;\n      }, e.fromObject = function (t) {\n        if (t instanceof h.onnx.FunctionProto) return t;\n        var r = new h.onnx.FunctionProto();\n        if (t.name != null && (r.name = String(t.name)), t.input) {\n          if (!Array.isArray(t.input)) throw TypeError(\".onnx.FunctionProto.input: array expected\");\n          r.input = [];\n          for (var n = 0; n < t.input.length; ++n) r.input[n] = String(t.input[n]);\n        }\n        if (t.output) {\n          if (!Array.isArray(t.output)) throw TypeError(\".onnx.FunctionProto.output: array expected\");\n          r.output = [];\n          for (var n = 0; n < t.output.length; ++n) r.output[n] = String(t.output[n]);\n        }\n        if (t.attribute) {\n          if (!Array.isArray(t.attribute)) throw TypeError(\".onnx.FunctionProto.attribute: array expected\");\n          r.attribute = [];\n          for (var n = 0; n < t.attribute.length; ++n) r.attribute[n] = String(t.attribute[n]);\n        }\n        if (t.attributeProto) {\n          if (!Array.isArray(t.attributeProto)) throw TypeError(\".onnx.FunctionProto.attributeProto: array expected\");\n          r.attributeProto = [];\n          for (var n = 0; n < t.attributeProto.length; ++n) {\n            if (typeof t.attributeProto[n] != \"object\") throw TypeError(\".onnx.FunctionProto.attributeProto: object expected\");\n            r.attributeProto[n] = h.onnx.AttributeProto.fromObject(t.attributeProto[n]);\n          }\n        }\n        if (t.node) {\n          if (!Array.isArray(t.node)) throw TypeError(\".onnx.FunctionProto.node: array expected\");\n          r.node = [];\n          for (var n = 0; n < t.node.length; ++n) {\n            if (typeof t.node[n] != \"object\") throw TypeError(\".onnx.FunctionProto.node: object expected\");\n            r.node[n] = h.onnx.NodeProto.fromObject(t.node[n]);\n          }\n        }\n        if (t.docString != null && (r.docString = String(t.docString)), t.opsetImport) {\n          if (!Array.isArray(t.opsetImport)) throw TypeError(\".onnx.FunctionProto.opsetImport: array expected\");\n          r.opsetImport = [];\n          for (var n = 0; n < t.opsetImport.length; ++n) {\n            if (typeof t.opsetImport[n] != \"object\") throw TypeError(\".onnx.FunctionProto.opsetImport: object expected\");\n            r.opsetImport[n] = h.onnx.OperatorSetIdProto.fromObject(t.opsetImport[n]);\n          }\n        }\n        return t.domain != null && (r.domain = String(t.domain)), r;\n      }, e.toObject = function (t, r) {\n        r || (r = {});\n        var n = {};\n        if ((r.arrays || r.defaults) && (n.input = [], n.output = [], n.attribute = [], n.node = [], n.opsetImport = [], n.attributeProto = []), r.defaults && (n.name = \"\", n.docString = \"\", n.domain = \"\"), t.name != null && t.hasOwnProperty(\"name\") && (n.name = t.name), t.input && t.input.length) {\n          n.input = [];\n          for (var s = 0; s < t.input.length; ++s) n.input[s] = t.input[s];\n        }\n        if (t.output && t.output.length) {\n          n.output = [];\n          for (var s = 0; s < t.output.length; ++s) n.output[s] = t.output[s];\n        }\n        if (t.attribute && t.attribute.length) {\n          n.attribute = [];\n          for (var s = 0; s < t.attribute.length; ++s) n.attribute[s] = t.attribute[s];\n        }\n        if (t.node && t.node.length) {\n          n.node = [];\n          for (var s = 0; s < t.node.length; ++s) n.node[s] = h.onnx.NodeProto.toObject(t.node[s], r);\n        }\n        if (t.docString != null && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.opsetImport && t.opsetImport.length) {\n          n.opsetImport = [];\n          for (var s = 0; s < t.opsetImport.length; ++s) n.opsetImport[s] = h.onnx.OperatorSetIdProto.toObject(t.opsetImport[s], r);\n        }\n        if (t.domain != null && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), t.attributeProto && t.attributeProto.length) {\n          n.attributeProto = [];\n          for (var s = 0; s < t.attributeProto.length; ++s) n.attributeProto[s] = h.onnx.AttributeProto.toObject(t.attributeProto[s], r);\n        }\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, nt.util.toJSONOptions);\n      }, e.getTypeUrl = function (t) {\n        return t === void 0 && (t = \"type.googleapis.com\"), t + \"/onnx.FunctionProto\";\n      }, e;\n    }(), i;\n  }();\n  zu.exports = h;\n});\nfunction ur(i, e) {\n  if (!i) throw new Error(typeof e == \"string\" ? e : e());\n}\nfunction kr(i) {\n  return new TextDecoder().decode(i);\n}\nvar ot,\n  Me,\n  ai,\n  kt,\n  Sn,\n  At,\n  Rt,\n  B,\n  $r,\n  Ue,\n  Ve,\n  ze,\n  Y = O(() => {\n    \"use strict\";\n\n    wn();\n    qo();\n    ot = rr(sr());\n    We();\n    Me = class {\n      static arraysEqual(e, o) {\n        if (e.length !== o.length) return !1;\n        for (let t = 0; t < e.length; t++) if (e[t] !== o[t]) return !1;\n        return !0;\n      }\n    }, ai = class {\n      static preprocessInputShapes(e, o) {\n        let t = e.length === 1 ? [1, e[0]] : e,\n          r = o.length === 1 ? [o[0], 1] : o;\n        return [t, r];\n      }\n      static postprocessOutputShape(e, o, t) {\n        o === 1 && e.splice(e.length - 2, 1), t === 1 && e.pop();\n      }\n      static calcMatMulShape(e, o) {\n        return e[1] !== o[0] ? void 0 : [e[0], o[1]];\n      }\n    }, kt = class i {\n      static calcShape(e, o, t = !1) {\n        let r = e.length,\n          n = o.length;\n        if (r === 0) return o;\n        if (n === 0) return e;\n        let s = Math.max(e.length, o.length),\n          a = new Array(s);\n        if (t) {\n          if (r < 2 || n < 2) return;\n          let u = ai.calcMatMulShape([e[r - 2], e[r - 1]], [o[n - 2], o[n - 1]]);\n          if (u === void 0) return;\n          [a[s - 2], a[s - 1]] = u;\n        }\n        for (let u = t ? 3 : 1; u <= s; u++) {\n          let l = r - u < 0 ? 1 : e[r - u],\n            f = n - u < 0 ? 1 : o[n - u];\n          if (l !== f && l > 1 && f > 1) return;\n          a[s - u] = Math.max(l, f);\n        }\n        return a;\n      }\n      static index(e, o) {\n        let t = new Array(o.length);\n        return i.fillIndex(e, o, t), t;\n      }\n      static fillIndex(e, o, t) {\n        let r = e.length - o.length;\n        for (let n = 0; n < o.length; n++) t[n] = e[r + n] % o[n];\n      }\n      static calc(e, o, t, r, n) {\n        let s = i.calcShape(e.dims, o.dims);\n        if (s) {\n          if (r && !B.areEqual(s, e.dims)) return;\n          let a = B.size(s),\n            u = r ? e : new bt(s, n || e.type);\n          if (s.length === 0) u.set([], t(e.get([]), o.get([])));else {\n            let l = new Array(s.length),\n              f = new Array(e.dims.length),\n              p = new Array(o.dims.length),\n              d = 0,\n              y = 0,\n              T = !1,\n              v = !1;\n            e.dims.length === 0 && (d = e.get([]), T = !0), o.dims.length === 0 && (y = o.get([]), v = !0);\n            let S;\n            for (let L = 0; L < a; L++) {\n              S = L;\n              for (let P = s.length - 1; P >= 0; P--) l[P] = S % s[P], S = Math.floor(S / s[P]);\n              T || (i.fillIndex(l, e.dims, f), d = e.get(f)), v || (i.fillIndex(l, o.dims, p), y = o.get(p)), u.set(l, t(d, y));\n            }\n          }\n          return u;\n        }\n      }\n      static isValidBroadcast(e, o) {\n        let t = e.length,\n          r = o.length;\n        if (t > r) return !1;\n        for (let n = 1; n <= t; n++) if (e[t - n] !== 1 && e[t - n] !== o[r - n]) return !1;\n        return !0;\n      }\n      static getBroadcastDims(e, o) {\n        let t = e.length,\n          r = [];\n        for (let n = 0; n < t; n++) {\n          let s = t - 1 - n,\n            a = e[s] || 1;\n          (o[o.length - 1 - n] || 1) > 1 && a === 1 && r.unshift(s);\n        }\n        return r;\n      }\n    }, Sn = class {\n      static getShapeOfGemmResult(e, o, t, r, n) {\n        if (e.length !== 2 || t.length !== 2) throw new Error(\"shape need to be of size 2\");\n        let s, a, u;\n        o ? (s = e[1], a = e[0]) : (s = e[0], a = e[1]);\n        let l = -1;\n        if (r ? (u = t[0], l = 1) : (u = t[1], l = 0), t[l] !== a) throw new Error(\"dimension mismatch\");\n        if (s <= 0 || u <= 0 || a <= 0) throw new Error(\"invalid shape specified\");\n        if (n && !kt.isValidBroadcast(n, [s, u])) throw new Error(\"gemm: invalid bias shape for broadcast\");\n        return [s, u, a];\n      }\n    }, At = class i {\n      static tensorDataTypeFromProto(e) {\n        switch (e) {\n          case ot.onnx.TensorProto.DataType.INT8:\n            return \"int8\";\n          case ot.onnx.TensorProto.DataType.UINT8:\n            return \"uint8\";\n          case ot.onnx.TensorProto.DataType.BOOL:\n            return \"bool\";\n          case ot.onnx.TensorProto.DataType.INT16:\n            return \"int16\";\n          case ot.onnx.TensorProto.DataType.UINT16:\n            return \"uint16\";\n          case ot.onnx.TensorProto.DataType.INT32:\n            return \"int32\";\n          case ot.onnx.TensorProto.DataType.UINT32:\n            return \"uint32\";\n          case ot.onnx.TensorProto.DataType.FLOAT:\n            return \"float32\";\n          case ot.onnx.TensorProto.DataType.DOUBLE:\n            return \"float64\";\n          case ot.onnx.TensorProto.DataType.STRING:\n            return \"string\";\n          case ot.onnx.TensorProto.DataType.INT64:\n            return \"int32\";\n          case ot.onnx.TensorProto.DataType.UINT64:\n            return \"uint32\";\n          default:\n            throw new Error(`unsupported data type: ${ot.onnx.TensorProto.DataType[e]}`);\n        }\n      }\n      static tensorDataTypeStringToEnum(e) {\n        switch (e) {\n          case \"int8\":\n            return ot.onnx.TensorProto.DataType.INT8;\n          case \"uint8\":\n            return ot.onnx.TensorProto.DataType.UINT8;\n          case \"bool\":\n            return ot.onnx.TensorProto.DataType.BOOL;\n          case \"int16\":\n            return ot.onnx.TensorProto.DataType.INT16;\n          case \"uint16\":\n            return ot.onnx.TensorProto.DataType.UINT16;\n          case \"int32\":\n            return ot.onnx.TensorProto.DataType.INT32;\n          case \"uint32\":\n            return ot.onnx.TensorProto.DataType.UINT32;\n          case \"float32\":\n            return ot.onnx.TensorProto.DataType.FLOAT;\n          case \"float64\":\n            return ot.onnx.TensorProto.DataType.DOUBLE;\n          case \"string\":\n            return ot.onnx.TensorProto.DataType.STRING;\n          case \"int64\":\n            return ot.onnx.TensorProto.DataType.INT64;\n          case \"uint64\":\n            return ot.onnx.TensorProto.DataType.UINT64;\n          default:\n            throw new Error(`unsupported data type: ${e}`);\n        }\n      }\n      static tensorDimsFromProto(e) {\n        return e.map(o => xe.isLong(o) ? o.toNumber() : o);\n      }\n      static tensorValueTypeFromProto(e) {\n        return {\n          tensorType: i.tensorDataTypeFromProto(e.elemType),\n          shape: {\n            dims: i.tensorDimsFromProto(e.shape.dim.map(o => o.dimValue))\n          }\n        };\n      }\n      static tensorDimsFromORTFormat(e) {\n        let o = [];\n        for (let t = 0; t < e.dimsLength(); t++) o.push(Rt.longToNumber(e.dims(t)));\n        return o;\n      }\n      static tensorAttributesFromORTFormat(e) {\n        let o = [];\n        for (let t = 0; t < e.attributesLength(); t++) o.push(e.attributes(t));\n        return o;\n      }\n    }, Rt = class {\n      static longToNumber(e, o) {\n        return xe.isLong(e) ? e.toNumber() : e instanceof w.Long ? xe.fromValue({\n          low: e.low,\n          high: e.high,\n          unsigned: o ?? !1\n        }).toNumber() : e;\n      }\n      static isLong(e) {\n        return xe.isLong(e) || e instanceof w.Long;\n      }\n    }, B = class i {\n      static size(e) {\n        return i.getSizeFromDimensionRange(e, 0, e.length);\n      }\n      static sizeFromDimension(e, o) {\n        if (o < 0 || o > e.length) throw new Error(`invalid dimension of ${o} for sizeFromDimension as Tensor has ${e.length} dimensions.`);\n        return i.getSizeFromDimensionRange(e, o, e.length);\n      }\n      static sizeToDimension(e, o) {\n        if (o < 0 || o > e.length) throw new Error(`invalid dimension of ${o} for sizeToDimension as Tensor has ${e.length} dimensions.`);\n        return i.getSizeFromDimensionRange(e, 0, o);\n      }\n      static getSizeFromDimensionRange(e, o, t) {\n        let r = 1;\n        for (let n = o; n < t; n++) {\n          if (e[n] <= 0) throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.\");\n          r *= e[n];\n        }\n        return r;\n      }\n      static computeStrides(e) {\n        let o = e.length;\n        if (o === 0) return [];\n        if (o === 1) return [1];\n        let t = new Array(o);\n        t[o - 1] = 1, t[o - 2] = e[o - 1];\n        for (let r = o - 3; r >= 0; --r) t[r] = t[r + 1] * e[r + 1];\n        return t;\n      }\n      static transpose(e) {\n        return e.slice().reverse();\n      }\n      static indicesToOffset(e, o, t) {\n        t === void 0 && (t = e.length);\n        let r = 0;\n        for (let n = 0; n < t; ++n) r += o[n] * e[n];\n        return r;\n      }\n      static offsetToIndices(e, o) {\n        let t = o.length;\n        if (t === 0) return [];\n        if (t === 1) return [e * o[0]];\n        let r = new Array(o.length);\n        for (let n = 0; n < r.length - 1; ++n) r[n] = Math.floor(e / o[n]), e -= r[n] * o[n];\n        return r[r.length - 1] = e, r;\n      }\n      static normalizeAxis(e, o) {\n        if (e < -o && e >= o) throw new Error(\"unsupported axis for this operation.\");\n        return e < 0 ? e + o : e;\n      }\n      static normalizeAxes(e, o) {\n        return e.map(t => this.normalizeAxis(t, o));\n      }\n      static incrementIndex(e, o, t) {\n        if (o.length === 0 || e.length === 0) throw new Error(\"Index incrementing unsupported for scalar Tensor\");\n        if (t === void 0) t = o.length;else if (t <= 0 || t > o.length) throw new Error(\"Incorrect axis to increment on\");\n        for (let r = t - 1; r >= 0 && (e[r]++, !(e[r] < o[r])); --r) e[r] = 0;\n      }\n      static calculateReshapedDims(e, o) {\n        if (o.length === 0) {\n          if (e.length === 0 || i.size(e) === 1) return [];\n          throw new Error(\"cannot reshape to a scalar Tensor\");\n        }\n        let t = o.length,\n          r = new Array(t),\n          n = -1,\n          s = 1;\n        for (let u = 0; u < t; u++) {\n          if (o[u] < -1) throw new Error(\"a dimension in shape hints cannot be less than -1\");\n          if (o[u] === -1) {\n            if (n !== -1) throw new Error(\"at most one dimension in shape hints can be -1\");\n            n = u;\n          } else {\n            if (o[u] === 0) {\n              if (u >= e.length) throw new Error(\"the dimension with value zero exceeds the dimension size of the input tensor\");\n              r[u] = e[u];\n            } else r[u] = o[u];\n            s *= r[u];\n          }\n        }\n        let a = i.size(e);\n        if (n !== -1) {\n          if (a % s !== 0) throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${o}]`);\n          r[n] = a / s;\n        } else if (s !== a) throw new Error(\"reshapedDims and originalDims don't have matching sizes\");\n        return r;\n      }\n      static sortBasedOnPerm(e, o) {\n        return o ? o.map(t => e[t]) : e.slice().reverse();\n      }\n      static padShape(e, o) {\n        let t = e.length;\n        return e.map((r, n) => r + o[n] + o[n + t]);\n      }\n      static areEqual(e, o) {\n        return e.length !== o.length ? !1 : e.every((t, r) => t === o[r]);\n      }\n      static validateDimsAndCalcSize(e) {\n        if (e.length > 6) throw new TypeError(\"Only rank 0 to 6 is supported for tensor shape.\");\n        let o = 1;\n        for (let t of e) {\n          if (!Number.isInteger(t)) throw new TypeError(`Invalid shape: ${t} is not an integer`);\n          if (t < 0 || t > 2147483647) throw new TypeError(`Invalid shape: length ${t} is not allowed`);\n          o *= t;\n        }\n        return o;\n      }\n      static flattenShape(e, o) {\n        o < 0 && (o += e.length);\n        let t = e.reduce((s, a) => s * a, 1),\n          r = e.slice(o).reduce((s, a) => s * a, 1);\n        return [t / r, r];\n      }\n      static squeezeShape(e, o) {\n        let t = new Array();\n        o = i.normalizeAxes(o, e.length);\n        for (let r = 0; r < e.length; r++) {\n          let n = o.indexOf(r) >= 0;\n          if (n && e[r] !== 1) throw new Error(\"squeeze an axis of size different than 1\");\n          (o.length === 0 && e[r] > 1 || o.length > 0 && !n) && t.push(e[r]);\n        }\n        return t;\n      }\n      static unsqueezeShape(e, o) {\n        let t = new Array(e.length + o.length);\n        t.fill(0);\n        for (let n = 0; n < o.length; n++) {\n          let s = i.normalizeAxis(o[n], t.length);\n          if (s >= t.length) throw new Error(\"'axes' has an out of range axis\");\n          if (t[s] !== 0) throw new Error(\"'axes' has a duplicate axis\");\n          t[s] = 1;\n        }\n        let r = 0;\n        for (let n = 0; n < t.length; n++) t[n] === 0 && (t[n] = e[r++]);\n        if (r !== e.length) throw new Error(\"the unsqueezed dimension could not be established\");\n        return t;\n      }\n    }, $r = class i {\n      static splitShape(e, o, t, r) {\n        if (t.length === 0) {\n          if (!r) throw new Error(\"need to know number of outputs when the 'split' attribute is not specified\");\n          i.determineSplit(e[o], r, t);\n        }\n        let n = [],\n          s = [0];\n        for (let a = 0; a < t.length; ++a) {\n          a !== 0 && s.push(s[a - 1] + t[a - 1]);\n          let u = e.slice();\n          u[o] = t[a], n.push(u);\n        }\n        return [n, s];\n      }\n      static determineSplit(e, o, t) {\n        if (e % o !== 0) throw new Error(\"cannot split tensor to equal sized parts\");\n        for (let r = 0; r < o; ++r) t.push(e / o);\n      }\n    }, Ue = class i {\n      static adjustPoolAttributes(e, o, t, r, n, s) {\n        if (!e && t.length !== o.length - 2) throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");\n        if (e) for (let a = 0; a < o.length - 2; a++) a >= t.length ? t.push(o[a + 2]) : t[a] = o[a + 2];\n        for (let a = 0; a < t.length; a++) if (a < r.length) {\n          if (r[a] < 0) throw new Error(\"strides should be greater than or equal to 1\");\n        } else r.push(1);\n        for (let a = 0; a < t.length; a++) if (a < n.length) {\n          if (n[a] < 0) throw new Error(\"dilations should be greater than or equal to 1\");\n        } else n.push(1);\n        for (let a = 0; a < t.length * 2; a++) if (a < s.length) {\n          if (s[a] < 0) throw new Error(\"pad should be greater than or equal to 1\");\n        } else s.push(0);\n        for (let a = 0; a < t.length; a++) {\n          if (t[a] <= 0) throw new Error(\"kernel shapes need to be greater than 0\");\n          if (s[a] >= t[a] || s[a + t.length] >= t[a]) throw new Error(\"pads should be smaller than kernel\");\n        }\n      }\n      static adjustPadsBasedOnAutoPad(e, o, t, r, n, s) {\n        if (s) {\n          if (n.length !== 2 * (e.length - 2)) throw new Error(\"length of pads should be twice the length of data dimensions\");\n          if (o.length !== e.length - 2) throw new Error(\"length of strides should be the length of data dimensions\");\n          if (r.length !== e.length - 2) throw new Error(\"length of kernel shapes should be the length of data dimensions\");\n          for (let a = 0; a < e.length - 2; a++) i.adjustPadAndReturnShape(e[a + 2], o[a], t[a], r[a], n, a, a + e.length - 2, s);\n        }\n      }\n      static computePoolOutputShape(e, o, t, r, n, s, a) {\n        if (o.length <= 0) throw new Error(\"input shape must be of size greater than 0\");\n        let u = [o[0], o[1]];\n        return i.computeShapeHelper(e, o, u, t, r, n, s, a), u;\n      }\n      static computeConvOutputShape(e, o, t, r, n, s, a) {\n        if (e.length <= 0 || o.length <= 0) throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");\n        let u = [e[0], o[0]];\n        return i.computeShapeHelper(!1, e, u, t, r, n, s, a), u;\n      }\n      static computeShapeHelper(e, o, t, r, n, s, a, u) {\n        if (e) for (let l = 0; l < o.length - 2; l++) t.push(1);else for (let l = 0; l < o.length - 2; l++) t.push(i.adjustPadAndReturnShape(o[l + 2], r[l], n[l], s[l], a, l, l + o.length - 2, u));\n      }\n      static adjustPadAndReturnShape(e, o, t, r, n, s, a, u) {\n        let l = t * (r - 1) + 1;\n        if (u && u !== \"NOTSET\") switch (u) {\n          case \"VALID\":\n            return n[s] = 0, n[a] = 0, Math.floor((e - l) / o + 1);\n          case \"SAME_LOWER\":\n          case \"SAME_UPPER\":\n            if (t !== 1) throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");\n            {\n              let p = ((e + o - 1) / o - 1) * o + r - e;\n              return n[s] = Math.floor(u === \"SAME_LOWER\" ? (p + 1) / 2 : p / 2), n[a] = p - n[s], Math.floor((e + p - r) / o + 1);\n            }\n          default:\n            throw new Error(\"Unsupported AutoPad type\");\n        } else return Math.floor((e + n[s] + n[a] - l) / o + 1);\n      }\n    }, Ve = -34028234663852886e22, ze = 34028234663852886e22;\n  });\nfunction hh(i) {\n  switch (i) {\n    case \"bool\":\n    case \"int8\":\n    case \"uint8\":\n      return 1;\n    case \"int16\":\n    case \"uint16\":\n      return 2;\n    case \"int32\":\n    case \"uint32\":\n    case \"float32\":\n      return 4;\n    case \"float64\":\n      return 8;\n    default:\n      throw new Error(`cannot calculate sizeof() on type ${i}`);\n  }\n}\nfunction Wu(i) {\n  switch (i) {\n    case H.onnx.TensorProto.DataType.UINT8:\n    case H.onnx.TensorProto.DataType.INT8:\n    case H.onnx.TensorProto.DataType.BOOL:\n      return 1;\n    case H.onnx.TensorProto.DataType.UINT16:\n    case H.onnx.TensorProto.DataType.INT16:\n      return 2;\n    case H.onnx.TensorProto.DataType.FLOAT:\n    case H.onnx.TensorProto.DataType.INT32:\n    case H.onnx.TensorProto.DataType.UINT32:\n      return 4;\n    case H.onnx.TensorProto.DataType.INT64:\n    case H.onnx.TensorProto.DataType.DOUBLE:\n    case H.onnx.TensorProto.DataType.UINT64:\n      return 8;\n    default:\n      throw new Error(`cannot calculate sizeof() on type ${H.onnx.TensorProto.DataType[i]}`);\n  }\n}\nfunction mh(i, e) {\n  return new (ju(e))(i);\n}\nfunction ju(i) {\n  switch (i) {\n    case \"bool\":\n    case \"uint8\":\n      return Uint8Array;\n    case \"int8\":\n      return Int8Array;\n    case \"int16\":\n      return Int16Array;\n    case \"uint16\":\n      return Uint16Array;\n    case \"int32\":\n      return Int32Array;\n    case \"uint32\":\n      return Uint32Array;\n    case \"int64\":\n      return BigInt64Array;\n    case \"float32\":\n      return Float32Array;\n    case \"float64\":\n      return Float64Array;\n    default:\n      throw new Error(\"unspecified error\");\n  }\n}\nfunction ui(i, e) {\n  if (e === H.onnx.TensorProto.DataType.INT64 || e === si.TensorDataType.INT64) {\n    if (i.greaterThanOrEqual(2147483648) || i.lessThan(-2147483648)) throw new TypeError(\"int64 is not supported\");\n  } else if (e === H.onnx.TensorProto.DataType.UINT32 || e === si.TensorDataType.UINT32 || e === H.onnx.TensorProto.DataType.UINT64 || e === si.TensorDataType.UINT64) {\n    if (i.greaterThanOrEqual(4294967296) || i.lessThan(0)) throw new TypeError(\"uint64 is not supported\");\n  } else throw new TypeError(`not a LONG type: ${H.onnx.TensorProto.DataType[e]}`);\n  return i.toNumber();\n}\nfunction Hu(i, e, o) {\n  switch (e) {\n    case H.onnx.TensorProto.DataType.BOOL:\n    case H.onnx.TensorProto.DataType.UINT8:\n      return i.getUint8(o);\n    case H.onnx.TensorProto.DataType.INT8:\n      return i.getInt8(o);\n    case H.onnx.TensorProto.DataType.UINT16:\n      return i.getUint16(o, !0);\n    case H.onnx.TensorProto.DataType.INT16:\n      return i.getInt16(o, !0);\n    case H.onnx.TensorProto.DataType.FLOAT:\n      return i.getFloat32(o, !0);\n    case H.onnx.TensorProto.DataType.INT32:\n      return i.getInt32(o, !0);\n    case H.onnx.TensorProto.DataType.UINT32:\n      return i.getUint32(o, !0);\n    case H.onnx.TensorProto.DataType.INT64:\n      return ui(xe.fromBits(i.getUint32(o, !0), i.getUint32(o + 4, !0), !1), e);\n    case H.onnx.TensorProto.DataType.DOUBLE:\n      return i.getFloat64(o, !0);\n    case H.onnx.TensorProto.DataType.UINT64:\n      return ui(xe.fromBits(i.getUint32(o, !0), i.getUint32(o + 4, !0), !0), e);\n    default:\n      throw new Error(`cannot read from DataView for type ${H.onnx.TensorProto.DataType[e]}`);\n  }\n}\nvar qu,\n  H,\n  si,\n  bt,\n  We = O(() => {\n    \"use strict\";\n\n    qu = rr(Fs());\n    qo();\n    Pr();\n    H = rr(sr());\n    Y();\n    si = F.experimental.fbs, bt = class i {\n      constructor(e, o, t, r, n, s = qu.Guid.create()) {\n        this.dims = e;\n        this.type = o;\n        this.dataProvider = t;\n        this.asyncDataProvider = r;\n        this.cache = n;\n        this.dataId = s;\n        this.size = B.validateDimsAndCalcSize(e);\n        let a = this.size,\n          u = t === void 0 && r === void 0 && n === void 0;\n        if (n !== void 0 && n.length !== a) throw new RangeError(\"Input dims doesn't match data length.\");\n        if (o === \"string\") {\n          if (n !== void 0 && (!Array.isArray(n) || !n.every(l => typeof l == \"string\"))) throw new TypeError(\"cache should be a string array\");\n          u && (this.cache = new Array(a));\n        } else {\n          if (n !== void 0) {\n            let l = ju(o);\n            if (!(n instanceof l)) throw new TypeError(`cache should be type ${l.name}`);\n          }\n          if (u) {\n            let l = new ArrayBuffer(a * hh(o));\n            this.cache = mh(l, o);\n          }\n        }\n      }\n      get data() {\n        if (this.cache === void 0) {\n          let e = this.dataProvider(this.dataId);\n          if (e.length !== this.size) throw new Error(\"Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.\");\n          this.cache = e;\n        }\n        return this.cache;\n      }\n      get stringData() {\n        if (this.type !== \"string\") throw new TypeError(\"data type is not string\");\n        return this.data;\n      }\n      get integerData() {\n        switch (this.type) {\n          case \"uint8\":\n          case \"int8\":\n          case \"uint16\":\n          case \"int16\":\n          case \"int32\":\n          case \"uint32\":\n          case \"bool\":\n            return this.data;\n          default:\n            throw new TypeError(\"data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)\");\n        }\n      }\n      get floatData() {\n        switch (this.type) {\n          case \"float32\":\n          case \"float64\":\n            return this.data;\n          default:\n            throw new TypeError(\"data type is not float (float32, float64)\");\n        }\n      }\n      get numberData() {\n        if (this.type !== \"string\") return this.data;\n        throw new TypeError(\"type cannot be non-number (string)\");\n      }\n      get(e) {\n        return this.data[B.indicesToOffset(e, this.strides)];\n      }\n      set(e, o) {\n        this.data[B.indicesToOffset(e, this.strides)] = o;\n      }\n      async getData() {\n        return this.cache === void 0 && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;\n      }\n      get strides() {\n        return this._strides || (this._strides = B.computeStrides(this.dims)), this._strides;\n      }\n      static fromProto(e) {\n        if (!e) throw new Error(\"cannot construct Value from an empty tensor\");\n        let o = At.tensorDataTypeFromProto(e.dataType),\n          t = At.tensorDimsFromProto(e.dims),\n          r = new i(t, o);\n        if (o === \"string\") e.stringData.forEach((n, s) => {\n          r.data[s] = kr(n);\n        });else if (e.rawData && typeof e.rawData.byteLength == \"number\" && e.rawData.byteLength > 0) {\n          let n = r.data,\n            s = new DataView(e.rawData.buffer, e.rawData.byteOffset, e.rawData.byteLength),\n            a = Wu(e.dataType),\n            u = e.rawData.byteLength / a;\n          if (e.rawData.byteLength % a !== 0) throw new Error(\"invalid buffer length\");\n          if (n.length !== u) throw new Error(\"buffer length mismatch\");\n          for (let l = 0; l < u; l++) {\n            let f = Hu(s, e.dataType, l * a);\n            n[l] = f;\n          }\n        } else {\n          let n;\n          switch (e.dataType) {\n            case H.onnx.TensorProto.DataType.FLOAT:\n              n = e.floatData;\n              break;\n            case H.onnx.TensorProto.DataType.INT32:\n            case H.onnx.TensorProto.DataType.INT16:\n            case H.onnx.TensorProto.DataType.UINT16:\n            case H.onnx.TensorProto.DataType.INT8:\n            case H.onnx.TensorProto.DataType.UINT8:\n            case H.onnx.TensorProto.DataType.BOOL:\n              n = e.int32Data;\n              break;\n            case H.onnx.TensorProto.DataType.INT64:\n              n = e.int64Data;\n              break;\n            case H.onnx.TensorProto.DataType.DOUBLE:\n              n = e.doubleData;\n              break;\n            case H.onnx.TensorProto.DataType.UINT32:\n            case H.onnx.TensorProto.DataType.UINT64:\n              n = e.uint64Data;\n              break;\n            default:\n              throw new Error(\"unspecific error\");\n          }\n          if (n == null) throw new Error(\"failed to populate data from a tensorproto value\");\n          let s = r.data;\n          if (s.length !== n.length) throw new Error(\"array length mismatch\");\n          for (let a = 0; a < n.length; a++) {\n            let u = n[a];\n            xe.isLong(u) ? s[a] = ui(u, e.dataType) : s[a] = u;\n          }\n        }\n        return r;\n      }\n      static fromData(e, o, t) {\n        return new i(o, t, void 0, void 0, e);\n      }\n      static fromOrtTensor(e) {\n        if (!e) throw new Error(\"cannot construct Value from an empty tensor\");\n        let o = At.tensorDimsFromORTFormat(e),\n          t = At.tensorDataTypeFromProto(e.dataType()),\n          r = new i(o, t);\n        if (t === \"string\") for (let n = 0; n < e.stringDataLength(); n++) r.data[n] = e.stringData(n);else if (e.rawDataArray() && typeof e.rawDataLength() == \"number\" && e.rawDataLength() > 0) {\n          let n = r.data,\n            s = new DataView(e.rawDataArray().buffer, e.rawDataArray().byteOffset, e.rawDataLength()),\n            a = Wu(e.dataType()),\n            u = e.rawDataLength() / a;\n          if (e.rawDataLength() % a !== 0) throw new Error(\"invalid buffer length\");\n          if (n.length !== u) throw new Error(\"buffer length mismatch\");\n          for (let l = 0; l < u; l++) {\n            let f = Hu(s, e.dataType(), l * a);\n            n[l] = f;\n          }\n        }\n        return r;\n      }\n    };\n  });\nfunction G(i) {\n  return i === 1 ? bh : gh;\n}\nfunction Xu(i) {\n  let e = G(i);\n  return `${e.version}\n      precision highp float;\n      ${e.attribute} vec3 position;\n      ${e.attribute} vec2 textureCoord;\n\n      ${e.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`;\n}\nfunction Ku(i) {\n  let e = G(i);\n  return `${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFrag} vec2 TexCoords;\n    ${e.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `;\n}\nfunction Ju(i, e) {\n  let o = G(i);\n  return `\n  void main() {\n    int indices[${e}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${o.output} = result;\n  }\n  `;\n}\nvar bh,\n  gh,\n  ut = O(() => {\n    \"use strict\";\n\n    bh = {\n      version: \"\",\n      attribute: \"attribute\",\n      varyingVertex: \"varying\",\n      varyingFrag: \"varying\",\n      texture2D: \"texture2D\",\n      output: \"gl_FragColor\",\n      outputDeclaration: \"\"\n    }, gh = {\n      version: \"#version 300 es\",\n      attribute: \"in\",\n      varyingVertex: \"out\",\n      varyingFrag: \"in\",\n      texture2D: \"texture\",\n      output: \"outputColor\",\n      outputDeclaration: \"out vec4 outputColor;\"\n    };\n  });\nvar j = O(() => {\n  \"use strict\";\n});\nasync function li(i, e = t => 0, o) {\n  return new Promise((t, r) => {\n    let n = 0,\n      s = () => {\n        if (i()) {\n          t();\n          return;\n        }\n        n++;\n        let a = e(n);\n        if (o != null && n >= o) {\n          r();\n          return;\n        }\n        setTimeout(s, a);\n      };\n    s();\n  });\n}\nfunction An(i) {\n  return ur(typeof i < \"u\" && i.length !== 0, () => \"empty string found for sampler name\"), \"get\" + i.charAt(0).toUpperCase() + i.slice(1);\n}\nfunction Yu(i) {\n  return ur(typeof i < \"u\" && i.length !== 0, () => \"empty string found for sampler name\"), \"get\" + i.charAt(0).toUpperCase() + i.slice(1) + \"AtOutCoords\";\n}\nfunction lr(i, e) {\n  let o = JSON.parse(JSON.stringify(i));\n  return o = e, o;\n}\nfunction fr(i, e) {\n  return e.map(o => i[o]).join(\", \");\n}\nfunction Bt(i) {\n  if (i <= 1) return \"int\";\n  if (i === 2) return \"ivec2\";\n  if (i === 3) return \"ivec3\";\n  if (i === 4) return \"ivec4\";\n  if (i === 5) return \"ivec5\";\n  if (i === 6) return \"ivec6\";\n  throw Error(`GPU for rank ${i} is not yet supported`);\n}\nfunction ne(i = 6) {\n  return [\"x\", \"y\", \"z\", \"w\", \"u\", \"v\"].slice(0, i);\n}\nvar pe = O(() => {\n  \"use strict\";\n\n  Y();\n});\nfunction yh(i, e) {\n  return ne(e).map(o => `${i}.${o}`);\n}\nfunction cr(i, e) {\n  return e === 1 ? [i] : yh(i, e);\n}\nfunction de() {\n  return `\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  `;\n}\nvar He = O(() => {\n  \"use strict\";\n\n  pe();\n});\nfunction Th(i, e, o) {\n  if (i === 0) return \"false\";\n  if (i === 1) return `rc > ${e[0]}`;\n  let t = \"\";\n  for (let r = i - 2; r < i; r++) t += `${o[r]} >= ${e[r - i + 2]}`, r < i - 1 && (t += \"||\");\n  return t;\n}\nfunction wh(i, e) {\n  let o = i.length;\n  if (o === 0) return \"getA(), 0, 0, 0\";\n  if (o === 1) return `getA(rc),\n            rc + 1 >= ${i[0]} ? 0. : getA(rc + 1),\n            0, 0`;\n  let t = \"r, c\",\n    r = \"r, cp1\",\n    n = \"rp1, c\",\n    s = \"rp1, cp1\",\n    a = \"\";\n  if (o > 2) for (let u = 0; u < o - 2; ++u) a = a + `${e[u]},`;\n  return `getA(${a}${t}),\n          rEdge ? 0. : getA(${a}${n}),\n          cEdge ? 0. : getA(${a}${r}),\n          rEdge || cEdge ? 0. : getA(${a}${s})`;\n}\nfunction vh(i, e, o, t) {\n  return i === 0 || i === 1 ? \"\" : `\n    int r = ${e[i - 2]};\n    int c = ${e[i - 1]};\n    int rp1 = ${e[i - 2]} + 1;\n    int cp1 = ${e[i - 1]} + 1;\n    bool rEdge = rp1 >= ${t};\n    bool cEdge = cp1 >= ${o};\n    `;\n}\nvar Zu,\n  xh,\n  Qu,\n  tl = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    pe();\n    He();\n    Zu = {\n      name: \"pack\",\n      inputNames: [\"A\"],\n      inputTypes: [1]\n    }, xh = (i, e) => {\n      let o = G(i.session.backend.glContext.version),\n        t = e.dims,\n        r = t.length,\n        n = e.dims.length,\n        s = Bt(n),\n        a = cr(\"rc\", n),\n        u = vh(n, a, t[t.length - 2], t[t.length - 1]),\n        l;\n      r === 0 ? l = [1, 1] : r === 1 ? l = [t[0], 1] : l = [t[n - 1], t[n - 2]];\n      let f = Th(n, l, a),\n        p = wh(t, a),\n        d = `\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${f}) {\n            ${o.output} = vec4(0);\n          } else {\n            ${u}\n\n            ${o.output} = vec4(${p});\n          }\n        }\n      `;\n      return {\n        ...Zu,\n        hasMain: !0,\n        output: {\n          dims: e.dims,\n          type: e.type,\n          textureType: 2\n        },\n        shaderSource: d\n      };\n    }, Qu = (i, e) => ({\n      ...Zu,\n      get: () => xh(i, e)\n    });\n  });\nfunction fi(i) {\n  if (i.length === 0) return [1, 1, 1];\n  let e = 1;\n  for (let o = 0; o < i.length - 2; ++o) e *= i[o];\n  return [e, i.length > 1 ? i[i.length - 2] : 1, i[i.length - 1]];\n}\nfunction rl(i, e) {\n  let o = !1;\n  return i.length === 0 || e.length === 0 ? o = !0 : i.length < 2 || e.length < 2 ? o = i[i.length - 1] === e[e.length - 1] : o = i[i.length - 1] === e[e.length - 1] && i[i.length - 2] === e[e.length - 2], o;\n}\nfunction Oh(i) {\n  let e = B.computeStrides(i),\n    o = [\"b\", \"r\", \"c\"],\n    t = \"index\";\n  return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${e.map((n, s) => {\n    let a = `int ${o[s]} = ${t} / ${n}`,\n      u = s === e.length - 1 ? `int ${o[s + 1]} = ${t} - ${o[s]} * ${n}` : `index -= ${o[s]} * ${n}`;\n    return `${a}; ${u};`;\n  }).join(\"\")}\n      return ivec3(b, r, c);\n    }\n  `;\n}\nfunction Sh(i) {\n  let e = B.computeStrides(i);\n  return `\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;\n  }\n`;\n}\nvar Ih,\n  _h,\n  el,\n  nl = O(() => {\n    \"use strict\";\n\n    Y();\n    ut();\n    j();\n    He();\n    Ih = i => ({\n      name: \"Reshape (packed)\",\n      inputTypes: [2],\n      inputNames: [\"A\"],\n      cacheHint: `${i}`\n    }), _h = (i, e, o, t) => {\n      let r = e.dims,\n        n = t,\n        s = \"\";\n      for (let l = 0; l < 4; l++) {\n        let f = \"\";\n        switch (l) {\n          case 0:\n            f = \"outputCoords = rc;\";\n            break;\n          case 1:\n            f = \"outputCoords = ivec3(rc.x, rc.y+1, rc.z);\";\n            break;\n          case 2:\n            f = \"outputCoords = ivec3(rc.x, rc.y, rc.z+1);\";\n            break;\n          case 3:\n            f = \"outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);\";\n            break;\n          default:\n            throw new Error();\n        }\n        s += `\n        ${f}\n        ${l > 0 ? \"if(outputCoords.y < rows && outputCoords.z < cols){\" : \"\"}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${l}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${l > 0 ? \"}\" : \"\"}\n      `;\n      }\n      let a = G(i.session.backend.glContext.version),\n        u = `\n      ${Oh(r)}\n      ${Sh(n)}\n      ${de()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${n[2]};\n        int cols = ${n[1]};\n\n        ${s}\n        ${a.output} = result;\n      }\n    `;\n      return {\n        ...o,\n        output: {\n          dims: n,\n          type: e.type,\n          textureType: 2\n        },\n        shaderSource: u,\n        hasMain: !0\n      };\n    }, el = (i, e, o) => {\n      let t = Ih(o);\n      return {\n        ...t,\n        get: () => _h(i, e, t, o)\n      };\n    };\n  });\nvar ci,\n  ol = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    ci = (i, e) => {\n      let o = e.shape,\n        t = G(i.session.backend.glContext.version),\n        r = `\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${t.texture2D}(X,TexCoords).r;\n      ${t.output} = encodeAsUint8(value);\n    }`,\n        n = {\n          name: \"Uint8Encode\",\n          inputTypes: [0],\n          inputNames: [\"X\"],\n          output: {\n            dims: o,\n            type: e.tensor.type,\n            textureType: 3\n          },\n          shaderSource: r,\n          hasMain: !0\n        };\n      return i.executeProgram(n, [e.tensor]);\n    };\n  });\nfunction Ph(i, e) {\n  if (i === 1) return \"rc\";\n  let o = \"\";\n  for (let t = 0; t < i; t++) o += e[t], t < i - 1 && (o += \",\");\n  return o;\n}\nvar il,\n  Ah,\n  al,\n  sl = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    pe();\n    He();\n    il = {\n      name: \"unpack\",\n      inputNames: [\"A\"],\n      inputTypes: [2]\n    }, Ah = (i, e) => {\n      let o = e.dims.length,\n        t = cr(\"rc\", o),\n        r = t.slice(-2),\n        n = Bt(o),\n        s = de(),\n        u = e.dims.length === 0 ? \"\" : Ph(o, t),\n        l = o <= 1 ? \"rc\" : `vec2(${r.join(\",\")})`,\n        f = G(i.session.backend.glContext.version),\n        p = `\n    ${s}\n    void main() {\n      ${n} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${u});\n\n       ${f.output} = vec4(getChannel(packedInput, ${l}), 0, 0, 0);\n     }\n   `;\n      return {\n        ...il,\n        hasMain: !0,\n        output: {\n          dims: e.dims,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: p\n      };\n    }, al = (i, e) => ({\n      ...il,\n      get: () => Ah(i, e)\n    });\n  });\nvar Pn,\n  Br,\n  En,\n  Fr = O(() => {\n    \"use strict\";\n\n    Ut();\n    Pn = class {\n      constructor(e, o = 1) {\n        if (o === 1) this.internalFormat = e.R32F, this.format = e.RED, this.textureType = e.FLOAT, this.channelSize = o;else if (o === 4) this.internalFormat = e.RGBA32F, this.format = e.RGBA, this.textureType = e.FLOAT, this.channelSize = o;else throw new Error(`Invalid number of channels: ${o}`);\n      }\n      encode(e, o) {\n        let t, r;\n        return e.constructor !== Float32Array && (tt.warning(\"Encoder\", \"data was not of type Float32; creating new Float32Array\"), r = new Float32Array(e)), o * this.channelSize > e.length ? (tt.warning(\"Encoder\", \"Source data too small. Allocating larger array\"), r = e, t = this.allocate(o * this.channelSize), r.forEach((n, s) => t[s] = n)) : (r = e, t = r), t;\n      }\n      allocate(e) {\n        return new Float32Array(e * 4);\n      }\n      decode(e, o) {\n        return this.channelSize === 1 ? e.filter((r, n) => n % 4 === 0).subarray(0, o) : e.subarray(0, o);\n      }\n    }, Br = class {\n      constructor(e, o = 1, t) {\n        if (o !== 1 && o !== 4) throw new Error(`Invalid number of channels: ${o}`);\n        this.internalFormat = e.RGBA, this.format = e.RGBA, this.channelSize = o, this.textureType = t || e.FLOAT;\n      }\n      encode(e, o) {\n        let t = e;\n        return this.channelSize === 1 && (tt.verbose(\"Encoder\", \"Exploding into a larger array\"), t = this.allocate(o), e.forEach((r, n) => t[n * 4] = r)), t;\n      }\n      allocate(e) {\n        return new Float32Array(e * 4);\n      }\n      decode(e, o) {\n        return this.channelSize === 1 ? e.filter((r, n) => n % 4 === 0).subarray(0, o) : e.subarray(0, o);\n      }\n    }, En = class {\n      constructor(e, o = 1) {\n        this.channelSize = 4;\n        if (o === 1) this.internalFormat = e.ALPHA, this.format = e.ALPHA, this.textureType = e.UNSIGNED_BYTE, this.channelSize = o;else if (o === 4) this.internalFormat = e.RGBA, this.format = e.RGBA, this.textureType = e.UNSIGNED_BYTE, this.channelSize = o;else throw new Error(`Invalid number of channels: ${o}`);\n      }\n      encode(e, o) {\n        return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);\n      }\n      allocate(e) {\n        return new Uint8Array(e * this.channelSize);\n      }\n      decode(e, o) {\n        if (e instanceof Uint8Array) return e.subarray(0, o);\n        throw new Error(`Invalid array type: ${e.constructor}`);\n      }\n    };\n  });\nvar Cr,\n  ul,\n  pi,\n  ll = O(() => {\n    \"use strict\";\n\n    Y();\n    j();\n    Cr = (i, e, o) => {\n      let t = o === 0 || o === 1 ? 1 : 4,\n        r = o === 2,\n        n = o === 1 || o === 2,\n        s = o === 4 ? e.length - 1 : void 0,\n        a = o === 4 ? e.map((u, l) => l === e.length - 1 ? u * 4 : u) : void 0;\n      return pi(i, e, t, a, {\n        isPacked: r,\n        reverseWH: n,\n        breakAxis: s\n      });\n    }, ul = (i, e, o) => {\n      let t = Cr(i, e, o);\n      return [t.width, t.height];\n    }, pi = (i, e, o = 1, t, r) => {\n      let n = !!(r && r.isPacked),\n        [s, a] = i.computeTextureWH(n && t || e, r),\n        u = e.length,\n        l = e.slice(0);\n      if (u === 0 && (l = [1]), o === 1) t = e;else if (n) {\n        if (o !== 4) throw new Error(\"a packed texture must be 4-channel\");\n        t = e, u > 0 && (l[u - 1] = Math.ceil(l[u - 1] / 2)), u > 1 && (l[u - 2] = Math.ceil(l[u - 2] / 2));\n      } else if (!t) throw new Error(\"Unpacked shape is needed when using channels > 1\");\n      return {\n        width: s,\n        height: a,\n        channels: o,\n        isPacked: n,\n        shape: l,\n        strides: B.computeStrides(l),\n        unpackedShape: t,\n        reversedWH: r && r.reverseWH\n      };\n    };\n  });\nvar Dh,\n  Dn,\n  cl = O(() => {\n    \"use strict\";\n\n    Ut();\n    We();\n    Y();\n    tl();\n    nl();\n    ol();\n    sl();\n    Fr();\n    ll();\n    j();\n    Dh = (i, e) => {\n      let o = e.map(r => `${r.unpackedShape.join(\",\")};${r.width}x${r.height}`).join(\"_\"),\n        t = i.name;\n      return i.cacheHint && (t += \"[\" + i.cacheHint + \"]\"), t += \":\" + o, t;\n    }, Dn = class {\n      constructor(e) {\n        this.session = e;\n        this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache = new Map();\n      }\n      calculateTextureWidthAndHeight(e, o) {\n        return ul(this.session.layoutStrategy, e, o);\n      }\n      executeProgram(e, o) {\n        if (o.length < e.inputNames.length) throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);\n        if (e.inputNames.length !== e.inputTypes.length) throw new Error(\"input names size does not match input types\");\n        let t = [];\n        for (let l = 0; l < e.inputNames.length; ++l) t[l] = this.getOrCreateTextureData(o[l], e.inputTypes[l]);\n        let r = Dh(e, t),\n          n = this.session.programManager.getArtifact(r),\n          s = n ? n.programInfo : typeof e.get == \"function\" ? e.get() : e,\n          a = Cr(this.session.layoutStrategy, s.output.dims, s.output.textureType),\n          u = this.createTextureData(a, s.output.type);\n        return n || (n = this.session.programManager.build(s, t, u), this.session.programManager.setArtifact(r, n)), this.runProgram(n, t, u), u;\n      }\n      run(e, o) {\n        return this.executeProgram(e, o).tensor;\n      }\n      runProgram(e, o, t) {\n        for (let r = 0; r < o.length; ++r) if (!!o[r].isPacked != (e.programInfo.inputTypes[r] === 2)) throw new Error(`input[${r}] property packed inconsistent`);\n        if (!!t.isPacked != (e.programInfo.output.textureType === 2)) throw new Error(\"output property packed inconsistent\");\n        this.session.programManager.run(e, o, t);\n      }\n      getOrCreateTextureData(e, o) {\n        let t = this.getTextureData(e.dataId, o === 2);\n        if (!t && (t = this.getTextureData(e.dataId, o !== 2), t)) return o === 2 ? this.pack(t) : this.unpack(t);\n        if (!t) {\n          let r = Cr(this.session.layoutStrategy, e.dims, o);\n          if (o === 4) {\n            let a = e.dims;\n            if (a.length === 4) {\n              let u = [a[0], Math.ceil(a[1] * a[2] * a[3] / 4)],\n                l = Cr(this.session.layoutStrategy, u, o),\n                f = e.numberData;\n              if (a[1] * a[2] * a[3] % 4 !== 0) {\n                let p = a[0],\n                  d = a[1] * a[2] * a[3],\n                  y = Math.ceil(d * 1 / 4) * 4,\n                  T = p * y;\n                f = new Float32Array(T);\n                for (let v = 0; v < p; ++v) {\n                  let S = v * d,\n                    L = v * y + v % 1 * d;\n                  f.set(e.numberData.subarray(S, S + d), L);\n                }\n              }\n              return this.createTextureData(l, e.type, f, e, 1);\n            }\n          }\n          if (o === 2) {\n            let n = pi(this.session.layoutStrategy, e.dims, 1, [], {\n                reverseWH: !0\n              }),\n              s = this.createTextureData(n, e.type, e.numberData, e, 1);\n            t = this.pack(s);\n          } else t = this.createTextureData(r, e.type, e.numberData, e, 1);\n        }\n        return t;\n      }\n      createTextureDataFromLayoutBindTensor(e, o, t, r) {\n        return this.createTextureData(e, o, t, r, 1);\n      }\n      createTextureData(e, o, t, r, n) {\n        tt.verbose(\"InferenceHandler\", `Creating TextureData: layout:[${JSON.stringify(e)}]`);\n        let s = this.session.textureManager.createTextureFromLayout(o, e, t, n);\n        return this.createTextureDataFromTexture(e, o, s, r);\n      }\n      reshapeUnpacked(e, o) {\n        let t = this.getOrCreateTextureData(e, 0),\n          r = {\n            channels: t.channels,\n            height: t.height,\n            width: t.width,\n            shape: o.length !== 0 ? o : [1],\n            strides: B.computeStrides(o),\n            unpackedShape: o\n          };\n        return this.createTextureDataFromTexture(r, e.type, t.texture).tensor;\n      }\n      reshapePacked(e, o) {\n        let t = this.getOrCreateTextureData(e, 2);\n        if (rl(e.dims, o)) {\n          let l = {\n            channels: t.channels,\n            height: t.height,\n            width: t.width,\n            shape: o.length !== 0 ? o : [1],\n            strides: B.computeStrides(o),\n            unpackedShape: o,\n            isPacked: !0\n          };\n          return this.createTextureDataFromTexture(l, e.type, t.texture).tensor;\n        }\n        let r = fi(e.dims),\n          n = fi(o),\n          s = this.reshapePacked(e, r),\n          a = this.run(el(this, s, n), [s]);\n        return this.reshapePacked(a, o);\n      }\n      cast(e, o) {\n        let t = this.getOrCreateTextureData(e, 0);\n        return this.createTextureDataFromTexture(t, o, t.texture).tensor;\n      }\n      createTextureDataFromTexture(e, o, t, r, n) {\n        let s = {\n          ...e,\n          tensor: r || new bt(e.unpackedShape, o, a => this.readTexture(s), async a => this.readTextureAsync(s), void 0, n),\n          texture: t\n        };\n        return this.setTextureData(s.tensor.dataId, s, e.isPacked), s;\n      }\n      getTextureData(e, o = !1) {\n        return this.session.isInitializer(e) ? this.session.getTextureData(e, o) : o ? this.packedTextureDataCache.get(e) : this.unpackedTextureDataCache.get(e);\n      }\n      setTextureData(e, o, t = !1) {\n        this.session.isInitializer(e) ? this.session.setTextureData(e, o, t) : (t ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(e, o);\n      }\n      isTextureLayoutCached(e, o = !1) {\n        return !!this.getTextureData(e.dataId, o);\n      }\n      dispose() {\n        this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach(e => this.session.textureManager.releaseTexture(e)), this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache.forEach(e => this.session.textureManager.releaseTexture(e)), this.unpackedTextureDataCache = new Map();\n      }\n      readTexture(e) {\n        return e.isPacked ? this.readTexture(this.unpack(e)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(e, e.tensor.type, e.channels) : this.session.textureManager.readUint8TextureAsFloat(ci(this, e));\n      }\n      async readTextureAsync(e) {\n        return e.isPacked ? this.readTextureAsync(this.unpack(e)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(e, e.tensor.type, e.channels) : this.session.textureManager.readUint8TextureAsFloat(ci(this, e));\n      }\n      pack(e) {\n        return this.executeProgram(Qu(this, e.tensor), [e.tensor]);\n      }\n      unpack(e) {\n        return this.executeProgram(al(this, e.tensor), [e.tensor]);\n      }\n    };\n  });\nvar di,\n  W,\n  It = O(() => {\n    \"use strict\";\n\n    di = class {\n      constructor(e) {\n        Object.assign(this, e);\n      }\n      get cacheKey() {\n        return this.key || (this.key = Object.getOwnPropertyNames(this).sort().map(e => `${this[e]}`).join(\";\")), this.key;\n      }\n    }, W = i => new di(i);\n  });\nvar pl,\n  dl,\n  hl,\n  Lh,\n  $h,\n  ml = O(() => {\n    \"use strict\";\n\n    It();\n    ut();\n    j();\n    pl = {\n      name: \"BatchNormalization\",\n      inputNames: [\"A\", \"Scale\", \"B\", \"Mean\", \"Variance\"],\n      inputTypes: [0, 0, 0, 0, 0]\n    }, dl = (i, e, o) => ($h(e), [i.run({\n      ...pl,\n      cacheHint: o.cacheKey,\n      get: () => Lh(i, e, o)\n    }, e)]), hl = i => {\n      let e = i.attributes.getFloat(\"epsilon\", 1e-5),\n        o = i.attributes.getFloat(\"momentum\", .9),\n        t = i.attributes.getInt(\"spatial\", 1);\n      return W({\n        epsilon: e,\n        momentum: o,\n        spatial: t\n      });\n    }, Lh = (i, e, o) => {\n      let t = G(i.session.backend.glContext.version),\n        r = e[0].dims.length,\n        [n, s] = i.calculateTextureWidthAndHeight(e[1].dims, 0),\n        a = `\n  float process(int[${r}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${n}, ${s});\n    float scale = getColorAsFloat(${t.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${t.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${t.texture2D}(Variance, position));\n    float b = getColorAsFloat(${t.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${o.epsilon})) ) + b;\n  }`;\n      return {\n        ...pl,\n        output: {\n          dims: e[0].dims,\n          type: e[0].type,\n          textureType: 0\n        },\n        shaderSource: a\n      };\n    }, $h = i => {\n      if (!i || i.length !== 5) throw new Error(\"BatchNormalization requires 5 inputs.\");\n      let e = i[0],\n        o = i[1],\n        t = i[2],\n        r = i[3],\n        n = i[4];\n      if (e.dims.length < 3 || o.dims.length !== 1 || t.dims.length !== 1 || r.dims.length !== 1 || n.dims.length !== 1) throw new Error(\"invalid input shape.\");\n      if (o.dims[0] !== e.dims[1] || t.dims[0] !== e.dims[1] || r.dims[0] !== e.dims[1] || n.dims[0] !== e.dims[1]) throw new Error(\"invalid input shape.\");\n      if (e.type !== \"float32\" && e.type !== \"float64\" || o.type !== \"float32\" && o.type !== \"float64\" || t.type !== \"float32\" && t.type !== \"float64\" || r.type !== \"float32\" && r.type !== \"float64\" || n.type !== \"float32\" && n.type !== \"float64\") throw new Error(\"invalid input tensor types.\");\n    };\n  });\nvar Ln,\n  Ht,\n  k,\n  Nr,\n  $n,\n  Te = O(() => {\n    \"use strict\";\n\n    Ln = class {\n      constructor(e, o, t, r) {\n        this.glContext = e;\n        this.programInfo = o;\n        this.inputTextureLayouts = t;\n        this.outputTextureLayout = r;\n      }\n    }, Ht = class {\n      constructor(e) {\n        this.context = e;\n      }\n    }, k = class {\n      constructor(e, o) {\n        this.routineBody = e;\n        this.dependencies = o;\n      }\n    }, Nr = class {\n      constructor(e, o, t) {\n        this.name = e;\n        t ? this.dependencies = t : this.dependencies = [], o && (this.routineBody = o);\n      }\n      addDependency(e) {\n        e && this.dependencies.push(e);\n      }\n    }, $n = class {\n      static returnOrderedNodes(e) {\n        if (!e || e.length === 0) return [];\n        if (e.length === 1) return e;\n        let o = new Set(),\n          t = new Set(),\n          r = new Array();\n        return this.createOrderedNodes(e, o, t, r), r;\n      }\n      static createOrderedNodes(e, o, t, r) {\n        for (let n = 0; n < e.length; ++n) this.dfsTraverse(e[n], o, t, r);\n      }\n      static dfsTraverse(e, o, t, r) {\n        if (!e || t.has(e.name)) return;\n        if (o.has(e.name)) throw new Error(\"Cyclic dependency detected. Can't topologically sort routines needed for shader.\");\n        o.add(e.name);\n        let n = e.dependencies;\n        if (n && n.length > 0) for (let s = 0; s < n.length; ++s) this.dfsTraverse(n[s], o, t, r);\n        r.push(e), t.add(e.name), o.delete(e.name);\n      }\n    };\n  });\nfunction Bh() {\n  let i = \"add_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Fh() {\n  let i = \"div_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Ch() {\n  let i = \"mul_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Nh() {\n  let i = \"sub_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Rh() {\n  let i = \"equal_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Gh() {\n  let i = \"greater_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Mh() {\n  let i = \"less_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Uh() {\n  let i = \"and_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Vh() {\n  let i = \"or_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction zh() {\n  let i = \"xor_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Wh() {\n  return qh(\"pow\");\n}\nfunction Hh() {\n  let i = \"prelu_\";\n  return {\n    body: `\n  float ${i}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${i}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction qh(i) {\n  let e = `${i}_`;\n  return {\n    body: `\n  float ${e}(float a, float b) {\n    return ${i}(a, b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return ${i}(v1, v2);\n  }\n  `,\n    name: e,\n    type: 0\n  };\n}\nvar qt,\n  jh,\n  bl,\n  gl,\n  yl,\n  xl,\n  Tl,\n  wl,\n  vl,\n  Il,\n  _l,\n  Ol,\n  Sl,\n  Al,\n  Pl = O(() => {\n    \"use strict\";\n\n    Y();\n    Te();\n    ut();\n    j();\n    qt = (i, e, o, t = e[0].type, r) => {\n      let n = i.session.pack ? 2 : 0;\n      return {\n        name: o.name,\n        inputNames: [\"A\", \"B\"],\n        inputTypes: [n, n],\n        cacheHint: r,\n        get: () => jh(i, e, o, t)\n      };\n    }, jh = (i, e, o, t = e[0].type) => {\n      let r = i.session.pack ? 2 : 0,\n        n = !B.areEqual(e[0].dims, e[1].dims),\n        s = e[0].dims,\n        a = i.session.pack;\n      if (n) {\n        let f = kt.calcShape(e[0].dims, e[1].dims, !1);\n        if (!f) throw new Error(\"Can't perform binary op on the given tensors\");\n        s = f;\n        let p = s.length,\n          d = e[0].dims.length !== 0 ? e[0].dims.length : 1,\n          y = e[1].dims.length !== 0 ? e[1].dims.length : 1,\n          T = e[0].dims.length !== 0 ? \"bcastIndices_A(indices, aindices);\" : \"aindices[0] = 0;\",\n          v = e[1].dims.length !== 0 ? \"bcastIndices_B(indices, bindices);\" : \"bindices[0] = 0;\",\n          S = G(i.session.backend.glContext.version),\n          L = a ? `\n      ${o.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${o.name}(a, b);\n        ${S.output} = result;\n      }` : `\n      ${o.body}\n      float process(int indices[${p}]) {\n        int aindices[${d}];\n        int bindices[${y}];\n        ${T}\n        ${v}\n        return ${o.name}(_A(aindices), _B(bindices));\n      }`;\n        return {\n          name: o.name,\n          inputNames: [\"A\", \"B\"],\n          inputTypes: [r, r],\n          output: {\n            dims: s,\n            type: t,\n            textureType: r\n          },\n          shaderSource: L,\n          hasMain: a\n        };\n      }\n      let u = G(i.session.backend.glContext.version),\n        l = `\n    ${o.body}\n    void main() {\n      vec4 v1 = ${u.texture2D}(A, TexCoords);\n      vec4 v2 = ${u.texture2D}(B, TexCoords);\n      vec4 result = ${o.name}(v1, v2);\n      ${u.output} = result;\n    }\n    `;\n      return {\n        name: o.name,\n        inputNames: [\"A\", \"B\"],\n        inputTypes: [r, r],\n        output: {\n          dims: e[0].dims,\n          type: t,\n          textureType: r\n        },\n        shaderSource: l,\n        hasMain: !0\n      };\n    }, bl = (i, e) => [i.run(qt(i, e, Bh()), e)], gl = (i, e) => [i.run(qt(i, e, Uh(), \"bool\"), e)], yl = (i, e) => [i.run(qt(i, e, Fh()), e)], xl = (i, e) => [i.run(qt(i, e, Rh(), \"bool\"), e)], Tl = (i, e) => [i.run(qt(i, e, Gh(), \"bool\"), e)], wl = (i, e) => [i.run(qt(i, e, Mh(), \"bool\"), e)], vl = (i, e) => [i.run(qt(i, e, Ch()), e)], Il = (i, e) => [i.run(qt(i, e, Vh(), \"bool\"), e)], _l = (i, e) => [i.run(qt(i, e, Wh()), e)], Ol = (i, e) => [i.run(qt(i, e, Hh()), e)], Sl = (i, e) => [i.run(qt(i, e, Nh()), e)], Al = (i, e) => [i.run(qt(i, e, zh(), \"bool\"), e)];\n  });\nvar El,\n  Dl,\n  Kh,\n  Ll = O(() => {\n    \"use strict\";\n\n    Y();\n    El = (i, e, o) => (Kh(e), [i.cast(e[0], o)]), Dl = i => At.tensorDataTypeFromProto(i.attributes.getInt(\"to\")), Kh = i => {\n      if (!i || i.length !== 1) throw new Error(\"Cast requires 1 input.\");\n      if (i[0].type === \"string\") throw new Error(\"Invalid input type.\");\n    };\n  });\nvar Jh,\n  Yh,\n  $l,\n  kn,\n  kl = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    pe();\n    He();\n    Jh = (i, e) => ({\n      name: \"Concat (packed)\",\n      inputNames: Array.from({\n        length: i\n      }, (o, t) => `X${t}`),\n      inputTypes: Array(i).fill(2),\n      cacheHint: e\n    }), Yh = (i, e, o, t) => {\n      let r = o[0].dims.slice();\n      if (t >= r.length || t < -1 * r.length) throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n      t < 0 && (t = r.length + t);\n      let n = r.slice(0);\n      for (let V = 1; V < o.length; V++) {\n        let lt = o[V].dims.slice();\n        for (let wt = 0; wt < r.length; wt++) if (wt === t) n[t] += lt[wt];else if (r[wt] !== lt[wt]) throw new Error(\"non concat dimensions must match\");\n      }\n      let s = n.length,\n        a = cr(\"coords\", s),\n        u = Bt(s),\n        l = de(),\n        f = o.map(V => V.dims),\n        p = ne(s),\n        d = new Array(f.length - 1);\n      d[0] = f[0][t];\n      for (let V = 1; V < d.length; V++) d[V] = d[V - 1] + f[V][t];\n      let y = p[t],\n        T = p.slice(-2),\n        v = p.join(),\n        S = `if (${y} < ${d[0]}) {\n        return getChannel(\n            getX0(${v}), vec2(${T.join()}));\n        }`;\n      for (let V = 1; V < d.length; V++) {\n        let lt = d[V - 1];\n        S += `\n            if (${y} < ${d[V]}  && ${y} >= ${d[V - 1]}) {\n              return getChannel(\n                getX${V}(${kn(p, y, lt)}),\n                vec2(${kn(T, y, lt)}));\n            }`;\n      }\n      let L = d.length,\n        P = d[d.length - 1];\n      S += `\n            return getChannel(\n              getX${L}(${kn(p, y, P)}),\n              vec2(${kn(T, y, P)}));`;\n      let A = G(i.session.backend.glContext.version),\n        M = `\n          ${l}\n          float getValue(${p.map(V => \"int \" + V)}) {\n            ${S}\n          }\n\n          void main() {\n            ${u} coords = getOutputCoords();\n            int lastDim = coords.${p[s - 1]};\n            coords.${p[s - 1]} = coords.${p[s - 2]};\n            coords.${p[s - 2]} = lastDim;\n\n            vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n            ${a[s - 1]} = ${a[s - 1]} + 1;\n            if (${a[s - 1]} < ${n[s - 1]}) {\n              result.g = getValue(${a});\n            }\n\n            ${a[s - 2]} = ${a[s - 2]} + 1;\n            if (${a[s - 2]} < ${n[s - 2]}) {\n              result.a = getValue(${a});\n            }\n\n            ${a[s - 1]} = ${a[s - 1]} - 1;\n            if (${a[s - 2]} < ${n[s - 2]} &&\n                ${a[s - 1]} < ${n[s - 1]}) {\n              result.b = getValue(${a});\n            }\n            ${A.output} = result;\n          }\n        `;\n      return {\n        ...e,\n        output: {\n          dims: n,\n          type: o[0].type,\n          textureType: 2\n        },\n        shaderSource: M,\n        hasMain: !0\n      };\n    }, $l = (i, e, o) => {\n      let t = Jh(e.length, o.cacheKey);\n      return {\n        ...t,\n        get: () => Yh(i, t, e, o.axis)\n      };\n    }, kn = (i, e, o) => {\n      let t = i.indexOf(e);\n      return i.map((n, s) => s === t ? `${n} - ${o}` : n).join();\n    };\n  });\nvar Bl,\n  Zh,\n  Qh,\n  tm,\n  Fl,\n  em,\n  rm,\n  nm,\n  Cl,\n  om,\n  Nl = O(() => {\n    \"use strict\";\n\n    It();\n    j();\n    kl();\n    Bl = (i, e, o) => (om(e), i.session.pack && e[0].dims.length > 1 ? [i.run($l(i, e, o), e)] : [i.run(tm(i, e, o), e)]), Zh = (i, e) => ({\n      name: \"Concat\",\n      inputNames: Array.from({\n        length: i\n      }, (o, t) => `X${t}`),\n      inputTypes: Array(i).fill(0),\n      cacheHint: e\n    }), Qh = (i, e, o, t) => {\n      let r = o[0].dims.slice();\n      if (t >= r.length || t < -1 * r.length) throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n      t < 0 && (t = r.length + t);\n      let n = r.slice(0);\n      for (let y = 1; y < o.length; y++) {\n        let T = o[y].dims.slice();\n        for (let v = 0; v < r.length; v++) if (v === t) n[t] += T[v];else if (r[v] !== T[v]) throw new Error(\"non concat dimensions must match\");\n      }\n      let s = n.length,\n        a = new Array(o.length),\n        u = 0;\n      for (let y = 0; y < a.length; ++y) u += o[y].dims[t], a[y] = u;\n      let l = \"\";\n      o.length < 5 ? l = Fl(a) : l = em(a);\n      let f = rm(o.length, s),\n        p = nm(a),\n        d = `\n        ${f}\n        ${p}\n        ${l}\n        float process(int indices[${s}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${t}]);\n\n          if(textureIndex != 0) {\n            indices[${t}] = indices[${t}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;\n      return {\n        ...e,\n        output: {\n          dims: n,\n          type: o[0].type,\n          textureType: 0\n        },\n        shaderSource: d\n      };\n    }, tm = (i, e, o) => {\n      let t = Zh(e.length, o.cacheKey);\n      return {\n        ...t,\n        get: () => Qh(i, t, e, o.axis)\n      };\n    }, Fl = i => `int getTextureWhereDataResides(int index) {\n      ${i.map((o, t) => `if(index<${o}) {return ${t};}\n`).join(\"\")}\n    }`, em = i => Fl(i), rm = (i, e) => {\n      let o = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];\n      for (let t = 0; t < i; ++t) t === 0 ? o.push(`\tif (textureIndex == ${t}) { return _X${t}(indices); }`) : t === i - 1 ? o.push(`\telse { return _X${t}(indices); }`) : o.push(`\telse if (textureIndex == ${t}) { return _X${t}(indices); }`);\n      return o.push(\"\t}\"), o.join(`\n`);\n    }, nm = i => {\n      let e = [\"int getSizeInConcatAxisValueFromIndex(int index) {\"];\n      for (let o = 0; o < i.length; ++o) o === 0 ? e.push(`\tif (index == ${o}) { return ${i[o]}; }`) : o === i.length - 1 ? e.push(`\telse { return ${i[o]}; }`) : e.push(`\telse if (index == ${o}) { return ${i[o]}; }`);\n      return e.push(\"\t}\"), e.join(`\n`);\n    }, Cl = i => W({\n      axis: i.attributes.getInt(\"axis\")\n    }), om = i => {\n      if (!i || i.length < 1) throw new Error(\"too few inputs\");\n      let e = i[0].type,\n        o = i[0].dims.length;\n      if (e === \"string\") throw new Error(\"string tensor is not supported yet\");\n      for (let t of i) {\n        if (t.type !== e) throw new Error(\"input tensors should be one type\");\n        if (t.dims.length !== o) throw new Error(\"input tensors should have the same shape\");\n      }\n    };\n  });\nfunction im() {\n  return jt(\"abs\");\n}\nfunction am() {\n  return jt(\"acos\");\n}\nfunction sm() {\n  return jt(\"asin\");\n}\nfunction um() {\n  return jt(\"atan\");\n}\nfunction lm() {\n  return jt(\"ceil\");\n}\nfunction fm() {\n  return jt(\"cos\");\n}\nfunction cm(i) {\n  let e = \"elu\";\n  return {\n    body: `\n  const float alpha = float(${i});\n\n  float ${e}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\n  }\n  `,\n    name: e,\n    type: 0\n  };\n}\nfunction pm() {\n  return jt(\"exp\");\n}\nfunction dm() {\n  return jt(\"floor\");\n}\nfunction hi(i, e) {\n  let o = \"clip\";\n  return {\n    body: `\n  const float min = float(${i});\n  const float max = float(${e});\n\n  float ${o}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${o}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,\n    name: o,\n    type: 0\n  };\n}\nfunction hm() {\n  let i = \"indentity\";\n  return {\n    body: `\n  float ${i}_(float a) {\n    return a;\n  }\n  vec4 ${i}_(vec4 v) {\n    return v;\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction mm(i) {\n  let e = \"leakyRelu\";\n  return {\n    body: `\n  const float alpha = float(${i});\n\n  float ${e}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\n  }\n  `,\n    name: e,\n    type: 0\n  };\n}\nfunction bm() {\n  return jt(\"log\");\n}\nfunction gm() {\n  let i = \"neg\";\n  return {\n    body: `\n  float ${i}_(float a) {\n    return -a;\n  }\n  vec4 ${i}_(vec4 v) {\n    return -v;\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction ym() {\n  let i = \"not\";\n  return {\n    body: `\n  float ${i}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${i}_(bool a) {\n    return !a;\n  }\n  vec4 ${i}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${i}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction xm() {\n  return jt(\"sin\");\n}\nfunction mi() {\n  let i = \"relu\";\n  return {\n    body: `\n  float ${i}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${i}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction bi() {\n  let i = \"sigmoid\";\n  return {\n    body: `\n  float ${i}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${i}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction Tm() {\n  return jt(\"sqrt\");\n}\nfunction wm() {\n  return jt(\"tan\");\n}\nfunction vm() {\n  let i = \"tanh\";\n  return {\n    body: `\n  float ${i}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${i}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nfunction jt(i) {\n  return {\n    body: `\n  float ${i}_(float a) {\n    return ${i}(a);\n  }\n  vec4 ${i}_(vec4 v) {\n    return ${i}(v);\n  }\n  `,\n    name: i,\n    type: 0\n  };\n}\nvar Im,\n  dt,\n  Rl,\n  Gl,\n  Ml,\n  Ul,\n  gi,\n  Vl,\n  zl,\n  _m,\n  Wl,\n  Hl,\n  ql,\n  jl,\n  Xl,\n  Kl,\n  yi,\n  Jl,\n  Yl,\n  Zl,\n  Ql,\n  tf,\n  ef,\n  rf,\n  nf,\n  of,\n  af,\n  sf,\n  xi = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    Te();\n    ut();\n    j();\n    Im = (i, e, o, t) => {\n      let r = i.session.pack ? 2 : 0,\n        n = G(i.session.backend.glContext.version);\n      return {\n        ...e,\n        output: {\n          dims: o.dims,\n          type: o.type,\n          textureType: r\n        },\n        shaderSource: `\n     ${t.body}\n     void main() {\n       vec4 v = ${n.texture2D}(A, TexCoords);\n       v = ${t.name}_(v);\n       ${n.output} = v;\n     }\n     `,\n        hasMain: !0\n      };\n    }, dt = (i, e, o, t) => {\n      let r = i.session.pack ? 2 : 0,\n        n = {\n          name: o.name,\n          inputTypes: [r],\n          inputNames: [\"A\"],\n          cacheHint: t\n        };\n      return {\n        ...n,\n        get: () => Im(i, n, e, o)\n      };\n    }, Rl = (i, e) => [i.run(dt(i, e[0], im()), e)], Gl = (i, e) => [i.run(dt(i, e[0], am()), e)], Ml = (i, e) => [i.run(dt(i, e[0], sm()), e)], Ul = (i, e) => [i.run(dt(i, e[0], um()), e)], gi = (i, e, o) => [i.run(dt(i, e[0], hi(o.min, o.max), o.cacheKey), e)], Vl = i => W({\n      min: i.attributes.getFloat(\"min\", Ve),\n      max: i.attributes.getFloat(\"max\", ze)\n    }), zl = (i, e) => {\n      let o = _m(i, e);\n      return gi(i, [e[0]], o);\n    }, _m = (i, e) => {\n      if (e.length >= 3 && (!i.session.isInitializer(e[1].dataId) || !i.session.isInitializer(e[2].dataId))) throw new Error(\"dynamic clip attributes are not allowed\");\n      let o = e.length >= 3 ? e[1].numberData[0] : Ve,\n        t = e.length >= 3 ? e[2].numberData[0] : ze;\n      return W({\n        min: o,\n        max: t\n      });\n    }, Wl = (i, e) => [i.run(dt(i, e[0], lm()), e)], Hl = (i, e) => [i.run(dt(i, e[0], fm()), e)], ql = (i, e, o) => [i.run(dt(i, e[0], cm(o.alpha), o.cacheKey), e)], jl = i => W({\n      alpha: i.attributes.getFloat(\"alpha\", 1)\n    }), Xl = (i, e) => [i.run(dt(i, e[0], pm()), e)], Kl = (i, e) => [i.run(dt(i, e[0], dm()), e)], yi = (i, e) => [i.run(dt(i, e[0], hm()), e)], Jl = (i, e, o) => [i.run(dt(i, e[0], mm(o.alpha), o.cacheKey), e)], Yl = i => W({\n      alpha: i.attributes.getFloat(\"alpha\", .01)\n    }), Zl = (i, e) => [i.run(dt(i, e[0], bm()), e)], Ql = (i, e) => [i.run(dt(i, e[0], gm()), e)], tf = (i, e) => [i.run(dt(i, e[0], ym()), e)], ef = (i, e) => [i.run(dt(i, e[0], mi()), e)], rf = (i, e) => [i.run(dt(i, e[0], bi()), e)], nf = (i, e) => [i.run(dt(i, e[0], xm()), e)], of = (i, e) => [i.run(dt(i, e[0], Tm()), e)], af = (i, e) => [i.run(dt(i, e[0], wm()), e)], sf = (i, e) => [i.run(dt(i, e[0], vm()), e)];\n  });\nfunction he(i) {\n  let e;\n  switch (i.activation) {\n    case \"Relu\":\n      e = mi();\n      break;\n    case \"Sigmoid\":\n      e = bi();\n      break;\n    case \"Clip\":\n      e = hi(i.clipMin, i.clipMax);\n      break;\n    default:\n      return {\n        activationFunction: \"\",\n        applyActivation: \"\"\n      };\n  }\n  let o = e.name,\n    t = e.body,\n    r = `value = ${o}_(value);`;\n  return {\n    activationFunction: t,\n    applyActivation: r\n  };\n}\nvar pr,\n  qe = O(() => {\n    \"use strict\";\n\n    Y();\n    xi();\n    pr = i => {\n      let e = i.getString(\"activation\", \"\");\n      if (e === \"Clip\") {\n        let [o, t] = i.getFloats(\"activation_params\", [Ve, ze]);\n        return {\n          activation: e,\n          clipMax: t,\n          clipMin: o,\n          activationCacheKey: `${e}:${o},${t}`\n        };\n      }\n      return {\n        activation: e,\n        activationCacheKey: e\n      };\n    };\n  });\nvar Sm,\n  Am,\n  uf,\n  lf = O(() => {\n    \"use strict\";\n\n    Ut();\n    ut();\n    j();\n    Bn();\n    qe();\n    Sm = (i, e) => ({\n      name: \"GroupedConv\",\n      inputNames: i ? [\"X\", \"W\", \"Bias\"] : [\"X\", \"W\"],\n      inputTypes: i ? [0, 0, 0] : [0, 0],\n      cacheHint: e\n    }), Am = (i, e, o, t) => {\n      let n = e.length > 2 ? \"value += getBias(output_channel);\" : \"\",\n        s = e[0].dims.slice(),\n        a = e[1].dims.slice(),\n        u = a[0] / t.group;\n      tt.verbose(\"GroupedConv\", `autpPad:${t.autoPad}, dilations:${t.dilations}, group:${t.group}, kernelShape:${t.kernelShape}, pads:${t.pads}, strides:${t.strides}`);\n      let l = dr(s, a, t.dilations, t.pads, t.strides),\n        f = G(i.session.backend.glContext.version),\n        {\n          activationFunction: p,\n          applyActivation: d\n        } = he(t),\n        y = `\n  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});\n  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});\n  ${p}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${u};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${a[1]}; wInChannel++) {\n      int input_channel = group_id * ${a[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${a[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${t.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${s[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${a[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${t.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${s[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${n}\n    ${d}\n    ${f.output} = vec4(value, .0, .0, .0);\n  }\n`;\n      return {\n        ...o,\n        output: {\n          dims: l,\n          type: e[0].type,\n          textureType: 0\n        },\n        shaderSource: y,\n        hasMain: !0\n      };\n    }, uf = (i, e, o) => {\n      let t = Sm(e.length > 2, o.cacheKey);\n      return {\n        ...t,\n        get: () => Am(i, e, t, o)\n      };\n    };\n  });\nvar Pm,\n  Em,\n  ff,\n  cf = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    He();\n    Pm = i => ({\n      name: \"Im2Col (packed)\",\n      inputNames: [\"A\"],\n      inputTypes: [2],\n      cacheHint: i\n    }), Em = (i, e, o, t, r, n) => {\n      let s = o.dims,\n        a = t.dims,\n        u = 2,\n        l = 3,\n        f = r.length,\n        p = [a[1] * a[2] * a[3], r[2] * r[3]],\n        d = a[2] * a[3],\n        y = de(),\n        T = G(i.session.backend.glContext.version),\n        v = \"\";\n      for (let L = 0; L <= 1; L++) for (let P = 0; P <= 1; P++) v += `\n            blockIndex = rc.x + ${P};\n            pos = rc.y + ${L};\n\n            if(blockIndex < ${p[1]} && pos < ${p[0]}) {\n              offsetY = int(blockIndex / (${r[f - 1]})) * ${n.strides[0]} -\n                ${n.pads[0]};\n              d0 = offsetY + ${n.dilations[0]} * (imod(pos, ${d}) / ${a[2]});\n\n              if(d0 < ${s[u]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${r[f - 1]}) * ${n.strides[1]} -\n                  ${n.pads[1]};\n                d1 = offsetX + ${n.dilations[1]} * imod(imod(pos, ${d}), ${a[2]});\n\n                if(d1 < ${s[l]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${d}.);\n                    innerDims = vec2(d0, d1);\n                    result[${L * 2 + P}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;\n      let S = `\n      ${y}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${v}\n          ${T.output} = result;\n      }\n            `;\n      return {\n        ...e,\n        output: {\n          dims: p,\n          type: o.type,\n          textureType: 2\n        },\n        shaderSource: S,\n        hasMain: !0\n      };\n    }, ff = (i, e, o, t, r) => {\n      let n = Pm(r.cacheKey);\n      return {\n        ...n,\n        get: () => Em(i, n, e, o, t, r)\n      };\n    };\n  });\nfunction Lm(i, e, o) {\n  let t = e[0].dims,\n    r = e[1].dims,\n    n = kt.calcShape(t, r, !0);\n  if (!n) throw new Error(\"Can't use matmul on the given tensors\");\n  let s = Bt(n.length),\n    a = ne(),\n    {\n      activationFunction: u,\n      applyActivation: l\n    } = he(o),\n    f = e.length > 2,\n    p = f ? \"value += getBiasForMatmul();\" : \"\",\n    d = f ? `${wi(s, a, e[2].dims, n, !1)}` : \"\",\n    y = n.length,\n    T = t.length,\n    v = r.length,\n    S = t[t.length - 1],\n    L = `\n    ${u}\n    ${d}\n    float process(int indices[${y}]) {\n        int a[${T}];\n        int b[${v}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${S}; ++k) {\n            a[${T - 1}] = k;\n            b[${v - 2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${p}\n        ${l}\n        return value;\n    }`;\n  return {\n    ...i,\n    output: {\n      dims: n,\n      type: e[0].type,\n      textureType: 0\n    },\n    shaderSource: L\n  };\n}\nfunction Ti(i, e) {\n  let o = Dm(i.length > 2, e.activationCacheKey);\n  return {\n    ...o,\n    get: () => Lm(o, i, e)\n  };\n}\nfunction wi(i, e, o, t, r) {\n  let n = \"\",\n    s = o.length,\n    a = t.length,\n    u = a - s;\n  a < 2 && s > 0 ? n = \"coords\" : n = o.map((v, S) => `coords.${e[S + u]}`).join(\", \");\n  let f = kt.getBroadcastDims(o, t).map(v => `coords.${e[v + u]} = 0;`).join(`\n`),\n    d = B.size(o) === 1,\n    y = \"vec4(outputValue.xx, outputValue.yy)\";\n  return d && (y = \"vec4(outputValue.x)\"), r ? `\nvec4 getBiasForMatmul() {\n  ${i} coords = getOutputCoords();\n  ${f}\n  vec4 outputValue = getBias(${n});\n  return ${y};\n}` : `\nfloat getBiasForMatmul() {\n  ${i} coords = getOutputCoords();\n  ${f}\n  return getBias(coords.x);\n}`;\n}\nvar pf,\n  df,\n  Dm,\n  $m,\n  Fn = O(() => {\n    \"use strict\";\n\n    Y();\n    j();\n    pe();\n    qe();\n    vi();\n    pf = (i, e, o) => ($m(e), i.session.pack ? [i.run(Cn(i, e, o), e)] : [i.run(Ti(e, o), e)]), df = i => pr(i.attributes), Dm = (i, e) => ({\n      name: \"MatMul\",\n      inputNames: i ? [\"A\", \"B\", \"Bias\"] : [\"A\", \"B\"],\n      inputTypes: i ? [0, 0, 0] : [0, 0],\n      cacheHint: e\n    });\n    $m = i => {\n      if (!i || i.length !== 2) throw new Error(\"MatMul requires 2 inputs.\");\n      if (i[0].dims[i[0].dims.length - 1] !== i[1].dims[i[1].dims.length - 2]) throw new Error(\"shared dimension does not match.\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\" || i[1].type !== \"float32\" && i[1].type !== \"float64\") throw new Error(\"inputs should be float type\");\n      if (i[0].type !== i[1].type) throw new Error(\"inputs types should match\");\n    };\n  });\nfunction Fm(i, e, o, t) {\n  let r = [],\n    n = [],\n    s = o[0].dims,\n    a = o[1].dims,\n    u = s.length,\n    l = a.length,\n    f = t.length,\n    p = f - u,\n    d = f - l;\n  r = s.map((A, M) => `coords.${e[M + p]}`), r[u - 1] = \"i*2\", r.join(\", \"), n = a.map((A, M) => `coords.${e[M + d]}`), n[l - 2] = \"i*2\", n.join(\", \");\n  let y = kt.getBroadcastDims(s, t),\n    T = kt.getBroadcastDims(a, t),\n    v = y.map(A => `coords.${e[A + p]} = 0;`).join(`\n`),\n    S = T.map(A => `coords.${e[A + d]} = 0;`).join(`\n`),\n    L = `int lastDim = coords.${e[f - 1]};\n  coords.${e[f - 1]} = coords.${e[f - 2]};\n  coords.${e[f - 2]} = lastDim;`;\n  return `\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${i} coords = getOutputCoords();\n  ${L}\n  ${v}\n  vec4 outputValue = getA(${r});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${i} coords = getOutputCoords();\n  ${L}\n  ${S}\n  vec4 outputValue = getB(${n});\n  return outputValue;\n}`;\n}\nfunction Cm(i, e) {\n  let o = \"\";\n  for (let t = 0; t < e - 2; t++) o += `rc.${i[t]}, `;\n  return o += `rc.${i[e - 2]}, i*2`, o;\n}\nfunction Nm(i, e) {\n  let o = \"\";\n  for (let t = 0; t < e - 2; t++) o += `rc.${i[t]}, `;\n  return o += `i*2, rc.${i[e - 1]}`, o;\n}\nvar km,\n  Bm,\n  Cn,\n  vi = O(() => {\n    \"use strict\";\n\n    Y();\n    ut();\n    j();\n    pe();\n    qe();\n    Fn();\n    km = (i, e) => ({\n      name: \"MatMul (packed)\",\n      inputNames: i ? [\"A\", \"B\", \"Bias\"] : [\"A\", \"B\"],\n      inputTypes: i ? [2, 2, 2] : [2, 2],\n      cacheHint: e\n    }), Bm = (i, e, o, t) => {\n      let r = o.length > 2,\n        n = r ? \"value += getBiasForMatmul();\" : \"\",\n        s = o[0].dims,\n        a = o[1].dims,\n        u = kt.calcShape(s, a, !0),\n        l = !B.areEqual(o[0].dims, o[1].dims);\n      if (!u) throw new Error(\"Can't use matmul on the given tensors\");\n      let f = s[s.length - 1],\n        p = Math.ceil(f / 2),\n        d = s.length,\n        y = a.length,\n        T = G(i.session.backend.glContext.version),\n        v = Bt(u.length),\n        S = u.length,\n        L = ne(),\n        {\n          activationFunction: P,\n          applyActivation: A\n        } = he(t),\n        M = r ? `${wi(v, L, o[2].dims, u, !0)}` : \"\",\n        V = l ? `${Fm(v, L, o, u)}` : \"\",\n        lt = l ? \"getAAtOutCoordsMatmul(i)\" : `getA(${Cm(L, d)})`,\n        wt = l ? \"getBAtOutCoordsMatmul(i)\" : `getB(${Nm(L, y)})`,\n        et = l ? \"\" : `${v} rc =\n          getOutputCoords(); int lastDim = rc.${L[S - 1]}; rc.${L[S - 1]} =\n          rc.${L[S - 2]}; rc.${L[S - 2]} = lastDim;\n      `,\n        Dt = `\n            ${V}\n            ${M}\n            ${P}\n            void main() {\n              ${et}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${p}; i++) {\n                vec4 a = ${lt};\n                vec4 b = ${wt};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${n}\n              ${A}\n              ${T.output} = value;\n            }`;\n      return {\n        ...e,\n        output: {\n          dims: u,\n          type: o[0].type,\n          textureType: 2\n        },\n        shaderSource: Dt,\n        hasMain: !0\n      };\n    }, Cn = (i, e, o) => {\n      let t = km(e.length > 2, o.activationCacheKey);\n      return {\n        ...t,\n        get: () => Bm(i, t, e, o)\n      };\n    };\n  });\nvar hf,\n  mf = O(() => {\n    \"use strict\";\n\n    Bn();\n    cf();\n    vi();\n    hf = (i, e, o) => {\n      let t = e[0].dims,\n        r = e[1].dims,\n        n = dr(t, r, o.dilations, o.pads, o.strides),\n        s = i.run(ff(i, e[0], e[1], n, o), [e[0]]),\n        a = i.reshapePacked(e[1], [r[0], r[1] * r[2] * r[3]]),\n        u = e.length === 3 ? [a, s, e[2]] : [a, s],\n        l = i.run(Cn(i, u, o), u);\n      return i.reshapePacked(l, n);\n    };\n  });\nvar Rm,\n  Gm,\n  bf,\n  Ii,\n  _i = O(() => {\n    \"use strict\";\n\n    j();\n    Rm = i => ({\n      name: \"Im2Col\",\n      inputNames: [\"X\"],\n      inputTypes: [0],\n      cacheHint: i\n    }), Gm = (i, e, o, t, r, n) => {\n      let s = o.dims,\n        a = t.dims,\n        u = r.length,\n        l = Ii(s, a, r, 4),\n        f = `\n        const int XC = ${s[1]};\n        const int XH = ${s[2]};\n        const int XW = ${s[3]};\n        const int KH = ${n.kernelShape[0]};\n        const int KW = ${n.kernelShape[1]};\n        const int dilationH = ${n.dilations[0]};\n        const int dilationW = ${n.dilations[1]};\n        const int strideH = ${n.strides[0]};\n        const int strideW = ${n.strides[1]};\n        const int padH = ${n.pads[0]};\n        const int padW = ${n.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${u}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${s.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;\n      return {\n        ...e,\n        output: {\n          dims: l,\n          type: o.type,\n          textureType: 4\n        },\n        shaderSource: f\n      };\n    }, bf = (i, e, o, t, r) => {\n      let n = Rm(r.cacheKey);\n      return {\n        ...n,\n        get: () => Gm(i, n, e, o, t, r)\n      };\n    }, Ii = (i, e, o, t = 4) => [o[0], o[2], o[3], Math.ceil(i[1] * e[2] * e[3] / t)];\n  });\nvar Mm,\n  Um,\n  gf,\n  yf = O(() => {\n    \"use strict\";\n\n    Y();\n    ut();\n    j();\n    qe();\n    _i();\n    Mm = (i, e) => ({\n      name: \"ConvDotProduct\",\n      inputNames: i ? [\"Im2Col\", \"K\", \"B\"] : [\"Im2Col\", \"K\"],\n      inputTypes: i ? [0, 4, 0] : [0, 4],\n      cacheKey: e.activationCacheKey\n    }), Um = (i, e, o, t, r) => {\n      let n = o[0].dims,\n        s = o[1].dims,\n        a = [s[0], Math.ceil(n[1] * s[2] * s[3] / 4)],\n        u = Ii(n, s, t),\n        [l, f] = i.calculateTextureWidthAndHeight(a, 4),\n        p = B.computeStrides(u),\n        [d, y] = i.calculateTextureWidthAndHeight(u, 4),\n        T = t.length,\n        v = o.length < 3 ? \"0.0\" : \"_B(b)\",\n        S = Math.ceil(n[1] * s[2] * s[3] / 4),\n        {\n          activationFunction: L,\n          applyActivation: P\n        } = he(r),\n        A = G(i.session.backend.glContext.version),\n        M = `\n${L}\nfloat process(int indices[${T}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${p[0]} + im2col[1] * ${p[1]} + im2col[2] * ${p[2]};\n  int kernelOffset = indices[1] * ${a[1]};\n  float value = ${v};\n  for (int i = 0; i < ${S}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${d}, ${y});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${l}, ${f});\n    value += dot(${A.texture2D}(Im2Col, im2colCoords), ${A.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${P}\n  return value;\n}`;\n      return {\n        ...e,\n        output: {\n          dims: t,\n          type: o[0].type,\n          textureType: 0\n        },\n        shaderSource: M\n      };\n    }, gf = (i, e, o, t) => {\n      let r = Mm(e.length > 2, t);\n      return {\n        ...r,\n        get: () => Um(i, r, e, o, t)\n      };\n    };\n  });\nvar dr,\n  Oi,\n  Vm,\n  zm,\n  Wm,\n  Hm,\n  Si,\n  qm,\n  Bn = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    lf();\n    mf();\n    yf();\n    qe();\n    _i();\n    Fn();\n    dr = (i, e, o, t, r) => {\n      let n = i[0],\n        s = i.slice(2),\n        a = s.length,\n        u = e[0],\n        f = e.slice(2).map((T, v) => T + (T - 1) * (o[v] - 1)),\n        d = s.map((T, v) => T + t[v] + t[v + a]).map((T, v) => Math.floor((T - f[v] + r[v]) / r[v]));\n      return [n, u].concat(...d);\n    }, Oi = (i, e, o) => (qm(e, o), Vm(i, e, o)), Vm = (i, e, o) => {\n      let t = Hm(o, e),\n        r = i.session.pack,\n        n = t.kernelShape[0] === 1 && t.kernelShape[1] === 1;\n      return t.group > 1 ? [i.run(uf(i, e, t), e)] : n && r ? [zm(i, e, t)] : r && e[0].dims.length === 4 && e[0].dims[0] === 1 && !n ? [hf(i, e, t)] : [Wm(i, e, t)];\n    }, zm = (i, e, o) => {\n      let t = e[0].dims,\n        r = e[1].dims,\n        n = dr(t, r, o.dilations, o.pads, o.strides),\n        s = i.reshapeUnpacked(e[0], [t[1], t[2] * t[3]]),\n        a = i.reshapeUnpacked(e[1], [r[0], r[1]]),\n        u = e.length > 2 ? [a, s, e[2]] : [a, s],\n        l = i.run(Ti(u, o), u);\n      return i.reshapeUnpacked(l, n);\n    }, Wm = (i, e, o) => {\n      let t = e[0].dims,\n        r = e[1].dims,\n        n = dr(t, r, o.dilations, o.pads, o.strides),\n        s = i.run(bf(i, e[0], e[1], n, o), [e[0]]),\n        a = e.length === 3 ? [s, e[1], e[2]] : [s, e[1]];\n      return i.run(gf(i, e, n, o), a);\n    }, Hm = (i, e) => {\n      let o = i.kernelShape.slice();\n      if (i.kernelShape.length === 0) for (let n = 2; n < e[1].dims.length; ++n) o.push(e[1].dims[n]);\n      let t = i.pads.slice();\n      Ue.adjustPadsBasedOnAutoPad(e[0].dims, i.strides, i.dilations, o, t, i.autoPad);\n      let r = Object.assign({}, i);\n      return Object.assign(r, {\n        kernelShape: o,\n        pads: t,\n        cacheKey: i.cacheKey\n      }), r;\n    }, Si = i => {\n      let e = i.attributes,\n        o = pr(e),\n        t = e.getString(\"auto_pad\", \"NOTSET\"),\n        r = e.getInts(\"dilations\", [1, 1]),\n        n = e.getInt(\"group\", 1),\n        s = e.getInts(\"kernel_shape\", []),\n        a = e.getInts(\"pads\", [0, 0, 0, 0]),\n        u = e.getInts(\"strides\", [1, 1]);\n      return W({\n        autoPad: t,\n        dilations: r,\n        group: n,\n        kernelShape: s,\n        pads: a,\n        strides: u,\n        ...o\n      });\n    }, qm = (i, e) => {\n      if (!i || i.length !== 2 && i.length !== 3) throw new Error(\"Conv requires 2 or 3 inputs\");\n      if (i[0].dims.length !== 4 || i[1].dims.length !== 4) throw new Error(\"currently only support 2-dimensional conv\");\n      let o = i[0].dims[1],\n        t = i[1].dims[1] * e.group;\n      if (o !== t) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n      if (i.length === 3 && (i[2].dims.length !== 1 || i[1].dims[0] !== i[2].dims[0])) throw new Error(\"invalid bias\");\n      let r = i[0].dims.length - 2;\n      if (e.dilations.length !== r) throw new Error(`dilations should be ${r}D`);\n      if (e.strides.length !== r) throw new Error(`strides should be ${r}D`);\n      if (e.pads.length !== r * 2) throw new Error(`pads should be ${r * 2}D`);\n      if (e.kernelShape.length !== 0 && e.kernelShape.length !== i[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n      if (i[0].type !== \"float32\" || i[1].type !== \"float32\") throw new Error(\"Conv input(X,W) should be float tensor\");\n      if (i.length === 3 && i[2].type !== \"float32\") throw new Error(\"Conv input(bias) should be float tensor\");\n    };\n  });\nvar jm,\n  Xm,\n  Km,\n  xf,\n  Jm,\n  Ym,\n  Zm,\n  Qm,\n  tb,\n  eb,\n  Tf,\n  rb,\n  wf = O(() => {\n    \"use strict\";\n\n    It();\n    ut();\n    j();\n    qe();\n    jm = (i, e, o, t, r, n) => (i - 1) * e + o + (t - 1) * r + 1 - n, Xm = (i, e, o, t, r) => {\n      let n = Math.floor(i / 2);\n      e === \"SAME_UPPER\" ? (o[t] = n, o[r] = i - n) : e === \"SAME_LOWER\" && (o[t] = i - n, o[r] = n);\n    }, Km = (i, e, o, t, r, n, s, a) => {\n      let u = i.length - 2,\n        l = a.length === 0;\n      for (let f = 0; f < u; ++f) {\n        let p = l ? i[f + 2] * n[f] : a[f],\n          d = jm(i[f + 2], n[f], r[f], e[f], o[f], p);\n        Xm(d, t, r, f, f + u), l && a.push(n[f] * (i[f + 2] - 1) + s[f] + (e[f] - 1) * o[f] + 1 - r[f] - r[f + u]);\n      }\n    }, xf = (i, e, o) => (rb(e, o), Jm(i, e, o)), Jm = (i, e, o) => {\n      let t = eb(o, e);\n      return [tb(i, e, t)];\n    }, Ym = (i, e) => ({\n      name: \"ConvTranspose\",\n      inputNames: i ? [\"X\", \"W\", \"B\"] : [\"X\", \"W\"],\n      inputTypes: i ? [0, 0, 0] : [0, 0],\n      cacheHint: e\n    }), Zm = (i, e, o, t) => {\n      let n = e.length > 2 ? \"getB(output_channel)\" : \"0.0\",\n        s = e[0].dims,\n        a = e[1].dims,\n        u = a[1],\n        l = a[0] / t.group,\n        f = [e[0].dims[0], e[1].dims[1] * t.group, ...t.outputShape],\n        p = G(i.session.backend.glContext.version),\n        {\n          activationFunction: d,\n          applyActivation: y\n        } = he(t),\n        T = `\n  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});\n  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});\n  ${d}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${u};\n    int wOutChannel = output_channel - group_id * ${u};\n\n    float value = ${n};\n    for (int inChannelOffset = 0; inChannelOffset < ${l}; inChannelOffset++) {\n      int input_channel = group_id * ${l} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${a[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${a[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${t.dilations[0]}, wHOff * ${t.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${s[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${s[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${y}\n    ${p.output} = vec4(value, .0, .0, .0);\n  }\n`;\n      return {\n        ...o,\n        output: {\n          dims: f,\n          type: e[0].type,\n          textureType: 0\n        },\n        shaderSource: T,\n        hasMain: !0\n      };\n    }, Qm = (i, e, o) => {\n      let t = Ym(e.length > 2, o.cacheKey);\n      return {\n        ...t,\n        get: () => Zm(i, e, t, o)\n      };\n    }, tb = (i, e, o) => i.run(Qm(i, e, o), e), eb = (i, e) => {\n      let o = i.kernelShape.slice();\n      if (i.kernelShape.length === 0) for (let a = 2; a < e[1].dims.length; ++a) o.push(e[1].dims[a]);\n      let t = i.pads.slice(),\n        r = i.outputShape.slice(),\n        n = e[0].dims;\n      Km(n, o, i.dilations, i.autoPad, t, i.strides, i.outputPadding, r);\n      let s = Object.assign({}, i);\n      return Object.assign(s, {\n        kernelShape: o,\n        pads: t,\n        outputShape: r,\n        cacheKey: i.cacheKey\n      }), s;\n    }, Tf = i => {\n      let e = i.attributes,\n        o = pr(e),\n        t = e.getString(\"auto_pad\", \"NOTSET\"),\n        r = e.getInts(\"dilations\", [1, 1]),\n        n = e.getInt(\"group\", 1),\n        s = e.getInts(\"kernel_shape\", []),\n        a = e.getInts(\"output_padding\", [0, 0]),\n        u = e.getInts(\"output_shape\", []),\n        l = e.getInts(\"pads\", [0, 0, 0, 0]),\n        f = e.getInts(\"strides\", [1, 1]);\n      return W({\n        autoPad: t,\n        dilations: r,\n        group: n,\n        kernelShape: s,\n        outputPadding: a,\n        outputShape: u,\n        pads: l,\n        strides: f,\n        ...o\n      });\n    }, rb = (i, e) => {\n      if (!i || i.length !== 2 && i.length !== 3) throw new Error(\"Conv requires 2 or 3 inputs\");\n      if (i[0].dims.length !== 4 || i[1].dims.length !== 4) throw new Error(\"currently only support 2-dimensional conv\");\n      let o = i[0].dims[1],\n        t = i[1].dims[0];\n      if (o !== t) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n      let r = i[1].dims[1] * e.group;\n      if (i.length === 3 && (i[2].dims.length !== 1 || i[2].dims[0] !== r)) throw new Error(\"invalid bias\");\n      let n = i[0].dims.length - 2;\n      if (e.dilations.length !== n) throw new Error(`dilations should be ${n}D`);\n      if (e.strides.length !== n) throw new Error(`strides should be ${n}D`);\n      if (e.pads.length !== n * 2) throw new Error(`pads should be ${n * 2}D`);\n      if (e.outputPadding.length !== n) throw new Error(`output_padding should be ${n}D`);\n      if (e.kernelShape.length !== 0 && e.kernelShape.length !== i[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n      if (e.outputShape.length !== 0 && e.outputShape.length !== i[0].dims.length - 2) throw new Error(\"invalid output shape\");\n      if (i[0].type !== \"float32\" || i[1].type !== \"float32\") throw new Error(\"ConvTranspose input(X,W) should be float tensor\");\n      if (i.length === 3 && i[2].type !== \"float32\") throw new Error(\"ConvTranspose input(bias) should be float tensor\");\n    };\n  });\nvar vf,\n  je,\n  If,\n  nb,\n  _f,\n  ob,\n  ib,\n  ab,\n  Nn = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    j();\n    vf = {\n      name: \"Transpose\",\n      inputNames: [\"A\"],\n      inputTypes: [0]\n    }, je = (i, e, o) => (ab(e), [i.run({\n      ...vf,\n      cacheHint: o.cacheKey,\n      get: () => nb(i, e[0], o.perm)\n    }, e)]), If = i => W({\n      perm: i.attributes.getInts(\"perm\", [])\n    }), nb = (i, e, o) => {\n      let t = e.dims;\n      o = _f(t, o);\n      let r = ob(t, o),\n        n = t.length,\n        s = `\n      ${ib(\"perm\", o, n)}\n      float process(int indices[${n}]) {\n        int a[${n}];\n        perm(a, indices);\n        return _A(a);\n      }`;\n      return {\n        ...vf,\n        output: {\n          dims: r,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: s\n      };\n    }, _f = (i, e) => (e && e.length !== i.length && (e = [...i.keys()].reverse()), e), ob = (i, e) => (e = _f(i, e), B.sortBasedOnPerm(i, e)), ib = (i, e, o) => {\n      let t = [];\n      t.push(`void ${i}(out int a[${o}], int src[${o}]) {`);\n      for (let r = 0; r < o; ++r) t.push(`\ta[${e[r]}]=src[${r}];`);\n      return t.push(\"\t}\"), t.join(`\n`);\n    }, ab = i => {\n      if (!i || i.length !== 1) throw new Error(\"Transpose requires 1 input.\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\") throw new Error(\"input should be float tensor\");\n    };\n  });\nvar Of,\n  Sf,\n  sb,\n  Af = O(() => {\n    \"use strict\";\n\n    Nn();\n    Of = (i, e, o) => {\n      sb(e);\n      let t = o.blocksize,\n        r = t * t,\n        n = o.mode === \"DCR\" ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3],\n        s = o.mode === \"DCR\" ? [e[0].dims[0], t, t, e[0].dims[1] / r, e[0].dims[2], e[0].dims[3]] : [e[0].dims[0], e[0].dims[1] / r, t, t, e[0].dims[2], e[0].dims[3]],\n        a = i.reshapeUnpacked(e[0], s),\n        u = {\n          perm: n,\n          cacheKey: `${n}`\n        },\n        [l] = je(i, [a], u),\n        f = [e[0].dims[0], e[0].dims[1] / r, e[0].dims[2] * t, e[0].dims[3] * t];\n      return [i.reshapeUnpacked(l, f)];\n    }, Sf = i => {\n      let e = i.attributes.getInt(\"blocksize\");\n      if (e < 1) throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);\n      let o = i.attributes.getString(\"mode\", \"DCR\");\n      if (o !== \"DCR\" && o !== \"CRD\") throw new Error(`unrecognized mode: ${o} for DepthToSpace`);\n      return {\n        mode: o,\n        blocksize: e\n      };\n    }, sb = i => {\n      if (i.length !== 1) throw new Error(`DepthToSpace expect 1 inputs, but got ${i.length}`);\n      if (i[0].type === \"string\" || i[0].dims.length !== 4) throw new TypeError(\"DepthToSpace input should be a 4-D numeric tensor\");\n    };\n  });\nvar Pf,\n  Ef,\n  ub,\n  Df = O(() => {\n    \"use strict\";\n\n    Y();\n    Pf = (i, e, o) => {\n      ub(e, o);\n      let t = B.flattenShape(e[0].dims, o);\n      return [i.reshapeUnpacked(e[0], t)];\n    }, Ef = i => i.attributes.getInt(\"axis\", 1), ub = (i, e) => {\n      if (!i || i.length !== 1) throw new Error(\"Flatten requires 1 input.\");\n      let o = i[0].dims.length;\n      if (o === 0) throw new Error(\"scalar tensor is not supported.\");\n      if (e < -o || e > o) throw new Error(\"Invalid axis\");\n      if (i[0].type === \"string\") throw new Error(\"string tensor is not supported.\");\n    };\n  });\nvar Pe,\n  Rr = O(() => {\n    \"use strict\";\n\n    Pe = [\"float32\", \"float64\", \"int32\", \"int16\", \"int8\", \"uint16\", \"uint32\", \"uint8\"];\n  });\nvar Lf,\n  $f,\n  lb,\n  fb,\n  cb,\n  pb,\n  kf = O(() => {\n    \"use strict\";\n\n    It();\n    Rr();\n    Y();\n    j();\n    Lf = (i, e, o) => (pb(e, o.axis), [i.run(cb(i, e, o), e)]), $f = i => W({\n      axis: i.attributes.getInt(\"axis\", 0)\n    }), lb = {\n      name: \"Gather\",\n      inputNames: [\"A\", \"B\"],\n      inputTypes: [0, 0]\n    }, fb = (i, e, o, t) => {\n      let r = o[0].dims.slice(),\n        n = o[1].dims.slice(),\n        s = new Array(r.length + n.length - 1);\n      t = B.normalizeAxis(t, r.length);\n      let a = [];\n      for (let d = 0; d < s.length; d++) d < t ? (s[d] = r[d], a.push(`inputIdx[${d}] = outputIdx[${d}];`)) : d < t + n.length ? (s[d] = n[d - t], a.push(`indexDataIdx[${d - t}] = outputIdx[${d}];`)) : (s[d] = r[d - n.length + 1], a.push(`inputIdx[${d - n.length + 1}] = outputIdx[${d}];`));\n      let u = s.length || 1,\n        l = r.length,\n        f = n.length || 1,\n        p = `\n      float process(int outputIdx[${u}]) {\n        int inputIdx[${l}];\n        int indexDataIdx[${f}];\n        indexDataIdx[0] = 0;\n        ${a.join(`\n        `)}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${t}] = idx < 0 ? idx + ${r[t]} : idx;\n        return _A(inputIdx);\n      }`;\n      return {\n        ...e,\n        output: {\n          dims: s,\n          type: o[0].type,\n          textureType: 0\n        },\n        shaderSource: p\n      };\n    }, cb = (i, e, o) => {\n      let t = {\n        ...lb,\n        cacheHint: o.cacheKey\n      };\n      return {\n        ...t,\n        get: () => fb(i, t, e, o.axis)\n      };\n    }, pb = (i, e) => {\n      if (!i || i.length !== 2) throw new Error(\"Gather requires 2 inputs.\");\n      let o = i[0].dims.length;\n      if (o < 1) throw new Error(\"Invalid input shape.\");\n      if (e < -o || e > o - 1) throw new Error(\"Invalid axis.\");\n      if (Pe.indexOf(i[0].type) === -1) throw new Error(\"Invaid input type.\");\n      if (i[1].type !== \"int32\" && i[1].type !== \"int16\") throw new Error(\"Invaid input type.\");\n    };\n  });\nvar Ai,\n  Bf,\n  Ff,\n  Cf,\n  db,\n  hb,\n  mb,\n  Nf = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    j();\n    Ai = (i, e, o) => (mb(e, o), [i.run(db(e, o), e)]), Bf = (i, e) => {\n      let o = i.attributes.getInt(\"transA\", 0) !== 0,\n        t = i.attributes.getInt(\"transB\", 0) !== 0,\n        r = i.attributes.getFloat(\"alpha\", 1),\n        n = i.attributes.getFloat(\"beta\", 1);\n      return W({\n        transA: o,\n        transB: t,\n        alpha: r,\n        beta: n,\n        isOptionalC: e\n      });\n    }, Ff = i => Bf(i, !1), Cf = i => Bf(i, !0), db = (i, e) => {\n      let o = {\n        name: \"Gemm\",\n        inputNames: i.length === 3 ? [\"A\", \"B\", \"C\"] : [\"A\", \"B\"],\n        inputTypes: i.length === 3 ? [0, 0, 0] : [0, 0],\n        key: e.cacheKey\n      };\n      return {\n        ...o,\n        get: () => hb(o, i, e)\n      };\n    }, hb = (i, e, o) => {\n      let t = e[0].dims.slice(),\n        r = e[1].dims.slice(),\n        [n, s] = Sn.getShapeOfGemmResult(t, o.transA, r, o.transB, e.length === 3 ? e[2].dims : void 0),\n        a = [n, s];\n      if (!a) throw new Error(\"Can't use gemm on the given tensors\");\n      let u = t[t.length - 1],\n        l = \"\";\n      o.transA && (u = t[0]), o.transA && o.transB ? l = \"value += _A_T(a) * _B_T(b);\" : o.transA && !o.transB ? l = \"value += _A_T(a) * _B(b);\" : !o.transA && o.transB ? l = \"value += _A(a) * _B_T(b);\" : !o.transA && !o.transB && (l = \"value += _A(a) * _B(b);\");\n      let f = a.length,\n        p = e.length === 3 ? `int c[${e[2].dims.length}];` : \"\",\n        d = e.length === 3 ? \"bcastIndices_C(indices, c);\" : \"\",\n        y = e.length === 3 ? \"value += beta * _C(c);\" : \"\",\n        T = `\n      float process(int indices[${f}]) {\n          int a[${f}];\n          int b[${f}];\n          ${p}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${d}\n\n          float value = 0.0;\n          for (int k=0; k<${u}; ++k) {\n              a[${f - 1}] = k;\n              b[${f - 2}] = k;\n              ${l}\n          }\n\n          value = value * alpha;\n          ${y}\n          return value;\n      }`;\n      return {\n        ...i,\n        output: {\n          dims: a,\n          type: e[0].type,\n          textureType: 0\n        },\n        variables: [{\n          name: \"alpha\",\n          type: \"float\",\n          data: o.alpha\n        }, {\n          name: \"beta\",\n          type: \"float\",\n          data: o.beta\n        }],\n        shaderSource: T\n      };\n    }, mb = (i, e) => {\n      if (!i) throw new Error(\"Input is missing\");\n      if (e.isOptionalC && (i.length < 2 || i.length > 3)) throw new Error(\"Invaid input shape.\");\n      if (!e.isOptionalC && i.length !== 3) throw new Error(\"Gemm requires 3 inputs\");\n      if (i.length === 3 && i[2].dims.length !== 1 && i[2].dims.length !== 2) throw new Error(\"Invalid input shape of C\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\" || i[1].type !== \"float32\" && i[1].type !== \"float64\" || i.length === 3 && i[2].type !== \"float32\" && i[2].type !== \"float64\") throw new Error(\"Invalid input type.\");\n      if (i[0].type !== i[1].type || i.length === 3 && i[0].type !== i[2].type) throw new Error(\"Input types are mismatched\");\n    };\n  });\nvar Rf,\n  Gf,\n  bb,\n  gb,\n  yb,\n  xb,\n  Tb,\n  Mf = O(() => {\n    \"use strict\";\n\n    It();\n    j();\n    Rf = (i, e, o) => (Tb(e), [i.run(yb(i, e, o), e)]), Gf = i => {\n      let e = i.attributes.getFloat(\"scale\"),\n        o = i.attributes.getFloats(\"bias\");\n      return W({\n        scale: e,\n        bias: o\n      });\n    }, bb = {\n      name: \"ImageScaler\",\n      inputNames: [\"X\"],\n      inputTypes: [0]\n    }, gb = (i, e, o, t) => {\n      let r = o[0].dims.slice(),\n        n = r.length,\n        a = `\n      ${xb(t.bias.length)}\n      float process(int indices[${n}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;\n      return {\n        ...e,\n        output: {\n          dims: r,\n          type: o[0].type,\n          textureType: 0\n        },\n        variables: [{\n          name: \"bias\",\n          type: \"float\",\n          arrayLength: t.bias.length,\n          data: t.bias\n        }, {\n          name: \"scale\",\n          type: \"float\",\n          data: t.scale\n        }],\n        shaderSource: a\n      };\n    }, yb = (i, e, o) => {\n      let t = {\n        ...bb,\n        cacheHint: o.cacheKey\n      };\n      return {\n        ...t,\n        get: () => gb(i, t, e, o)\n      };\n    }, xb = i => {\n      let e = [`float getBias(float bias[${i}], int channel) {`];\n      for (let o = 0; o < i; ++o) o === 0 ? e.push(`\tif (channel == ${o}) { return bias[${o}]; }`) : o === i - 1 ? e.push(`\telse { return bias[${o}]; }`) : e.push(`\telse if (channel == ${o}) { return bias[${o}]; }`);\n      return e.push(\"\t}\"), e.join(`\n`);\n    }, Tb = i => {\n      if (!i || i.length !== 1) throw new Error(\"ImageScaler requires 1 input.\");\n      if (i[0].dims.length !== 4) throw new Error(\"Invalid input shape.\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\") throw new Error(\"Invalid input type.\");\n    };\n  });\nvar Vf,\n  zf,\n  Uf,\n  wb,\n  vb,\n  Ib,\n  _b,\n  Ob,\n  Sb,\n  Wf = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    Vf = (i, e, o) => {\n      Sb(e);\n      let t = i.run(vb(e[0]), e);\n      return [i.run(Ob(i, e[0], o, t.dims), [e[0], t, e[1], e[2]])];\n    }, zf = i => i.attributes.getFloat(\"epsilon\", 1e-5), Uf = {\n      name: \"InstanceNormalization_MeanAndVariance\",\n      inputNames: [\"X\"],\n      inputTypes: [0]\n    }, wb = (i, e) => {\n      let o = e.dims.slice(),\n        t = o[1],\n        r = o[2] * o[3],\n        n = [o[0], t],\n        s = `\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${o[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${o[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${r});\n        temp = 0.0;\n        for(int a2=0; a2<${o[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${o[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${r});\n\n        return v;\n      }`;\n      return {\n        ...i,\n        output: {\n          dims: n,\n          type: e.type,\n          textureType: 4\n        },\n        shaderSource: s\n      };\n    }, vb = i => ({\n      ...Uf,\n      get: () => wb(Uf, i)\n    }), Ib = {\n      name: \"InstanceNormalization_ComputeOutput\",\n      inputNames: [\"X\", \"MeanAndVariance\", \"Scale\", \"B\"],\n      inputTypes: [0, 4, 0, 0]\n    }, _b = (i, e, o, t, r) => {\n      let n = G(i.session.backend.glContext.version),\n        [s, a] = i.calculateTextureWidthAndHeight(r, 4),\n        [u, l] = [s / 4, a],\n        f = `\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${u}, ${l});\n        return ${n.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;\n      return {\n        ...e,\n        output: {\n          dims: o.dims,\n          type: o.type,\n          textureType: 0\n        },\n        variables: [{\n          name: \"epsilon\",\n          type: \"float\",\n          data: t\n        }],\n        shaderSource: f\n      };\n    }, Ob = (i, e, o, t) => {\n      let r = {\n        ...Ib,\n        cacheHint: `${o}`\n      };\n      return {\n        ...r,\n        get: () => _b(i, r, e, o, t)\n      };\n    }, Sb = i => {\n      if (!i || i.length !== 3) throw new Error(\"InstanceNormalization requires 3 inputs.\");\n      let e = i[0],\n        o = i[1],\n        t = i[2];\n      if (e.dims.length < 3 || o.dims.length !== 1 || t.dims.length !== 1) throw new Error(\"Invalid input shape.\");\n      if (o.dims[0] !== e.dims[1] || t.dims[0] !== e.dims[1]) throw new Error(\"Input shapes are mismatched.\");\n      if (e.type !== \"float32\" && e.type !== \"float64\" || o.type !== \"float32\" && o.type !== \"float64\" || t.type !== \"float32\" && t.type !== \"float64\") throw new Error(\"Invalid input type.\");\n      if (i[0].dims.length !== 4) throw new Error(\"Only support 4-D input shape.\");\n    };\n  });\nfunction Ab(i, e) {\n  let o = i[0].dims[1],\n    t = i[0].dims.length,\n    r = -Math.floor((e.size - 1) / 2),\n    n = Math.ceil((e.size - 1) / 2),\n    s = `float(${e.alpha}) / float(${e.size})`,\n    a = `float(${e.bias})`,\n    u = `float(${e.beta})`,\n    l = `\n    float process(int indices[${t}]) {\n        int c = indices[1];\n        float x = _X(indices);\n        float square_sum = 0.0;\n\n        for (int i = ${r}; i <= ${n}; i++) {\n          int idx = c + i;\n          if (c >= 0 && c < ${o}) {\n            indices[1] = idx;\n            float j = _X(indices);\n            square_sum += j * j;\n          }\n        }\n        return x / pow(${a} + ${s} * square_sum, ${u});\n    }`;\n  return {\n    ...jf,\n    cacheHint: e.cacheKey,\n    output: {\n      dims: i[0].dims,\n      type: i[0].type,\n      textureType: 0\n    },\n    shaderSource: l\n  };\n}\nfunction Pb(i, e) {\n  return {\n    ...jf,\n    cacheHint: e.cacheKey,\n    get: () => Ab(i, e)\n  };\n}\nvar Hf,\n  qf,\n  jf,\n  Eb,\n  Xf = O(() => {\n    \"use strict\";\n\n    It();\n    j();\n    Hf = (i, e, o) => (Eb(e), [i.run(Pb(e, o), e)]), qf = i => {\n      let e = i.attributes.getFloat(\"alpha\", 1e-4),\n        o = i.attributes.getFloat(\"beta\", .75),\n        t = i.attributes.getFloat(\"bias\", 1),\n        r = i.attributes.getInt(\"size\");\n      return W({\n        alpha: e,\n        beta: o,\n        bias: t,\n        size: r\n      });\n    }, jf = {\n      name: \"LRN\",\n      inputNames: [\"X\"],\n      inputTypes: [0]\n    };\n    Eb = i => {\n      if (!i || i.length !== 1) throw new Error(\"LRN requires 1 input.\");\n      if (i[0].dims.length !== 4) throw new Error('currently only support LRN for input with \"NCHW\" format');\n      if (i[0].type !== \"float32\") throw new Error(\"input should be float type\");\n    };\n  });\nvar Db,\n  Pi,\n  Kf,\n  Jf,\n  Yf,\n  Lb,\n  $b,\n  kb,\n  Bb,\n  Fb,\n  Cb,\n  Nb,\n  Rb,\n  Zf = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    ut();\n    j();\n    Db = {\n      name: \"Pad\",\n      inputNames: [\"A\"],\n      inputTypes: [0]\n    }, Pi = (i, e, o) => (kb(e), [i.run({\n      ...Db,\n      cacheHint: o.cacheKey,\n      get: () => $b(i, e[0], o)\n    }, e)]), Kf = i => {\n      let e = i.attributes.getString(\"mode\", \"constant\"),\n        o = i.attributes.getFloat(\"value\", 0),\n        t = i.attributes.getInts(\"pads\");\n      return W({\n        mode: e,\n        value: o,\n        pads: t\n      });\n    }, Jf = (i, e, o) => {\n      Bb(e);\n      let t = Lb(i, e, o);\n      return Pi(i, [e[0]], t);\n    }, Yf = i => i.attributes.getString(\"mode\", \"constant\"), Lb = (i, e, o) => {\n      if (!i.session.isInitializer(e[1].dataId) || e.length >= 3 && !i.session.isInitializer(e[2].dataId)) throw new Error(\"dynamic pad attributes are not allowed\");\n      let t = Array.from(e[1].integerData),\n        r = e.length >= 3 ? e[2].floatData[0] : 0;\n      return W({\n        mode: o,\n        pads: t,\n        value: r\n      });\n    }, $b = (i, e, o) => {\n      let t = B.padShape(e.dims.slice(), o.pads),\n        r = t.length,\n        s = `\n      ${Fb(i, e, o)}\n      float process(int[${r}] indices) {\n          return padA(indices);\n      }`;\n      return {\n        name: \"Pad\",\n        inputNames: [\"A\"],\n        inputTypes: [0],\n        output: {\n          dims: t,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: s\n      };\n    }, kb = i => {\n      if (!i || i.length !== 1) throw new Error(\"Pad requires 1 input\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\") throw new Error(\"Invalid input type.\");\n    }, Bb = i => {\n      if (!i || i.length !== 2 && i.length !== 3) throw new Error(\"Pad requires 2 or 3 inputs\");\n      if (i[1].type !== \"int32\") throw new Error(\"Invalid input type.\");\n      if (i.length >= 3 && i[2].type === \"string\") throw new Error(\"Invalid input type.\");\n    }, Fb = (i, e, o) => {\n      let t = G(i.session.backend.glContext.version),\n        [r, n] = i.calculateTextureWidthAndHeight(e.dims, 0),\n        s = B.computeStrides(e.dims);\n      switch (o.mode) {\n        case \"constant\":\n          return Cb(t, e.dims, s, r, n, o.pads, o.value);\n        case \"reflect\":\n          return Nb(t, e.dims, s, r, n, o.pads);\n        case \"edge\":\n          return Rb(t, e.dims, s, r, n, o.pads);\n        default:\n          throw new Error(\"Invalid mode\");\n      }\n    }, Cb = (i, e, o, t, r, n, s) => {\n      let a = e.length,\n        u = \"\";\n      for (let l = a - 1; l >= 0; --l) u += `\n        k = m[${l}] - ${n[l]};\n        if (k < 0)  return constant;\n        if (k >= ${e[l]}) return constant;\n        offset += k * ${o[l]};\n        `;\n      return `\n      float padA(int m[${a}]) {\n        const float constant = float(${s});\n        int offset = 0;\n        int k = 0;\n        ${u}\n        vec2 coords = offsetToCoords(offset, ${t}, ${r});\n        float value = getColorAsFloat(${i.texture2D}(A, coords));\n        return value;\n      }\n      `;\n    }, Nb = (i, e, o, t, r, n) => {\n      let s = e.length,\n        a = \"\";\n      for (let u = s - 1; u >= 0; --u) a += `\n        k = m[${u}] - ${n[u]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2 * (e[u] - 1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${e[u]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${o[u]};\n        `;\n      return `\n      float padA(int m[${s}]) {\n        int offset = 0;\n        int k = 0;\n        ${a}\n        vec2 coords = offsetToCoords(offset, ${t}, ${r});\n        float value = getColorAsFloat(${i.texture2D}(A, coords));\n        return value;\n      }\n      `;\n    }, Rb = (i, e, o, t, r, n) => {\n      let s = e.length,\n        a = \"\";\n      for (let u = s - 1; u >= 0; --u) a += `\n        k = m[${u}] - ${n[u]};\n        if (k < 0)  k = 0;\n        if (k >= ${e[u]}) k = ${e[u] - 1};\n        offset += k * ${o[u]};\n      `;\n      return `\n      float padA(int m[${s}]) {\n        int offset = 0;\n        int k = 0;\n        ${a}\n        vec2 coords = offsetToCoords(offset, ${t}, ${r});\n        float value = getColorAsFloat(${i.texture2D}(A, coords));\n        return value;\n      }\n      `;\n    };\n  });\nvar tc,\n  ec,\n  rc,\n  nc,\n  oc,\n  ic,\n  ac,\n  sc,\n  uc,\n  Gb,\n  Qf,\n  lc,\n  Gn,\n  fc,\n  Rn,\n  Mb,\n  cc = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    j();\n    tc = (i, e, o) => {\n      Gn(e);\n      let t = {\n        name: \"AveragePool\",\n        inputNames: [\"X\"],\n        inputTypes: [0],\n        cacheHint: o.cacheKey\n      };\n      return [i.run({\n        ...t,\n        get: () => rc(e, t, !1, o)\n      }, e)];\n    }, ec = i => {\n      let e = i.attributes.getString(\"auto_pad\", \"NOTSET\"),\n        o = i.attributes.getInt(\"ceil_mode\", 0),\n        t = i.attributes.getInt(\"count_include_pad\", 0) !== 0,\n        r = i.attributes.getInts(\"kernel_shape\"),\n        n = i.attributes.getInts(\"strides\", []),\n        s = i.attributes.getInts(\"pads\", []);\n      if (o !== 0) throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");\n      return W({\n        autoPad: e,\n        ceilMode: o,\n        countIncludePad: t,\n        kernelShape: r,\n        strides: n,\n        pads: s\n      });\n    }, rc = (i, e, o, t) => {\n      let [r, n] = uc(i, t, o),\n        s = B.size(r.kernelShape),\n        a = \"value += _X(x);\",\n        u = \"\";\n      r.countIncludePad ? u += `value /= float(${s});` : u += `value /= float(${s} - pad);`;\n      let f = `\n        ${fc(i[0].dims, r, a, u, \"0.0\")}\n      `;\n      return {\n        ...e,\n        output: {\n          dims: n,\n          type: i[0].type,\n          textureType: 0\n        },\n        shaderSource: f\n      };\n    }, nc = (i, e, o) => {\n      Gn(e);\n      let t = {\n        name: \"GlobalAveragePool\",\n        inputNames: [\"X\"],\n        inputTypes: [0],\n        cacheHint: `${o.countIncludePad}`\n      };\n      return [i.run({\n        ...t,\n        get: () => rc(e, t, !0, o)\n      }, e)];\n    }, oc = i => {\n      let e = i.attributes.getInt(\"count_include_pad\", 0) !== 0;\n      return W({\n        autoPad: \"\",\n        ceilMode: 0,\n        countIncludePad: e,\n        kernelShape: [],\n        strides: [],\n        pads: []\n      });\n    }, ic = (i, e, o) => {\n      Gn(e);\n      let t = {\n        name: \"MaxPool\",\n        inputNames: [\"X\"],\n        inputTypes: [0],\n        cacheHint: o.cacheKey\n      };\n      return [i.run({\n        ...t,\n        get: () => sc(e, t, !1, o)\n      }, e)];\n    }, ac = i => {\n      let e = i.attributes.getString(\"auto_pad\", \"NOTSET\"),\n        o = i.attributes.getInt(\"ceil_mode\", 0),\n        t = i.attributes.getInts(\"kernel_shape\"),\n        r = i.attributes.getInts(\"strides\", []),\n        n = i.attributes.getInts(\"pads\", []),\n        s = i.attributes.getInt(\"storage_order\", 0),\n        a = i.attributes.getInts(\"dilations\", []);\n      if (s !== 0) throw new Error(\"column major storage order is not yet supported for MaxPool\");\n      if (o !== 0) throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");\n      return W({\n        autoPad: e,\n        ceilMode: o,\n        countIncludePad: !1,\n        kernelShape: t,\n        strides: r,\n        pads: n,\n        storageOrder: s,\n        dilations: a\n      });\n    }, sc = (i, e, o, t) => {\n      let [r, n] = uc(i, t, o),\n        s = `\n      value = max(_X(x), value);\n    `,\n        a = \"\",\n        l = `\n      ${fc(i[0].dims, r, s, a, \"-1e5\")}\n    `;\n      return {\n        ...e,\n        output: {\n          dims: n,\n          type: i[0].type,\n          textureType: 0\n        },\n        shaderSource: l\n      };\n    }, uc = (i, e, o) => {\n      let t = i[0].dims.slice(),\n        r = Object.hasOwnProperty.call(e, \"dilations\"),\n        n = e.kernelShape.slice(),\n        s = e.strides.slice(),\n        a = r ? e.dilations.slice() : [],\n        u = e.pads.slice();\n      Ue.adjustPoolAttributes(o, t, n, s, a, u);\n      let l = Ue.computePoolOutputShape(o, t, s, a, n, u, e.autoPad),\n        f = Object.assign({}, e);\n      return r ? Object.assign(f, {\n        kernelShape: n,\n        strides: s,\n        pads: u,\n        dilations: a,\n        cacheKey: e.cacheKey\n      }) : Object.assign(f, {\n        kernelShape: n,\n        strides: s,\n        pads: u,\n        cacheKey: e.cacheKey\n      }), [f, l];\n    }, Gb = {\n      autoPad: \"\",\n      ceilMode: 0,\n      countIncludePad: !1,\n      kernelShape: [],\n      strides: [],\n      pads: [],\n      storageOrder: 0,\n      dilations: [],\n      cacheKey: \"\"\n    }, Qf = {\n      name: \"GlobalMaxPool\",\n      inputNames: [\"X\"],\n      inputTypes: [0]\n    }, lc = (i, e) => (Gn(e), [i.run({\n      ...Qf,\n      get: () => sc(e, Qf, !0, Gb)\n    }, e)]), Gn = i => {\n      if (!i || i.length !== 1) throw new Error(\"Pool ops requires 1 input.\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\") throw new Error(\"Invalid input type.\");\n    }, fc = (i, e, o, t, r) => {\n      let n = i.length;\n      if (e.kernelShape.length <= 2) {\n        let s = e.kernelShape[e.kernelShape.length - 1],\n          a = e.strides[e.strides.length - 1],\n          u = e.pads[e.pads.length / 2 - 1],\n          l = e.pads[e.pads.length - 1],\n          f = i[n - 1],\n          p = \"\",\n          d = \"\",\n          y = \"\";\n        if (u + l !== 0 ? p = `\n          for (int i = 0; i < ${s}; i++) {\n            x[${n} - 1] = indices[${n} - 1] * ${a} - ${u} + i;\n            if (x[${n} - 1] < 0 || x[${n} - 1] >= ${f}) {\n              pad++;\n              continue;\n            }\n            ${o}\n          }` : p = `\n          for (int i = 0; i < ${s}; i++) {\n            x[${n} - 1] = indices[${n} - 1] * ${a} - ${u} + i;\n            ${o}\n          }`, e.kernelShape.length === 2) {\n          let v = e.kernelShape[e.kernelShape.length - 2],\n            S = e.strides[e.strides.length - 2],\n            L = e.pads[e.pads.length / 2 - 2],\n            P = e.pads[e.pads.length - 2],\n            A = i[n - 2];\n          L + P !== 0 ? d = `\n            for (int j = 0; j < ${v}; j++) {\n              x[${n} - 2] = indices[${n} - 2] * ${S} - ${L} + j;\n              if (x[${n} - 2] < 0 || x[${n} - 2] >= ${A}) {\n                pad+= ${s};\n                continue;\n              }\n          ` : d = `\n            for (int j = 0; j < ${v}; j++) {\n              x[${n} - 2] = indices[${n} - 2] * ${S} - ${L} + j;\n            `, y = `\n          }\n        `;\n        }\n        return `\n        float process(int indices[${n}]) {\n          int x[${n}];\n          copyVec(indices, x);\n\n          float value = ${r};\n          int pad = 0;\n          ${d}\n          ${p}\n          ${y}\n          ${t}\n          return value;\n        }\n      `;\n      } else {\n        let s = B.size(e.kernelShape),\n          a = B.computeStrides(e.kernelShape),\n          u = a.length,\n          l = e.pads.length,\n          f = Mb(u),\n          p = Rn(i, \"inputDims\"),\n          d = Rn(e.pads, \"pads\"),\n          y = Rn(a, \"kernelStrides\"),\n          T = Rn(e.strides, \"strides\"),\n          v = e.pads.reduce((P, A) => P + A),\n          S = \"\";\n        return v ? S = `\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${o}\n          }` : S = `\n          }\n          ${o}\n        `, `\n        ${f}\n        float process(int indices[${n}]) {\n          int x[${n}];\n          copyVec(indices, x);\n          int offset[${u}];\n          int pads[${l}];\n          int inputDims[${n}];\n          int kernelStrides[${u}];\n          int strides[${u}];\n          ${d}\n          ${p}\n          ${T}\n          ${y}\n\n          float value = ${r};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${s}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${n} - ${u}; j < ${n}; j++) {\n              x[j] = indices[j] * strides[j - ${n} + ${u}]\n                + offset[j - ${n} + ${u}] - pads[j - 2];\n              ${S}\n          }\n          ${t}\n\n          return value;\n        }\n      `;\n      }\n    }, Rn = (i, e) => {\n      let o = \"\";\n      for (let t = 0; t < i.length; t++) o += `\n      ${e}[${t}] = ${i[t]};\n    `;\n      return o;\n    }, Mb = i => `\n  void offsetToIndices(int offset, int[${i}] strides, out int[${i}] indices) {\n    if (${i} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${i} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${i} - 1] = offset;\n  }`;\n  });\nvar Xe,\n  Ee,\n  Ub,\n  Vb,\n  pc,\n  dc,\n  hc,\n  mc,\n  bc,\n  gc,\n  yc,\n  xc = O(() => {\n    \"use strict\";\n\n    It();\n    Rr();\n    Y();\n    j();\n    Xe = (i, e, o, t, r) => {\n      Vb(e);\n      let n = {\n        name: t,\n        inputNames: [\"A\"],\n        inputTypes: [0]\n      };\n      return [i.run({\n        ...n,\n        cacheHint: o.cacheKey,\n        get: () => Ub(i, e, o, t, r, n)\n      }, e)];\n    }, Ee = i => {\n      let e = i.attributes.getInts(\"axes\", []),\n        o = i.attributes.getInt(\"keepdims\", 1) === 1;\n      return W({\n        axes: e,\n        keepDims: o\n      });\n    }, Ub = (i, e, o, t, r, n) => {\n      let s = [],\n        a = e[0].dims.length || 1,\n        u = [],\n        l = B.normalizeAxes(o.axes, e[0].dims.length),\n        f = r(e, l),\n        p = f[1];\n      for (let T = 0; T < e[0].dims.length; T++) l.indexOf(T) >= 0 || l.length === 0 ? (o.keepDims && s.push(1), p = `\n          for(int j${T} = 0; j${T} < ${e[0].dims[T]}; j${T}++) {\n            inputIdx[${T}] = j${T};\n            ${p}\n          }`) : (u.push(`inputIdx[${T}] = outputIdx[${s.length}];`), s.push(e[0].dims[T]));\n      let y = `\n      float process(int outputIdx[${s.length || 1}]) {\n        float value;                 // final result\n        int inputIdx[${a}];      // addressing input data\n        ${u.join(`\n`)}\n        ${f[0]}       // init ops for reduce max/min\n        ${p}\n        ${f[2]}       // final computation for reduce mean\n        return value;\n      }`;\n      return {\n        ...n,\n        output: {\n          dims: s,\n          type: e[0].type,\n          textureType: 0\n        },\n        shaderSource: y\n      };\n    }, Vb = i => {\n      if (!i || i.length !== 1) throw new Error(\"Reduce op requires 1 input.\");\n      if (Pe.indexOf(i[0].type) === -1) throw new Error(\"Invalid input type.\");\n    }, pc = (i, e, o) => Xe(i, e, o, \"ReduceSum\", () => [\"value = 0.0;\", \"value += _A(inputIdx);\", \"\"]), dc = (i, e, o) => Xe(i, e, o, \"ReduceMean\", (r, n) => {\n      let s = 1;\n      for (let a = 0; a < r[0].dims.length; a++) (n.indexOf(a) >= 0 || n.length === 0) && (s *= r[0].dims[a]);\n      return [\"value = 0.0;\", \"value += _A(inputIdx);\", `value /= ${s}.;`];\n    }), hc = (i, e, o) => Xe(i, e, o, \"ReduceMax\", (r, n) => {\n      let s = [];\n      for (let a = 0; a < r[0].dims.length; a++) (n.indexOf(a) >= 0 || n.length === 0) && s.push(`inputIdx[${a}] = 0;`);\n      return [`${s.join(`\n`)}\nvalue = _A(inputIdx);`, \"value = max(value, _A(inputIdx));\", \"\"];\n    }), mc = (i, e, o) => Xe(i, e, o, \"ReduceMin\", (r, n) => {\n      let s = [];\n      for (let a = 0; a < r[0].dims.length; a++) (n.indexOf(a) >= 0 || n.length === 0) && s.push(`inputIdx[${a}] = 0;`);\n      return [`${s.join(`\n`)}\nvalue = _A(inputIdx);`, \"value = min(value, _A(inputIdx));\", \"\"];\n    }), bc = (i, e, o) => Xe(i, e, o, \"ReduceProd\", () => [\"value = 1.0;\", \"value *= _A(inputIdx);\", \"\"]), gc = (i, e, o) => Xe(i, e, o, \"ReduceLogSum\", () => [\"value = 0.0;\", \"value += _A(inputIdx);\", \"value = log(value);\"]), yc = (i, e, o) => Xe(i, e, o, \"ReduceLogSumSquare\", () => [\"float t; value = 0.0;\", \"t = _A(inputIdx); value += t * t;\", \"\"]);\n  });\nvar Tc,\n  wc = O(() => {\n    \"use strict\";\n\n    Y();\n    Tc = (i, e) => {\n      let o = B.calculateReshapedDims(e[0].dims, e[1].integerData);\n      return i.session.pack ? [i.reshapePacked(e[0], o)] : [i.reshapeUnpacked(e[0], o)];\n    };\n  });\nvar vc,\n  Ei,\n  Ic,\n  _c,\n  Gr,\n  zb,\n  Di,\n  Mn,\n  Li = O(() => {\n    \"use strict\";\n\n    It();\n    ut();\n    j();\n    vc = {\n      name: \"Upsample\",\n      inputNames: [\"X\"],\n      inputTypes: [0]\n    }, Ei = (i, e, o) => (Di(e, o), [i.run({\n      ...vc,\n      cacheHint: o.cacheKey,\n      get: () => zb(i, e, o)\n    }, e)]), Ic = i => Gr(i, 7), _c = i => Gr(i, 9), Gr = (i, e) => {\n      let o = e >= 10,\n        t = i.attributes.getString(\"mode\", \"nearest\");\n      if (t !== \"nearest\" && t !== \"linear\" && (e < 11 || t !== \"cubic\")) throw new Error(`unrecognized mode: ${t}`);\n      let r = [];\n      e < 9 && (r = i.attributes.getFloats(\"scales\"), Mn(r, t, o));\n      let n = i.attributes.getFloat(\"extrapolation_value\", 0),\n        s = e > 10 ? i.attributes.getString(\"coordinate_transformation_mode\", \"half_pixel\") : \"asymmetric\";\n      if ([\"asymmetric\", \"pytorch_half_pixel\", \"tf_half_pixel_for_nn\", \"align_corners\", \"tf_crop_and_resize\", \"half_pixel\"].indexOf(s) === -1) throw new Error(`coordinate_transform_mode '${s}' is not supported`);\n      let a = s === \"tf_crop_and_resize\",\n        u = a,\n        l = t === \"nearest\" && e >= 11 ? i.attributes.getString(\"nearest_mode\", \"round_prefer_floor\") : \"\";\n      if ([\"round_prefer_floor\", \"round_prefer_ceil\", \"floor\", \"ceil\", \"\"].indexOf(l) === -1) throw new Error(`nearest_mode '${l}' is not supported`);\n      let f = i.attributes.getFloat(\"cubic_coeff_a\", -.75),\n        p = i.attributes.getInt(\"exclude_outside\", 0) !== 0;\n      if (p && t !== \"cubic\") throw new Error(\"exclude_outside can be set to 1 only when mode is CUBIC.\");\n      let d = e < 11 ? !0 : t === \"nearest\" && s === \"asymmetric\" && l === \"floor\",\n        y = 0,\n        T = 0,\n        v = 0;\n      return e > 10 ? i.inputs.length > 2 ? (y = 1, T = 2, v = 3) : (T = 1, v = 2) : e === 9 && (T = 1), W({\n        opset: e,\n        isResize: o,\n        mode: t,\n        scales: r,\n        extrapolationValue: n,\n        coordinateTransformMode: s,\n        useExtrapolation: u,\n        needRoiInput: a,\n        nearestMode: l,\n        cubicCoefficientA: f,\n        excludeOutside: p,\n        useNearest2xOptimization: d,\n        roiInputIdx: y,\n        scalesInputIdx: T,\n        sizesInputIdx: v\n      });\n    }, zb = (i, e, o) => {\n      let t = G(i.session.backend.glContext.version),\n        [r, n] = i.calculateTextureWidthAndHeight(e[0].dims, 0),\n        s = e[0].dims.map((v, S) => Math.floor(v * o.scales[S])),\n        [a, u] = i.calculateTextureWidthAndHeight(s, 0),\n        l = s.length,\n        f = new Array(l),\n        p = new Array(l),\n        d = `\n      int output_pitches[${l}];\n      int input_pitches[${l}];\n      `;\n      for (let v = l - 1; v >= 0; v--) f[v] = v === l - 1 ? 1 : f[v + 1] * s[v + 1], p[v] = v === l - 1 ? 1 : p[v + 1] * e[0].dims[v + 1], d += `\n        output_pitches[${v}] = ${f[v]};\n        input_pitches[${v}] = ${p[v]};\n        `;\n      let y = `\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${r}, ${n});\n        float value = getColorAsFloat(${t.texture2D}(X, coords));\n        return value;\n      }\n      `,\n        T = o.mode === \"nearest\" ? `\n    ${y}\n    float process(int indices[${l}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${a}, ${u});\n\n      ${d}\n\n      int d, m;\n      for (int dim = 0; dim < ${l}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }` : l === 4 ? `\n    ${y}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${a}, ${u});\n\n      ${d}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }` : `\n    ${y}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${a}, ${u});\n\n      ${d}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;\n      return {\n        ...vc,\n        output: {\n          dims: s,\n          type: e[0].type,\n          textureType: 0\n        },\n        shaderSource: T,\n        variables: [{\n          name: \"scales\",\n          type: \"int\",\n          arrayLength: o.scales.length,\n          data: o.scales.map(v => Math.ceil(v))\n        }]\n      };\n    }, Di = (i, e) => {\n      if (!i || e.opset < 9 && i.length !== 1 || e.opset >= 9 && e.opset < 11 && i.length !== 2 || e.opset >= 11 && i.length < 2) throw new Error(\"invalid inputs.\");\n      if (e.scales.length > 0 && i[0].dims.length !== e.scales.length) throw new Error(\"Invalid input shape.\");\n      if (i[0].type === \"string\") throw new Error(\"Invalid input tensor types.\");\n    }, Mn = (i, e, o) => {\n      if (o) {\n        for (let t of i) if (t <= 0) throw new Error(\"Scale value should be greater than 0.\");\n      } else for (let t of i) if (t < 1) throw new Error(\"Scale value should be greater than or equal to 1.\");\n      if ((e === \"linear\" || e === \"cubic\") && i.length !== 2 && (i.length !== 4 || i[0] !== 1 || i[1] !== 1)) throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${o ? \"Resize\" : \"Upsample\"} opeartor.`);\n    };\n  });\nvar $i,\n  ki,\n  Oc,\n  Sc,\n  Wb,\n  Hb,\n  qb,\n  jb,\n  Ac = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    pe();\n    He();\n    Li();\n    $i = {\n      name: \"Resize\",\n      inputNames: [\"A\"],\n      inputTypes: [2]\n    }, ki = (i, e, o) => (Di(e, o), [i.run({\n      ...$i,\n      cacheHint: o.cacheKey,\n      get: () => Wb(i, e, o)\n    }, e)]), Oc = i => Gr(i, 10), Sc = i => Gr(i, 11), Wb = (i, e, o) => {\n      let t = G(i.session.backend.glContext.version),\n        [r, n] = Hb(e, o);\n      if (r.every(A => A === 1) && o.coordinateTransformMode !== \"tf_crop_and_resize\") return {\n        ...$i,\n        output: {\n          dims: n,\n          type: e[0].type,\n          textureType: 2\n        },\n        hasMain: !0,\n        shaderSource: `void main() {\n                    vec4 v = ${t.texture2D}(X, TexCoords);\n                    ${t.output} = v;\n                }`\n      };\n      let a = n.length;\n      if (a < 2) throw new Error(`output dimension should be at least 2, but got ${a}`);\n      let u = n[a - 2],\n        l = n[a - 1],\n        f = e[0].dims;\n      if (a !== f.length) throw new Error(`output dimension should match input ${f.length}, but got ${a}`);\n      let p = f[a - 2],\n        d = f[a - 1],\n        y = r[a - 2],\n        T = r[a - 1],\n        v = \"\";\n      if (o.mode !== \"linear\") throw new Error(`resize (packed) does not support mode: '${o.mode}'`);\n      switch (o.coordinateTransformMode) {\n        case \"asymmetric\":\n          v = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                `;\n          break;\n        case \"half_pixel\":\n          v = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                `;\n          break;\n        case \"pytorch_half_pixel\":\n          v = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${l}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${u}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${l}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${u}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;\n          break;\n        case \"align_corners\":\n          v = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${l}.0 - 1.0, ${u}.0 - 1.0, ${l}.0 - 1.0,\n                            ${u}.0 - 1.0);\n                        vec4 original = vec4(${d}.0 - 1.0, ${p}.0 - 1.0, ${d}.0 - 1.0,\n                            ${p}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;\n          break;\n        default:\n          throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${o.coordinateTransformMode}'`);\n      }\n      let S = Bt(a),\n        L = de(),\n        P = `\n            const vec2 inputWH = vec2(${p}.0, ${d}.0);\n            const vec4 scaleWHWH = vec4(float(${y}), float(${T}), float(${y}), float(${T}));\n            ${L}\n            ${v}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${S} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${u - 1};\n                bool hasNextCol = rc.z < ${l - 1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${t.output} = vec4(newValue);\n            }\n        `;\n      return {\n        ...$i,\n        output: {\n          dims: n,\n          type: e[0].type,\n          textureType: 2\n        },\n        hasMain: !0,\n        shaderSource: P\n      };\n    }, Hb = (i, e) => {\n      let t = i[0].dims,\n        r = e.scales,\n        n;\n      if (r.length === 0) {\n        let a = i[e.scalesInputIdx];\n        if (a && a.size !== 0) {\n          if (i[e.sizesInputIdx]) throw new Error(\"Only one of scales or sizes must be provided as input.\");\n          r = qb(a, e.mode, e.isResize);\n        } else {\n          let u = i[e.sizesInputIdx];\n          if (!u || u.size === 0) throw new Error(\"Either scales or sizes MUST be provided as input.\");\n          n = Array.from(u.integerData), r = jb(n, t, e.mode, e.isResize);\n        }\n      } else if (i[e.sizesInputIdx]) throw new Error(\"Only one of scales or sizes must be provided as input.\");\n      let s = n || t.map((a, u) => Math.floor(a * r[u]));\n      return [r, s];\n    }, qb = (i, e, o) => {\n      let t = Array.from(i.floatData);\n      return Mn(t, e, o), t;\n    }, jb = (i, e, o, t) => {\n      let r = e.length,\n        n = new Array(r);\n      for (let s = 0, a = r; s < a; s++) if (e[s] === 0) {\n        if (i[s] !== 0) throw new Error(\"Input dim is zero but required output dim is non-zero.\");\n        n[s] = 1;\n      } else n[s] = i[s] / e[s];\n      return Mn(n, o, t), n;\n    };\n  });\nvar Pc,\n  Xb,\n  Ec = O(() => {\n    \"use strict\";\n\n    We();\n    Pc = (i, e) => (Xb(e), [new bt([e[0].dims.length], \"int32\", void 0, void 0, new Int32Array(e[0].dims))]), Xb = i => {\n      if (!i || i.length !== 1) throw new Error(\"Shape requires 1 input.\");\n    };\n  });\nvar Bi,\n  Dc,\n  Lc,\n  $c,\n  Kb,\n  kc,\n  Jb,\n  Yb,\n  Bc = O(() => {\n    \"use strict\";\n\n    It();\n    Rr();\n    Y();\n    j();\n    Bi = {\n      name: \"Slice\",\n      inputNames: [\"A\"],\n      inputTypes: [0]\n    }, Dc = (i, e, o) => (Kb(e), [i.run({\n      ...Bi,\n      cacheHint: o.cacheKey,\n      get: () => $c(i, e[0], o)\n    }, e)]), Lc = i => {\n      let e = i.attributes.getInts(\"starts\"),\n        o = i.attributes.getInts(\"ends\"),\n        t = i.attributes.getInts(\"axes\", []);\n      return W({\n        starts: e,\n        ends: o,\n        axes: t\n      });\n    }, $c = (i, e, o) => {\n      let t = o.axes.length === 0 ? e.dims.slice(0).map((p, d) => d) : o.axes,\n        r = B.normalizeAxes(t, e.dims.length),\n        n = o.starts.map((p, d) => p > e.dims[r[d]] - 1 ? e.dims[r[d]] : B.normalizeAxis(p, e.dims[r[d]])),\n        s = o.ends.map((p, d) => p > e.dims[r[d]] - 1 ? e.dims[r[d]] : B.normalizeAxis(p, e.dims[r[d]])),\n        a = e.dims.slice(),\n        u = [];\n      for (let p = 0; p < r.length; p++) a[r[p]] = s[p] - n[p], n[p] > 0 && u.push(`outputIdx[${r[p]}] += ${n[p]};`);\n      let f = `\n      float process(int outputIdx[${a.length}]) {\n        ${u.join(`\n      `)}\n        return _A(outputIdx);\n      }`;\n      return {\n        ...Bi,\n        output: {\n          dims: a,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: f\n      };\n    }, Kb = i => {\n      if (!i || i.length !== 1) throw new Error(\"Slice requires 1 input.\");\n      if (Pe.indexOf(i[0].type) === -1) throw new Error(\"Invalid input type.\");\n    }, kc = (i, e) => {\n      Yb(e);\n      let o = Jb(i, e);\n      return [i.run({\n        ...Bi,\n        cacheHint: o.cacheKey,\n        get: () => $c(i, e[0], o)\n      }, [e[0]])];\n    }, Jb = (i, e) => {\n      if (!i.session.isInitializer(e[1].dataId) || !i.session.isInitializer(e[2].dataId) || e.length >= 4 && !i.session.isInitializer(e[3].dataId) || e.length >= 5 && !i.session.isInitializer(e[4].dataId)) throw new Error(\"dynamic slice attributes are not allowed\");\n      if (e.length >= 5 && e[4].integerData.some(s => s !== 1)) throw new Error(\"currently non-1 steps is not supported for Slice\");\n      let o = Array.from(e[1].integerData),\n        t = Array.from(e[2].integerData),\n        r = e.length >= 4 ? Array.from(e[3].integerData) : [],\n        n = `${r};${o};${t}`;\n      return {\n        starts: o,\n        ends: t,\n        axes: r,\n        cacheKey: n\n      };\n    }, Yb = i => {\n      if (!i || i.length < 3 || i.length > 5) throw new Error(\"Invalid input number.\");\n      if (i[1].type !== \"int32\" || i[1].dims.length !== 1) throw new Error(\"Invalid input type.\");\n      if (i[2].type !== \"int32\" || i[2].dims.length !== 1) throw new Error(\"Invalid input type.\");\n      if (i.length >= 4 && (i[3].type !== \"int32\" || i[3].dims.length !== 1)) throw new Error(\"Invalid input type.\");\n      if (i.length >= 5 && (i[4].type !== \"int32\" || i[4].dims.length !== 1)) throw new Error(\"Invalid input type.\");\n    };\n  });\nvar Fc,\n  Cc,\n  Nc,\n  Rc,\n  Gc,\n  Mc,\n  Uc,\n  Vc,\n  Zb,\n  Qb,\n  tg,\n  zc,\n  Wc = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    ut();\n    j();\n    Nn();\n    Fc = {\n      name: \"SoftmaxComputeMax\",\n      inputNames: [\"A\"],\n      inputTypes: [0]\n    }, Cc = {\n      name: \"SoftmaxComputeScale\",\n      inputNames: [\"A\", \"Max\"],\n      inputTypes: [0, 0]\n    }, Nc = {\n      name: \"SoftMax\",\n      inputNames: [\"A\", \"Max\", \"Norm\"],\n      inputTypes: [0, 0, 0]\n    }, Rc = (i, e, o) => {\n      zc(e);\n      let t = e[0].dims.slice(),\n        r = B.normalizeAxis(o.axis, t.length),\n        n = B.sizeToDimension(t, r),\n        s = B.sizeFromDimension(t, r);\n      return Vc(i, e, o, n, s);\n    }, Gc = i => W({\n      axis: i.attributes.getInt(\"axis\", 1)\n    }), Mc = i => W({\n      axis: i.attributes.getInt(\"axis\", -1)\n    }), Uc = (i, e, o) => {\n      zc(e);\n      let t = e[0].dims.slice(),\n        r = B.normalizeAxis(o.axis, t.length),\n        n = t.length,\n        s = r !== n - 1,\n        a = [],\n        u = [],\n        l = [],\n        f;\n      s && (u = Array.from({\n        length: n\n      }).map((T, v) => v), u[r] = n - 1, u[n - 1] = r, u.map(T => a.push(t[T])), f = W({\n        perm: u\n      }), l = je(i, e, f));\n      let p = s ? B.sizeToDimension(a, n - 1) : B.sizeToDimension(t, n - 1),\n        d = s ? B.sizeFromDimension(a, n - 1) : B.sizeFromDimension(t, n - 1),\n        y = Vc(i, s ? l : e, o, p, d);\n      return s ? je(i, y, f) : y;\n    }, Vc = (i, e, o, t, r) => {\n      let n = Zb(i, e[0], t, r, [t]),\n        s = i.run({\n          ...Fc,\n          cacheHint: o.cacheKey,\n          get: () => n\n        }, e),\n        a = Qb(i, e[0], t, r, n.output.dims, [t]),\n        u = i.run({\n          ...Cc,\n          cacheHint: o.cacheKey,\n          get: () => a\n        }, [e[0], s]),\n        l = tg(i, e[0], t, r, n.output.dims, a.output.dims);\n      return [i.run({\n        ...Nc,\n        cacheHint: o.cacheKey,\n        get: () => l\n      }, [e[0], s, u])];\n    }, Zb = (i, e, o, t, r) => {\n      let [n, s] = i.calculateTextureWidthAndHeight(e.dims, 0),\n        a = r.length;\n      if (o < 1 || t < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n      if (r.length !== 1) throw new Error(\"Dimensionality of the output should be 1\");\n      if (r[0] !== o) throw new Error(\"Shape of the output should be equal to logical row count\");\n      let u = G(i.session.backend.glContext.version),\n        l = `\n      float process(int[${a}] indices) {\n        int logical_row_start_offset = indices[0] * ${t};\n\n        float max = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset, ${n},\n        ${s} )));\n        for(int i=1; i<${t}; ++i)\n        {\n          float current = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${n}, ${s})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;\n      return {\n        ...Fc,\n        output: {\n          dims: r,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: l\n      };\n    }, Qb = (i, e, o, t, r, n) => {\n      let [s, a] = i.calculateTextureWidthAndHeight(e.dims, 0),\n        u = n.length;\n      if (o < 1 || t < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n      if (n.length !== 1) throw new Error(\"Dimensionality of the output should be 1\");\n      if (n[0] !== o) throw new Error(\"Shape of the output should be equal to logical row count\");\n      if (r.length !== 1) throw new Error(\"Dimensionality of the intermediate results should be 1\");\n      if (r[0] !== o) throw new Error(\"Shape of the intermediate results should be equal to logical row count\");\n      let l = G(i.session.backend.glContext.version),\n        f = `\n      float process(int[${u}] indices) {\n        int logical_row_start_offset = indices[0] * ${t};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${t}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${l.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${s}, ${a}))) - max);\n        }\n\n        return norm_factor;\n      }`;\n      return {\n        ...Cc,\n        output: {\n          dims: n,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: f\n      };\n    }, tg = (i, e, o, t, r, n) => {\n      let [s, a] = i.calculateTextureWidthAndHeight(e.dims, 0),\n        u = e.dims.length;\n      if (o < 1 || t < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n      if (r.length !== 1 || n.length !== 1) throw new Error(\"Dimensionality of the intermediate results should be 1\");\n      if (r[0] !== o || n[0] !== o) throw new Error(\"Shape of the intermediate results should be equal to logical row count\");\n      let l = `\n      float process(int[${u}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${s}, ${a});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${t};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;\n      return {\n        ...Nc,\n        output: {\n          dims: e.dims,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: l\n      };\n    }, zc = i => {\n      if (!i || i.length !== 1) throw new Error(\"Softmax requires 1 input.\");\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\") throw new Error(\"Invalid input type\");\n    };\n  });\nvar Hc,\n  qc,\n  jc,\n  eg,\n  rg,\n  ng,\n  Xc = O(() => {\n    \"use strict\";\n\n    It();\n    Y();\n    j();\n    Hc = {\n      name: \"Split\",\n      inputNames: [\"A\"],\n      inputTypes: [0]\n    }, qc = (i, e, o) => {\n      ng(e);\n      let t = B.normalizeAxis(o.axis, e[0].dims.length),\n        r = eg(i, e, t, o),\n        n = [];\n      for (let s = 0; s < r; ++s) n.push(i.run({\n        ...Hc,\n        cacheHint: `${o.cacheKey};${s}`,\n        get: () => rg(i, e[0], o, t, s)\n      }, e));\n      return n;\n    }, jc = i => {\n      let e = i.attributes.getInt(\"axis\", 0),\n        o = i.attributes.getInts(\"split\", []),\n        t = i.outputs.length;\n      return W({\n        axis: e,\n        split: o,\n        numOutputs: t\n      });\n    }, eg = (i, e, o, t) => {\n      let [, r] = $r.splitShape(e[0].dims, o, t.split, t.numOutputs);\n      return r.length;\n    }, rg = (i, e, o, t, r) => {\n      let [n, s] = $r.splitShape(e.dims, t, o.split, o.numOutputs),\n        a = s[r],\n        u = n[r],\n        f = `\n      float process(int indices[${u.length}]) {\n        indices[${t}] += ${a};\n        return _A(indices);\n      }\n    `;\n      return {\n        ...Hc,\n        cacheHint: `${o.cacheKey}:${r}`,\n        output: {\n          dims: u,\n          type: e.type,\n          textureType: 0\n        },\n        shaderSource: f\n      };\n    }, ng = i => {\n      if (!i || i.length !== 1) throw new Error(\"Split requires one input.\");\n      if (i[0].type !== \"int8\" && i[0].type !== \"uint8\" && i[0].type !== \"int16\" && i[0].type !== \"uint16\" && i[0].type !== \"int32\" && i[0].type !== \"uint32\" && i[0].type !== \"float32\" && i[0].type !== \"float64\" && i[0].type !== \"bool\") throw new Error(\"Invalid input type.\");\n    };\n  });\nvar Fi,\n  Kc,\n  Jc,\n  og,\n  ig,\n  Yc = O(() => {\n    \"use strict\";\n\n    Y();\n    Fi = (i, e, o) => {\n      og(e);\n      let t = B.squeezeShape(e[0].dims, o);\n      return [i.reshapeUnpacked(e[0], t)];\n    }, Kc = (i, e) => (ig(e), Fi(i, [e[0]], Array.from(e[1].integerData))), Jc = i => i.attributes.getInts(\"axes\"), og = i => {\n      if (!i || i.length !== 1) throw new Error(\"Squeeze requires 1 input.\");\n      if (i[0].type === \"string\") throw new Error(\"invalid input tensor types.\");\n    }, ig = i => {\n      if (!i || i.length !== 2) throw new Error(\"Squeeze requires 2 inputs.\");\n      if (i[1].type !== \"int32\") throw new Error(\"Invalid input type.\");\n    };\n  });\nvar Zc,\n  ag,\n  sg,\n  Qc = O(() => {\n    \"use strict\";\n\n    ut();\n    j();\n    Zc = (i, e) => {\n      sg(e);\n      let o = {\n        name: \"Sum\",\n        inputNames: e.map((r, n) => `X${n}`),\n        inputTypes: new Array(e.length).fill(0)\n      };\n      return [i.run({\n        ...o,\n        get: () => ag(i, e, o)\n      }, e)];\n    }, ag = (i, e, o) => {\n      let t = G(i.session.backend.glContext.version),\n        r = e[0].dims.slice(),\n        s = `\n      void main() {\n        vec4 result = ${e.map((a, u) => `${t.texture2D}(X${u},TexCoords)`).join(\" + \")};\n        ${t.output} = result;\n      }\n    `;\n      return {\n        ...o,\n        output: {\n          dims: r,\n          type: e[0].type,\n          textureType: 0\n        },\n        hasMain: !0,\n        shaderSource: s\n      };\n    }, sg = i => {\n      if (!i || i.length === 0) throw new Error(\"Sum requires inputs.\");\n      let e = i[0].dims.length;\n      for (let o = 1; o < i.length; o++) {\n        if (e !== i[o].dims.length) throw new Error(\"Input shapes are mismatched.\");\n        for (let t = 0; t < e; t++) if (i[0].dims[t] !== i[o].dims[t]) throw new Error(\"Input shapes are not matched.\");\n      }\n      if (i[0].type !== \"float32\" && i[0].type !== \"float64\") throw new Error(\"Invalid input type.\");\n      for (let o = 1; o < i.length; o++) if (i[0].type !== i[o].type) throw new Error(\"Input types are not matched.\");\n    };\n  });\nvar tp,\n  ug,\n  lg,\n  ep = O(() => {\n    \"use strict\";\n\n    Rr();\n    j();\n    tp = (i, e) => {\n      lg(e);\n      let o = {\n        name: \"Tile\",\n        inputNames: [\"A\"],\n        inputTypes: [0]\n      };\n      return [i.run({\n        ...o,\n        get: () => ug(i, e, o)\n      }, e)];\n    }, ug = (i, e, o) => {\n      let t = e[0].dims.slice(),\n        r = new Array(t.length),\n        n = [];\n      for (let u = 0; u < t.length; u++) r[u] = t[u] * e[1].numberData[u], n.push(`inputIdx[${u}] = int(mod(float(outputIdx[${u}]), ${t[u]}.));`);\n      let s = r.length,\n        a = `\n      float process(int outputIdx[${s}]) {\n        int inputIdx[${s}];\n        ${n.join(`\n`)}\n        return _A(inputIdx);\n      }\n    `;\n      return {\n        ...o,\n        output: {\n          dims: r,\n          type: e[0].type,\n          textureType: 0\n        },\n        shaderSource: a\n      };\n    }, lg = i => {\n      if (!i || i.length !== 2) throw new Error(\"Tile requires 2 input.\");\n      if (i[1].dims.length !== 1) throw new Error(\"The second input shape must 1 dimension.\");\n      if (i[1].dims[0] !== i[0].dims.length) throw new Error(\"Invalid input shape.\");\n      if (Pe.indexOf(i[0].type) === -1) throw new Error(\"Invalid input type.\");\n      if (i[1].type !== \"int32\" && i[1].type !== \"int16\") throw new Error(\"Invalid repeat type.\");\n    };\n  });\nvar Ci,\n  rp,\n  np,\n  fg,\n  cg,\n  op = O(() => {\n    \"use strict\";\n\n    Y();\n    Ci = (i, e, o) => {\n      fg(e);\n      let t = B.unsqueezeShape(e[0].dims, o);\n      return [i.reshapeUnpacked(e[0], t)];\n    }, rp = (i, e) => (cg(e), Ci(i, [e[0]], Array.from(e[1].integerData))), np = i => i.attributes.getInts(\"axes\"), fg = i => {\n      if (!i || i.length !== 1) throw new Error(\"Unsqueeze requires 1 input.\");\n      if (i[0].type === \"string\") throw new Error(\"invalid input tensor types.\");\n    }, cg = i => {\n      if (!i || i.length !== 2) throw new Error(\"Unsqueeze requires 2 inputs.\");\n      if (i[1].type !== \"int32\") throw new Error(\"Invalid input type.\");\n    };\n  });\nvar ip,\n  ap = O(() => {\n    \"use strict\";\n\n    ml();\n    Pl();\n    Ll();\n    Nl();\n    Bn();\n    wf();\n    Af();\n    Df();\n    kf();\n    Nf();\n    Mf();\n    Wf();\n    Xf();\n    Fn();\n    Zf();\n    cc();\n    xc();\n    wc();\n    Ac();\n    Ec();\n    Bc();\n    Wc();\n    Xc();\n    Yc();\n    Qc();\n    ep();\n    Nn();\n    xi();\n    op();\n    Li();\n    ip = [[\"Abs\", \"\", \"6+\", Rl], [\"Acos\", \"\", \"7+\", Gl], [\"Add\", \"\", \"7+\", bl], [\"And\", \"\", \"7+\", gl], [\"Asin\", \"\", \"7+\", Ml], [\"Atan\", \"\", \"7+\", Ul], [\"AveragePool\", \"\", \"7+\", tc, ec], [\"BatchNormalization\", \"\", \"7+\", dl, hl], [\"Cast\", \"\", \"6+\", El, Dl], [\"Ceil\", \"\", \"6+\", Wl], [\"Clip\", \"\", \"6-10\", gi, Vl], [\"Clip\", \"\", \"11+\", zl], [\"Concat\", \"\", \"4+\", Bl, Cl], [\"Conv\", \"\", \"1+\", Oi, Si], [\"ConvTranspose\", \"\", \"1+\", xf, Tf], [\"Cos\", \"\", \"7+\", Hl], [\"Div\", \"\", \"7+\", yl], [\"Dropout\", \"\", \"7+\", yi], [\"DepthToSpace\", \"\", \"1+\", Of, Sf], [\"Equal\", \"\", \"7+\", xl], [\"Elu\", \"\", \"6+\", ql, jl], [\"Exp\", \"\", \"6+\", Xl], [\"Flatten\", \"\", \"1+\", Pf, Ef], [\"Floor\", \"\", \"6+\", Kl], [\"FusedConv\", \"com.microsoft\", \"1+\", Oi, Si], [\"Gather\", \"\", \"1+\", Lf, $f], [\"Gemm\", \"\", \"7-10\", Ai, Ff], [\"Gemm\", \"\", \"11+\", Ai, Cf], [\"GlobalAveragePool\", \"\", \"1+\", nc, oc], [\"GlobalMaxPool\", \"\", \"1+\", lc], [\"Greater\", \"\", \"7+\", Tl], [\"Identity\", \"\", \"1+\", yi], [\"ImageScaler\", \"\", \"1+\", Rf, Gf], [\"InstanceNormalization\", \"\", \"6+\", Vf, zf], [\"LeakyRelu\", \"\", \"6+\", Jl, Yl], [\"Less\", \"\", \"7+\", wl], [\"LRN\", \"\", \"1+\", Hf, qf], [\"Log\", \"\", \"6+\", Zl], [\"MatMul\", \"\", \"1+\", pf, df], [\"MaxPool\", \"\", \"1+\", ic, ac], [\"Mul\", \"\", \"7+\", vl], [\"Neg\", \"\", \"6+\", Ql], [\"Not\", \"\", \"1+\", tf], [\"Or\", \"\", \"7+\", Il], [\"Pad\", \"\", \"2-10\", Pi, Kf], [\"Pad\", \"\", \"11+\", Jf, Yf], [\"Pow\", \"\", \"7+\", _l], [\"PRelu\", \"\", \"7+\", Ol], [\"ReduceLogSum\", \"\", \"1+\", gc, Ee], [\"ReduceMax\", \"\", \"1+\", hc, Ee], [\"ReduceMean\", \"\", \"1+\", dc, Ee], [\"ReduceMin\", \"\", \"1+\", mc, Ee], [\"ReduceProd\", \"\", \"1+\", bc, Ee], [\"ReduceSum\", \"\", \"1-12\", pc, Ee], [\"ReduceSumSquare\", \"\", \"1+\", yc, Ee], [\"Relu\", \"\", \"6+\", ef], [\"Reshape\", \"\", \"5+\", Tc], [\"Resize\", \"\", \"10\", ki, Oc], [\"Resize\", \"\", \"11+\", ki, Sc], [\"Shape\", \"\", \"1+\", Pc], [\"Sigmoid\", \"\", \"6+\", rf], [\"Sin\", \"\", \"7+\", nf], [\"Slice\", \"\", \"10+\", kc], [\"Slice\", \"\", \"1-9\", Dc, Lc], [\"Softmax\", \"\", \"1-12\", Rc, Gc], [\"Softmax\", \"\", \"13+\", Uc, Mc], [\"Split\", \"\", \"2-12\", qc, jc], [\"Sqrt\", \"\", \"6+\", of], [\"Squeeze\", \"\", \"1-12\", Fi, Jc], [\"Squeeze\", \"\", \"13+\", Kc], [\"Sub\", \"\", \"7+\", Sl], [\"Sum\", \"\", \"6+\", Zc], [\"Tan\", \"\", \"7+\", af], [\"Tanh\", \"\", \"6+\", sf], [\"Tile\", \"\", \"6+\", tp], [\"Transpose\", \"\", \"1+\", je, If], [\"Upsample\", \"\", \"7-8\", Ei, Ic], [\"Upsample\", \"\", \"9\", Ei, _c], [\"Unsqueeze\", \"\", \"1-12\", Ci, np], [\"Unsqueeze\", \"\", \"13+\", rp], [\"Xor\", \"\", \"7+\", Al]];\n  });\nfunction up(i) {\n  let e = {},\n    o;\n  for (; (o = sp.exec(i)) !== null;) {\n    let t = o[3].split(\",\").map(r => {\n      let n = r.trim().split(\" \");\n      return n && n.length === 2 ? {\n        type: n[0],\n        name: n[1]\n      } : null;\n    }).filter(r => r !== null);\n    e[o[2]] = {\n      params: t,\n      body: o[4]\n    };\n  }\n  for (let t in e) {\n    let r = pg.replace(\"__FUNC__\", t),\n      n = new RegExp(r, \"gm\");\n    for (; (o = n.exec(i)) !== null;) {\n      let s = o[1],\n        a = o[2],\n        u = o[3].split(\",\"),\n        l = s ? `${s} ${a};` : \"\",\n        f = e[t].body,\n        p = \"\";\n      e[t].params.forEach((y, T) => {\n        y && (p += `${y.type} ${y.name} = ${u[T]};\n`);\n      }), f = `${p}\n ${f}`, f = f.replace(\"return\", `${a} = `);\n      let d = `\n      ${l}\n      {\n        ${f}\n      }\n      `;\n      i = i.replace(o[0], d);\n    }\n  }\n  return i = i.replace(sp, \"\"), i;\n}\nvar sp,\n  pg,\n  lp = O(() => {\n    \"use strict\";\n\n    sp = /@inline[\\s\\n\\r]+(\\w+)[\\s\\n\\r]+([0-9a-zA-Z_]+)\\s*\\(([^)]*)\\)\\s*{(([^}]|[\\n\\r])*)}/gm, pg = \"(\\\\w+)?\\\\s+([_0-9a-zA-Z]+)\\\\s+=\\\\s+__FUNC__\\\\((.*)\\\\)\\\\s*;\";\n  });\nfunction hr(i, e) {\n  let o = [],\n    t = [],\n    r = e != null && Array.isArray(e) && e.length === 0,\n    n = e == null || r ? null : dg(e, i).sort(),\n    s = 0;\n  for (let a = 0; a < i.length; ++a) {\n    if (n != null) {\n      if (n[s] === a && i[a] !== 1) throw new Error(`Can't squeeze axis ${a} since its dim '${i[a]}' is not 1`);\n      (n[s] == null || n[s] > a) && i[a] === 1 && (o.push(i[a]), t.push(a)), n[s] <= a && s++;\n    }\n    i[a] !== 1 && (o.push(i[a]), t.push(a));\n  }\n  return {\n    newShape: o,\n    keptDims: t\n  };\n}\nfunction dg(i, e) {\n  let o = e.length;\n  return i = i == null ? e.map((t, r) => r) : [].concat(i), ur(i.every(t => t >= -o && t < o), () => `All values in axis param must be in range [-${o}, ${o}) but got axis ${i}`), ur(i.every(hg), () => `All values in axis param must be integers but got axis ${i}`), i.map(t => t < 0 ? o + t : t);\n}\nfunction hg(i) {\n  return i % 1 === 0;\n}\nfunction mg(i) {\n  if (i.length === 0) return 1;\n  let e = i[0];\n  for (let o = 1; o < i.length; o++) e *= i[o];\n  return e;\n}\nfunction fp(i) {\n  let e = Math.ceil(Math.sqrt(i));\n  return [e, Math.ceil(i / e)];\n}\nvar Un,\n  Ni = O(() => {\n    \"use strict\";\n\n    Ut();\n    Y();\n    Un = class {\n      constructor(e) {\n        this.maxTextureSize = e;\n      }\n      computeTextureWH(e, o) {\n        let t = this.computeTexture(e, o);\n        return o && o.isPacked && (t[0] /= 2, t[1] /= 2), o && o.reverseWH ? [t[1], t[0]] : t;\n      }\n      computeTexture(e, o) {\n        let t = o && o.isPacked;\n        if (e.length === 0) return t ? [2, 2] : [1, 1];\n        let r = this.maxTextureSize;\n        if (o && o.breakAxis !== void 0) {\n          let a = o.breakAxis >= e.length ? 1 : e.slice(o.breakAxis).reduce((l, f) => l * f),\n            u = o.breakAxis <= 0 ? 1 : e.slice(0, o.breakAxis).reduce((l, f) => l * f);\n          if (a > r || u > r) tt.verbose(\"TextureLayout\", `Given width/height preferences were unattainable: shape:${e}, breakAxis:${o.breakAxis}`);else return [a, u];\n        }\n        let n = e.slice(0);\n        t && (r = r * 2, n = n.map((a, u) => u >= n.length - 2 ? n[u] % 2 === 0 ? n[u] : n[u] + 1 : n[u]), n.length === 1 && (n = [2, n[0]])), n.length !== 2 && (n = hr(n).newShape);\n        let s = mg(n);\n        return n.length <= 1 && s <= r ? [1, s] : n.length === 2 && n[0] <= r && n[1] <= r ? n : n.length === 3 && n[0] * n[1] <= r && n[2] <= r ? [n[0] * n[1], n[2]] : n.length === 3 && n[0] <= r && n[1] * n[2] <= r ? [n[0], n[1] * n[2]] : n.length === 4 && n[0] * n[1] * n[2] <= r && n[3] <= r ? [n[0] * n[1] * n[2], n[3]] : n.length === 4 && n[0] <= r && n[1] * n[2] * n[3] <= r ? [n[0], n[1] * n[2] * n[3]] : t ? fp(s / 4).map(a => a * 2) : fp(s);\n      }\n    };\n  });\nvar Vn,\n  cp = O(() => {\n    \"use strict\";\n\n    Y();\n    Te();\n    ut();\n    Ni();\n    pe();\n    Vn = class extends Ht {\n      constructor(o) {\n        super(o);\n      }\n      getFunctions() {\n        return {\n          ...this.offsetToCoords(),\n          ...this.coordsToOffset(),\n          ...this.toVec(),\n          ...this.valueFrom(),\n          ...this.getCommonUtilFuncs(),\n          ...this.getInputsSamplingSnippets(),\n          ...this.getOutputSamplingSnippet()\n        };\n      }\n      getCustomTypes() {\n        return {};\n      }\n      offsetToCoords() {\n        let o = \"offsetToCoords\";\n        return {\n          offsetToCoords: new k(`\n      vec2 ${o}(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      `)\n        };\n      }\n      coordsToOffset() {\n        let o = \"coordsToOffset\";\n        return {\n          coordsToOffset: new k(`\n      int ${o}(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      `)\n        };\n      }\n      getOutputSamplingSnippet() {\n        let o = this.context.outputTextureLayout;\n        return o.isPacked ? this.getPackedOutputSamplingSnippet(o) : this.getUnpackedOutputSamplingSnippet(o);\n      }\n      getPackedOutputSamplingSnippet(o) {\n        let t = o.unpackedShape,\n          r = [o.width, o.height],\n          n = {},\n          s = \"getOutputCoords\";\n        switch (t.length) {\n          case 0:\n            n[s] = this.getOutputScalarCoords();\n            break;\n          case 1:\n            n[s] = this.getOutputPacked1DCoords(t, r);\n            break;\n          case 2:\n            n[s] = this.getOutputPacked2DCoords(t, r);\n            break;\n          case 3:\n            n[s] = this.getOutputPacked3DCoords(t, r);\n            break;\n          default:\n            n[s] = this.getOutputPackedNDCoords(t, r);\n        }\n        let u = `\n      void setOutput(vec4 val) {\n        ${G(this.context.glContext.version).output} = val;\n      }\n    `,\n          l = \"floatTextureSetRGBA\";\n        return n[l] = new k(u), n;\n      }\n      getUnpackedOutputSamplingSnippet(o) {\n        let t = o.unpackedShape,\n          r = [o.width, o.height],\n          n = {},\n          s = \"getOutputCoords\";\n        switch (t.length) {\n          case 0:\n            n[s] = this.getOutputScalarCoords();\n            break;\n          case 1:\n            n[s] = this.getOutputUnpacked1DCoords(t, r);\n            break;\n          case 2:\n            n[s] = this.getOutputUnpacked2DCoords(t, r);\n            break;\n          case 3:\n            n[s] = this.getOutputUnpacked3DCoords(t, r);\n            break;\n          case 4:\n            n[s] = this.getOutputUnpacked4DCoords(t, r);\n            break;\n          case 5:\n            n[s] = this.getOutputUnpacked5DCoords(t, r);\n            break;\n          case 6:\n            n[s] = this.getOutputUnpacked6DCoords(t, r);\n            break;\n          default:\n            throw new Error(`Unsupported output dimensionality: ${t.length}`);\n        }\n        let u = `\n        void setOutput(float val) {\n          ${G(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `,\n          l = \"floatTextureSetR\";\n        return n[l] = new k(u), n;\n      }\n      getOutputScalarCoords() {\n        return new k(`\n      int getOutputCoords() {\n        return 0;\n      }\n    `);\n      }\n      getOutputPacked1DCoords(o, t) {\n        let r = t,\n          n = \"\";\n        return r[0] === 1 ? (n = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${r[1]}.0);\n          }\n        `, new k(n)) : r[1] === 1 ? (n = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${r[0]}.0);\n          }\n        `, new k(n)) : (n = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${r[0]}, ${r[1]}));\n          return 2 * (resTexRC.y * ${r[0]} + resTexRC.x);\n        }\n      `, new k(n));\n      }\n      getOutputPacked2DCoords(o, t) {\n        let r = \"\";\n        if (Me.arraysEqual(o, t)) return r = `\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));\n        }\n      `, new k(r);\n        let n = t,\n          s = Math.ceil(o[1] / 2);\n        return r = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${n[0]}, ${n[1]}));\n\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${s}) * 2;\n          int c = 2 * (index / ${s});\n\n          return ivec2(r, c);\n        }\n      `, new k(r);\n      }\n      getOutputPacked3DCoords(o, t) {\n        let r = [t[0], t[1]],\n          n = Math.ceil(o[2] / 2),\n          s = n * Math.ceil(o[1] / 2),\n          a = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${r[0]}, ${r[1]}));\n          int index = resTexRC.y * ${r[0]} + resTexRC.x;\n\n          int b = index / ${s};\n          index -= b * ${s};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${n}) * 2;\n          int c = 2 * (index / ${n});\n\n          return ivec3(b, r, c);\n        }\n      `;\n        return new k(a);\n      }\n      getOutputPackedNDCoords(o, t) {\n        let r = [t[0], t[1]],\n          n = Math.ceil(o[o.length - 1] / 2),\n          s = n * Math.ceil(o[o.length - 2] / 2),\n          a = s,\n          u = \"\",\n          l = \"b, r, c\";\n        for (let p = 2; p < o.length - 1; p++) a *= o[o.length - p - 1], u = `\n      int b${p} = index / ${a};\n      index -= b${p} * ${a};\n    ` + u, l = `b${p}, ` + l;\n        let f = `\n      ivec${o.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${r[0]}, ${r[1]}));\n        int index = resTexRC.y * ${r[0]} + resTexRC.x;\n\n        ${u}\n\n        int b = index / ${s};\n        index -= b * ${s};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${n}) * 2;\n        int c = 2 * (index / ${n});\n\n        return ivec${o.length}(${l});\n      }\n    `;\n        return new k(f);\n      }\n      getOutputUnpacked1DCoords(o, t) {\n        let r = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          return resTexRC.y * ${t[0]} + resTexRC.x;\n        }\n      `;\n        return new k(r);\n      }\n      getOutputUnpacked2DCoords(o, t) {\n        let r = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          int r = index / ${o[1]};\n          int c = index - r * ${o[1]};\n          return ivec2(r, c);\n        }\n      `;\n        return new k(r);\n      }\n      getOutputUnpacked3DCoords(o, t) {\n        let r = \"\",\n          n = o.length,\n          s = null;\n        n < 2 && (s = []), s = new Array(n - 1), s[n - 2] = o[n - 1];\n        for (let l = n - 3; l >= 0; --l) s[l] = s[l + 1] * o[l + 1];\n        let a = [\"r\", \"c\", \"d\"],\n          u = s.map((l, f) => {\n            let p = `int ${a[f]} = index / ${l}`,\n              d = f === s.length - 1 ? `int ${a[f + 1]} = index - ${a[f]} * ${l}` : `index -= ${a[f]} * ${l}`;\n            return `${p}; ${d};`;\n          }).join(\"\");\n        return r = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${u}\n          return ivec3(r, c, d);\n        }\n      `, new k(r);\n      }\n      getOutputUnpacked4DCoords(o, t) {\n        let r = \"\",\n          n = o.length,\n          s = null;\n        n < 2 && (s = []), s = new Array(n - 1), s[n - 2] = o[n - 1];\n        for (let l = n - 3; l >= 0; --l) s[l] = s[l + 1] * o[l + 1];\n        let a = [\"r\", \"c\", \"d\", \"d2\"],\n          u = s.map((l, f) => {\n            let p = `int ${a[f]} = index / ${l}`,\n              d = f === s.length - 1 ? `int ${a[f + 1]} = index - ${a[f]} * ${l}` : `index -= ${a[f]} * ${l}`;\n            return `${p}; ${d};`;\n          }).join(\"\");\n        return r = `\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${u}\n          return ivec4(r, c, d, d2);\n        }\n      `, new k(r);\n      }\n      getOutputUnpacked5DCoords(o, t) {\n        let r = \"\",\n          n = o.length,\n          s = null;\n        n < 2 && (s = []), s = new Array(n - 1), s[n - 2] = o[n - 1];\n        for (let l = n - 3; l >= 0; --l) s[l] = s[l + 1] * o[l + 1];\n        let a = [\"r\", \"c\", \"d\", \"d2\", \"d3\"],\n          u = s.map((l, f) => {\n            let p = `int ${a[f]} = index / ${l}`,\n              d = f === s.length - 1 ? `int ${a[f + 1]} = index - ${a[f]} * ${l}` : `index -= ${a[f]} * ${l}`;\n            return `${p}; ${d};`;\n          }).join(\"\");\n        return r = `\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${u}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `, new k(r);\n      }\n      getOutputUnpacked6DCoords(o, t) {\n        let r = \"\",\n          n = o.length,\n          s = null;\n        n < 2 && (s = []), s = new Array(n - 1), s[n - 2] = o[n - 1];\n        for (let l = n - 3; l >= 0; --l) s[l] = s[l + 1] * o[l + 1];\n        let a = [\"r\", \"c\", \"d\", \"d2\", \"d3\", \"d4\"],\n          u = s.map((l, f) => {\n            let p = `int ${a[f]} = index / ${l}`,\n              d = f === s.length - 1 ? `int ${a[f + 1]} = index - ${a[f]} * ${l}` : `index -= ${a[f]} * ${l}`;\n            return `${p}; ${d};`;\n          }).join(\"\");\n        return r = `\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${t[0]}, ${t[1]}));\n         int index = resTexRC.y * ${t[0]} + resTexRC.x;\n         ${u}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `, new k(r);\n      }\n      getCommonUtilFuncs() {\n        let o = {},\n          t = \"uvFromFlat\";\n        o[t] = new k(`\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    `), t = \"packedUVfrom1D\", o[t] = new k(`\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `), t = \"packedUVfrom2D\", o[t] = new k(`\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `), t = \"packedUVfrom3D\", o[t] = new k(`\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `), t = \"sampleTexture\";\n        let r = G(this.context.glContext.version);\n        return o[t] = new k(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${r.texture2D}(textureSampler, uv).r;\n        }`), o;\n      }\n      getInputsSamplingSnippets() {\n        let o = {},\n          t = this.context.outputTextureLayout;\n        return this.context.programInfo.inputNames.forEach((r, n) => {\n          let s = this.context.inputTextureLayouts[n],\n            a = An(r);\n          s.isPacked ? o[a] = this.getPackedSamplerFromInput(a, r, s) : o[a] = this.getUnpackedSamplerFromInput(a, r, s);\n          let u = Yu(r);\n          s.unpackedShape.length <= t.unpackedShape.length && (s.isPacked ? o[u] = this.getPackedSamplerAtOutputCoords(u, s, t, r) : o[u] = this.getUnpackedSamplerAtOutputCoords(u, s, t, r));\n        }), o;\n      }\n      getPackedSamplerAtOutputCoords(o, t, r, n) {\n        let s = t.unpackedShape,\n          a = r.unpackedShape,\n          l = An(n),\n          f = s.length,\n          p = a.length,\n          d = kt.getBroadcastDims(s, a),\n          y = Bt(p),\n          T = p - f,\n          v,\n          S = ne();\n        f === 0 ? v = \"\" : p < 2 && d.length >= 1 ? v = \"coords = 0;\" : v = d.map(Dt => `coords.${S[Dt + T]} = 0;`).join(`\n`);\n        let L = \"\";\n        p < 2 && f > 0 ? L = \"coords\" : L = s.map((Dt, _t) => `coords.${S[_t + T]}`).join(\", \");\n        let P = \"return outputValue;\",\n          M = B.size(s) === 1,\n          lt = B.size(a) === 1;\n        if (f === 1 && !M && !lt) P = `\n        return vec4(outputValue.xy, outputValue.xy);\n      `;else if (M && !lt) p === 1 ? P = `\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ` : P = `\n          return vec4(outputValue.x);\n        `;else if (d.length) {\n          let Dt = f - 2,\n            _t = f - 1;\n          d.indexOf(Dt) > -1 && d.indexOf(_t) > -1 ? P = \"return vec4(outputValue.x);\" : d.indexOf(Dt) > -1 ? P = \"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\" : d.indexOf(_t) > -1 && (P = \"return vec4(outputValue.xx, outputValue.zz);\");\n        }\n        let wt = `\n        int lastDim = coords.${S[p - 1]};\n        coords.${S[p - 1]} = coords.${S[p - 2]};\n        coords.${S[p - 2]} = lastDim;\n      `,\n          et = `\n      vec4 ${o}() {\n        ${y} coords = getOutputCoords();\n        ${wt}\n        ${v}\n        vec4 outputValue = ${l}(${L});\n        ${P}\n      }\n    `;\n        return new k(et, [\"coordinates.getOutputCoords\"]);\n      }\n      getUnpackedSamplerAtOutputCoords(o, t, r, n) {\n        let s = [r.width, r.height],\n          a = [t.width, t.height],\n          u = t.unpackedShape.length,\n          l = r.unpackedShape.length,\n          f = t.unpackedShape,\n          p = r.unpackedShape,\n          d = An(n);\n        if (u === l && Me.arraysEqual(a, s)) {\n          let M = `\n          float ${o}() {\n            return sampleTexture(${n}, TexCoords);\n          }\n        `;\n          return new k(M, [\"coordinates.sampleTexture\"]);\n        }\n        let y = Bt(l),\n          T = kt.getBroadcastDims(f, p),\n          v = l - u,\n          S,\n          L = ne();\n        u === 0 ? S = \"\" : l < 2 && T.length >= 1 ? S = \"coords = 0;\" : S = T.map(M => `coords.${L[M + v]} = 0;`).join(`\n`);\n        let P = \"\";\n        l < 2 && u > 0 ? P = \"coords\" : P = t.unpackedShape.map((M, V) => `coords.${L[V + v]}`).join(\", \");\n        let A = `\n        float ${o}() {\n          ${y} coords = getOutputCoords();\n          ${S}\n          return ${d}(${P});\n        }\n      `;\n        return new k(A, [\"coordinates.getOutputCoords\"]);\n      }\n      getPackedSamplerFromInput(o, t, r) {\n        switch (r.unpackedShape.length) {\n          case 0:\n            return this.getPackedSamplerScalar(o, t);\n          case 1:\n            return this.getPackedSampler1D(o, t, r);\n          case 2:\n            return this.getPackedSampler2D(o, t, r);\n          case 3:\n            return this.getPackedSampler3D(o, t, r);\n          default:\n            return this.getPackedSamplerND(o, t, r);\n        }\n      }\n      getUnpackedSamplerFromInput(o, t, r) {\n        let n = r.unpackedShape;\n        switch (n.length) {\n          case 0:\n            return this.getUnpackedSamplerScalar(o, t, r);\n          case 1:\n            return this.getUnpackedSampler1D(o, t, r);\n          case 2:\n            return this.getUnpackedSampler2D(o, t, r);\n          case 3:\n            return this.getUnpackedSampler3D(o, t, r);\n          case 4:\n            return this.getUnpackedSampler4D(o, t, r);\n          case 5:\n            return this.getUnpackedSampler5D(o, t, r);\n          case 6:\n            return this.getUnpackedSampler6D(o, t, r);\n          default:\n            throw new Error(`Unsupported dimension ${n.length}-D`);\n        }\n      }\n      getPackedSamplerScalar(o, t) {\n        let r = G(this.context.glContext.version),\n          n = `\n          vec4 ${o}() {\n            return ${r.texture2D}(${t}, halfCR);\n          }\n        `;\n        return new k(n);\n      }\n      getPackedSampler1D(o, t, r) {\n        let n = [r.width, r.height],\n          s = [n[1], n[0]],\n          a = G(this.context.glContext.version),\n          l = `vec4 ${o}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${s[0]}, ${s[1]}, index);\n      return ${a.texture2D}(${t}, uv);\n    }`;\n        return new k(l, [\"coordinates.packedUVfrom1D\"]);\n      }\n      getPackedSampler2D(o, t, r) {\n        let n = r.unpackedShape,\n          s = [r.width, r.height],\n          a = G(this.context.glContext.version),\n          u = s[0],\n          l = s[1];\n        if (s != null && Me.arraysEqual(n, s)) {\n          let T = `vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${u}.0);\n        return ${a.texture2D}(${t}, uv);\n      }`;\n          return new k(T);\n        }\n        let f = s,\n          p = Math.ceil(n[1] / 2),\n          y = `vec4 ${o}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${f[1]}, ${f[0]}, ${p}, row, col);\n      return ${a.texture2D}(${t}, uv);\n    }`;\n        return new k(y, [\"coordinates.packedUVfrom2D\"]);\n      }\n      getPackedSampler3D(o, t, r) {\n        let n = r.unpackedShape,\n          s = [r.width, r.height],\n          a = [s[0], s[1]],\n          u = G(this.context.glContext.version);\n        if (n[0] === 1) {\n          let v = n.slice(1),\n            S = [1, 2],\n            L = lr(n, v),\n            P = [\"b\", \"row\", \"col\"],\n            A = JSON.parse(JSON.stringify(r));\n          A.unpackedShape = L;\n          let M = this.getPackedSamplerFromInput(o, t, A),\n            lt = `${M.routineBody}\n      vec4 ${o}(int b, int row, int col) {\n        return ${o}(${fr(P, S)});\n      } `;\n          return new k(lt, M.dependencies);\n        }\n        let l = a[0],\n          f = a[1],\n          p = Math.ceil(n[2] / 2),\n          d = p * Math.ceil(n[1] / 2),\n          T = `vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${f}, ${l}, ${d}, ${p}, b, row, col);\n      return ${u.texture2D}(${t}, uv);}`;\n        return new k(T, [\"coordinates.packedUVfrom3D\"]);\n      }\n      getPackedSamplerND(o, t, r) {\n        let n = r.unpackedShape,\n          s = n.length,\n          a = [r.width, r.height],\n          u = G(this.context.glContext.version),\n          l = [a[0], a[1]],\n          f = l[1],\n          p = l[0],\n          d = Math.ceil(n[s - 1] / 2),\n          y = d * Math.ceil(n[s - 2] / 2),\n          T = \"int b, int row, int col\",\n          v = `b * ${y} + (row / 2) * ${d} + (col / 2)`;\n        for (let P = 2; P < s - 1; P++) T = `int b${P}, ` + T, y *= n[s - P - 1], v = `b${P} * ${y} + ` + v;\n        let L = `vec4 ${o}(${T}) {\n      int index = ${v};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${f});\n      return ${u.texture2D}(${t}, uv);\n    }`;\n        return new k(L);\n      }\n      getUnpackedSamplerScalar(o, t, r) {\n        let [n, s] = [r.width, r.height];\n        if (n === 1 && s === 1) {\n          let u = `\n          float ${o}() {\n            return sampleTexture(${t}, halfCR);\n          }\n        `;\n          return new k(u, [\"coordinates.sampleTexture\"]);\n        }\n        let a = `\n        float ${o}() {\n          int offset_${t} = coordsToOffset(TexCoords, ${n}, ${s});\n          vec2 uv = uvFromFlat(${n}, ${s}, offset_${t});\n          return sampleTexture(${t}, uv);\n        }\n      `;\n        return new k(a, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n      }\n      getUnpackedSampler1D(o, t, r) {\n        let n = r.width,\n          s = r.height;\n        if (s === 1 && n === 1) {\n          let u = `\n        float ${o}(int index) {\n          return sampleTexture(${t}, halfCR);\n        }\n      `;\n          return new k(u, [\"coordinates.sampleTexture\"]);\n        }\n        if (s === 1) {\n          let u = `\n          float ${o}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${n}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;\n          return new k(u, [\"coordinates.sampleTexture\"]);\n        }\n        if (n === 1) {\n          let u = `\n          float ${o}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${s}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;\n          return new k(u, [\"coordinates.sampleTexture\"]);\n        }\n        let a = `\n        float ${o}(int index) {\n          vec2 uv = uvFromFlat(${n}, ${s}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;\n        return new k(a, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\"]);\n      }\n      getUnpackedSampler2D(o, t, r) {\n        let n = r.unpackedShape,\n          s = [r.height, r.width];\n        if (s != null && Me.arraysEqual(n, s)) {\n          let y = s[1],\n            T = s[0],\n            v = `\n          float ${o}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${y}.0, ${T}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;\n          return new k(v, [\"coordinates.sampleTexture\"]);\n        }\n        let {\n            newShape: a,\n            keptDims: u\n          } = hr(n),\n          l = a;\n        if (l.length < n.length) {\n          let y = lr(n, l),\n            T = JSON.parse(JSON.stringify(r));\n          T.unpackedShape = y;\n          let v = [\"col\", \"row\"],\n            S = `\n          ${this.getUnpackedSamplerFromInput(o, t, T).routineBody}\n          float ${o}(int row, int col) {\n            return ${o}(${fr(v, u)});\n          }\n        `;\n          return new k(S, [\"coordinates.sampleTexture\"]);\n        }\n        let f = s[1],\n          p = s[0];\n        if (p === 1) {\n          let y = `\n          float ${o}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${f}, ${p});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${n[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;\n          return new k(y, [\"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n        }\n        if (f === 1) {\n          let y = `\n          float ${o}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${f}, ${p});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${n[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;\n          return new k(y, [\"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n        }\n        let d = `\n        float ${o}(int row, int col) {\n          int index = col * ${n[1]} + row;\n          vec2 uv = uvFromFlat(${f}, ${p}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;\n        return new k(d, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n      }\n      getUnpackedSampler3D(o, t, r) {\n        let n = r.unpackedShape,\n          s = n[1] * n[2],\n          a = n[2],\n          {\n            newShape: u,\n            keptDims: l\n          } = hr(n),\n          f = u;\n        if (f.length < n.length) {\n          let T = lr(n, f),\n            v = [\"batch\", \"col\", \"row\"],\n            S = JSON.parse(JSON.stringify(r));\n          S.unpackedShape = T;\n          let L = this.getUnpackedSamplerFromInput(o, t, S),\n            P = l.reverse(),\n            A = `\n          ${L.routineBody}\n          float ${o}(int batch, int row, int col) {\n            return ${o}(${fr(v, P)});\n          }\n        `;\n          return new k(A, L.dependencies);\n        }\n        let p = r.width,\n          d = r.height,\n          y = `\n          float ${o}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${s} + col * ${a} + row;\n            vec2 uv = uvFromFlat(${p}, ${d}, index);\n            return sampleTexture(${t}, uv);\n          }\n      `;\n        return new k(y, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n      }\n      getUnpackedSampler4D(o, t, r) {\n        let n = r.unpackedShape,\n          s = n[3],\n          a = n[2] * s,\n          u = n[1] * a,\n          l = r.width,\n          f = r.height,\n          p = `\n        float ${o}(int row, int col, int depth, int depth2) {\n          int index = row * ${u} + col * ${a} +\n              depth2 * ${s} + depth;\n          vec2 uv = uvFromFlat(${l}, ${f}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;\n        return new k(p, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\"]);\n      }\n      getUnpackedSampler5D(o, t, r) {\n        let n = r.unpackedShape,\n          s = n[4],\n          a = n[3] * s,\n          u = n[2] * a,\n          l = n[1] * u,\n          {\n            newShape: f,\n            keptDims: p\n          } = hr(n);\n        if (f.length < n.length) {\n          let v = lr(n, f),\n            S = [\"row\", \"col\", \"depth\", \"depth2\", \"depth3\"],\n            L = JSON.parse(JSON.stringify(r));\n          L.unpackedShape = v;\n          let P = `\n          ${this.getUnpackedSamplerFromInput(o, t, L).routineBody}\n          float ${o}(int row, int col, int depth, int depth2, int depth3) {\n            return ${o}(${fr(S, p)});\n          }\n        `;\n          return new k(P, [\"coordinates.sampleTexture\", \"coordinates.uvFromFlat\"]);\n        }\n        let d = r.width,\n          y = r.height,\n          T = `\n        float ${o}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${l} + col * ${u} + depth * ${a} +\n          depth3 * ${s} + depth2;\n          vec2 uv = uvFromFlat(${d}, ${y}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;\n        return new k(T, [\"coordinates.sampleTexture\", \"coordinates.uvFromFlat\"]);\n      }\n      getUnpackedSampler6D(o, t, r) {\n        let n = r.unpackedShape,\n          s = n[5],\n          a = n[4] * s,\n          u = n[3] * a,\n          l = n[2] * u,\n          f = n[1] * l,\n          {\n            newShape: p,\n            keptDims: d\n          } = hr(n);\n        if (p.length < n.length) {\n          let S = lr(n, p),\n            L = [\"row\", \"col\", \"depth\", \"depth2\", \"depth3\", \"depth4\"],\n            P = JSON.parse(JSON.stringify(r));\n          P.unpackedShape = S;\n          let A = `\n            ${this.getUnpackedSamplerFromInput(o, t, P).routineBody}\n            float ${o}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${o}(${fr(L, d)});\n            }\n          `;\n          return new k(A, [\"coordinates.sampleTexture\", \"coordinates.uvFromFlat\"]);\n        }\n        let y = r.width,\n          T = r.height,\n          v = `\n          float ${o}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${f} + col * ${l} + depth * ${u} +\n            depth2 * ${a} + depth3 * ${s} + depth4;\n            vec2 uv = uvFromFlat(${y}, ${T}, index);\n            return sampleTexture(${t}, uv);\n          }\n        `;\n        return new k(v, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n      }\n      toVec() {\n        let o = this.context.outputTextureLayout,\n          t = o.shape.length,\n          r = o.strides,\n          n = o.width,\n          s = o.height,\n          a = [];\n        for (let l = 0; l < t - 1; ++l) a.push(`\n        c[${l}] = offset / ${r[l]};`), a.push(`\n        offset -= c[${l}] * ${r[l]};`);\n        a.push(`\n        c[${t - 1}] = offset;`);\n        let u = `\n      void toVec(vec2 texCoords, out int c[${t}]) {\n        int offset = coordsToOffset(texCoords, ${n}, ${s});\n        ${a.join(\"\")}\n      }\n      void toVec(int offset, out int c[${t}]) {\n        ${a.join(\"\")}\n      }\n    `;\n        return {\n          toVec: new k(u, [\"coordinates.coordsToOffset\"])\n        };\n      }\n      valueFrom() {\n        let o = {};\n        return this.context.programInfo.inputNames.forEach((t, r) => {\n          let n = this.context.inputTextureLayouts[r],\n            a = (n.unpackedShape.length > 0 ? n.unpackedShape : n.shape).length,\n            u = `_${t}`;\n          o[u] = new k(this.getValueFromSingle(t, a, n.width, n.height, !1), [`shapeUtils.indicesToOffset${u}`, \"coordinates.offsetToCoords\", \"fragcolor.getColorAsFloat\"]), u = u + \"_T\", o[u] = new k(this.getValueFromSingle(t, a, n.width, n.height, !0), [`shapeUtils.indicesToOffset${u}`, \"coordinates.offsetToCoords\", \"fragcolor.getColorAsFloat\"]);\n        }), o;\n      }\n      getValueFromSingle(o, t, r, n, s) {\n        let a = `_${o}`;\n        s && (a = a + \"_T\");\n        let u = G(this.context.glContext.version);\n        return `\n        float ${a}(int m[${t}]) {\n          int offset = indicesToOffset${a}(m);\n          vec2 coords = offsetToCoords(offset, ${r}, ${n});\n          float value = getColorAsFloat(${u.texture2D}(${o}, coords));\n          return value;\n        }\n        `;\n      }\n      getPackedValueFrom(o, t, r, n, s) {\n        let a = `_${o}_Pack`;\n        s && (a = a + \"_T\");\n        let u = G(this.context.glContext.version);\n        return `\n        vec4 ${a}(int m[${t}]) {\n          int offset = indicesToOffset_${o}(m);\n          vec2 coords = offsetToCoords(offset, ${r}, ${n});\n          return ${u.texture2D}(${o}, coords);\n        }\n        `;\n      }\n    };\n  });\nvar zn,\n  pp = O(() => {\n    \"use strict\";\n\n    Te();\n    zn = class i extends Ht {\n      constructor(e) {\n        super(e);\n      }\n      getFunctions() {\n        return {\n          ...this.encodeFloat32(),\n          ...this.decodeFloat32()\n        };\n      }\n      getCustomTypes() {\n        return {};\n      }\n      encodeFloat32() {\n        return {\n          encode: new k(`highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        `)\n        };\n      }\n      decodeFloat32() {\n        return {\n          decode: new k(`highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        `)\n        };\n      }\n      encodeUint8() {\n        let e = i.isLittleEndian() ? \"rgba.rgba=rgba.abgr;\" : \"\";\n        return {\n          encode: new k(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${e}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)\n        };\n      }\n      decodeUint8() {\n        let e = i.isLittleEndian() ? \"rgba.rgba=rgba.abgr;\" : \"\";\n        return {\n          decode: new k(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${e}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)\n        };\n      }\n      static isLittleEndian() {\n        let e = new ArrayBuffer(4),\n          o = new Uint32Array(e),\n          t = new Uint8Array(e);\n        if (o[0] = 3735928559, t[0] === 239) return !0;\n        if (t[0] === 222) return !1;\n        throw new Error(\"unknown endianness\");\n      }\n    };\n  });\nvar Wn,\n  dp = O(() => {\n    \"use strict\";\n\n    Te();\n    ut();\n    Wn = class extends Ht {\n      constructor(e) {\n        super(e);\n      }\n      getFunctions() {\n        return {\n          ...this.setFragColor(),\n          ...this.getColorAsFloat()\n        };\n      }\n      getCustomTypes() {\n        return {};\n      }\n      setFragColor() {\n        let e = G(this.context.glContext.version);\n        return {\n          setFragColor: new k(`\n        void setFragColor(float value) {\n            ${e.output} = encode(value);\n        }\n        `, [\"encoding.encode\"])\n        };\n      }\n      getColorAsFloat() {\n        return {\n          getColorAsFloat: new k(`\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        `, [\"encoding.decode\"])\n        };\n      }\n    };\n  });\nvar Hn,\n  hp = O(() => {\n    \"use strict\";\n\n    Te();\n    Hn = class i extends Ht {\n      constructor(e) {\n        super(e);\n      }\n      getFunctions() {\n        return {\n          ...this.bcastIndex(),\n          ...this.bcastMatmulIndex(),\n          ...this.offsetToIndices(),\n          ...this.indicesToOffset(),\n          ...this.incrementIndices()\n        };\n      }\n      getCustomTypes() {\n        return {};\n      }\n      bcastIndex() {\n        let e = this.context.outputTextureLayout.shape.length,\n          o = {};\n        return this.context.programInfo.inputNames.forEach((t, r) => {\n          let n = this.context.inputTextureLayouts[r].unpackedShape;\n          if (n.length <= e) {\n            let s = n.length,\n              a = e - s,\n              u = `bcastIndices_${t}`,\n              l = \"\";\n            for (let p = 0; p < s; ++p) l += `\n          realIndices[${p}] = int( mod(float(bcastedIndices[${a + p}]), ${n[p]}.0) );\n          `;\n            let f = `\n        void ${u} (int bcastedIndices[${e}], out int realIndices[${s}]) {\n          ${l}\n        }\n        `;\n            o[u] = new k(f);\n          }\n        }), o;\n      }\n      bcastMatmulIndex() {\n        let e = this.context.outputTextureLayout.shape.length,\n          o = {};\n        return this.context.programInfo.inputNames.forEach((t, r) => {\n          let n = this.context.inputTextureLayouts[r].shape;\n          if (!(n.length < 2 || n.length > e)) {\n            let s = n.length,\n              a = e - s,\n              u = `bcastMatmulIndices_${t}`,\n              l = \"\";\n            for (let p = 0; p < s - 2; ++p) l += `\n          realIndices[${p}] = int( mod(float(bcastedIndices[${a + p}]), ${n[p]}.0) );\n          `;\n            let f = `\n        void ${u}(int bcastedIndices[${e}], out int realIndices[${s}]) {\n          ${l}\n          realIndices[${s - 1}] = bcastedIndices[${e - 1}];\n          realIndices[${s - 2}] = bcastedIndices[${e - 2}];\n        }\n        `;\n            o[u] = new k(f);\n          }\n        }), o;\n      }\n      indicesToOffset() {\n        let e = {};\n        return this.context.programInfo.inputNames.forEach((o, t) => {\n          let r = this.context.inputTextureLayouts[t].shape,\n            n = this.context.inputTextureLayouts[t].strides,\n            s = r.length,\n            a = `indicesToOffset_${o}`;\n          e[a] = new k(i.indexToOffsetSingle(a, s, n)), a = `indicesToOffset_${o}_T`, e[a] = new k(i.indexToOffsetSingle(a, s, n.slice().reverse()));\n        }), e;\n      }\n      static indexToOffsetSingle(e, o, t) {\n        let r = \"\";\n        for (let n = o - 1; n >= 0; --n) r += `\n        offset += indices[${n}] * ${t[n]};\n        `;\n        return `\n      int ${e}(int indices[${o}]) {\n        int offset = 0;\n        ${r}\n        return offset;\n      }\n      `;\n      }\n      offsetToIndices() {\n        let e = {};\n        return this.context.programInfo.inputNames.forEach((o, t) => {\n          let r = this.context.inputTextureLayouts[t].shape,\n            n = this.context.inputTextureLayouts[t].strides,\n            s = r.length,\n            a = `offsetToIndices_${o}`;\n          e[a] = new k(i.offsetToIndicesSingle(a, s, n)), a = `offsetToIndices_${o}_T`, e[a] = new k(i.offsetToIndicesSingle(a, s, n.slice().reverse()));\n        }), e;\n      }\n      static offsetToIndicesSingle(e, o, t) {\n        let r = [];\n        for (let n = 0; n < o - 1; ++n) r.push(`\n      indices[${n}] = offset / ${t[n]};`), r.push(`\n        offset -= indices[${n}] * ${t[n]};`);\n        return r.push(`\n      indices[${o - 1}] = offset;`), `\n      void ${e}(int offset, out int indices[${o}]) {\n        ${r.join(\"\")}\n      }\n      `;\n      }\n      incrementIndices() {\n        let e = {};\n        return this.context.programInfo.inputNames.forEach((o, t) => {\n          let r = this.context.inputTextureLayouts[t].shape,\n            n = r.length,\n            s = `incrementIndices_${o}`,\n            a = \"\";\n          for (let l = 0; l < n; ++l) a += `\n        shape[${l}] = ${r[l]};`;\n          let u = `\n        void ${s}(int axis, out int indices[${n}]) {\n          int shape[${n}];\n          ${a};\n          for(int i = ${n} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;\n          e[s] = new k(u);\n        }), e;\n      }\n    };\n  });\nvar qn,\n  mp = O(() => {\n    \"use strict\";\n\n    Te();\n    qn = class extends Ht {\n      constructor(e) {\n        super(e);\n      }\n      getCustomTypes() {\n        return {};\n      }\n      getFunctions() {\n        return {\n          ...this.binaryVecFunctions(),\n          ...this.copyVec(),\n          ...this.setVecItem(),\n          ...this.getVecItem()\n        };\n      }\n      binaryVecFunctions() {\n        let o = this.context.outputTextureLayout.shape.length,\n          t = {\n            add: \"+=\",\n            sub: \"-=\",\n            mul: \"*=\",\n            div: \"/=\"\n          },\n          r = {};\n        for (let n in t) {\n          let s = `${n}Vec`,\n            a = \"\";\n          for (let l = 0; l < o; ++l) a += `\n          dest[${l}] ${t[n]} src[${l}];\n          `;\n          let u = `\n        void ${s}(int src[${o}], out int dest[${o}]) {\n          ${a}\n        }\n        `;\n          r[s] = new k(u);\n        }\n        return r;\n      }\n      copyVec() {\n        let o = this.context.outputTextureLayout.shape.length,\n          t = \"\";\n        for (let n = 0; n < o; ++n) t += `\n        dest[${n}] = src[${n}];\n        `;\n        let r = `\n      void copyVec(int src[${o}], out int dest[${o}]) {\n        ${t}\n      }\n      `;\n        return {\n          copyVec: new k(r)\n        };\n      }\n      setVecItem() {\n        let o = this.context.outputTextureLayout.shape.length,\n          t = `\n        if(index < 0)\n            index =${o} + index;\n        if (index == 0)\n            m[0] = value;\n        `;\n        for (let n = 1; n < o - 1; ++n) t += `\n        else if (index == ${n})\n            m[${n}] = value;\n            `;\n        t += `\n        else\n            m[${o - 1}] = value;\n        `;\n        let r = `\n      void setVecItem(out int m[${o}], int index, int value) {\n        ${t}\n      }\n        `;\n        return {\n          setVecItem: new k(r)\n        };\n      }\n      getVecItem() {\n        let o = this.context.outputTextureLayout.shape.length,\n          t = `\n        if(index < 0)\n            index = ${o} + index;\n        if (index == 0)\n            return m[0];\n      `;\n        for (let n = 1; n < o - 1; ++n) t += `\n        else if (index == ${n})\n            return m[${n}];\n      `;\n        t += `\n        else\n            return m[${o - 1}];\n        `;\n        let r = `\n      int getVecItem(int m[${o}], int index) {\n        ${t}\n      }\n    `;\n        return {\n          getVecItem: new k(r)\n        };\n      }\n    };\n  });\nvar Ri,\n  bp = O(() => {\n    \"use strict\";\n\n    cp();\n    pp();\n    dp();\n    hp();\n    mp();\n    Ri = {\n      encoding: zn,\n      fragcolor: Wn,\n      vec: qn,\n      shapeUtils: Hn,\n      coordinates: Vn\n    };\n  });\nvar jn,\n  gp = O(() => {\n    \"use strict\";\n\n    Te();\n    lp();\n    bp();\n    ut();\n    jn = class {\n      constructor(e, o, t, r) {\n        this.libs = {};\n        this.glslLibRoutineDependencyGraph = {};\n        this.context = new Ln(e, o, t, r), Object.keys(Ri).forEach(s => {\n          let a = new Ri[s](this.context);\n          this.libs[s] = a;\n        });\n        let n = this.glslLibRoutineDependencyGraph;\n        for (let s in this.libs) {\n          let u = this.libs[s].getFunctions();\n          for (let l in u) {\n            let f = s + \".\" + l,\n              p;\n            n[f] ? (p = n[f], p.routineBody = u[l].routineBody) : (p = new Nr(f, u[l].routineBody), n[f] = p);\n            let d = u[l].dependencies;\n            if (d) for (let y = 0; y < d.length; ++y) if (n[d[y]]) p.addDependency(n[d[y]]);else {\n              let T = new Nr(d[y]);\n              n[d[y]] = T, p.addDependency(T);\n            }\n          }\n        }\n      }\n      preprocess() {\n        let e = this.context.programInfo,\n          o = e.shaderSource;\n        return this.context.programInfo.hasMain || (o = `${o}\n      ${Ju(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), o = up(o), `${Ku(this.context.glContext.version)}\n    ${this.getUniforms(e.inputNames, e.variables)}\n    ${this.getImports(o)}\n    ${o}`;\n      }\n      getImports(e) {\n        let o = this.selectGlslLibRoutinesToBeIncluded(e);\n        if (o.length === 0) return \"\";\n        let t = \"\";\n        for (let r = 0; r < o.length; ++r) if (o[r].routineBody) t += o[r].routineBody + `\n`;else throw new Error(`Missing body for the Glsl Library routine: ${o[r].name}`);\n        return t;\n      }\n      selectGlslLibRoutinesToBeIncluded(e) {\n        let o = [];\n        return Object.keys(this.glslLibRoutineDependencyGraph).forEach(t => {\n          let r = t.split(\".\")[1];\n          e.indexOf(r) !== -1 && o.push(this.glslLibRoutineDependencyGraph[t]);\n        }), $n.returnOrderedNodes(o);\n      }\n      getUniforms(e, o) {\n        let t = [];\n        if (e) for (let r of e) t.push(`uniform sampler2D ${r};`);\n        if (o) for (let r of o) t.push(`uniform ${r.type} ${r.name}${r.arrayLength ? `[${r.arrayLength}]` : \"\"};`);\n        return t.join(`\n`);\n      }\n    };\n  });\nvar Xn,\n  yp = O(() => {\n    \"use strict\";\n\n    Yt();\n    Ut();\n    gp();\n    ut();\n    Xn = class {\n      constructor(e, o, t) {\n        this.profiler = e;\n        this.glContext = o;\n        this.textureLayoutStrategy = t;\n        this.repo = new Map(), this.attributesBound = !1;\n      }\n      getArtifact(e) {\n        return this.repo.get(e);\n      }\n      setArtifact(e, o) {\n        this.repo.set(e, o);\n      }\n      run(e, o, t) {\n        this.profiler.event(\"op\", `ProgramManager.run ${e.programInfo.name ?? \"unknown kernel\"}`, () => {\n          let r = this.glContext.gl,\n            n = e.program;\n          r.useProgram(n);\n          try {\n            this.bindOutput(t), this.attributesBound || this.bindAttributes(e.attribLocations), this.bindUniforms(e.uniformLocations, e.programInfo.variables ?? [], o);\n          } catch (s) {\n            throw tt.error(\"ProgramManager\", e.programInfo.shaderSource), s;\n          }\n          this.profiler.event(\"backend\", \"GlContext.draw()\", () => {\n            this.glContext.draw();\n          });\n        }, this.glContext);\n      }\n      dispose() {\n        this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach(e => this.glContext.deleteProgram(e.program));\n      }\n      build(e, o, t) {\n        return this.profiler.event(\"backend\", \"ProgramManager.build\", () => {\n          let r = new jn(this.glContext, e, o, t),\n            n = r.preprocess(),\n            s = this.compile(n);\n          return {\n            programInfo: e,\n            program: s,\n            uniformLocations: this.getUniformLocations(s, r.context.programInfo.inputNames, r.context.programInfo.variables),\n            attribLocations: this.getAttribLocations(s)\n          };\n        });\n      }\n      compile(e) {\n        if (!this.vertexShader) {\n          tt.verbose(\"ProrgramManager\", \"Compiling and caching Vertex shader for the first time\");\n          let r = Xu(this.glContext.version);\n          this.vertexShader = this.glContext.compileShader(r, this.glContext.gl.VERTEX_SHADER);\n        }\n        z.debug && tt.verbose(\"ProrgramManager\", `FragShader:\n${e}\n`);\n        let o = this.glContext.compileShader(e, this.glContext.gl.FRAGMENT_SHADER),\n          t = this.glContext.createProgram(this.vertexShader, o);\n        return this.glContext.deleteShader(o), t;\n      }\n      bindOutput(e) {\n        let o = e.width,\n          t = e.height;\n        tt.verbose(\"ProrgramManager\", `Binding output texture to Framebuffer: w/h=${o}/${t}, shape=${e.shape}, type=${e.tensor.type}`), this.glContext.attachFramebuffer(e.texture, o, t);\n      }\n      bindAttributes(e) {\n        let o = e.position,\n          t = e.textureCoord;\n        this.glContext.setVertexAttributes(o, t), this.attributesBound = !0;\n      }\n      bindUniforms(e, o, t) {\n        let r = this.glContext.gl,\n          n = 0;\n        for (let {\n          name: s,\n          type: a,\n          location: u,\n          arrayLength: l\n        } of e) {\n          let f = o.find(p => p.name === s)?.data;\n          if (a !== \"sampler2D\" && !f) throw new Error(`variable '${s}' does not have data defined in program info`);\n          switch (a) {\n            case \"sampler2D\":\n              this.bindTexture(t[n], u, n), n++;\n              break;\n            case \"float\":\n              l ? r.uniform1fv(u, f) : r.uniform1f(u, f);\n              break;\n            case \"int\":\n              l ? r.uniform1iv(u, f) : r.uniform1i(u, f);\n              break;\n            default:\n              throw new Error(`Uniform not implemented: ${a}`);\n          }\n        }\n      }\n      bindTexture(e, o, t) {\n        this.glContext.bindTextureToUniform(e.texture, t, o);\n      }\n      getAttribLocations(e) {\n        return {\n          position: this.getAttribLocation(e, \"position\"),\n          textureCoord: this.getAttribLocation(e, \"textureCoord\")\n        };\n      }\n      getUniformLocations(e, o, t) {\n        let r = [];\n        if (o) for (let n of o) r.push({\n          name: n,\n          type: \"sampler2D\",\n          location: this.getUniformLocation(e, n)\n        });\n        if (t) for (let n of t) r.push({\n          ...n,\n          location: this.getUniformLocation(e, n.name)\n        });\n        return r;\n      }\n      getUniformLocation(e, o) {\n        let r = this.glContext.gl.getUniformLocation(e, o);\n        if (r === null) throw new Error(`Uniform ${o} not found.`);\n        return r;\n      }\n      getAttribLocation(e, o) {\n        return this.glContext.gl.getAttribLocation(e, o);\n      }\n    };\n  });\nvar Kn,\n  xp = O(() => {\n    \"use strict\";\n\n    Ut();\n    Fr();\n    Kn = class {\n      constructor(e, o, t, r) {\n        this.glContext = e;\n        this.layoutStrategy = o;\n        this.profiler = t;\n        this.config = r;\n        this.pendingRead = new Map();\n        r.reuseTextures && (this.inUseTextures = new Map(), this.idleTextures = new Map(), this.textureLookup = new Map());\n      }\n      createTextureFromLayout(e, o, t, r) {\n        let n = this.toEncoderType(e),\n          s = this.glContext.getEncoder(n, o.channels || 1, r);\n        if (o.isPacked && r === 1) throw new Error(\"not implemented\");\n        let a = o.width,\n          u = o.height,\n          l,\n          f;\n        if (this.config.reuseTextures) {\n          l = `${a}x${u}_${s.format}_${s.internalFormat}_${s.textureType}`, f = this.inUseTextures.get(l), f || (f = [], this.inUseTextures.set(l, f));\n          let d = this.idleTextures.get(l);\n          if (d && d.length > 0) {\n            let y = d.pop();\n            return f.push(y), r === 1 && this.glContext.updateTexture(y, a, u, s, this.toTextureData(e, t)), y;\n          }\n        }\n        tt.verbose(\"TextureManager\", `Creating new texture of size ${o.width}x${o.height}`);\n        let p = this.glContext.allocateTexture(a, u, s, this.toTextureData(e, t));\n        return this.config.reuseTextures && (f.push(p), this.textureLookup.set(p, l)), p;\n      }\n      readTexture(e, o, t) {\n        return t || (t = 1), this.profiler.event(\"backend\", \"TextureManager.readTexture\", () => {\n          let r = e.shape.reduce((s, a) => s * a) * t,\n            n = this.glContext.readTexture(e.texture, e.width, e.height, r, this.toEncoderType(o), t);\n          return this.toTensorData(o, n);\n        });\n      }\n      async readTextureAsync(e, o, t) {\n        let r = e.tensor.dataId;\n        if (t || (t = 1), this.pendingRead.has(r)) {\n          let n = this.pendingRead.get(r);\n          return new Promise(s => n?.push(s));\n        }\n        return this.profiler.event(\"backend\", \"TextureManager.readTextureAsync\", async () => {\n          this.pendingRead.set(r, []);\n          let n = e.shape.reduce((l, f) => l * f) * t;\n          await this.glContext.createAndWaitForFence();\n          let s = this.glContext.readTexture(e.texture, e.width, e.height, n, this.toEncoderType(o), t),\n            a = this.toTensorData(o, s),\n            u = this.pendingRead.get(r);\n          return this.pendingRead.delete(r), u?.forEach(l => l(a)), a;\n        });\n      }\n      readUint8TextureAsFloat(e) {\n        return this.profiler.event(\"backend\", \"TextureManager.readUint8TextureAsFloat\", () => {\n          let o = e.shape.reduce((r, n) => r * n),\n            t = this.glContext.readTexture(e.texture, e.width, e.height, o * 4, \"byte\", 4);\n          return new Float32Array(t.buffer, t.byteOffset, o);\n        });\n      }\n      releaseTexture(e, o) {\n        let t;\n        if (this.config.reuseTextures && (t = this.textureLookup.get(e.texture), t)) {\n          o && this.textureLookup.delete(t);\n          let r = this.inUseTextures.get(t);\n          if (r) {\n            let n = r.indexOf(e.texture);\n            if (n !== -1) {\n              r.splice(n, 1);\n              let s = this.idleTextures.get(t);\n              s || (s = [], this.idleTextures.set(t, s)), s.push(e.texture);\n            }\n          }\n        }\n        (!t || o) && (tt.verbose(\"TextureManager\", `Deleting texture of size ${e.width}x${e.height}`), this.glContext.deleteTexture(e.texture));\n      }\n      toTensorData(e, o) {\n        switch (e) {\n          case \"int16\":\n            return o instanceof Int16Array ? o : Int16Array.from(o);\n          case \"int32\":\n            return o instanceof Int32Array ? o : Int32Array.from(o);\n          case \"int8\":\n            return o instanceof Int8Array ? o : Int8Array.from(o);\n          case \"uint16\":\n            return o instanceof Uint16Array ? o : Uint16Array.from(o);\n          case \"uint32\":\n            return o instanceof Uint32Array ? o : Uint32Array.from(o);\n          case \"uint8\":\n          case \"bool\":\n            return o instanceof Uint8Array ? o : Uint8Array.from(o);\n          case \"float32\":\n            return o instanceof Float32Array ? o : Float32Array.from(o);\n          case \"float64\":\n            return o instanceof Float64Array ? o : Float64Array.from(o);\n          default:\n            throw new Error(`TensorData type ${e} is not supported`);\n        }\n      }\n      toTextureData(e, o) {\n        if (o) return o instanceof Float32Array ? o : new Float32Array(o);\n      }\n      toEncoderType(e) {\n        return \"float\";\n      }\n      clearActiveTextures() {\n        this.glContext.clearActiveTextures();\n      }\n    };\n  });\nvar Jn,\n  Tp = O(() => {\n    \"use strict\";\n\n    Ut();\n    Bs();\n    cl();\n    ap();\n    yp();\n    Ni();\n    xp();\n    Jn = class {\n      constructor(e, o) {\n        this.backend = e;\n        this.context = o;\n        this.layoutStrategy = new Un(e.glContext.maxTextureSize), this.programManager = new Xn(this.context.profiler, e.glContext, this.layoutStrategy), this.textureManager = new Kn(e.glContext, this.layoutStrategy, this.context.profiler, {\n          reuseTextures: e.textureCacheMode === \"full\"\n        }), this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache = new Map(), this.pack = e.pack, this.pack2unpackMap = new Map(), this.unpack2packMap = new Map();\n      }\n      createInferenceHandler() {\n        return new Dn(this);\n      }\n      onGraphInitialized(e) {\n        let o = e.getValues().filter(t => t.from === -1 && t.tensor).map(t => t.tensor.dataId);\n        this.initializers = new Set(o);\n      }\n      isInitializer(e) {\n        return this.initializers ? this.initializers.has(e) : !1;\n      }\n      addInitializer(e) {\n        this.initializers.add(e);\n      }\n      getTextureData(e, o) {\n        return o ? this.packedTextureDataCache.get(e) : this.unpackedTextureDataCache.get(e);\n      }\n      setTextureData(e, o, t = !1) {\n        tt.verbose(\"WebGLSessionHandler\", \"Storing Texture data in cache\"), t ? this.packedTextureDataCache.set(e, o) : this.unpackedTextureDataCache.set(e, o);\n      }\n      dispose() {\n        this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach(e => this.textureManager.releaseTexture(e, !0)), this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache.forEach(e => this.textureManager.releaseTexture(e, !0)), this.unpackedTextureDataCache = new Map();\n      }\n      resolve(e, o, t) {\n        let r = ks(e, o, ip);\n        return {\n          impl: r.opImpl,\n          context: r.opInit ? r.opInit(e, t) : e\n        };\n      }\n    };\n  });\nfunction bg(i) {\n  let e = 0;\n  for (; e < i.length && i[e](); ++e);\n  return e - 1;\n}\nvar Mr,\n  wp = O(() => {\n    \"use strict\";\n\n    Yt();\n    Fr();\n    Fr();\n    pe();\n    Mr = class {\n      constructor(e, o) {\n        this.frameBufferBound = !1;\n        this.itemsToPoll = [];\n        this.gl = e, this.version = o, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();\n      }\n      allocateTexture(e, o, t, r) {\n        let n = this.gl,\n          s = n.createTexture();\n        n.bindTexture(n.TEXTURE_2D, s), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);\n        let a = r ? t.encode(r, e * o) : null;\n        return n.texImage2D(n.TEXTURE_2D, 0, t.internalFormat, e, o, 0, t.format, t.textureType, a), this.checkError(), s;\n      }\n      updateTexture(e, o, t, r, n) {\n        let s = this.gl;\n        s.bindTexture(s.TEXTURE_2D, e);\n        let a = r.encode(n, o * t);\n        s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, o, t, r.format, r.textureType, a), this.checkError();\n      }\n      attachFramebuffer(e, o, t) {\n        let r = this.gl;\n        r.bindTexture(r.TEXTURE_2D, e), r.bindFramebuffer(r.FRAMEBUFFER, this.framebuffer), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e, 0), this.checkError(), r.viewport(0, 0, o, t), r.scissor(0, 0, o, t);\n      }\n      readTexture(e, o, t, r, n, s) {\n        let a = this.gl;\n        s || (s = 1), this.frameBufferBound || this.attachFramebuffer(e, o, t);\n        let u = this.getEncoder(n, s),\n          l = u.allocate(o * t);\n        return a.bindTexture(a.TEXTURE_2D, e), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, e, 0), a.readPixels(0, 0, o, t, a.RGBA, u.textureType, l), this.checkError(), u.decode(l, r);\n      }\n      isFramebufferReady() {\n        return !0;\n      }\n      getActiveTexture() {\n        let e = this.gl;\n        return `TEXTURE${e.getParameter(this.gl.ACTIVE_TEXTURE) - e.TEXTURE0}`;\n      }\n      getTextureBinding() {\n        return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n      }\n      getFramebufferBinding() {\n        return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);\n      }\n      setVertexAttributes(e, o) {\n        let t = this.gl;\n        t.vertexAttribPointer(e, 3, t.FLOAT, !1, 20, 0), t.enableVertexAttribArray(e), o !== -1 && (t.vertexAttribPointer(o, 2, t.FLOAT, !1, 20, 12), t.enableVertexAttribArray(o)), this.checkError();\n      }\n      createProgram(e, o) {\n        let t = this.gl,\n          r = t.createProgram();\n        return t.attachShader(r, e), t.attachShader(r, o), t.linkProgram(r), r;\n      }\n      compileShader(e, o) {\n        let t = this.gl,\n          r = t.createShader(o);\n        if (!r) throw new Error(`createShader() returned null with type ${o}`);\n        if (t.shaderSource(r, e), t.compileShader(r), t.getShaderParameter(r, t.COMPILE_STATUS) === !1) throw new Error(`Failed to compile shader: ${t.getShaderInfoLog(r)}\nShader source:\n${e}`);\n        return r;\n      }\n      deleteShader(e) {\n        this.gl.deleteShader(e);\n      }\n      bindTextureToUniform(e, o, t) {\n        let r = this.gl;\n        r.activeTexture(r.TEXTURE0 + o), this.checkError(), r.bindTexture(r.TEXTURE_2D, e), this.checkError(), r.uniform1i(t, o), this.checkError();\n      }\n      draw() {\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();\n      }\n      checkError() {\n        if (z.debug) {\n          let e = this.gl,\n            o = e.getError(),\n            t = \"\";\n          switch (o) {\n            case e.NO_ERROR:\n              return;\n            case e.INVALID_ENUM:\n              t = \"INVALID_ENUM\";\n              break;\n            case e.INVALID_VALUE:\n              t = \"INVALID_VALUE\";\n              break;\n            case e.INVALID_OPERATION:\n              t = \"INVALID_OPERATION\";\n              break;\n            case e.INVALID_FRAMEBUFFER_OPERATION:\n              t = \"INVALID_FRAMEBUFFER_OPERATION\";\n              break;\n            case e.OUT_OF_MEMORY:\n              t = \"OUT_OF_MEMORY\";\n              break;\n            case e.CONTEXT_LOST_WEBGL:\n              t = \"CONTEXT_LOST_WEBGL\";\n              break;\n            default:\n              t = `Unknown WebGL Error: ${o.toString(16)}`;\n          }\n          throw new Error(t);\n        }\n      }\n      deleteTexture(e) {\n        this.gl.deleteTexture(e);\n      }\n      deleteProgram(e) {\n        this.gl.deleteProgram(e);\n      }\n      getEncoder(e, o, t = 0) {\n        if (this.version === 2) return new Pn(this.gl, o);\n        switch (e) {\n          case \"float\":\n            return t === 1 || this.isRenderFloat32Supported ? new Br(this.gl, o) : new Br(this.gl, o, this.textureHalfFloatExtension.HALF_FLOAT_OES);\n          case \"int\":\n            throw new Error(\"not implemented\");\n          case \"byte\":\n            return new En(this.gl, o);\n          default:\n            throw new Error(`Invalid dataType: ${e}`);\n        }\n      }\n      clearActiveTextures() {\n        let e = this.gl;\n        for (let o = 0; o < this.maxTextureImageUnits; ++o) e.activeTexture(e.TEXTURE0 + o), e.bindTexture(e.TEXTURE_2D, null);\n      }\n      dispose() {\n        if (this.disposed) return;\n        let e = this.gl;\n        e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteFramebuffer(this.framebuffer), e.bindBuffer(e.ARRAY_BUFFER, null), e.deleteBuffer(this.vertexbuffer), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null), e.finish(), this.disposed = !0;\n      }\n      createDefaultGeometry() {\n        return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n      }\n      createVertexbuffer() {\n        let e = this.gl,\n          o = e.createBuffer();\n        if (!o) throw new Error(\"createBuffer() returned null\");\n        let t = this.createDefaultGeometry();\n        return e.bindBuffer(e.ARRAY_BUFFER, o), e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW), this.checkError(), o;\n      }\n      createFramebuffer() {\n        let e = this.gl.createFramebuffer();\n        if (!e) throw new Error(\"createFramebuffer returned null\");\n        return e;\n      }\n      queryVitalParameters() {\n        let e = this.gl;\n        if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) throw new Error(\"both float32 and float16 TextureType are not supported\");\n        this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), this.version;\n      }\n      getExtensions() {\n        this.version === 2 ? (this.colorBufferFloatExtension = this.gl.getExtension(\"EXT_color_buffer_float\"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\")) : (this.textureFloatExtension = this.gl.getExtension(\"OES_texture_float\"), this.textureHalfFloatExtension = this.gl.getExtension(\"OES_texture_half_float\"));\n      }\n      checkFloatTextureAttachableToFrameBuffer() {\n        let e = this.gl,\n          o = e.createTexture();\n        e.bindTexture(e.TEXTURE_2D, o);\n        let t = this.version === 2 ? e.RGBA32F : e.RGBA;\n        e.texImage2D(e.TEXTURE_2D, 0, t, 1, 1, 0, e.RGBA, e.FLOAT, null);\n        let r = e.createFramebuffer();\n        e.bindFramebuffer(e.FRAMEBUFFER, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, o, 0);\n        let n = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;\n        return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(o), e.deleteFramebuffer(r), n;\n      }\n      checkRenderFloat32() {\n        if (this.version === 2) {\n          if (!this.colorBufferFloatExtension) return !1;\n        } else if (!this.textureFloatExtension) return !1;\n        return this.isFloatTextureAttachableToFrameBuffer;\n      }\n      checkFloat32Download() {\n        if (this.version === 2) {\n          if (!this.colorBufferFloatExtension) return !1;\n        } else if (!this.textureFloatExtension || !this.gl.getExtension(\"WEBGL_color_buffer_float\")) return !1;\n        return this.isFloatTextureAttachableToFrameBuffer;\n      }\n      checkFloat32Blend() {\n        let e = this.gl,\n          o,\n          t,\n          r,\n          n,\n          s;\n        try {\n          o = e.createTexture(), t = e.createFramebuffer(), e.bindTexture(e.TEXTURE_2D, o);\n          let a = this.version === 2 ? e.RGBA32F : e.RGBA;\n          return e.texImage2D(e.TEXTURE_2D, 0, a, 1, 1, 0, e.RGBA, e.FLOAT, null), e.bindFramebuffer(e.FRAMEBUFFER, t), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, o, 0), e.enable(e.BLEND), r = e.createShader(e.VERTEX_SHADER), !r || (e.shaderSource(r, \"void main(){}\"), e.compileShader(r), n = e.createShader(e.FRAGMENT_SHADER), !n) || (e.shaderSource(n, \"precision highp float;void main(){gl_FragColor=vec4(0.5);}\"), e.compileShader(n), s = e.createProgram(), !s) ? !1 : (e.attachShader(s, r), e.attachShader(s, n), e.linkProgram(s), e.useProgram(s), e.drawArrays(e.POINTS, 0, 1), e.getError() === e.NO_ERROR);\n        } finally {\n          e.disable(e.BLEND), s && e.deleteProgram(s), r && e.deleteShader(r), n && e.deleteShader(n), t && (e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteFramebuffer(t)), o && (e.bindTexture(e.TEXTURE_2D, null), e.deleteTexture(o));\n        }\n      }\n      beginTimer() {\n        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n          let e = this.gl,\n            o = this.disjointTimerQueryWebgl2Extension,\n            t = e.createQuery();\n          return e.beginQuery(o.TIME_ELAPSED_EXT, t), t;\n        } else throw new Error(\"WebGL1 profiling currently not supported.\");\n      }\n      endTimer() {\n        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n          let e = this.gl,\n            o = this.disjointTimerQueryWebgl2Extension;\n          e.endQuery(o.TIME_ELAPSED_EXT);\n          return;\n        } else throw new Error(\"WebGL1 profiling currently not supported\");\n      }\n      isTimerResultAvailable(e) {\n        let o = !1,\n          t = !1;\n        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n          let r = this.gl,\n            n = this.disjointTimerQueryWebgl2Extension;\n          o = r.getQueryParameter(e, r.QUERY_RESULT_AVAILABLE), t = r.getParameter(n.GPU_DISJOINT_EXT);\n        } else throw new Error(\"WebGL1 profiling currently not supported\");\n        return o && !t;\n      }\n      getTimerResult(e) {\n        let o = 0;\n        if (this.version === 2) {\n          let t = this.gl;\n          o = t.getQueryParameter(e, t.QUERY_RESULT), t.deleteQuery(e);\n        } else throw new Error(\"WebGL1 profiling currently not supported\");\n        return o / 1e6;\n      }\n      async waitForQueryAndGetTime(e) {\n        return await li(() => this.isTimerResultAvailable(e)), this.getTimerResult(e);\n      }\n      async createAndWaitForFence() {\n        let e = this.createFence(this.gl);\n        return this.pollFence(e);\n      }\n      createFence(e) {\n        let o,\n          t = e,\n          r = t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE, 0);\n        return e.flush(), r === null ? o = () => !0 : o = () => {\n          let n = t.clientWaitSync(r, 0, 0);\n          return n === t.ALREADY_SIGNALED || n === t.CONDITION_SATISFIED;\n        }, {\n          query: r,\n          isFencePassed: o\n        };\n      }\n      async pollFence(e) {\n        return new Promise(o => {\n          this.addItemToPoll(() => e.isFencePassed(), () => o());\n        });\n      }\n      pollItems() {\n        let e = bg(this.itemsToPoll.map(o => o.isDoneFn));\n        for (let o = 0; o <= e; ++o) {\n          let {\n            resolveFn: t\n          } = this.itemsToPoll[o];\n          t();\n        }\n        this.itemsToPoll = this.itemsToPoll.slice(e + 1);\n      }\n      async addItemToPoll(e, o) {\n        this.itemsToPoll.push({\n          isDoneFn: e,\n          resolveFn: o\n        }), !(this.itemsToPoll.length > 1) && (await li(() => (this.pollItems(), this.itemsToPoll.length === 0)));\n      }\n    };\n  });\nfunction Gi(i) {\n  let e;\n  if ((!i || i === \"webgl2\") && \"webgl2\" in mr ? e = mr.webgl2 : (!i || i === \"webgl\") && \"webgl\" in mr && (e = mr.webgl), !e) try {\n    let t = yg();\n    e = vp(t, i);\n  } catch {\n    let r = gg();\n    e = vp(r, i);\n  }\n  i = i || e.version === 1 ? \"webgl\" : \"webgl2\";\n  let o = e.gl;\n  return mr[i] = e, o.isContextLost() ? (delete mr[i], Gi(i)) : (o.disable(o.DEPTH_TEST), o.disable(o.STENCIL_TEST), o.disable(o.BLEND), o.disable(o.DITHER), o.disable(o.POLYGON_OFFSET_FILL), o.disable(o.SAMPLE_COVERAGE), o.enable(o.SCISSOR_TEST), o.enable(o.CULL_FACE), o.cullFace(o.BACK), e);\n}\nfunction vp(i, e) {\n  let o = {\n      alpha: !1,\n      depth: !1,\n      antialias: !1,\n      stencil: !1,\n      preserveDrawingBuffer: !1,\n      premultipliedAlpha: !1,\n      failIfMajorPerformanceCaveat: !1\n    },\n    t,\n    r = o;\n  if ((!e || e === \"webgl2\") && (t = i.getContext(\"webgl2\", r), t)) try {\n    return new Mr(t, 2);\n  } catch (n) {\n    tt.warning(\"GlContextFactory\", `failed to create WebGLContext using contextId 'webgl2'. Error: ${n}`);\n  }\n  if ((!e || e === \"webgl\") && (t = i.getContext(\"webgl\", r) || i.getContext(\"experimental-webgl\", r), t)) try {\n    return new Mr(t, 1);\n  } catch (n) {\n    tt.warning(\"GlContextFactory\", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${n}`);\n  }\n  throw new Error(\"WebGL is not supported\");\n}\nfunction gg() {\n  if (typeof document > \"u\") throw new TypeError(\"failed to create canvas: document is not supported\");\n  let i = document.createElement(\"canvas\");\n  return i.width = 1, i.height = 1, i;\n}\nfunction yg() {\n  if (typeof OffscreenCanvas > \"u\") throw new TypeError(\"failed to create offscreen canvas: OffscreenCanvas is not supported\");\n  return new OffscreenCanvas(1, 1);\n}\nvar mr,\n  Ip = O(() => {\n    \"use strict\";\n\n    Ut();\n    wp();\n    mr = {};\n  });\nvar Yn,\n  _p = O(() => {\n    \"use strict\";\n\n    Yt();\n    Ut();\n    Tp();\n    Ip();\n    Yn = class {\n      get contextId() {\n        return z.webgl.contextId;\n      }\n      set contextId(e) {\n        z.webgl.contextId = e;\n      }\n      get matmulMaxBatchSize() {\n        return z.webgl.matmulMaxBatchSize;\n      }\n      set matmulMaxBatchSize(e) {\n        z.webgl.matmulMaxBatchSize = e;\n      }\n      get textureCacheMode() {\n        return z.webgl.textureCacheMode;\n      }\n      set textureCacheMode(e) {\n        z.webgl.textureCacheMode = e;\n      }\n      get pack() {\n        return z.webgl.pack;\n      }\n      set pack(e) {\n        z.webgl.pack = e;\n      }\n      get async() {\n        return z.webgl.async;\n      }\n      set async(e) {\n        z.webgl.async = e;\n      }\n      initialize() {\n        try {\n          return this.glContext = Gi(this.contextId), typeof this.matmulMaxBatchSize != \"number\" && (this.matmulMaxBatchSize = 16), typeof this.textureCacheMode != \"string\" && (this.textureCacheMode = \"full\"), typeof this.pack != \"boolean\" && (this.pack = !1), typeof this.async != \"boolean\" && (this.async = !1), tt.setWithEnv(z), z.webgl.context || Object.defineProperty(z.webgl, \"context\", {\n            value: this.glContext.gl\n          }), tt.verbose(\"WebGLBackend\", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), !0;\n        } catch (e) {\n          return tt.warning(\"WebGLBackend\", `Unable to initialize WebGLBackend. ${e}`), !1;\n        }\n      }\n      createSessionHandler(e) {\n        return new Jn(this, e);\n      }\n      dispose() {\n        this.glContext.dispose();\n      }\n    };\n  });\nasync function Mi(i) {\n  if (i) {\n    let e = typeof i == \"string\" ? [i] : i;\n    for (let o of e) {\n      let t = Op.get(o);\n      if (t) return t;\n      let r = await Tg(o);\n      if (r) return r;\n    }\n  } else return Mi([\"webgl\"]);\n  throw new Error(\"no available backend to use\");\n}\nasync function Tg(i) {\n  let e = xg;\n  if (typeof e[i] < \"u\" && wg(e[i])) {\n    let o = e[i],\n      t = o.initialize();\n    if (typeof t == \"object\" && \"then\" in t && (t = await t), t) return Op.set(i, o), o;\n  }\n}\nfunction wg(i) {\n  let e = i;\n  return \"initialize\" in e && typeof e.initialize == \"function\" && \"createSessionHandler\" in e && typeof e.createSessionHandler == \"function\" && \"dispose\" in e && typeof e.dispose == \"function\";\n}\nvar Op,\n  xg,\n  Sp = O(() => {\n    \"use strict\";\n\n    _p();\n    Op = new Map(), xg = {\n      webgl: new Yn()\n    };\n  });\nvar Ui,\n  Zn,\n  Ap = O(() => {\n    \"use strict\";\n\n    Ut();\n    Ui = class {\n      constructor(e, o) {\n        this.op = e;\n        this.node = o;\n      }\n    }, Zn = class {\n      constructor(e, o, t) {\n        this.graph = e;\n        this.profiler = t;\n        this.initialize(o);\n      }\n      initialize(e) {\n        this.profiler.event(\"session\", \"ExecutionPlan.initialize\", () => {\n          let o = this.graph.getNodes();\n          if (o.length !== e.length) throw new Error(\"The size of nodes and OPs do not match.\");\n          this._ops = e.map((t, r) => new Ui(t, o[r])), this.reset(), this._starter = [], this._ops.forEach((t, r) => {\n            let n = !0;\n            for (let s of t.node.inputs) if (!this._values[s] && this.graph.getInputIndices().indexOf(s) === -1) {\n              n = !1;\n              break;\n            }\n            n && this._starter.push(r);\n          });\n        });\n      }\n      reset() {\n        this._values = this.graph.getValues().map(e => e.tensor);\n      }\n      async execute(e, o) {\n        return this.profiler.event(\"session\", \"ExecutionPlan.execute\", async () => {\n          this.reset();\n          let t = e.createInferenceHandler(),\n            r = this.graph.getInputIndices();\n          if (o.length !== r.length) throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${o.length} expected: ${r.length}`);\n          o.forEach((f, p) => {\n            let d = r[p];\n            this._values[d] = f;\n          });\n          let n = this._starter.slice(0),\n            s = this.graph.getValues(),\n            a = this.graph.getNodes(),\n            u = 0;\n          for (; u < n.length;) {\n            let f = n[u++],\n              p = this._ops[f],\n              d = p.node.inputs.map(S => this._values[S]);\n            if (d.indexOf(void 0) !== -1) throw new Error(`unresolved input detected: op: ${p.node}`);\n            let y = d;\n            tt.verbose(\"ExecPlan\", `Running op:${p.node.name} (${y.map((S, L) => `'${p.node.inputs[L]}': ${S.type}[${S.dims.join(\",\")}]`).join(\", \")})`);\n            let T = await this.profiler.event(\"node\", p.node.name, async () => p.op.impl(t, y, p.op.context));\n            if (T.length !== p.node.outputs.length) throw new Error(\"the size of output does not match model definition.\");\n            T.forEach((S, L) => {\n              let P = p.node.outputs[L];\n              if (this._values[P]) throw new Error(`output [${P}] already has value: op:${p.node.name}`);\n              this._values[P] = S;\n            });\n            let v = new Set();\n            T.forEach((S, L) => {\n              let P = p.node.outputs[L];\n              for (let A of s[P].to) {\n                let M = a[A],\n                  V = !0;\n                for (let lt of M.inputs) if (!this._values[lt]) {\n                  V = !1;\n                  break;\n                }\n                V && v.add(A);\n              }\n            }), n.push(...v);\n          }\n          let l = [];\n          for (let f = 0; f < this.graph.getOutputIndices().length; f++) {\n            let p = this.graph.getOutputIndices()[f],\n              d = this._values[p];\n            if (d === void 0) throw new Error(`required output [${p}] does not have value`);\n            p === 0 ? await d.getData() : d.data, l.push(d);\n          }\n          return tt.verbose(\"ExecPlan\", \"disposing of inferenceHandler\"), t.dispose(), l;\n        });\n      }\n    };\n  });\nvar q,\n  Xt,\n  Ur,\n  Pp = O(() => {\n    \"use strict\";\n\n    Pr();\n    q = rr(sr());\n    We();\n    Y();\n    Xt = F.experimental.fbs, Ur = class i {\n      constructor(e) {\n        if (this._attributes = new Map(), e != null) {\n          for (let o of e) o instanceof q.onnx.AttributeProto ? this._attributes.set(o.name, [i.getValue(o), i.getType(o)]) : o instanceof Xt.Attribute && this._attributes.set(o.name(), [i.getValue(o), i.getType(o)]);\n          if (this._attributes.size < e.length) throw new Error(\"duplicated attribute names\");\n        }\n      }\n      set(e, o, t) {\n        this._attributes.set(e, [t, o]);\n      }\n      delete(e) {\n        this._attributes.delete(e);\n      }\n      getFloat(e, o) {\n        return this.get(e, \"float\", o);\n      }\n      getInt(e, o) {\n        return this.get(e, \"int\", o);\n      }\n      getString(e, o) {\n        return this.get(e, \"string\", o);\n      }\n      getTensor(e, o) {\n        return this.get(e, \"tensor\", o);\n      }\n      getFloats(e, o) {\n        return this.get(e, \"floats\", o);\n      }\n      getInts(e, o) {\n        return this.get(e, \"ints\", o);\n      }\n      getStrings(e, o) {\n        return this.get(e, \"strings\", o);\n      }\n      getTensors(e, o) {\n        return this.get(e, \"tensors\", o);\n      }\n      get(e, o, t) {\n        let r = this._attributes.get(e);\n        if (r === void 0) {\n          if (t !== void 0) return t;\n          throw new Error(`required attribute not found: ${e}`);\n        }\n        if (r[1] !== o) throw new Error(`type mismatch: expected ${o} but got ${r[1]}`);\n        return r[0];\n      }\n      static getType(e) {\n        let o = e instanceof q.onnx.AttributeProto ? e.type : e.type();\n        switch (o) {\n          case q.onnx.AttributeProto.AttributeType.FLOAT:\n            return \"float\";\n          case q.onnx.AttributeProto.AttributeType.INT:\n            return \"int\";\n          case q.onnx.AttributeProto.AttributeType.STRING:\n            return \"string\";\n          case q.onnx.AttributeProto.AttributeType.TENSOR:\n            return \"tensor\";\n          case q.onnx.AttributeProto.AttributeType.FLOATS:\n            return \"floats\";\n          case q.onnx.AttributeProto.AttributeType.INTS:\n            return \"ints\";\n          case q.onnx.AttributeProto.AttributeType.STRINGS:\n            return \"strings\";\n          case q.onnx.AttributeProto.AttributeType.TENSORS:\n            return \"tensors\";\n          default:\n            throw new Error(`attribute type is not supported yet: ${q.onnx.AttributeProto.AttributeType[o]}`);\n        }\n      }\n      static getValue(e) {\n        let o = e instanceof q.onnx.AttributeProto ? e.type : e.type();\n        if (o === q.onnx.AttributeProto.AttributeType.GRAPH || o === q.onnx.AttributeProto.AttributeType.GRAPHS) throw new Error(\"graph attribute is not supported yet\");\n        let t = this.getValueNoCheck(e);\n        if (o === q.onnx.AttributeProto.AttributeType.INT && Rt.isLong(t)) return Rt.longToNumber(t);\n        if (o === q.onnx.AttributeProto.AttributeType.INTS) {\n          let r = t,\n            n = new Array(r.length);\n          for (let s = 0; s < r.length; s++) {\n            let a = r[s];\n            n[s] = Rt.longToNumber(a);\n          }\n          return n;\n        }\n        if (o === q.onnx.AttributeProto.AttributeType.TENSOR) return e instanceof q.onnx.AttributeProto ? bt.fromProto(t) : bt.fromOrtTensor(t);\n        if (o === q.onnx.AttributeProto.AttributeType.TENSORS) {\n          if (e instanceof q.onnx.AttributeProto) return t.map(n => bt.fromProto(n));\n          if (e instanceof Xt.Attribute) return t.map(n => bt.fromOrtTensor(n));\n        }\n        return o === q.onnx.AttributeProto.AttributeType.STRING && e instanceof q.onnx.AttributeProto ? kr(t) : o === q.onnx.AttributeProto.AttributeType.STRINGS && e instanceof q.onnx.AttributeProto ? t.map(kr) : t;\n      }\n      static getValueNoCheck(e) {\n        return e instanceof q.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(e) : this.getValueNoCheckFromOrtFormat(e);\n      }\n      static getValueNoCheckFromOnnxFormat(e) {\n        switch (e.type) {\n          case q.onnx.AttributeProto.AttributeType.FLOAT:\n            return e.f;\n          case q.onnx.AttributeProto.AttributeType.INT:\n            return e.i;\n          case q.onnx.AttributeProto.AttributeType.STRING:\n            return e.s;\n          case q.onnx.AttributeProto.AttributeType.TENSOR:\n            return e.t;\n          case q.onnx.AttributeProto.AttributeType.GRAPH:\n            return e.g;\n          case q.onnx.AttributeProto.AttributeType.FLOATS:\n            return e.floats;\n          case q.onnx.AttributeProto.AttributeType.INTS:\n            return e.ints;\n          case q.onnx.AttributeProto.AttributeType.STRINGS:\n            return e.strings;\n          case q.onnx.AttributeProto.AttributeType.TENSORS:\n            return e.tensors;\n          case q.onnx.AttributeProto.AttributeType.GRAPHS:\n            return e.graphs;\n          default:\n            throw new Error(`unsupported attribute type: ${q.onnx.AttributeProto.AttributeType[e.type]}`);\n        }\n      }\n      static getValueNoCheckFromOrtFormat(e) {\n        switch (e.type()) {\n          case Xt.AttributeType.FLOAT:\n            return e.f();\n          case Xt.AttributeType.INT:\n            return e.i();\n          case Xt.AttributeType.STRING:\n            return e.s();\n          case Xt.AttributeType.TENSOR:\n            return e.t();\n          case Xt.AttributeType.GRAPH:\n            return e.g();\n          case Xt.AttributeType.FLOATS:\n            return e.floatsArray();\n          case Xt.AttributeType.INTS:\n            {\n              let o = [];\n              for (let t = 0; t < e.intsLength(); t++) o.push(e.ints(t));\n              return o;\n            }\n          case Xt.AttributeType.STRINGS:\n            {\n              let o = [];\n              for (let t = 0; t < e.stringsLength(); t++) o.push(e.strings(t));\n              return o;\n            }\n          case Xt.AttributeType.TENSORS:\n            {\n              let o = [];\n              for (let t = 0; t < e.tensorsLength(); t++) o.push(e.tensors(t));\n              return o;\n            }\n          default:\n            throw new Error(`unsupported attribute type: ${Xt.AttributeType[e.type()]}`);\n        }\n      }\n    };\n  });\nvar zi,\n  Qn,\n  Wi,\n  me,\n  to,\n  Vi,\n  Ep = O(() => {\n    \"use strict\";\n\n    Pp();\n    Pr();\n    zi = rr(sr());\n    We();\n    Y();\n    Qn = F.experimental.fbs, Wi = {\n      from: (i, e) => new Vi(i, e)\n    }, me = class {\n      constructor(e) {\n        this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, e && (this.type = At.tensorValueTypeFromProto(e.type.tensorType));\n      }\n      get from() {\n        return this._from;\n      }\n      get to() {\n        return this._to;\n      }\n    }, to = class {\n      constructor(e, o) {\n        e instanceof zi.onnx.NodeProto ? (this.name = e.name, this.opType = e.opType, this.attributes = new Ur(e.attribute)) : e instanceof Qn.Node && (this.name = o ?? e.name(), this.opType = e.opType(), this.attributes = new Ur(At.tensorAttributesFromORTFormat(e))), this.inputs = [], this.outputs = [], this.executeNode = !0;\n      }\n    }, Vi = class {\n      constructor(e, o) {\n        if (!e) throw new TypeError(\"graph is empty\");\n        this.buildGraph(e), this.transformGraph(o), this.checkIsAcyclic();\n      }\n      getInputIndices() {\n        return this._allInputIndices;\n      }\n      getInputNames() {\n        return this._allInputNames;\n      }\n      getOutputIndices() {\n        return this._allOutputIndices;\n      }\n      getOutputNames() {\n        return this._allOutputNames;\n      }\n      getValues() {\n        return this._allData;\n      }\n      getNodes() {\n        return this._nodes;\n      }\n      buildGraph(e) {\n        if (e instanceof zi.onnx.GraphProto) this.buildGraphFromOnnxFormat(e);else if (e instanceof Qn.Graph) this.buildGraphFromOrtFormat(e);else throw new TypeError(\"Graph type is not supported.\");\n      }\n      buildGraphFromOnnxFormat(e) {\n        let o = new Map();\n        this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];\n        let t = new Map();\n        if (!e.input) throw new Error(\"missing information in graph: input\");\n        let r = [];\n        for (let n of e.input) {\n          if (o.has(n.name)) throw new Error(`duplicated input name: ${n.name}`);\n          let s = this._allData.push(new me(n)) - 1;\n          o.set(n.name, s), r.push(n.name);\n        }\n        if (!e.initializer) throw new Error(\"missing information in graph: initializer\");\n        for (let n of e.initializer) {\n          let s = o.get(n.name);\n          if (s === void 0) {\n            let a = new me();\n            a.type = {\n              shape: {\n                dims: At.tensorDimsFromProto(n.dims)\n              },\n              tensorType: At.tensorDataTypeFromProto(n.dataType)\n            }, s = this._allData.push(a) - 1, o.set(n.name, s);\n          }\n          this._allData[s]._from = -1, this._allData[s].tensor = bt.fromProto(n);\n        }\n        for (let n = 0; n < this._allData.length; n++) this._allData[n].tensor || (this._allInputIndices.push(n), this._allInputNames.push(r[n]));\n        if (!e.output) throw new Error(\"missing information in graph: output\");\n        for (let n of e.output) {\n          if (o.has(n.name)) throw new Error(`duplicated output name: ${n.name}`);\n          let s = this._allData.push(new me(n)) - 1;\n          o.set(n.name, s), this._allOutputIndices.push(s), this._allOutputNames.push(n.name);\n        }\n        if (!e.node) throw new Error(\"missing information in graph: node\");\n        for (let n of e.node) {\n          if (!n.name) for (let a = 0;; a++) {\n            let u = `unnamed_${n.opType}_${a}`;\n            if (!t.has(u)) {\n              n.name = u;\n              break;\n            }\n          }\n          if (t.has(n.name)) throw new Error(`duplicated node name: ${n.name}`);\n          let s = this._nodes.push(new to(n)) - 1;\n          t.set(n.name, s);\n        }\n        for (let n = 0; n < this._nodes.length; n++) {\n          let s = this._nodes[n],\n            a = e.node[n];\n          if (!a.output) throw new Error(`missing output for node: ${a.name}`);\n          for (let u of a.output) {\n            let l = o.get(u);\n            if (typeof l > \"u\" && (l = this._allData.push(new me()) - 1, o.set(u, l)), s.outputs.push(l), this._allData[l]._from !== void 0) throw new Error(`multiple nodes output to one data value: ${l}`);\n            if (this._allData[l]._from = n, a.opType === \"Constant\") {\n              if (!a.attribute || a.attribute.length !== 1 || !a.attribute[0].t) throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");\n              if (!a.output || a.output.length !== 1) throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");\n              s.outputs.pop(), s.executeNode = !1, this._allData[l]._from = -1, this._allData[l].tensor = bt.fromProto(a.attribute[0].t);\n            }\n          }\n        }\n        for (let n = 0; n < this._nodes.length; n++) {\n          let s = this._nodes[n],\n            a = e.node[n];\n          if (!a.input) throw new Error(`missing input for node: ${a.name}`);\n          for (let u of a.input) {\n            let l = o.get(u);\n            if (typeof l > \"u\") {\n              if (u === \"\" && (a.input.length === 3 || a.input.length === 4) && a.opType === \"Resize\") continue;\n              throw new Error(`unrecognized input '${u}' for node: ${a.name}`);\n            }\n            s.inputs.push(l), this._allData[l]._to.push(n);\n          }\n        }\n        return !0;\n      }\n      buildGraphFromOrtFormat(e) {\n        let o = new Map();\n        this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];\n        let t = new Map(),\n          r = [];\n        for (let n = 0; n < e.inputsLength(); n++) {\n          let s = e.inputs(n);\n          if (o.has(s)) throw new Error(`duplicated input name: ${s}`);\n          for (let a = 0; a < e.nodeArgsLength(); a++) if (e.nodeArgs(a)?.name() === s) {\n            let u = new me();\n            if (e.nodeArgs(a)?.type()?.valueType() !== Qn.TypeInfoValue.tensor_type) throw new Error(\"Unexpected value type for the nodeArg.\");\n            let f = e.nodeArgs(a).type().value(new Qn.TensorTypeAndShape()),\n              p = At.tensorDataTypeFromProto(f.elemType()),\n              d = f.shape(),\n              y = [];\n            for (let v = 0; v < d.dimLength(); v++) y.push(Rt.longToNumber(d.dim(v).value().dimValue()));\n            u.type = {\n              shape: {\n                dims: y\n              },\n              tensorType: p\n            };\n            let T = this._allData.push(u) - 1;\n            o.set(s, T), r.push(s);\n          }\n        }\n        for (let n = 0; n < e.initializersLength(); n++) {\n          let s = e.initializers(n),\n            a = o.get(s.name());\n          if (a === void 0) {\n            let u = new me(),\n              l = At.tensorDimsFromORTFormat(s),\n              f = At.tensorDataTypeFromProto(s.dataType());\n            u.type = {\n              shape: {\n                dims: l\n              },\n              tensorType: f\n            }, a = this._allData.push(u) - 1, o.set(s.name(), a);\n          }\n          this._allData[a]._from = -1, this._allData[a].tensor = bt.fromOrtTensor(s);\n        }\n        for (let n = 0; n < this._allData.length; n++) this._allData[n].tensor || (this._allInputIndices.push(n), this._allInputNames.push(r[n]));\n        for (let n = 0; n < e.outputsLength(); n++) {\n          let s = e.outputs(n);\n          if (o.has(s)) throw new Error(`duplicated output name: ${s}`);\n          let a = this._allData.push(new me()) - 1;\n          o.set(s, a), this._allOutputIndices.push(a), this._allOutputNames.push(s);\n        }\n        if (!e.nodes) throw new Error(\"missing information in graph: node\");\n        for (let n = 0; n < e.nodesLength(); n++) {\n          let s = e.nodes(n),\n            a = s.name();\n          if (!a) for (let l = 0; a = `unnamed_${s.opType()}_${l}`, !!t.has(a); l++);\n          if (t.has(a)) throw new Error(`duplicated node name: ${a}`);\n          let u = this._nodes.push(new to(s, a)) - 1;\n          t.set(a, u);\n        }\n        for (let n = 0; n < this._nodes.length; n++) {\n          let s = this._nodes[n],\n            a = e.nodes(n);\n          if (a == null) throw new Error(`No node exists at index ${n}`);\n          if (a?.outputsLength() === 0) throw new Error(`missing output for node: ${a.name}`);\n          for (let u = 0; u < a?.outputsLength(); u++) {\n            let l = a?.outputs(u),\n              f = o.get(l);\n            if (typeof f > \"u\" && (f = this._allData.push(new me()) - 1, o.set(l, f)), s.outputs.push(f), this._allData[f]._from !== void 0) throw new Error(`multiple nodes output to one data value: ${f}`);\n            if (this._allData[f]._from = n, a.opType() === \"Constant\") {\n              if (a.attributesLength() !== 1 || !a.attributes(0).t()) throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");\n              if (a.outputsLength() !== 1) throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");\n              s.outputs.pop(), s.executeNode = !1, this._allData[f]._from = -1, this._allData[f].tensor = bt.fromOrtTensor(a.attributes(0).t());\n            }\n          }\n        }\n        for (let n = 0; n < this._nodes.length; n++) {\n          let s = this._nodes[n],\n            a = e.nodes(n);\n          if (a.inputsLength() === 0) throw new Error(`missing input for node: ${a.name}`);\n          for (let u = 0; u < a.inputsLength(); u++) {\n            let l = a.inputs(u),\n              f = o.get(l);\n            if (typeof f > \"u\") throw new Error(`unrecognized input '${l}' for node: ${a.name()}`);\n            s.inputs.push(f), this._allData[f]._to.push(n);\n          }\n        }\n      }\n      checkIsAcyclic() {\n        let e = new Set();\n        this._allInputIndices.forEach(r => {\n          this._allData[r]._to.forEach(s => {\n            e.add(s);\n          });\n        });\n        let o = Array.from(e),\n          t = new Array(this._nodes.length).fill(\"white\");\n        for (; o.length > 0;) {\n          let r = o.pop();\n          t[r] === \"gray\" ? t[r] = \"black\" : (o.push(r), t[r] = \"gray\", this._nodes[r].outputs.forEach(n => {\n            let s = this._allData[n];\n            if (typeof s.tensor < \"u\") throw new Error(\"node outputs should not be initialized\");\n            if (s._from !== r) throw new Error(\"from property of the Value object doesn't match index of Node being processed\");\n            s._to.forEach(a => {\n              if (t[a] === \"gray\") throw new Error(\"model graph is cyclic\");\n              t[a] === \"white\" && o.push(a);\n            });\n          }));\n        }\n      }\n      transformGraph(e) {\n        this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), e && e.transformGraph(this), this.finalizeGraph();\n      }\n      finalizeGraph() {\n        let e = 0,\n          o = new Array(this._nodes.length, 0),\n          t = 0;\n        for (let r = 0; r < this._nodes.length; r++) o[r] = t, this._nodes[r].executeNode ? (t !== r && (this._nodes[t] = this._nodes[r]), t++) : this._nodes[r].outputs.forEach(n => {\n          this._allData[n]._from = -2;\n        });\n        this._nodes.splice(t, this._nodes.length - t);\n        for (let r = 0; r < this._allData.length; r++) {\n          let n = this._allData[r];\n          n._from !== void 0 && n._from !== -1 && n._from !== -2 && (n._from = o[n._from]);\n          for (let s = 0; s < n._to.length; s++) if (n._to[s] >= 0) n._to[s] = o[n._to[s]];else throw new Error(\"Trying to update a removed node\");\n        }\n        e = 0;\n        for (let r = 0; r < this._allData.length; r++) {\n          if (this._allData[r].from === -2 && this._allOutputIndices.indexOf(r + e) === -1) {\n            e++, this._allData.splice(r, 1), r--;\n            continue;\n          }\n          if (e > 0) {\n            let n = -1;\n            this._allData[r].from !== void 0 && this._allData[r].from !== -1 ? (n = this._nodes[this._allData[r].from].outputs.indexOf(r + e), n !== -1 && (this._nodes[this._allData[r].from].outputs[n] = r)) : (n = this._allInputIndices.indexOf(r + e), n !== -1 && (this._allInputIndices[n] = r)), this._allData[r].to.forEach(s => {\n              n = this._nodes[s].inputs.indexOf(r + e), n !== -1 && (this._nodes[s].inputs[n] = r);\n            }), this._allData[r].to.length === 0 && (n = this._allOutputIndices.indexOf(r + e), n !== -1 && (this._allOutputIndices[n] = r));\n          }\n        }\n      }\n      deleteNode(e) {\n        let o = this._nodes[e];\n        if (o.outputs.length > 1) {\n          for (let a = 1; a < o.outputs.length; a++) if (this._allData[o.outputs[a]].to.length > 0) throw new Error(\"Node deletion with more than one output connected to other nodes is not supported. \");\n        }\n        o.executeNode = !1;\n        let t = o.inputs[0],\n          r = o.outputs[0],\n          n = this._allData[r].to;\n        for (let a = 0; a < o.inputs.length; a++) {\n          let u = this._allData[o.inputs[a]].to.indexOf(e);\n          if (u === -1) throw new Error(\"The Value object doesn't have the current Node in it's 'to' property \");\n          this._allData[o.inputs[a]].to.splice(u, 1);\n        }\n        this._allData[r]._to = [];\n        let s = this._allOutputIndices.indexOf(r);\n        if (s !== -1 && (this._allOutputIndices[s] = t), n && n.length > 0) for (let a of n) {\n          let u = this._nodes[a].inputs.indexOf(r);\n          if (u === -1) throw new Error(\"The Node object doesn't have the output Value in it's 'inputs' property \");\n          this._nodes[a].inputs[u] = t, this._allData[t].to.push(a);\n        }\n      }\n      removeAllDropoutNodes() {\n        let e = 0;\n        for (let o of this._nodes) {\n          if (o.opType === \"Dropout\") {\n            if (o.inputs.length !== 1) throw new Error(\"Dropout nodes should only contain one input. \");\n            if (o.outputs.length !== 1 && o.outputs.length !== 2) throw new Error(\"Dropout nodes should contain either 1 or 2 output(s)\");\n            if (o.outputs.length === 2 && this._allData[o.outputs[1]]._to.length !== 0) throw new Error(\"Dropout nodes's second output should not be referenced by other nodes\");\n            this.deleteNode(e);\n          }\n          e++;\n        }\n      }\n      removeAllIdentityNodes() {\n        let e = 0;\n        for (let o of this._nodes) o.opType === \"Identity\" && this.deleteNode(e), e++;\n      }\n      isActivation(e) {\n        switch (e.opType) {\n          case \"Relu\":\n          case \"Sigmoid\":\n          case \"Clip\":\n            return !0;\n          default:\n            return !1;\n        }\n      }\n      fuseConvActivationNodes() {\n        for (let e of this._nodes) if (e.opType === \"Conv\") {\n          let o = this._allData[e.outputs[0]]._to;\n          if (o.length === 1 && this.isActivation(this._nodes[o[0]])) {\n            let t = this._nodes[o[0]];\n            if (t.opType === \"Clip\") if (t.inputs.length === 1) try {\n              e.attributes.set(\"activation_params\", \"floats\", [t.attributes.getFloat(\"min\"), t.attributes.getFloat(\"max\")]);\n            } catch {\n              e.attributes.set(\"activation_params\", \"floats\", [Ve, ze]);\n            } else if (t.inputs.length >= 3 && this._allData[t.inputs[1]].tensor !== void 0 && this._allData[t.inputs[2]].tensor !== void 0) e.attributes.set(\"activation_params\", \"floats\", [this._allData[t.inputs[1]].tensor.floatData[0], this._allData[t.inputs[2]].tensor.floatData[0]]);else continue;\n            e.attributes.set(\"activation\", \"string\", t.opType), this.deleteNode(o[0]);\n          }\n        }\n      }\n    };\n  });\nvar Dp,\n  vg,\n  eo,\n  Lp = O(() => {\n    \"use strict\";\n\n    wn();\n    Ep();\n    Pr();\n    Dp = rr(sr());\n    Y();\n    vg = F.experimental.fbs, eo = class {\n      constructor() {}\n      load(e, o, t) {\n        let r;\n        if (!t) try {\n          this.loadFromOnnxFormat(e, o);\n          return;\n        } catch (n) {\n          if (t !== void 0) throw n;\n          r = n;\n        }\n        try {\n          this.loadFromOrtFormat(e, o);\n        } catch (n) {\n          throw t !== void 0 ? n : new Error(`Failed to load model as ONNX format: ${r}\nas ORT format: ${n}`);\n        }\n      }\n      loadFromOnnxFormat(e, o) {\n        let t = Dp.onnx.ModelProto.decode(e);\n        if (Rt.longToNumber(t.irVersion) < 3) throw new Error(\"only support ONNX model with IR_VERSION>=3\");\n        this._opsets = t.opsetImport.map(n => ({\n          domain: n.domain,\n          version: Rt.longToNumber(n.version)\n        })), this._graph = Wi.from(t.graph, o);\n      }\n      loadFromOrtFormat(e, o) {\n        let t = new w.ByteBuffer(e),\n          r = vg.InferenceSession.getRootAsInferenceSession(t).model();\n        if (Rt.longToNumber(r.irVersion()) < 3) throw new Error(\"only support ONNX model with IR_VERSION>=3\");\n        this._opsets = [];\n        for (let s = 0; s < r.opsetImportLength(); s++) {\n          let a = r.opsetImport(s);\n          this._opsets.push({\n            domain: a?.domain(),\n            version: Rt.longToNumber(a.version())\n          });\n        }\n        this._graph = Wi.from(r.graph(), o);\n      }\n      get graph() {\n        return this._graph;\n      }\n      get opsets() {\n        return this._opsets;\n      }\n    };\n  });\nvar ro,\n  $p = O(() => {\n    \"use strict\";\n\n    Sp();\n    Ap();\n    Ut();\n    Lp();\n    ro = class {\n      constructor(e = {}) {\n        this._initialized = !1, this.backendHint = e.backendHint, this.profiler = xn.create(e.profiler), this.context = {\n          profiler: this.profiler,\n          graphInputTypes: [],\n          graphInputDims: []\n        };\n      }\n      get inputNames() {\n        return this._model.graph.getInputNames();\n      }\n      get outputNames() {\n        return this._model.graph.getOutputNames();\n      }\n      startProfiling() {\n        this.profiler.start();\n      }\n      endProfiling() {\n        this.profiler.stop();\n      }\n      async loadModel(e, o, t) {\n        await this.profiler.event(\"session\", \"Session.loadModel\", async () => {\n          let r = await Mi(this.backendHint);\n          if (this.sessionHandler = r.createSessionHandler(this.context), this._model = new eo(), typeof e == \"string\") {\n            let n = e.endsWith(\".ort\");\n            {\n              let a = await (await fetch(e)).arrayBuffer();\n              this.initialize(new Uint8Array(a), n);\n            }\n          } else if (ArrayBuffer.isView(e)) this.initialize(e);else {\n            let n = new Uint8Array(e, o || 0, t || e.byteLength);\n            this.initialize(n);\n          }\n        });\n      }\n      initialize(e, o) {\n        if (this._initialized) throw new Error(\"already initialized\");\n        this.profiler.event(\"session\", \"Session.initialize\", () => {\n          let t = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;\n          this._model.load(e, t, o), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new Zn(this._model.graph, this._ops, this.profiler);\n        }), this._initialized = !0;\n      }\n      async run(e) {\n        if (!this._initialized) throw new Error(\"session not initialized yet\");\n        return this.profiler.event(\"session\", \"Session.run\", async () => {\n          let o = this.normalizeAndValidateInputs(e),\n            t = await this._executionPlan.execute(this.sessionHandler, o);\n          return this.createOutput(t);\n        });\n      }\n      normalizeAndValidateInputs(e) {\n        let o = this._model.graph.getInputNames();\n        if (Array.isArray(e)) {\n          if (e.length !== o.length) throw new Error(`incorrect input array length: expected ${o.length} but got ${e.length}`);\n        } else {\n          if (e.size !== o.length) throw new Error(`incorrect input map size: expected ${o.length} but got ${e.size}`);\n          let t = new Array(e.size),\n            r = 0;\n          for (let n = 0; n < o.length; ++n) {\n            let s = e.get(o[n]);\n            if (!s) throw new Error(`missing input tensor for: '${name}'`);\n            t[r++] = s;\n          }\n          e = t;\n        }\n        if (!this.context.graphInputTypes || this.context.graphInputTypes.length === 0 || !this.context.graphInputDims || this.context.graphInputDims.length === 0) {\n          let t = this._model.graph.getInputIndices(),\n            r = this._model.graph.getValues(),\n            n = new Array(t.length);\n          for (let s = 0; s < t.length; ++s) {\n            let a = r[t[s]];\n            n[s] = a.type.shape.dims, this.context.graphInputTypes.push(a.type.tensorType), this.context.graphInputDims.push(e[s].dims);\n          }\n          this.validateInputTensorDims(n, e, !0);\n        } else this.validateInputTensorDims(this.context.graphInputDims, e, !1);\n        return this.validateInputTensorTypes(this.context.graphInputTypes, e), e;\n      }\n      validateInputTensorTypes(e, o) {\n        for (let t = 0; t < o.length; t++) {\n          let r = e[t],\n            n = o[t].type;\n          if (r !== n) throw new Error(`input tensor[${t}] check failed: expected type '${r}' but got ${n}`);\n        }\n      }\n      validateInputTensorDims(e, o, t) {\n        for (let r = 0; r < o.length; r++) {\n          let n = e[r],\n            s = o[r].dims;\n          if (!this.compareTensorDims(n, s, t)) throw new Error(`input tensor[${r}] check failed: expected shape '[${n.join(\",\")}]' but got [${s.join(\",\")}]`);\n        }\n      }\n      compareTensorDims(e, o, t) {\n        if (e.length !== o.length) return !1;\n        for (let r = 0; r < e.length; ++r) if (e[r] !== o[r] && (!t || e[r] !== 0)) return !1;\n        return !0;\n      }\n      createOutput(e) {\n        let o = this._model.graph.getOutputNames();\n        if (e.length !== o.length) throw new Error(\"expected number of outputs do not match number of generated outputs\");\n        let t = new Map();\n        for (let r = 0; r < o.length; ++r) t.set(o[r], e[r]);\n        return t;\n      }\n      initializeOps(e) {\n        let o = e.getNodes();\n        this._ops = new Array(o.length);\n        for (let t = 0; t < o.length; t++) this._ops[t] = this.sessionHandler.resolve(o[t], this._model.opsets, e);\n      }\n    };\n  });\nvar no,\n  kp = O(() => {\n    \"use strict\";\n\n    Yt();\n    We();\n    no = class {\n      constructor(e) {\n        this.session = e;\n        this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;\n      }\n      async dispose() {}\n      async run(e, o, t) {\n        let r = new Map();\n        for (let a in e) if (Object.hasOwnProperty.call(e, a)) {\n          let u = e[a];\n          r.set(a, new bt(u.dims, u.type, void 0, void 0, u.data));\n        }\n        let n = await this.session.run(r),\n          s = {};\n        return n.forEach((a, u) => {\n          s[u] = new yt(a.type, a.data, a.dims);\n        }), s;\n      }\n      startProfiling() {\n        this.session.startProfiling();\n      }\n      endProfiling() {\n        this.session.endProfiling();\n      }\n    };\n  });\nvar Bp = {};\nOr(Bp, {\n  onnxjsBackend: () => Ig\n});\nvar Hi,\n  Ig,\n  Fp = O(() => {\n    \"use strict\";\n\n    $p();\n    kp();\n    Hi = class {\n      async init() {}\n      async createInferenceSessionHandler(e, o) {\n        let t = new ro(o);\n        return typeof e == \"string\" ? await t.loadModel(e) : await t.loadModel(e), new no(t);\n      }\n    }, Ig = new Hi();\n  });\nvar oo = O(() => {\n  \"use strict\";\n});\nvar Rp = {};\nOr(Rp, {\n  default: () => _g\n});\nvar Cp,\n  Np,\n  _g,\n  Gp = O(() => {\n    \"use strict\";\n\n    qi();\n    Ke();\n    Vr();\n    Cp = \"ort-wasm-proxy-worker\", Np = globalThis.self?.name === Cp;\n    Np && (self.onmessage = i => {\n      let {\n        type: e,\n        in: o\n      } = i.data;\n      try {\n        switch (e) {\n          case \"init-wasm\":\n            io(o.wasm).then(() => {\n              ao(o).then(() => {\n                postMessage({\n                  type: e\n                });\n              }, t => {\n                postMessage({\n                  type: e,\n                  err: t\n                });\n              });\n            }, t => {\n              postMessage({\n                type: e,\n                err: t\n              });\n            });\n            break;\n          case \"init-ep\":\n            {\n              let {\n                epName: t,\n                env: r\n              } = o;\n              so(r, t).then(() => {\n                postMessage({\n                  type: e\n                });\n              }, n => {\n                postMessage({\n                  type: e,\n                  err: n\n                });\n              });\n              break;\n            }\n          case \"copy-from\":\n            {\n              let {\n                  buffer: t\n                } = o,\n                r = zr(t);\n              postMessage({\n                type: e,\n                out: r\n              });\n              break;\n            }\n          case \"create\":\n            {\n              let {\n                model: t,\n                options: r\n              } = o;\n              uo(t, r).then(n => {\n                postMessage({\n                  type: e,\n                  out: n\n                });\n              }, n => {\n                postMessage({\n                  type: e,\n                  err: n\n                });\n              });\n              break;\n            }\n          case \"release\":\n            lo(o), postMessage({\n              type: e\n            });\n            break;\n          case \"run\":\n            {\n              let {\n                sessionId: t,\n                inputIndices: r,\n                inputs: n,\n                outputIndices: s,\n                options: a\n              } = o;\n              fo(t, r, n, s, new Array(s.length).fill(null), a).then(u => {\n                u.some(l => l[3] !== \"cpu\") ? postMessage({\n                  type: e,\n                  err: \"Proxy does not support non-cpu tensor location.\"\n                }) : postMessage({\n                  type: e,\n                  out: u\n                }, po([...n, ...u]));\n              }, u => {\n                postMessage({\n                  type: e,\n                  err: u\n                });\n              });\n              break;\n            }\n          case \"end-profiling\":\n            co(o), postMessage({\n              type: e\n            });\n            break;\n          default:\n        }\n      } catch (t) {\n        postMessage({\n          type: e,\n          err: t\n        });\n      }\n    });\n    _g = Np ? null : i => new Worker(i ?? br, {\n      type: \"module\",\n      name: Cp\n    });\n  });\nvar Up = {};\nOr(Up, {\n  default: () => Og\n});\nvar ji,\n  Mp,\n  Og,\n  Vp = O(() => {\n    \"use strict\";\n\n    Mp = (ji = import.meta.url, async function (i = {}) {\n      function e() {\n        return C.buffer != oe.buffer && it(), oe;\n      }\n      function o() {\n        return C.buffer != oe.buffer && it(), be;\n      }\n      function t() {\n        return C.buffer != oe.buffer && it(), Z;\n      }\n      function r() {\n        return C.buffer != oe.buffer && it(), ge;\n      }\n      function n() {\n        return C.buffer != oe.buffer && it(), ae;\n      }\n      var s,\n        a,\n        u = Object.assign({}, i),\n        l = new Promise((c, m) => {\n          s = c, a = m;\n        }),\n        f = typeof window == \"object\",\n        p = typeof importScripts == \"function\",\n        d = p && self.name == \"em-pthread\";\n      u.mountExternalData = (c, m) => {\n        c.startsWith(\"./\") && (c = c.substring(2)), (u.Ua || (u.Ua = new Map())).set(c, m);\n      }, u.unmountExternalData = () => {\n        delete u.Ua;\n      };\n      var y,\n        T,\n        v = globalThis.SharedArrayBuffer ?? new WebAssembly.Memory({\n          initial: 0,\n          maximum: 0,\n          shared: !0\n        }).buffer.constructor,\n        S = Object.assign({}, u),\n        L = \"./this.program\",\n        P = (c, m) => {\n          throw m;\n        },\n        A = \"\";\n      (f || p) && (p ? A = self.location.href : typeof document < \"u\" && document.currentScript && (A = document.currentScript.src), ji && (A = ji), A = A.startsWith(\"blob:\") ? \"\" : A.substr(0, A.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1), p && (T = c => {\n        var m = new XMLHttpRequest();\n        return m.open(\"GET\", c, !1), m.responseType = \"arraybuffer\", m.send(null), new Uint8Array(m.response);\n      }), y = (c, m, g) => {\n        var x = new XMLHttpRequest();\n        x.open(\"GET\", c, !0), x.responseType = \"arraybuffer\", x.onload = () => {\n          x.status == 200 || x.status == 0 && x.response ? m(x.response) : g();\n        }, x.onerror = g, x.send(null);\n      });\n      var M,\n        V = console.log.bind(console),\n        lt = console.error.bind(console),\n        wt = V,\n        et = lt;\n      if (Object.assign(u, S), S = null, d) {\n        let c = function (m) {\n          try {\n            var g = m.data,\n              x = g.cmd;\n            if (x === \"load\") {\n              let I = [];\n              self.onmessage = E => I.push(E), self.startWorker = () => {\n                postMessage({\n                  cmd: \"loaded\"\n                });\n                for (let E of I) c(E);\n                self.onmessage = c;\n              };\n              for (let E of g.handlers) u[E] && !u[E].proxy || (u[E] = (...R) => {\n                postMessage({\n                  Za: \"callHandler\",\n                  kb: E,\n                  args: R\n                });\n              }, E == \"print\" && (wt = u[E]), E == \"printErr\" && (et = u[E]));\n              C = g.wasmMemory, it(), Dt(g.wasmModule);\n            } else if (x === \"run\") {\n              $o(g.pthread_ptr, 0, 0, 1, 0, 0), Ao(g.pthread_ptr), md(), aa(), _t ||= !0;\n              try {\n                bd(g.start_routine, g.arg);\n              } catch (I) {\n                if (I != \"unwind\") throw I;\n              }\n            } else x === \"cancel\" ? er() && nn(-1) : g.target !== \"setimmediate\" && (x === \"checkMailbox\" ? _t && tn() : x && (et(`worker: received unknown command ${x}`), et(g)));\n          } catch (I) {\n            throw Ha(), I;\n          }\n        };\n        var Vg = c,\n          Dt,\n          _t = !1;\n        et = function (...m) {\n          m = m.join(\" \"), console.error(m);\n        }, self.alert = function (...m) {\n          postMessage({\n            Za: \"alert\",\n            text: m.join(\" \"),\n            nb: er()\n          });\n        }, u.instantiateWasm = (m, g) => new Promise(x => {\n          Dt = I => {\n            I = new WebAssembly.Instance(I, Yr()), g(I), x();\n          };\n        }), self.onunhandledrejection = m => {\n          throw m.reason || m;\n        }, self.onmessage = c;\n      }\n      u.wasmBinary && (M = u.wasmBinary);\n      var C,\n        Kr,\n        we,\n        oe,\n        be,\n        Z,\n        ge,\n        ie,\n        ae,\n        se = !1;\n      function it() {\n        var c = C.buffer;\n        u.HEAP8 = oe = new Int8Array(c), u.HEAP16 = new Int16Array(c), u.HEAPU8 = be = new Uint8Array(c), u.HEAPU16 = new Uint16Array(c), u.HEAP32 = Z = new Int32Array(c), u.HEAPU32 = ge = new Uint32Array(c), u.HEAPF32 = new Float32Array(c), u.HEAPF64 = ae = new Float64Array(c), u.HEAP64 = ie = new BigInt64Array(c), u.HEAPU64 = new BigUint64Array(c);\n      }\n      if (!d) {\n        if (!((C = new WebAssembly.Memory({\n          initial: 256,\n          maximum: 65536,\n          shared: !0\n        })).buffer instanceof v)) throw et(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"), Error(\"bad memory\");\n        it();\n      }\n      var Lt = [],\n        Jr = [],\n        Ye = [],\n        ue = 0,\n        Ze = null,\n        De = null;\n      function le() {\n        if (--ue == 0 && (Ze !== null && (clearInterval(Ze), Ze = null), De)) {\n          var c = De;\n          De = null, c();\n        }\n      }\n      function Mt(c) {\n        throw et(c = \"Aborted(\" + c + \")\"), se = !0, we = 1, c = new WebAssembly.RuntimeError(c + \". Build with -sASSERTIONS for more info.\"), a(c), c;\n      }\n      var ve,\n        gt = c => c.startsWith(\"data:application/octet-stream;base64,\"),\n        Ot = c => c.startsWith(\"file://\");\n      function Jt(c) {\n        if (c == ve && M) return new Uint8Array(M);\n        if (T) return T(c);\n        throw \"both async and sync fetching of the wasm failed\";\n      }\n      function wr(c, m, g) {\n        return function (x) {\n          if (!M && (f || p)) {\n            if (typeof fetch == \"function\" && !Ot(x)) return fetch(x, {\n              credentials: \"same-origin\"\n            }).then(I => {\n              if (!I.ok) throw `failed to load wasm binary file at '${x}'`;\n              return I.arrayBuffer();\n            }).catch(() => Jt(x));\n            if (y) return new Promise((I, E) => {\n              y(x, R => I(new Uint8Array(R)), E);\n            });\n          }\n          return Promise.resolve().then(() => Jt(x));\n        }(c).then(x => WebAssembly.instantiate(x, m)).then(g, x => {\n          et(`failed to asynchronously prepare wasm: ${x}`), Mt(x);\n        });\n      }\n      function Yr() {\n        return {\n          a: {\n            j: hd,\n            b: yd,\n            E: ca,\n            g: ha,\n            V: ma,\n            A: ya,\n            C: xa,\n            W: Ta,\n            T: wa,\n            L: va,\n            S: Ia,\n            o: _a,\n            B: Oa,\n            y: Sa,\n            U: Aa,\n            z: Pa,\n            _: xd,\n            Z: Td,\n            P: wd,\n            w: vd,\n            F: Id,\n            k: _d,\n            O: Ao,\n            Y: Od,\n            I: Sd,\n            J: Ad,\n            K: Pd,\n            G: La,\n            H: $a,\n            v: Ed,\n            q: Dd,\n            l: Ld,\n            p: $d,\n            e: kd,\n            X: Bd,\n            x: Fd,\n            d: ka,\n            f: Cd,\n            i: Nd,\n            u: Rd,\n            t: Gd,\n            s: Md,\n            Q: Ca,\n            R: Na,\n            D: So,\n            h: Ra,\n            n: Ga,\n            M: Ma,\n            m: Ua,\n            a: C,\n            r: Oo,\n            N: Wa,\n            c: zd\n          }\n        };\n      }\n      var ea = {\n        837620: (c, m, g, x, I) => {\n          if (u === void 0 || !u.Ua) return 1;\n          if ((c = Ir(c >>> 0)).startsWith(\"./\") && (c = c.substring(2)), !(c = u.Ua.get(c))) return 2;\n          if (x >>>= 0, (m >>>= 0) + (g >>>= 0) > c.byteLength) return 3;\n          try {\n            let E = c.subarray(m, m + g);\n            switch (I) {\n              case 0:\n                o().set(E, x >>> 0);\n                break;\n              case 1:\n                u.mb(x, E);\n                break;\n              default:\n                return 4;\n            }\n            return 0;\n          } catch {\n            return 4;\n          }\n        },\n        838303: () => typeof wasmOffsetConverter < \"u\"\n      };\n      function hd() {\n        return typeof wasmOffsetConverter < \"u\";\n      }\n      function Io(c) {\n        this.name = \"ExitStatus\", this.message = `Program terminated with exit(${c})`, this.status = c;\n      }\n      var _o = c => {\n          c.terminate(), c.onmessage = () => {};\n        },\n        ra = c => {\n          Ie.length == 0 && (ua(), sa(Ie[0]));\n          var m = Ie.pop();\n          if (!m) return 6;\n          Le.push(m), fe[c.Ra] = m, m.Ra = c.Ra;\n          var g = {\n            cmd: \"run\",\n            start_routine: c.cb,\n            arg: c.ab,\n            pthread_ptr: c.Ra\n          };\n          return m.postMessage(g, c.ib), 0;\n        },\n        vr = 0,\n        st = (c, m, ...g) => {\n          for (var x = 2 * g.length, I = Fo(), E = Bo(8 * x), R = E >>> 3, at = 0; at < g.length; at++) {\n            var Pt = g[at];\n            typeof Pt == \"bigint\" ? (ie[R + 2 * at] = 1n, ie[R + 2 * at + 1] = Pt) : (ie[R + 2 * at] = 0n, n()[R + 2 * at + 1 >>> 0] = Pt);\n          }\n          return c = qa(c, 0, x, E, m), on(I), c;\n        };\n      function Oo(c) {\n        if (d) return st(0, 1, c);\n        if (we = c, !(0 < vr)) {\n          for (var m of Le) _o(m);\n          for (m of Ie) _o(m);\n          Ie = [], Le = [], fe = [], se = !0;\n        }\n        P(c, new Io(c));\n      }\n      function na(c) {\n        if (d) return st(1, 0, c);\n        So(c);\n      }\n      var So = c => {\n          if (we = c, d) throw na(c), \"unwind\";\n          Oo(c);\n        },\n        Ie = [],\n        Le = [],\n        oa = [],\n        fe = {},\n        ia = c => {\n          var m = c.Ra;\n          delete fe[m], Ie.push(c), Le.splice(Le.indexOf(c), 1), c.Ra = 0, ko(m);\n        };\n      function aa() {\n        oa.forEach(c => c());\n      }\n      var sa = c => new Promise(m => {\n        c.onmessage = I => {\n          var E = (I = I.data).cmd;\n          if (I.targetThread && I.targetThread != er()) {\n            var R = fe[I.targetThread];\n            R ? R.postMessage(I, I.transferList) : et(`Internal error! Worker sent a message \"${E}\" to target pthread ${I.targetThread}, but that thread no longer exists!`);\n          } else E === \"checkMailbox\" ? tn() : E === \"spawnThread\" ? ra(I) : E === \"cleanupThread\" ? ia(fe[I.thread]) : E === \"killThread\" ? (I = I.thread, E = fe[I], delete fe[I], _o(E), ko(I), Le.splice(Le.indexOf(E), 1), E.Ra = 0) : E === \"cancelThread\" ? fe[I.thread].postMessage({\n            cmd: \"cancel\"\n          }) : E === \"loaded\" ? (c.loaded = !0, m(c)) : E === \"alert\" ? alert(`Thread ${I.threadId}: ${I.text}`) : I.target === \"setimmediate\" ? c.postMessage(I) : E === \"callHandler\" ? u[I.handler](...I.args) : E && et(`worker sent an unknown command ${E}`);\n        }, c.onerror = I => {\n          throw et(`worker sent an error! ${I.filename}:${I.lineno}: ${I.message}`), I;\n        };\n        var g,\n          x = [];\n        for (g of []) u.hasOwnProperty(g) && x.push(g);\n        c.postMessage({\n          cmd: \"load\",\n          handlers: x,\n          wasmMemory: C,\n          wasmModule: Kr\n        });\n      });\n      function ua() {\n        var c = new Worker(new URL(import.meta.url), {\n          type: \"module\",\n          workerData: \"em-pthread\",\n          name: \"em-pthread\"\n        });\n        Ie.push(c);\n      }\n      var la,\n        Zr = c => {\n          for (; 0 < c.length;) c.shift()(u);\n        },\n        md = () => {\n          var c = er(),\n            m = r()[c + 52 >>> 2 >>> 0];\n          c = r()[c + 56 >>> 2 >>> 0], Xa(m, m - c), on(m);\n        },\n        Qr = [],\n        bd = (c, m) => {\n          vr = 0;\n          var g = Qr[c];\n          g || (c >= Qr.length && (Qr.length = c + 1), Qr[c] = g = la.get(c)), c = g(m), 0 < vr ? we = c : nn(c);\n        };\n      class gd {\n        constructor(m) {\n          this.Xa = m - 24;\n        }\n      }\n      function yd(c, m, g) {\n        var x = new gd(c >>>= 0);\n        throw m >>>= 0, g >>>= 0, r()[x.Xa + 16 >>> 2 >>> 0] = 0, r()[x.Xa + 4 >>> 2 >>> 0] = m, r()[x.Xa + 8 >>> 2 >>> 0] = g, c;\n      }\n      function fa(c, m, g, x) {\n        return d ? st(2, 1, c, m, g, x) : ca(c, m, g, x);\n      }\n      function ca(c, m, g, x) {\n        if (c >>>= 0, m >>>= 0, g >>>= 0, x >>>= 0, v === void 0) return et(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"), 6;\n        var I = [];\n        return d && I.length === 0 ? fa(c, m, g, x) : (c = {\n          cb: g,\n          Ra: c,\n          ab: x,\n          ib: I\n        }, d ? (c.Za = \"spawnThread\", postMessage(c, I), 0) : ra(c));\n      }\n      var pa = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf8\") : void 0,\n        da = (c, m, g) => {\n          var x = (m >>>= 0) + g;\n          for (g = m; c[g] && !(g >= x);) ++g;\n          if (16 < g - m && c.buffer && pa) return pa.decode(c.buffer instanceof v ? c.slice(m, g) : c.subarray(m, g));\n          for (x = \"\"; m < g;) {\n            var I = c[m++];\n            if (128 & I) {\n              var E = 63 & c[m++];\n              if ((224 & I) == 192) x += String.fromCharCode((31 & I) << 6 | E);else {\n                var R = 63 & c[m++];\n                65536 > (I = (240 & I) == 224 ? (15 & I) << 12 | E << 6 | R : (7 & I) << 18 | E << 12 | R << 6 | 63 & c[m++]) ? x += String.fromCharCode(I) : (I -= 65536, x += String.fromCharCode(55296 | I >> 10, 56320 | 1023 & I));\n              }\n            } else x += String.fromCharCode(I);\n          }\n          return x;\n        },\n        Ir = (c, m) => (c >>>= 0) ? da(o(), c, m) : \"\";\n      function ha(c, m, g) {\n        return d ? st(3, 1, c, m, g) : 0;\n      }\n      function ma(c, m) {\n        if (d) return st(4, 1, c, m);\n      }\n      var ba = c => {\n          for (var m = 0, g = 0; g < c.length; ++g) {\n            var x = c.charCodeAt(g);\n            127 >= x ? m++ : 2047 >= x ? m += 2 : 55296 <= x && 57343 >= x ? (m += 4, ++g) : m += 3;\n          }\n          return m;\n        },\n        ga = (c, m, g, x) => {\n          if (!(0 < x)) return 0;\n          var I = g >>>= 0;\n          x = g + x - 1;\n          for (var E = 0; E < c.length; ++E) {\n            var R = c.charCodeAt(E);\n            if (55296 <= R && 57343 >= R && (R = 65536 + ((1023 & R) << 10) | 1023 & c.charCodeAt(++E)), 127 >= R) {\n              if (g >= x) break;\n              m[g++ >>> 0] = R;\n            } else {\n              if (2047 >= R) {\n                if (g + 1 >= x) break;\n                m[g++ >>> 0] = 192 | R >> 6;\n              } else {\n                if (65535 >= R) {\n                  if (g + 2 >= x) break;\n                  m[g++ >>> 0] = 224 | R >> 12;\n                } else {\n                  if (g + 3 >= x) break;\n                  m[g++ >>> 0] = 240 | R >> 18, m[g++ >>> 0] = 128 | R >> 12 & 63;\n                }\n                m[g++ >>> 0] = 128 | R >> 6 & 63;\n              }\n              m[g++ >>> 0] = 128 | 63 & R;\n            }\n          }\n          return m[g >>> 0] = 0, g - I;\n        },\n        _r = (c, m, g) => ga(c, o(), m, g);\n      function ya(c, m) {\n        if (d) return st(5, 1, c, m);\n      }\n      function xa(c, m, g) {\n        if (d) return st(6, 1, c, m, g);\n      }\n      function Ta(c, m, g) {\n        return d ? st(7, 1, c, m, g) : 0;\n      }\n      function wa(c, m) {\n        if (d) return st(8, 1, c, m);\n      }\n      function va(c, m, g) {\n        if (d) return st(9, 1, c, m, g);\n      }\n      function Ia(c, m, g, x) {\n        if (d) return st(10, 1, c, m, g, x);\n      }\n      function _a(c, m, g, x) {\n        if (d) return st(11, 1, c, m, g, x);\n      }\n      function Oa(c, m, g, x) {\n        if (d) return st(12, 1, c, m, g, x);\n      }\n      function Sa(c) {\n        if (d) return st(13, 1, c);\n      }\n      function Aa(c, m) {\n        if (d) return st(14, 1, c, m);\n      }\n      function Pa(c, m, g) {\n        if (d) return st(15, 1, c, m, g);\n      }\n      var xd = () => {\n          Mt(\"\");\n        },\n        Td = () => 1;\n      function wd(c) {\n        $o(c >>> 0, !p, 1, !f, 131072, !1), aa();\n      }\n      function Ao(c) {\n        c >>>= 0, typeof Atomics.jb == \"function\" && (Atomics.jb(t(), c >>> 2, c).value.then(tn), c += 128, Atomics.store(t(), c >>> 2, 1));\n      }\n      var tn = () => {\n        var c = er();\n        if (c && (Ao(c), c = ja, !se)) try {\n          if (c(), !(0 < vr)) try {\n            d ? nn(we) : So(we);\n          } catch (m) {\n            m instanceof Io || m == \"unwind\" || P(1, m);\n          }\n        } catch (m) {\n          m instanceof Io || m == \"unwind\" || P(1, m);\n        }\n      };\n      function vd(c, m) {\n        (c >>>= 0) == m >>> 0 ? setTimeout(tn) : d ? postMessage({\n          targetThread: c,\n          cmd: \"checkMailbox\"\n        }) : (c = fe[c]) && c.postMessage({\n          cmd: \"checkMailbox\"\n        });\n      }\n      var Po = [];\n      function Id(c, m, g, x, I) {\n        for (m >>>= 0, x /= 2, Po.length = x, g = I >>> 0 >>> 3, I = 0; I < x; I++) Po[I] = ie[g + 2 * I] ? ie[g + 2 * I + 1] : n()[g + 2 * I + 1 >>> 0];\n        return (m ? ea[m] : Wd[c])(...Po);\n      }\n      function _d(c) {\n        c >>>= 0, d ? postMessage({\n          cmd: \"cleanupThread\",\n          thread: c\n        }) : ia(fe[c]);\n      }\n      function Od(c) {}\n      function Sd(c, m) {\n        c = -9007199254740992 > c || 9007199254740992 < c ? NaN : Number(c), m >>>= 0, c = new Date(1e3 * c), t()[m >>> 2 >>> 0] = c.getUTCSeconds(), t()[m + 4 >>> 2 >>> 0] = c.getUTCMinutes(), t()[m + 8 >>> 2 >>> 0] = c.getUTCHours(), t()[m + 12 >>> 2 >>> 0] = c.getUTCDate(), t()[m + 16 >>> 2 >>> 0] = c.getUTCMonth(), t()[m + 20 >>> 2 >>> 0] = c.getUTCFullYear() - 1900, t()[m + 24 >>> 2 >>> 0] = c.getUTCDay(), c = (c.getTime() - Date.UTC(c.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, t()[m + 28 >>> 2 >>> 0] = c;\n      }\n      var Qe = c => c % 4 == 0 && (c % 100 != 0 || c % 400 == 0),\n        Ea = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],\n        Da = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n      function Ad(c, m) {\n        c = -9007199254740992 > c || 9007199254740992 < c ? NaN : Number(c), m >>>= 0, c = new Date(1e3 * c), t()[m >>> 2 >>> 0] = c.getSeconds(), t()[m + 4 >>> 2 >>> 0] = c.getMinutes(), t()[m + 8 >>> 2 >>> 0] = c.getHours(), t()[m + 12 >>> 2 >>> 0] = c.getDate(), t()[m + 16 >>> 2 >>> 0] = c.getMonth(), t()[m + 20 >>> 2 >>> 0] = c.getFullYear() - 1900, t()[m + 24 >>> 2 >>> 0] = c.getDay();\n        var g = (Qe(c.getFullYear()) ? Ea : Da)[c.getMonth()] + c.getDate() - 1 | 0;\n        t()[m + 28 >>> 2 >>> 0] = g, t()[m + 36 >>> 2 >>> 0] = -60 * c.getTimezoneOffset(), g = new Date(c.getFullYear(), 6, 1).getTimezoneOffset();\n        var x = new Date(c.getFullYear(), 0, 1).getTimezoneOffset();\n        c = 0 | (g != x && c.getTimezoneOffset() == Math.min(x, g)), t()[m + 32 >>> 2 >>> 0] = c;\n      }\n      function Pd(c) {\n        c >>>= 0;\n        var m = new Date(t()[c + 20 >>> 2 >>> 0] + 1900, t()[c + 16 >>> 2 >>> 0], t()[c + 12 >>> 2 >>> 0], t()[c + 8 >>> 2 >>> 0], t()[c + 4 >>> 2 >>> 0], t()[c >>> 2 >>> 0], 0),\n          g = t()[c + 32 >>> 2 >>> 0],\n          x = m.getTimezoneOffset(),\n          I = new Date(m.getFullYear(), 6, 1).getTimezoneOffset(),\n          E = new Date(m.getFullYear(), 0, 1).getTimezoneOffset(),\n          R = Math.min(E, I);\n        return 0 > g ? t()[c + 32 >>> 2 >>> 0] = +(I != E && R == x) : 0 < g != (R == x) && (I = Math.max(E, I), m.setTime(m.getTime() + 6e4 * ((0 < g ? R : I) - x))), t()[c + 24 >>> 2 >>> 0] = m.getDay(), g = (Qe(m.getFullYear()) ? Ea : Da)[m.getMonth()] + m.getDate() - 1 | 0, t()[c + 28 >>> 2 >>> 0] = g, t()[c >>> 2 >>> 0] = m.getSeconds(), t()[c + 4 >>> 2 >>> 0] = m.getMinutes(), t()[c + 8 >>> 2 >>> 0] = m.getHours(), t()[c + 12 >>> 2 >>> 0] = m.getDate(), t()[c + 16 >>> 2 >>> 0] = m.getMonth(), t()[c + 20 >>> 2 >>> 0] = m.getYear(), c = m.getTime(), BigInt(isNaN(c) ? -1 : c / 1e3);\n      }\n      function La(c, m, g, x, I, E, R) {\n        return d ? st(16, 1, c, m, g, x, I, E, R) : -52;\n      }\n      function $a(c, m, g, x, I, E) {\n        if (d) return st(17, 1, c, m, g, x, I, E);\n      }\n      function Ed(c, m, g, x) {\n        c >>>= 0, m >>>= 0, g >>>= 0, x >>>= 0;\n        var I = new Date().getFullYear(),\n          E = new Date(I, 0, 1),\n          R = new Date(I, 6, 1);\n        I = E.getTimezoneOffset();\n        var at = R.getTimezoneOffset(),\n          Pt = Math.max(I, at);\n        r()[c >>> 2 >>> 0] = 60 * Pt, t()[m >>> 2 >>> 0] = +(I != at), E = (c = $t => $t.toLocaleTimeString(void 0, {\n          hour12: !1,\n          timeZoneName: \"short\"\n        }).split(\" \")[1])(E), R = c(R), at < I ? (_r(E, g, 17), _r(R, x, 17)) : (_r(E, x, 17), _r(R, g, 17));\n      }\n      var Eo = [];\n      function Dd(c, m, g) {\n        c >>>= 0, m >>>= 0, g >>>= 0, Eo.length = 0;\n        for (var x; x = o()[m++ >>> 0];) {\n          var I = x != 105;\n          g += (I &= x != 112) && g % 8 ? 4 : 0, Eo.push(x == 112 ? r()[g >>> 2 >>> 0] : x == 106 ? ie[g >>> 3] : x == 105 ? t()[g >>> 2 >>> 0] : n()[g >>> 3 >>> 0]), g += I ? 8 : 4;\n        }\n        return ea[c](...Eo);\n      }\n      var Ld = () => {},\n        $d = () => Date.now();\n      function kd(c, m) {\n        return et(Ir(c >>> 0, m >>> 0));\n      }\n      var ka,\n        Bd = () => {\n          throw vr += 1, \"unwind\";\n        };\n      function Fd() {\n        return 4294901760;\n      }\n      ka = () => performance.timeOrigin + performance.now();\n      var Cd = () => navigator.hardwareConcurrency;\n      function Nd() {\n        return Mt(\"Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER\"), 0;\n      }\n      function Rd(c) {\n        c >>>= 0;\n        var m = o().length;\n        if (c <= m || 4294901760 < c) return !1;\n        for (var g = 1; 4 >= g; g *= 2) {\n          var x = m * (1 + .2 / g);\n          x = Math.min(x, c + 100663296);\n          var I = Math;\n          x = Math.max(c, x);\n          t: {\n            I = (I.min.call(I, 4294901760, x + (65536 - x % 65536) % 65536) - C.buffer.byteLength + 65535) / 65536;\n            try {\n              C.grow(I), it();\n              var E = 1;\n              break t;\n            } catch {}\n            E = void 0;\n          }\n          if (E) return !0;\n        }\n        return !1;\n      }\n      var en = () => (Mt(\"Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER\"), 0),\n        tr = {},\n        Ba = c => {\n          c.forEach(m => {\n            var g = en();\n            g && (tr[g] = m);\n          });\n        };\n      function Gd() {\n        var c = Error().stack.toString().split(`\n`);\n        return c[0] == \"Error\" && c.shift(), Ba(c), tr.$a = en(), tr.bb = c, tr.$a;\n      }\n      function Md(c, m, g) {\n        if (c >>>= 0, m >>>= 0, tr.$a == c) var x = tr.bb;else (x = Error().stack.toString().split(`\n`))[0] == \"Error\" && x.shift(), Ba(x);\n        for (var I = 3; x[I] && en() != c;) ++I;\n        for (c = 0; c < g && x[c + I]; ++c) t()[m + 4 * c >>> 2 >>> 0] = en();\n        return c;\n      }\n      var Do,\n        Lo = {},\n        Fa = () => {\n          if (!Do) {\n            var c,\n              m = {\n                USER: \"web_user\",\n                LOGNAME: \"web_user\",\n                PATH: \"/\",\n                PWD: \"/\",\n                HOME: \"/home/web_user\",\n                LANG: (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n                _: L || \"./this.program\"\n              };\n            for (c in Lo) Lo[c] === void 0 ? delete m[c] : m[c] = Lo[c];\n            var g = [];\n            for (c in m) g.push(`${c}=${m[c]}`);\n            Do = g;\n          }\n          return Do;\n        };\n      function Ca(c, m) {\n        if (d) return st(18, 1, c, m);\n        c >>>= 0, m >>>= 0;\n        var g = 0;\n        return Fa().forEach((x, I) => {\n          var E = m + g;\n          for (I = r()[c + 4 * I >>> 2 >>> 0] = E, E = 0; E < x.length; ++E) e()[I++ >>> 0] = x.charCodeAt(E);\n          e()[I >>> 0] = 0, g += x.length + 1;\n        }), 0;\n      }\n      function Na(c, m) {\n        if (d) return st(19, 1, c, m);\n        c >>>= 0, m >>>= 0;\n        var g = Fa();\n        r()[c >>> 2 >>> 0] = g.length;\n        var x = 0;\n        return g.forEach(I => x += I.length + 1), r()[m >>> 2 >>> 0] = x, 0;\n      }\n      function Ra(c) {\n        return d ? st(20, 1, c) : 52;\n      }\n      function Ga(c, m, g, x) {\n        return d ? st(21, 1, c, m, g, x) : 52;\n      }\n      function Ma(c, m, g, x) {\n        return d ? st(22, 1, c, m, g, x) : 70;\n      }\n      var Ud = [null, [], []];\n      function Ua(c, m, g, x) {\n        if (d) return st(23, 1, c, m, g, x);\n        m >>>= 0, g >>>= 0, x >>>= 0;\n        for (var I = 0, E = 0; E < g; E++) {\n          var R = r()[m >>> 2 >>> 0],\n            at = r()[m + 4 >>> 2 >>> 0];\n          m += 8;\n          for (var Pt = 0; Pt < at; Pt++) {\n            var $t = o()[R + Pt >>> 0],\n              Ft = Ud[c];\n            $t === 0 || $t === 10 ? ((c === 1 ? wt : et)(da(Ft, 0)), Ft.length = 0) : Ft.push($t);\n          }\n          I += at;\n        }\n        return r()[x >>> 2 >>> 0] = I, 0;\n      }\n      var Va = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n        za = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n        Vd = (c, m) => {\n          e().set(c, m >>> 0);\n        };\n      function Wa(c, m, g, x) {\n        function I(_, Q, ft) {\n          for (_ = typeof _ == \"number\" ? _.toString() : _ || \"\"; _.length < Q;) _ = ft[0] + _;\n          return _;\n        }\n        function E(_, Q) {\n          return I(_, Q, \"0\");\n        }\n        function R(_, Q) {\n          function ft(Za) {\n            return 0 > Za ? -1 : 0 < Za ? 1 : 0;\n          }\n          var $e;\n          return ($e = ft(_.getFullYear() - Q.getFullYear())) === 0 && ($e = ft(_.getMonth() - Q.getMonth())) === 0 && ($e = ft(_.getDate() - Q.getDate())), $e;\n        }\n        function at(_) {\n          switch (_.getDay()) {\n            case 0:\n              return new Date(_.getFullYear() - 1, 11, 29);\n            case 1:\n              return _;\n            case 2:\n              return new Date(_.getFullYear(), 0, 3);\n            case 3:\n              return new Date(_.getFullYear(), 0, 2);\n            case 4:\n              return new Date(_.getFullYear(), 0, 1);\n            case 5:\n              return new Date(_.getFullYear() - 1, 11, 31);\n            case 6:\n              return new Date(_.getFullYear() - 1, 11, 30);\n          }\n        }\n        function Pt(_) {\n          var Q = _.Sa;\n          for (_ = new Date(new Date(_.Ta + 1900, 0, 1).getTime()); 0 < Q;) {\n            var ft = _.getMonth(),\n              $e = (Qe(_.getFullYear()) ? Va : za)[ft];\n            if (!(Q > $e - _.getDate())) {\n              _.setDate(_.getDate() + Q);\n              break;\n            }\n            Q -= $e - _.getDate() + 1, _.setDate(1), 11 > ft ? _.setMonth(ft + 1) : (_.setMonth(0), _.setFullYear(_.getFullYear() + 1));\n          }\n          return ft = new Date(_.getFullYear() + 1, 0, 4), Q = at(new Date(_.getFullYear(), 0, 4)), ft = at(ft), 0 >= R(Q, _) ? 0 >= R(ft, _) ? _.getFullYear() + 1 : _.getFullYear() : _.getFullYear() - 1;\n        }\n        c >>>= 0, m >>>= 0, g >>>= 0, x >>>= 0;\n        var $t = r()[x + 40 >>> 2 >>> 0];\n        for (var Ft in x = {\n          gb: t()[x >>> 2 >>> 0],\n          fb: t()[x + 4 >>> 2 >>> 0],\n          Va: t()[x + 8 >>> 2 >>> 0],\n          Ya: t()[x + 12 >>> 2 >>> 0],\n          Wa: t()[x + 16 >>> 2 >>> 0],\n          Ta: t()[x + 20 >>> 2 >>> 0],\n          Qa: t()[x + 24 >>> 2 >>> 0],\n          Sa: t()[x + 28 >>> 2 >>> 0],\n          ob: t()[x + 32 >>> 2 >>> 0],\n          eb: t()[x + 36 >>> 2 >>> 0],\n          hb: $t ? Ir($t) : \"\"\n        }, g = Ir(g), $t = {\n          \"%c\": \"%a %b %d %H:%M:%S %Y\",\n          \"%D\": \"%m/%d/%y\",\n          \"%F\": \"%Y-%m-%d\",\n          \"%h\": \"%b\",\n          \"%r\": \"%I:%M:%S %p\",\n          \"%R\": \"%H:%M\",\n          \"%T\": \"%H:%M:%S\",\n          \"%x\": \"%m/%d/%y\",\n          \"%X\": \"%H:%M:%S\",\n          \"%Ec\": \"%c\",\n          \"%EC\": \"%C\",\n          \"%Ex\": \"%m/%d/%y\",\n          \"%EX\": \"%H:%M:%S\",\n          \"%Ey\": \"%y\",\n          \"%EY\": \"%Y\",\n          \"%Od\": \"%d\",\n          \"%Oe\": \"%e\",\n          \"%OH\": \"%H\",\n          \"%OI\": \"%I\",\n          \"%Om\": \"%m\",\n          \"%OM\": \"%M\",\n          \"%OS\": \"%S\",\n          \"%Ou\": \"%u\",\n          \"%OU\": \"%U\",\n          \"%OV\": \"%V\",\n          \"%Ow\": \"%w\",\n          \"%OW\": \"%W\",\n          \"%Oy\": \"%y\"\n        }) g = g.replace(new RegExp(Ft, \"g\"), $t[Ft]);\n        var Ja = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n          Ya = \"January February March April May June July August September October November December\".split(\" \");\n        for (Ft in $t = {\n          \"%a\": _ => Ja[_.Qa].substring(0, 3),\n          \"%A\": _ => Ja[_.Qa],\n          \"%b\": _ => Ya[_.Wa].substring(0, 3),\n          \"%B\": _ => Ya[_.Wa],\n          \"%C\": _ => E((_.Ta + 1900) / 100 | 0, 2),\n          \"%d\": _ => E(_.Ya, 2),\n          \"%e\": _ => I(_.Ya, 2, \" \"),\n          \"%g\": _ => Pt(_).toString().substring(2),\n          \"%G\": Pt,\n          \"%H\": _ => E(_.Va, 2),\n          \"%I\": _ => ((_ = _.Va) == 0 ? _ = 12 : 12 < _ && (_ -= 12), E(_, 2)),\n          \"%j\": _ => {\n            for (var Q = 0, ft = 0; ft <= _.Wa - 1; Q += (Qe(_.Ta + 1900) ? Va : za)[ft++]);\n            return E(_.Ya + Q, 3);\n          },\n          \"%m\": _ => E(_.Wa + 1, 2),\n          \"%M\": _ => E(_.fb, 2),\n          \"%n\": () => `\n`,\n          \"%p\": _ => 0 <= _.Va && 12 > _.Va ? \"AM\" : \"PM\",\n          \"%S\": _ => E(_.gb, 2),\n          \"%t\": () => \"\t\",\n          \"%u\": _ => _.Qa || 7,\n          \"%U\": _ => E(Math.floor((_.Sa + 7 - _.Qa) / 7), 2),\n          \"%V\": _ => {\n            var Q = Math.floor((_.Sa + 7 - (_.Qa + 6) % 7) / 7);\n            if (2 >= (_.Qa + 371 - _.Sa - 2) % 7 && Q++, Q) Q == 53 && ((ft = (_.Qa + 371 - _.Sa) % 7) == 4 || ft == 3 && Qe(_.Ta) || (Q = 1));else {\n              Q = 52;\n              var ft = (_.Qa + 7 - _.Sa - 1) % 7;\n              (ft == 4 || ft == 5 && Qe(_.Ta % 400 - 1)) && Q++;\n            }\n            return E(Q, 2);\n          },\n          \"%w\": _ => _.Qa,\n          \"%W\": _ => E(Math.floor((_.Sa + 7 - (_.Qa + 6) % 7) / 7), 2),\n          \"%y\": _ => (_.Ta + 1900).toString().substring(2),\n          \"%Y\": _ => _.Ta + 1900,\n          \"%z\": _ => {\n            var Q = 0 <= (_ = _.eb);\n            return _ = Math.abs(_) / 60, (Q ? \"+\" : \"-\") + (\"0000\" + (_ / 60 * 100 + _ % 60)).slice(-4);\n          },\n          \"%Z\": _ => _.hb,\n          \"%%\": () => \"%\"\n        }, g = g.replace(/%%/g, \"\\0\\0\"), $t) g.includes(Ft) && (g = g.replace(new RegExp(Ft, \"g\"), $t[Ft](x)));\n        return Ft = function (_) {\n          var Q = Array(ba(_) + 1);\n          return ga(_, Q, 0, Q.length), Q;\n        }(g = g.replace(/\\0\\0/g, \"%\")), Ft.length > m ? 0 : (Vd(Ft, c), Ft.length - 1);\n      }\n      function zd(c, m, g, x) {\n        return Wa(c >>> 0, m >>> 0, g >>> 0, x >>> 0);\n      }\n      d || function () {\n        for (var c = u.numThreads - 1; c--;) ua();\n        Lt.unshift(() => {\n          ue++, function (m) {\n            d ? m() : Promise.all(Ie.map(sa)).then(m);\n          }(() => le());\n        });\n      }();\n      var Wd = [Oo, na, fa, ha, ma, ya, xa, Ta, wa, va, Ia, _a, Oa, Sa, Aa, Pa, La, $a, Ca, Na, Ra, Ga, Ma, Ua],\n        U = function () {\n          function c(g, x) {\n            return U = g.exports, U = function () {\n              var I = U,\n                E = at => () => at() >>> 0,\n                R = at => Pt => at(Pt) >>> 0;\n              return (I = Object.assign({}, I)).Ba = E(I.Ba), I.Ca = R(I.Ca), I.emscripten_main_runtime_thread_id = E(I.emscripten_main_runtime_thread_id), I.Oa = R(I.Oa), I.Pa = E(I.Pa), I;\n            }(), oa.push(U.Ea), la = U.Fa, Jr.unshift(U.$), Kr = x, le(), U;\n          }\n          var m = Yr();\n          if (ue++, u.instantiateWasm) try {\n            return u.instantiateWasm(m, c);\n          } catch (g) {\n            et(`Module.instantiateWasm callback failed with error: ${g}`), a(g);\n          }\n          return ve ||= u.locateFile ? gt(\"ort-wasm-simd-threaded.wasm\") ? \"ort-wasm-simd-threaded.wasm\" : u.locateFile ? u.locateFile(\"ort-wasm-simd-threaded.wasm\", A) : A + \"ort-wasm-simd-threaded.wasm\" : new URL(\"ort-wasm-simd-threaded.wasm\", import.meta.url).href, function (g, x) {\n            var I = ve;\n            return M || typeof WebAssembly.instantiateStreaming != \"function\" || gt(I) || Ot(I) || typeof fetch != \"function\" ? wr(I, g, x) : fetch(I, {\n              credentials: \"same-origin\"\n            }).then(E => WebAssembly.instantiateStreaming(E, g).then(x, function (R) {\n              return et(`wasm streaming compile failed: ${R}`), et(\"falling back to ArrayBuffer instantiation\"), wr(I, g, x);\n            }));\n          }(m, function (g) {\n            c(g.instance, g.module);\n          }).catch(a), {};\n        }();\n      u._OrtInit = (c, m) => (u._OrtInit = U.aa)(c, m), u._OrtGetLastError = (c, m) => (u._OrtGetLastError = U.ba)(c, m), u._OrtCreateSessionOptions = (c, m, g, x, I, E, R, at, Pt, $t) => (u._OrtCreateSessionOptions = U.ca)(c, m, g, x, I, E, R, at, Pt, $t), u._OrtAppendExecutionProvider = (c, m) => (u._OrtAppendExecutionProvider = U.da)(c, m), u._OrtAddFreeDimensionOverride = (c, m, g) => (u._OrtAddFreeDimensionOverride = U.ea)(c, m, g), u._OrtAddSessionConfigEntry = (c, m, g) => (u._OrtAddSessionConfigEntry = U.fa)(c, m, g), u._OrtReleaseSessionOptions = c => (u._OrtReleaseSessionOptions = U.ga)(c), u._OrtCreateSession = (c, m, g) => (u._OrtCreateSession = U.ha)(c, m, g), u._OrtReleaseSession = c => (u._OrtReleaseSession = U.ia)(c), u._OrtGetInputOutputCount = (c, m, g) => (u._OrtGetInputOutputCount = U.ja)(c, m, g), u._OrtGetInputName = (c, m) => (u._OrtGetInputName = U.ka)(c, m), u._OrtGetOutputName = (c, m) => (u._OrtGetOutputName = U.la)(c, m), u._OrtFree = c => (u._OrtFree = U.ma)(c), u._OrtCreateTensor = (c, m, g, x, I, E) => (u._OrtCreateTensor = U.na)(c, m, g, x, I, E), u._OrtGetTensorData = (c, m, g, x, I) => (u._OrtGetTensorData = U.oa)(c, m, g, x, I), u._OrtReleaseTensor = c => (u._OrtReleaseTensor = U.pa)(c), u._OrtCreateRunOptions = (c, m, g, x) => (u._OrtCreateRunOptions = U.qa)(c, m, g, x), u._OrtAddRunConfigEntry = (c, m, g) => (u._OrtAddRunConfigEntry = U.ra)(c, m, g), u._OrtReleaseRunOptions = c => (u._OrtReleaseRunOptions = U.sa)(c), u._OrtCreateBinding = c => (u._OrtCreateBinding = U.ta)(c), u._OrtBindInput = (c, m, g) => (u._OrtBindInput = U.ua)(c, m, g), u._OrtBindOutput = (c, m, g, x) => (u._OrtBindOutput = U.va)(c, m, g, x), u._OrtClearBoundOutputs = c => (u._OrtClearBoundOutputs = U.wa)(c), u._OrtReleaseBinding = c => (u._OrtReleaseBinding = U.xa)(c), u._OrtRunWithBinding = (c, m, g, x, I) => (u._OrtRunWithBinding = U.ya)(c, m, g, x, I), u._OrtRun = (c, m, g, x, I, E, R, at) => (u._OrtRun = U.za)(c, m, g, x, I, E, R, at), u._OrtEndProfiling = c => (u._OrtEndProfiling = U.Aa)(c);\n      var er = () => (er = U.Ba)();\n      u._malloc = c => (u._malloc = U.Ca)(c), u._free = c => (u._free = U.Da)(c);\n      var rn,\n        $o = (c, m, g, x, I, E) => ($o = U.Ga)(c, m, g, x, I, E),\n        Ha = () => (Ha = U.Ha)(),\n        qa = (c, m, g, x, I) => (qa = U.Ia)(c, m, g, x, I),\n        ko = c => (ko = U.Ja)(c),\n        nn = c => (nn = U.Ka)(c),\n        ja = () => (ja = U.La)(),\n        Xa = (c, m) => (Xa = U.Ma)(c, m),\n        on = c => (on = U.Na)(c),\n        Bo = c => (Bo = U.Oa)(c),\n        Fo = () => (Fo = U.Pa)();\n      function Ka() {\n        0 < ue || (d ? (s(u), d || Zr(Jr), startWorker(u)) : (Zr(Lt), 0 < ue || rn || (rn = !0, u.calledRun = !0, se || (d || Zr(Jr), s(u), d || Zr(Ye)))));\n      }\n      return u.___start_em_js = 838360, u.___stop_em_js = 838421, u.stackSave = () => Fo(), u.stackRestore = c => on(c), u.stackAlloc = c => Bo(c), u.UTF8ToString = Ir, u.stringToUTF8 = _r, u.lengthBytesUTF8 = ba, De = function c() {\n        rn || Ka(), rn || (De = c);\n      }, Ka(), l;\n    }), Og = Mp;\n    globalThis.self?.name === \"em-pthread\" && Mp();\n  });\nvar br,\n  Sg,\n  Ag,\n  Pg,\n  zp,\n  Wp,\n  Eg,\n  Hp,\n  Vr = O(() => {\n    \"use strict\";\n\n    oo();\n    br = !1 ? void 0 : import.meta.url ?? (typeof document < \"u\" ? document.currentScript?.src : typeof self < \"u\" ? self.location?.href : void 0), Sg = !1 || typeof location > \"u\" ? void 0 : location.origin, Ag = (i, e) => {\n      try {\n        let o = e ?? br;\n        return (o ? new URL(i, o) : new URL(i)).origin === Sg;\n      } catch {\n        return !1;\n      }\n    }, Pg = async i => {\n      let o = await (await fetch(i, {\n        credentials: \"same-origin\"\n      })).blob();\n      return URL.createObjectURL(o);\n    }, zp = (Gp(), sn(Rp)).default, Wp = async () => {\n      if (!br) throw new Error(\"Failed to load proxy worker: cannot determine the script source URL.\");\n      if (Ag(br)) return [void 0, zp()];\n      let i = await Pg(br);\n      return [i, zp(i)];\n    }, Eg = (Vp(), sn(Up)).default, Hp = async (i, e, o) => [void 0, Eg];\n  });\nvar Xi,\n  Ki,\n  ho,\n  qp,\n  Dg,\n  Lg,\n  io,\n  xt,\n  Ke = O(() => {\n    \"use strict\";\n\n    Vr();\n    Ki = !1, ho = !1, qp = !1, Dg = () => {\n      if (typeof SharedArrayBuffer > \"u\") return !1;\n      try {\n        return typeof MessageChannel < \"u\" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));\n      } catch {\n        return !1;\n      }\n    }, Lg = () => {\n      try {\n        return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));\n      } catch {\n        return !1;\n      }\n    }, io = async i => {\n      if (Ki) return Promise.resolve();\n      if (ho) throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");\n      if (qp) throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");\n      ho = !0;\n      let e = i.initTimeout,\n        o = i.numThreads;\n      if (!Lg()) throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");\n      let t = Dg();\n      o > 1 && !t && (typeof self < \"u\" && !self.crossOriginIsolated && console.warn(\"env.wasm.numThreads is set to \" + o + \", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"), console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"), i.numThreads = o = 1);\n      let r = i.wasmPaths,\n        n = typeof r == \"string\" ? r : void 0,\n        s = r?.mjs,\n        a = s?.href ?? s,\n        u = r?.wasm,\n        l = u?.href ?? u,\n        f = i.wasmBinary,\n        [p, d] = await Hp(a, n, o > 1),\n        y = !1,\n        T = [];\n      if (e > 0 && T.push(new Promise(v => {\n        setTimeout(() => {\n          y = !0, v();\n        }, e);\n      })), T.push(new Promise((v, S) => {\n        let L = {\n          numThreads: o\n        };\n        f ? L.wasmBinary = f : (l || n) && (L.locateFile = (P, A) => l ?? (n ?? A) + P), d(L).then(P => {\n          ho = !1, Ki = !0, Xi = P, v(), p && URL.revokeObjectURL(p);\n        }, P => {\n          ho = !1, qp = !0, S(P);\n        });\n      })), await Promise.race(T), y) throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`);\n    }, xt = () => {\n      if (Ki && Xi) return Xi;\n      throw new Error(\"WebAssembly is not initialized yet.\");\n    };\n  });\nvar Tt,\n  Wr,\n  ht,\n  mo = O(() => {\n    \"use strict\";\n\n    Ke();\n    Tt = (i, e) => {\n      let o = xt(),\n        t = o.lengthBytesUTF8(i) + 1,\n        r = o._malloc(t);\n      return o.stringToUTF8(i, r, t), e.push(r), r;\n    }, Wr = (i, e, o, t) => {\n      if (typeof i == \"object\" && i !== null) {\n        if (o.has(i)) throw new Error(\"Circular reference in options\");\n        o.add(i);\n      }\n      Object.entries(i).forEach(([r, n]) => {\n        let s = e ? e + r : r;\n        if (typeof n == \"object\") Wr(n, s + \".\", o, t);else if (typeof n == \"string\" || typeof n == \"number\") t(s, n.toString());else if (typeof n == \"boolean\") t(s, n ? \"1\" : \"0\");else throw new Error(`Can't handle extra config type: ${typeof n}`);\n      });\n    }, ht = i => {\n      let e = xt(),\n        o = e.stackSave();\n      try {\n        let t = e.stackAlloc(8);\n        e._OrtGetLastError(t, t + 4);\n        let r = e.HEAP32[t / 4],\n          n = e.HEAPU32[t / 4 + 1],\n          s = n ? e.UTF8ToString(n) : \"\";\n        throw new Error(`${i} ERROR_CODE: ${r}, ERROR_MESSAGE: ${s}`);\n      } finally {\n        e.stackRestore(o);\n      }\n    };\n  });\nvar jp,\n  Xp = O(() => {\n    \"use strict\";\n\n    Ke();\n    mo();\n    jp = i => {\n      let e = xt(),\n        o = 0,\n        t = [],\n        r = i || {};\n      try {\n        if (i?.logSeverityLevel === void 0) r.logSeverityLevel = 2;else if (typeof i.logSeverityLevel != \"number\" || !Number.isInteger(i.logSeverityLevel) || i.logSeverityLevel < 0 || i.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${i.logSeverityLevel}`);\n        if (i?.logVerbosityLevel === void 0) r.logVerbosityLevel = 0;else if (typeof i.logVerbosityLevel != \"number\" || !Number.isInteger(i.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${i.logVerbosityLevel}`);\n        i?.terminate === void 0 && (r.terminate = !1);\n        let n = 0;\n        return i?.tag !== void 0 && (n = Tt(i.tag, t)), o = e._OrtCreateRunOptions(r.logSeverityLevel, r.logVerbosityLevel, !!r.terminate, n), o === 0 && ht(\"Can't create run options.\"), i?.extra !== void 0 && Wr(i.extra, \"\", new WeakSet(), (s, a) => {\n          let u = Tt(s, t),\n            l = Tt(a, t);\n          e._OrtAddRunConfigEntry(o, u, l) !== 0 && ht(`Can't set a run config entry: ${s} - ${a}.`);\n        }), [o, t];\n      } catch (n) {\n        throw o !== 0 && e._OrtReleaseRunOptions(o), t.forEach(s => e._free(s)), n;\n      }\n    };\n  });\nvar $g,\n  kg,\n  Bg,\n  Fg,\n  Kp,\n  Jp = O(() => {\n    \"use strict\";\n\n    Ke();\n    mo();\n    $g = i => {\n      switch (i) {\n        case \"disabled\":\n          return 0;\n        case \"basic\":\n          return 1;\n        case \"extended\":\n          return 2;\n        case \"all\":\n          return 99;\n        default:\n          throw new Error(`unsupported graph optimization level: ${i}`);\n      }\n    }, kg = i => {\n      switch (i) {\n        case \"sequential\":\n          return 0;\n        case \"parallel\":\n          return 1;\n        default:\n          throw new Error(`unsupported execution mode: ${i}`);\n      }\n    }, Bg = i => {\n      i.extra || (i.extra = {}), i.extra.session || (i.extra.session = {});\n      let e = i.extra.session;\n      e.use_ort_model_bytes_directly || (e.use_ort_model_bytes_directly = \"1\"), i.executionProviders && i.executionProviders.some(o => (typeof o == \"string\" ? o : o.name) === \"webgpu\") && (i.enableMemPattern = !1);\n    }, Fg = (i, e, o) => {\n      for (let t of e) {\n        let r = typeof t == \"string\" ? t : t.name;\n        switch (r) {\n          case \"webnn\":\n            if (r = \"WEBNN\", typeof t != \"string\") {\n              let a = t?.deviceType;\n              if (a) {\n                let u = Tt(\"deviceType\", o),\n                  l = Tt(a, o);\n                xt()._OrtAddSessionConfigEntry(i, u, l) !== 0 && ht(`Can't set a session config entry: 'deviceType' - ${a}.`);\n              }\n            }\n            break;\n          case \"webgpu\":\n            if (r = \"JS\", typeof t != \"string\") {\n              let s = t;\n              if (s?.preferredLayout) {\n                if (s.preferredLayout !== \"NCHW\" && s.preferredLayout !== \"NHWC\") throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);\n                let a = Tt(\"preferredLayout\", o),\n                  u = Tt(s.preferredLayout, o);\n                xt()._OrtAddSessionConfigEntry(i, a, u) !== 0 && ht(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`);\n              }\n            }\n            break;\n          case \"wasm\":\n          case \"cpu\":\n            continue;\n          default:\n            throw new Error(`not supported execution provider: ${r}`);\n        }\n        let n = Tt(r, o);\n        xt()._OrtAppendExecutionProvider(i, n) !== 0 && ht(`Can't append execution provider: ${r}.`);\n      }\n    }, Kp = i => {\n      let e = xt(),\n        o = 0,\n        t = [],\n        r = i || {};\n      Bg(r);\n      try {\n        let n = $g(r.graphOptimizationLevel ?? \"all\"),\n          s = kg(r.executionMode ?? \"sequential\"),\n          a = typeof r.logId == \"string\" ? Tt(r.logId, t) : 0,\n          u = r.logSeverityLevel ?? 2;\n        if (!Number.isInteger(u) || u < 0 || u > 4) throw new Error(`log serverity level is not valid: ${u}`);\n        let l = r.logVerbosityLevel ?? 0;\n        if (!Number.isInteger(l) || l < 0 || l > 4) throw new Error(`log verbosity level is not valid: ${l}`);\n        let f = typeof r.optimizedModelFilePath == \"string\" ? Tt(r.optimizedModelFilePath, t) : 0;\n        if (o = e._OrtCreateSessionOptions(n, !!r.enableCpuMemArena, !!r.enableMemPattern, s, !!r.enableProfiling, 0, a, u, l, f), o === 0 && ht(\"Can't create session options.\"), r.executionProviders && Fg(o, r.executionProviders, t), r.enableGraphCapture !== void 0) {\n          if (typeof r.enableGraphCapture != \"boolean\") throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);\n          let p = Tt(\"enableGraphCapture\", t),\n            d = Tt(r.enableGraphCapture.toString(), t);\n          e._OrtAddSessionConfigEntry(o, p, d) !== 0 && ht(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`);\n        }\n        if (r.freeDimensionOverrides) for (let [p, d] of Object.entries(r.freeDimensionOverrides)) {\n          if (typeof p != \"string\") throw new Error(`free dimension override name must be a string: ${p}`);\n          if (typeof d != \"number\" || !Number.isInteger(d) || d < 0) throw new Error(`free dimension override value must be a non-negative integer: ${d}`);\n          let y = Tt(p, t);\n          e._OrtAddFreeDimensionOverride(o, y, d) !== 0 && ht(`Can't set a free dimension override: ${p} - ${d}.`);\n        }\n        return r.extra !== void 0 && Wr(r.extra, \"\", new WeakSet(), (p, d) => {\n          let y = Tt(p, t),\n            T = Tt(d, t);\n          e._OrtAddSessionConfigEntry(o, y, T) !== 0 && ht(`Can't set a session config entry: ${p} - ${d}.`);\n        }), [o, t];\n      } catch (n) {\n        throw o !== 0 && e._OrtReleaseSessionOptions(o), t.forEach(s => e._free(s)), n;\n      }\n    };\n  });\nvar Hr,\n  Yp,\n  qr,\n  Zp,\n  Qp,\n  bo,\n  go,\n  td,\n  Ji = O(() => {\n    \"use strict\";\n\n    Hr = i => {\n      switch (i) {\n        case \"int8\":\n          return 3;\n        case \"uint8\":\n          return 2;\n        case \"bool\":\n          return 9;\n        case \"int16\":\n          return 5;\n        case \"uint16\":\n          return 4;\n        case \"int32\":\n          return 6;\n        case \"uint32\":\n          return 12;\n        case \"float16\":\n          return 10;\n        case \"float32\":\n          return 1;\n        case \"float64\":\n          return 11;\n        case \"string\":\n          return 8;\n        case \"int64\":\n          return 7;\n        case \"uint64\":\n          return 13;\n        case \"int4\":\n          return 22;\n        case \"uint4\":\n          return 21;\n        default:\n          throw new Error(`unsupported data type: ${i}`);\n      }\n    }, Yp = i => {\n      switch (i) {\n        case 3:\n          return \"int8\";\n        case 2:\n          return \"uint8\";\n        case 9:\n          return \"bool\";\n        case 5:\n          return \"int16\";\n        case 4:\n          return \"uint16\";\n        case 6:\n          return \"int32\";\n        case 12:\n          return \"uint32\";\n        case 10:\n          return \"float16\";\n        case 1:\n          return \"float32\";\n        case 11:\n          return \"float64\";\n        case 8:\n          return \"string\";\n        case 7:\n          return \"int64\";\n        case 13:\n          return \"uint64\";\n        case 22:\n          return \"int4\";\n        case 21:\n          return \"uint4\";\n        default:\n          throw new Error(`unsupported data type: ${i}`);\n      }\n    }, qr = (i, e) => {\n      let o = [-1, 4, 1, 1, 2, 2, 4, 8, -1, 1, 2, 8, 4, 8, -1, -1, -1, -1, -1, -1, -1, .5, .5][i],\n        t = typeof e == \"number\" ? e : e.reduce((r, n) => r * n, 1);\n      return o > 0 ? Math.ceil(t * o) : void 0;\n    }, Zp = i => {\n      switch (i) {\n        case \"float16\":\n          return typeof Float16Array < \"u\" && Float16Array.from ? Float16Array : Uint16Array;\n        case \"float32\":\n          return Float32Array;\n        case \"uint8\":\n          return Uint8Array;\n        case \"int8\":\n          return Int8Array;\n        case \"uint16\":\n          return Uint16Array;\n        case \"int16\":\n          return Int16Array;\n        case \"int32\":\n          return Int32Array;\n        case \"bool\":\n          return Uint8Array;\n        case \"float64\":\n          return Float64Array;\n        case \"uint32\":\n          return Uint32Array;\n        case \"int64\":\n          return BigInt64Array;\n        case \"uint64\":\n          return BigUint64Array;\n        default:\n          throw new Error(`unsupported type: ${i}`);\n      }\n    }, Qp = i => {\n      switch (i) {\n        case \"verbose\":\n          return 0;\n        case \"info\":\n          return 1;\n        case \"warning\":\n          return 2;\n        case \"error\":\n          return 3;\n        case \"fatal\":\n          return 4;\n        default:\n          throw new Error(`unsupported logging level: ${i}`);\n      }\n    }, bo = i => i === \"float32\" || i === \"float16\" || i === \"int32\" || i === \"int64\" || i === \"uint32\" || i === \"uint8\" || i === \"bool\" || i === \"uint4\" || i === \"int4\", go = i => i === \"float32\" || i === \"float16\" || i === \"int32\" || i === \"int64\" || i === \"uint32\" || i === \"uint64\" || i === \"int8\" || i === \"uint8\" || i === \"bool\", td = i => {\n      switch (i) {\n        case \"none\":\n          return 0;\n        case \"cpu\":\n          return 1;\n        case \"cpu-pinned\":\n          return 2;\n        case \"texture\":\n          return 3;\n        case \"gpu-buffer\":\n          return 4;\n        case \"ml-tensor\":\n          return 5;\n        default:\n          throw new Error(`unsupported data location: ${i}`);\n      }\n    };\n  });\nvar jr,\n  Yi = O(() => {\n    \"use strict\";\n\n    oo();\n    jr = async i => {\n      if (typeof i == \"string\") {\n        if (!1) try {\n          let {\n            readFile: e\n          } = Co(\"node:fs/promises\");\n          return new Uint8Array(await e(i));\n        } catch (e) {\n          if (e.code === \"ERR_FS_FILE_TOO_LARGE\") {\n            let {\n                createReadStream: o\n              } = Co(\"node:fs\"),\n              t = o(i),\n              r = [];\n            for await (let n of t) r.push(n);\n            return new Uint8Array(Buffer.concat(r));\n          }\n          throw e;\n        } else {\n          let e = await fetch(i);\n          if (!e.ok) throw new Error(`failed to load external data file: ${i}`);\n          let o = e.headers.get(\"Content-Length\"),\n            t = o ? parseInt(o, 10) : 0;\n          if (t < 1073741824) return new Uint8Array(await e.arrayBuffer());\n          {\n            if (!e.body) throw new Error(`failed to load external data file: ${i}, no response body.`);\n            let r = e.body.getReader(),\n              n;\n            try {\n              n = new ArrayBuffer(t);\n            } catch (a) {\n              if (a instanceof RangeError) {\n                let u = Math.ceil(t / 65536);\n                n = new WebAssembly.Memory({\n                  initial: u,\n                  maximum: u\n                }).buffer;\n              } else throw a;\n            }\n            let s = 0;\n            for (;;) {\n              let {\n                done: a,\n                value: u\n              } = await r.read();\n              if (a) break;\n              let l = u.byteLength;\n              new Uint8Array(n, s, l).set(u), s += l;\n            }\n            return new Uint8Array(n, 0, t);\n          }\n        }\n      } else return i instanceof Blob ? new Uint8Array(await i.arrayBuffer()) : i instanceof Uint8Array ? i : new Uint8Array(i);\n    };\n  });\nvar Cg,\n  ao,\n  so,\n  yr,\n  Ng,\n  zr,\n  uo,\n  lo,\n  ed,\n  fo,\n  co,\n  po,\n  qi = O(() => {\n    \"use strict\";\n\n    Xp();\n    Jp();\n    Ji();\n    Ke();\n    mo();\n    Yi();\n    Cg = (i, e) => {\n      xt()._OrtInit(i, e) !== 0 && ht(\"Can't initialize onnxruntime.\");\n    }, ao = async i => {\n      Cg(i.wasm.numThreads, Qp(i.logLevel));\n    }, so = async (i, e) => {}, yr = new Map(), Ng = i => {\n      let e = xt(),\n        o = e.stackSave();\n      try {\n        let t = e.stackAlloc(8);\n        return e._OrtGetInputOutputCount(i, t, t + 4) !== 0 && ht(\"Can't get session input/output count.\"), [e.HEAP32[t / 4], e.HEAP32[t / 4 + 1]];\n      } finally {\n        e.stackRestore(o);\n      }\n    }, zr = i => {\n      let e = xt(),\n        o = e._malloc(i.byteLength);\n      if (o === 0) throw new Error(`Can't create a session. failed to allocate a buffer of size ${i.byteLength}.`);\n      return e.HEAPU8.set(i, o), [o, i.byteLength];\n    }, uo = async (i, e) => {\n      let o,\n        t,\n        r = xt();\n      Array.isArray(i) ? [o, t] = i : i.buffer === r.HEAPU8.buffer ? [o, t] = [i.byteOffset, i.byteLength] : [o, t] = zr(i);\n      let n = 0,\n        s = 0,\n        a = 0,\n        u = [],\n        l = [],\n        f = [];\n      try {\n        if ([s, u] = Kp(e), e?.externalData && r.mountExternalData) {\n          let P = [];\n          for (let A of e.externalData) {\n            let M = typeof A == \"string\" ? A : A.path;\n            P.push(jr(typeof A == \"string\" ? A : A.data).then(V => {\n              r.mountExternalData(M, V);\n            }));\n          }\n          await Promise.all(P);\n        }\n        for (let P of e?.executionProviders ?? []) if ((typeof P == \"string\" ? P : P.name) === \"webnn\") {\n          if (r.shouldTransferToMLTensor = !1, r.currentContext) throw new Error(\"WebNN execution provider is already set.\");\n          if (typeof P != \"string\") {\n            let M = P,\n              V = M?.context,\n              lt = M?.gpuDevice,\n              wt = M?.deviceType,\n              et = M?.numThreads,\n              Dt = M?.powerPreference;\n            V ? r.currentContext = V : lt ? r.currentContext = await navigator.ml.createContext(lt) : r.currentContext = await navigator.ml.createContext({\n              deviceType: wt,\n              numThreads: et,\n              powerPreference: Dt\n            });\n          } else r.currentContext = await navigator.ml.createContext();\n          break;\n        }\n        n = await r._OrtCreateSession(o, t, s), n === 0 && ht(\"Can't create a session.\"), r.currentContext && (r.jsepRegisterMLContext(n, r.currentContext), r.currentContext = void 0, r.shouldTransferToMLTensor = !0);\n        let [p, d] = Ng(n),\n          y = !!e?.enableGraphCapture,\n          T = [],\n          v = [],\n          S = [];\n        for (let P = 0; P < p; P++) {\n          let A = r._OrtGetInputName(n, P);\n          A === 0 && ht(\"Can't get an input name.\"), l.push(A), T.push(r.UTF8ToString(A));\n        }\n        for (let P = 0; P < d; P++) {\n          let A = r._OrtGetOutputName(n, P);\n          A === 0 && ht(\"Can't get an output name.\"), f.push(A);\n          let M = r.UTF8ToString(A);\n          v.push(M);\n        }\n        let L = null;\n        return yr.set(n, [n, l, f, L, y, !1]), [n, T, v];\n      } catch (p) {\n        throw l.forEach(d => r._OrtFree(d)), f.forEach(d => r._OrtFree(d)), a !== 0 && r._OrtReleaseBinding(a), n !== 0 && r._OrtReleaseSession(n), p;\n      } finally {\n        r._free(o), s !== 0 && r._OrtReleaseSessionOptions(s), u.forEach(p => r._free(p)), r.unmountExternalData?.();\n      }\n    }, lo = i => {\n      let e = xt(),\n        o = yr.get(i);\n      if (!o) throw new Error(`cannot release session. invalid session id: ${i}`);\n      let [t, r, n, s, a] = o;\n      s && (a && e._OrtClearBoundOutputs(s.handle), e._OrtReleaseBinding(s.handle)), e.jsepOnReleaseSession?.(i), r.forEach(u => e._OrtFree(u)), n.forEach(u => e._OrtFree(u)), e._OrtReleaseSession(t), yr.delete(i);\n    }, ed = (i, e, o, t, r, n = !1) => {\n      if (!i) {\n        e.push(0);\n        return;\n      }\n      let s = xt(),\n        a = i[0],\n        u = i[1],\n        l = i[3],\n        f,\n        p;\n      if (a === \"string\" && (l === \"gpu-buffer\" || l === \"ml-tensor\")) throw new Error(\"String tensor is not supported on GPU.\");\n      if (n && l !== \"gpu-buffer\") throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);\n      if (l === \"gpu-buffer\") {\n        let T = i[2].gpuBuffer;\n        p = qr(Hr(a), u);\n        let v = s.jsepRegisterBuffer;\n        if (!v) throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');\n        f = v(t, r, T, p);\n      } else if (l === \"ml-tensor\") {\n        let T = i[2].mlTensor;\n        p = qr(Hr(a), u);\n        let v = s.jsepRegisterMLTensor;\n        if (!v) throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');\n        f = v(T, Hr(a), u);\n      } else {\n        let T = i[2];\n        if (Array.isArray(T)) {\n          p = 4 * T.length, f = s._malloc(p), o.push(f);\n          let v = f / 4;\n          for (let S = 0; S < T.length; S++) {\n            if (typeof T[S] != \"string\") throw new TypeError(`tensor data at index ${S} is not a string`);\n            s.HEAPU32[v++] = Tt(T[S], o);\n          }\n        } else p = T.byteLength, f = s._malloc(p), o.push(f), s.HEAPU8.set(new Uint8Array(T.buffer, T.byteOffset, p), f);\n      }\n      let d = s.stackSave(),\n        y = s.stackAlloc(4 * u.length);\n      try {\n        let T = y / 4;\n        u.forEach(S => s.HEAP32[T++] = S);\n        let v = s._OrtCreateTensor(Hr(a), f, p, y, u.length, td(l));\n        v === 0 && ht(`Can't create tensor for input/output. session=${t}, index=${r}.`), e.push(v);\n      } finally {\n        s.stackRestore(d);\n      }\n    }, fo = async (i, e, o, t, r, n) => {\n      let s = xt(),\n        a = yr.get(i);\n      if (!a) throw new Error(`cannot run inference. invalid session id: ${i}`);\n      let u = a[0],\n        l = a[1],\n        f = a[2],\n        p = a[3],\n        d = a[4],\n        y = a[5],\n        T = e.length,\n        v = t.length,\n        S = 0,\n        L = [],\n        P = [],\n        A = [],\n        M = [],\n        V = s.stackSave(),\n        lt = s.stackAlloc(T * 4),\n        wt = s.stackAlloc(T * 4),\n        et = s.stackAlloc(v * 4),\n        Dt = s.stackAlloc(v * 4);\n      try {\n        s.jsepOnRunStart?.(u), [S, L] = jp(n);\n        for (let Z = 0; Z < T; Z++) ed(o[Z], P, M, i, e[Z], d);\n        for (let Z = 0; Z < v; Z++) ed(r[Z], A, M, i, T + t[Z], d);\n        let _t = lt / 4,\n          C = wt / 4,\n          Kr = et / 4,\n          we = Dt / 4;\n        for (let Z = 0; Z < T; Z++) s.HEAPU32[_t++] = P[Z], s.HEAPU32[C++] = l[e[Z]];\n        for (let Z = 0; Z < v; Z++) s.HEAPU32[Kr++] = A[Z], s.HEAPU32[we++] = f[t[Z]];\n        let oe;\n        oe = await s._OrtRun(u, wt, lt, T, Dt, v, et, S), oe !== 0 && ht(\"failed to call OrtRun().\");\n        let be = [];\n        for (let Z = 0; Z < v; Z++) {\n          let ge = s.HEAPU32[et / 4 + Z];\n          if (ge === A[Z]) {\n            be.push(r[Z]);\n            continue;\n          }\n          let ie = s.stackSave(),\n            ae = s.stackAlloc(4 * 4),\n            se = !1,\n            it,\n            Lt = 0;\n          try {\n            s._OrtGetTensorData(ge, ae, ae + 4, ae + 8, ae + 12) !== 0 && ht(`Can't access output tensor data on index ${Z}.`);\n            let Ye = ae / 4,\n              ue = s.HEAPU32[Ye++];\n            Lt = s.HEAPU32[Ye++];\n            let Ze = s.HEAPU32[Ye++],\n              De = s.HEAPU32[Ye++],\n              le = [];\n            for (let gt = 0; gt < De; gt++) le.push(s.HEAPU32[Ze / 4 + gt]);\n            s._OrtFree(Ze);\n            let Mt = le.reduce((gt, Ot) => gt * Ot, 1);\n            it = Yp(ue);\n            let ve = p?.outputPreferredLocations[t[Z]];\n            if (it === \"string\") {\n              if (ve === \"gpu-buffer\" || ve === \"ml-tensor\") throw new Error(\"String tensor is not supported on GPU.\");\n              let gt = [],\n                Ot = Lt / 4;\n              for (let Jt = 0; Jt < Mt; Jt++) {\n                let wr = s.HEAPU32[Ot++],\n                  Yr = Jt === Mt - 1 ? void 0 : s.HEAPU32[Ot] - wr;\n                gt.push(s.UTF8ToString(wr, Yr));\n              }\n              be.push([it, le, gt, \"cpu\"]);\n            } else if (ve === \"gpu-buffer\" && Mt > 0) {\n              let gt = s.jsepGetBuffer;\n              if (!gt) throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');\n              let Ot = gt(Lt),\n                Jt = qr(ue, Mt);\n              if (Jt === void 0 || !bo(it)) throw new Error(`Unsupported data type: ${it}`);\n              se = !0, be.push([it, le, {\n                gpuBuffer: Ot,\n                download: s.jsepCreateDownloader(Ot, Jt, it),\n                dispose: () => {\n                  s._OrtReleaseTensor(ge);\n                }\n              }, \"gpu-buffer\"]);\n            } else if (ve === \"ml-tensor\" && Mt > 0) {\n              let gt = s.jsepEnsureTensor;\n              if (!gt) throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');\n              if (qr(ue, Mt) === void 0 || !go(it)) throw new Error(`Unsupported data type: ${it}`);\n              let Jt = await gt(Lt, ue, le, !1);\n              se = !0, be.push([it, le, {\n                mlTensor: Jt,\n                download: s.jsepCreateMLTensorDownloader(Lt, it),\n                dispose: () => {\n                  s.jsepReleaseTensorId(Lt), s._OrtReleaseTensor(ge);\n                }\n              }, \"ml-tensor\"]);\n            } else {\n              let gt = Zp(it),\n                Ot = new gt(Mt);\n              new Uint8Array(Ot.buffer, Ot.byteOffset, Ot.byteLength).set(s.HEAPU8.subarray(Lt, Lt + Ot.byteLength)), be.push([it, le, Ot, \"cpu\"]);\n            }\n          } finally {\n            s.stackRestore(ie), it === \"string\" && Lt && s._free(Lt), se || s._OrtReleaseTensor(ge);\n          }\n        }\n        return p && !d && (s._OrtClearBoundOutputs(p.handle), yr.set(i, [u, l, f, p, d, !1])), be;\n      } finally {\n        s.stackRestore(V), P.forEach(_t => s._OrtReleaseTensor(_t)), A.forEach(_t => s._OrtReleaseTensor(_t)), M.forEach(_t => s._free(_t)), S !== 0 && s._OrtReleaseRunOptions(S), L.forEach(_t => s._free(_t));\n      }\n    }, co = i => {\n      let e = xt(),\n        o = yr.get(i);\n      if (!o) throw new Error(\"invalid session id\");\n      let t = o[0],\n        r = e._OrtEndProfiling(t);\n      r === 0 && ht(\"Can't get an profile file name.\"), e._OrtFree(r);\n    }, po = i => {\n      let e = [];\n      for (let o of i) {\n        let t = o[2];\n        !Array.isArray(t) && \"buffer\" in t && e.push(t.buffer);\n      }\n      return e;\n    };\n  });\nvar Je,\n  Kt,\n  Xr,\n  xo,\n  To,\n  yo,\n  Zi,\n  Qi,\n  xr,\n  Tr,\n  Gg,\n  rd,\n  nd,\n  od,\n  id,\n  ad,\n  sd,\n  ud,\n  ta = O(() => {\n    \"use strict\";\n\n    Yt();\n    qi();\n    Ke();\n    Vr();\n    Je = () => !!z.wasm.proxy && typeof document < \"u\", Xr = !1, xo = !1, To = !1, Qi = new Map(), xr = (i, e) => {\n      let o = Qi.get(i);\n      o ? o.push(e) : Qi.set(i, [e]);\n    }, Tr = () => {\n      if (Xr || !xo || To || !Kt) throw new Error(\"worker not ready\");\n    }, Gg = i => {\n      switch (i.data.type) {\n        case \"init-wasm\":\n          Xr = !1, i.data.err ? (To = !0, Zi[1](i.data.err)) : (xo = !0, Zi[0]()), yo && (URL.revokeObjectURL(yo), yo = void 0);\n          break;\n        case \"init-ep\":\n        case \"copy-from\":\n        case \"create\":\n        case \"release\":\n        case \"run\":\n        case \"end-profiling\":\n          {\n            let e = Qi.get(i.data.type);\n            i.data.err ? e.shift()[1](i.data.err) : e.shift()[0](i.data.out);\n            break;\n          }\n        default:\n      }\n    }, rd = async () => {\n      if (!xo) {\n        if (Xr) throw new Error(\"multiple calls to 'initWasm()' detected.\");\n        if (To) throw new Error(\"previous call to 'initWasm()' failed.\");\n        if (Xr = !0, Je()) return new Promise((i, e) => {\n          Kt?.terminate(), Wp().then(([o, t]) => {\n            try {\n              Kt = t, Kt.onerror = n => e(n), Kt.onmessage = Gg, Zi = [i, e];\n              let r = {\n                type: \"init-wasm\",\n                in: z\n              };\n              Kt.postMessage(r), yo = o;\n            } catch (r) {\n              e(r);\n            }\n          }, e);\n        });\n        try {\n          await io(z.wasm), await ao(z), xo = !0;\n        } catch (i) {\n          throw To = !0, i;\n        } finally {\n          Xr = !1;\n        }\n      }\n    }, nd = async i => {\n      if (Je()) return Tr(), new Promise((e, o) => {\n        xr(\"init-ep\", [e, o]);\n        let t = {\n          type: \"init-ep\",\n          in: {\n            epName: i,\n            env: z\n          }\n        };\n        Kt.postMessage(t);\n      });\n      await so(z, i);\n    }, od = async i => Je() ? (Tr(), new Promise((e, o) => {\n      xr(\"copy-from\", [e, o]);\n      let t = {\n        type: \"copy-from\",\n        in: {\n          buffer: i\n        }\n      };\n      Kt.postMessage(t, [i.buffer]);\n    })) : zr(i), id = async (i, e) => {\n      if (Je()) {\n        if (e?.preferredOutputLocation) throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');\n        return Tr(), new Promise((o, t) => {\n          xr(\"create\", [o, t]);\n          let r = {\n              type: \"create\",\n              in: {\n                model: i,\n                options: {\n                  ...e\n                }\n              }\n            },\n            n = [];\n          i instanceof Uint8Array && n.push(i.buffer), Kt.postMessage(r, n);\n        });\n      } else return uo(i, e);\n    }, ad = async i => {\n      if (Je()) return Tr(), new Promise((e, o) => {\n        xr(\"release\", [e, o]);\n        let t = {\n          type: \"release\",\n          in: i\n        };\n        Kt.postMessage(t);\n      });\n      lo(i);\n    }, sd = async (i, e, o, t, r, n) => {\n      if (Je()) {\n        if (o.some(s => s[3] !== \"cpu\")) throw new Error(\"input tensor on GPU is not supported for proxy.\");\n        if (r.some(s => s)) throw new Error(\"pre-allocated output tensor is not supported for proxy.\");\n        return Tr(), new Promise((s, a) => {\n          xr(\"run\", [s, a]);\n          let u = o,\n            l = {\n              type: \"run\",\n              in: {\n                sessionId: i,\n                inputIndices: e,\n                inputs: u,\n                outputIndices: t,\n                options: n\n              }\n            };\n          Kt.postMessage(l, po(u));\n        });\n      } else return fo(i, e, o, t, r, n);\n    }, ud = async i => {\n      if (Je()) return Tr(), new Promise((e, o) => {\n        xr(\"end-profiling\", [e, o]);\n        let t = {\n          type: \"end-profiling\",\n          in: i\n        };\n        Kt.postMessage(t);\n      });\n      co(i);\n    };\n  });\nvar ld,\n  Mg,\n  wo,\n  fd = O(() => {\n    \"use strict\";\n\n    Yt();\n    ta();\n    Ji();\n    oo();\n    Yi();\n    ld = (i, e) => {\n      switch (i.location) {\n        case \"cpu\":\n          return [i.type, i.dims, i.data, \"cpu\"];\n        case \"gpu-buffer\":\n          return [i.type, i.dims, {\n            gpuBuffer: i.gpuBuffer\n          }, \"gpu-buffer\"];\n        case \"ml-tensor\":\n          return [i.type, i.dims, {\n            mlTensor: i.mlTensor\n          }, \"ml-tensor\"];\n        default:\n          throw new Error(`invalid data location: ${i.location} for ${e()}`);\n      }\n    }, Mg = i => {\n      switch (i[3]) {\n        case \"cpu\":\n          return new yt(i[0], i[2], i[1]);\n        case \"gpu-buffer\":\n          {\n            let e = i[0];\n            if (!bo(e)) throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);\n            let {\n              gpuBuffer: o,\n              download: t,\n              dispose: r\n            } = i[2];\n            return yt.fromGpuBuffer(o, {\n              dataType: e,\n              dims: i[1],\n              download: t,\n              dispose: r\n            });\n          }\n        case \"ml-tensor\":\n          {\n            let e = i[0];\n            if (!go(e)) throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);\n            let {\n              mlTensor: o,\n              download: t,\n              dispose: r\n            } = i[2];\n            return yt.fromMLTensor(o, {\n              dataType: e,\n              dims: i[1],\n              download: t,\n              dispose: r\n            });\n          }\n        default:\n          throw new Error(`invalid data location: ${i[3]}`);\n      }\n    }, wo = class {\n      async fetchModelAndCopyToWasmMemory(e) {\n        return od(await jr(e));\n      }\n      async loadModel(e, o) {\n        Fe();\n        let t;\n        typeof e == \"string\" ? !1 ? t = await jr(e) : t = await this.fetchModelAndCopyToWasmMemory(e) : t = e, [this.sessionId, this.inputNames, this.outputNames] = await id(t, o), Ce();\n      }\n      async dispose() {\n        return ad(this.sessionId);\n      }\n      async run(e, o, t) {\n        Fe();\n        let r = [],\n          n = [];\n        Object.entries(e).forEach(d => {\n          let y = d[0],\n            T = d[1],\n            v = this.inputNames.indexOf(y);\n          if (v === -1) throw new Error(`invalid input '${y}'`);\n          r.push(T), n.push(v);\n        });\n        let s = [],\n          a = [];\n        Object.entries(o).forEach(d => {\n          let y = d[0],\n            T = d[1],\n            v = this.outputNames.indexOf(y);\n          if (v === -1) throw new Error(`invalid output '${y}'`);\n          s.push(T), a.push(v);\n        });\n        let u = r.map((d, y) => ld(d, () => `input \"${this.inputNames[n[y]]}\"`)),\n          l = s.map((d, y) => d ? ld(d, () => `output \"${this.outputNames[a[y]]}\"`) : null),\n          f = await sd(this.sessionId, n, u, a, l, t),\n          p = {};\n        for (let d = 0; d < f.length; d++) p[this.outputNames[a[d]]] = s[d] ?? Mg(f[d]);\n        return Ce(), p;\n      }\n      startProfiling() {}\n      endProfiling() {\n        ud(this.sessionId);\n      }\n    };\n  });\nvar pd = {};\nOr(pd, {\n  OnnxruntimeWebAssemblyBackend: () => vo,\n  initializeFlags: () => cd,\n  wasmBackend: () => Ug\n});\nvar cd,\n  vo,\n  Ug,\n  dd = O(() => {\n    \"use strict\";\n\n    Yt();\n    ta();\n    fd();\n    Vr();\n    cd = () => {\n      if ((typeof z.wasm.initTimeout != \"number\" || z.wasm.initTimeout < 0) && (z.wasm.initTimeout = 0), z.wasm.simd === !1 && console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'), typeof z.wasm.proxy != \"boolean\" && (z.wasm.proxy = !1), typeof z.wasm.trace != \"boolean\" && (z.wasm.trace = !1), typeof z.wasm.numThreads != \"number\" || !Number.isInteger(z.wasm.numThreads) || z.wasm.numThreads <= 0) if (typeof self < \"u\" && !self.crossOriginIsolated) z.wasm.numThreads = 1;else {\n        let i = typeof navigator > \"u\" ? Co(\"node:os\").cpus().length : navigator.hardwareConcurrency;\n        z.wasm.numThreads = Math.min(4, Math.ceil((i || 1) / 2));\n      }\n    }, vo = class {\n      async init(e) {\n        cd(), await rd(), await nd(e);\n      }\n      async createInferenceSessionHandler(e, o) {\n        let t = new wo();\n        return await t.loadModel(e, o), Promise.resolve(t);\n      }\n    }, Ug = new vo();\n  });\nYt();\nYt();\nYt();\nvar Ds = \"1.20.1\";\nvar mO = Mo;\n{\n  let i = (Fp(), sn(Bp)).onnxjsBackend;\n  nr(\"webgl\", i, -10);\n}\n{\n  let i = (dd(), sn(pd)).wasmBackend;\n  nr(\"cpu\", i, 10), nr(\"wasm\", i, 10);\n}\nObject.defineProperty(z.versions, \"web\", {\n  value: Ds,\n  enumerable: !0\n});\nexport { Yd as InferenceSession, Ts as TRACE, Fe as TRACE_FUNC_BEGIN, Ce as TRACE_FUNC_END, yt as Tensor, Qd as TrainingSession, mO as default, z as env, nr as registerBackend };\n/*! Bundled license information:\n\nlong/index.js:\n  (**\n   * @license\n   * Copyright 2009 The Closure Library Authors\n   * Copyright 2020 Daniel Wirtz / The long.js Authors.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n*/","map":{"version":3,"names":["un","ke","nr","Jd","ln","fn","O","Map","registerBackend","i","e","o","init","createInferenceSessionHandler","t","get","set","backend","priority","Error","r","indexOf","splice","n","length","push","TypeError","initialized","aborted","error","initPromise","executionProviders","map","u","name","s","Set","l","err","add","join","includes","console","warn","a","filter","has","Proxy","Reflect","ts","es","rs","ns","Gt","No","wasm","webgl","webgpu","versions","common","logLevel","Object","defineProperty","enumerable","z","os","is","as","ss","tensorToDataURL","document","createElement","OffscreenCanvas","width","dims","height","getContext","tensorLayout","format","norm","mean","bias","f","p","d","y","T","v","S","L","data","P","A","M","fillStyle","fillRect","toDataURL","tensorToImageData","createImageData","V","Ro","us","ls","fs","cs","ps","ds","cn","bufferToTensor","tensorFormat","Float32Array","St","tensorFromImage","HTMLImageElement","ImageData","ImageBitmap","createCanvas","HTMLCanvasElement","resizedHeight","resizedWidth","drawImage","getImageData","putImageData","Promise","Image","crossOrigin","src","onload","tensorFromTexture","download","dispose","location","type","texture","tensorFromGpuBuffer","dataType","gpuBuffer","tensorFromMLTensor","mlTensor","tensorFromPinnedBuffer","Be","Sr","hs","ms","bs","Uint8Array","Int8Array","Uint16Array","Int16Array","Int32Array","Float64Array","Uint32Array","checkTypedArray","BigInt64Array","from","BigUint64Array","Float16Array","gs","ys","xs","Number","isSafeInteger","RangeError","tensorReshape","constructor","dataLocation","cpuData","gpuTextureData","downloader","disposer","gpuBufferData","mlTensorData","Array","isArray","BigInt","Uint8ClampedArray","Math","ceil","size","fromImage","fromTexture","fromGpuBuffer","fromMLTensor","fromPinnedBuffer","toImageData","ensureValid","getData","isDownloading","reshape","yt","pn","Ts","ws","Fe","Ce","Go","TRACE","trace","timeStamp","TRACE_FUNC","stack","split","trim","dn","vs","handler","run","outputNames","getOwnPropertyNames","inputNames","hasOwnProperty","call","release","create","ArrayBuffer","SharedArrayBuffer","byteLength","startProfiling","endProfiling","Yd","Is","_s","Os","Ss","As","Zd","hn","Ps","hasOptimizerModel","hasEvalModel","trainingInputNames","trainingOutputNames","evalInputNames","evalOutputNames","evalModel","optimizerModel","createTrainingSessionHandler","checkpointState","trainModel","typeNarrowingForRunStep","convertHandlerReturnTypeToMapOfTensors","lazyResetGrad","runTrainStep","runOptimizerStep","runEvalStep","getParametersSize","loadParametersBuffer","getContiguousParameters","Qd","Es","Mo","Or","InferenceSession","TRACE_FUNC_BEGIN","TRACE_FUNC_END","Tensor","TrainingSession","env","Yt","_e","eh","mn","verbose","bind","info","warning","fatal","Ar","Ls","minimalSeverity","logDateTime","Date","toISOString","logSourceLocation","th","provider","log","Uo","Vo","$s","tt","gn","yn","xn","bn","Ut","color","none","reset","setWithEnv","category","startTime","endCallback","timer","ctx","end","checkTimer","endTimer","waitForQueryAndGetTime","endTime","_started","_flushPointer","_maxNumberEvents","_flushBatchSize","_flushIntervalInMilliseconds","maxNumberEvents","flushBatchSize","flushIntervalInMilliseconds","start","_timingEvents","_flushTime","stop","logOneEvent","event","begin","then","flush","endSync","beginTimer","toFixed","started","performance","now","ks","opType","domain","rh","version","opImpl","opInit","endsWith","parseInt","substring","isNaN","Bs","Fs","mt","zo","__esModule","nh","value","EMPTY","isGuid","toString","validator","test","gen","createEmpty","parse","raw","random","prototype","equals","isEmpty","toJSON","RegExp","Guid","rt","low","high","unsigned","Et","__isLong__","Cs","clz32","Ne","Rs","J","Ns","zt","ye","Zt","Vs","Hs","Ms","Ct","Ws","neg","ir","Ho","Tn","min","mul","Qt","Vt","Gs","oh","Us","or","zs","Wo","D","xe","qo","WebAssembly","Instance","Module","exports","isLong","fromInt","fromNumber","fromBits","pow","fromString","fromValue","ZERO","UZERO","ONE","UONE","NEG_ONE","MAX_VALUE","MAX_UNSIGNED_VALUE","MIN_VALUE","toInt","toNumber","isZero","isNegative","eq","div","sub","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","eqz","isPositive","isOdd","isEven","notEquals","neq","ne","lessThan","comp","lt","lessThanOrEqual","lte","le","greaterThan","gt","greaterThanOrEqual","gte","ge","compare","negate","not","subtract","multiply","get_high","divide","div_u","div_s","toUnsigned","shru","shr","shl","max","floor","LN2","modulo","rem_u","rem_s","mod","rem","countLeadingZeros","clz","countTrailingZeros","ctz","and","xor","shiftLeft","shiftRight","shiftRightUnsigned","shr_u","rotateLeft","rotl","rotateRight","rotr","toSigned","toBytes","toBytesLE","toBytesBE","fromBytes","fromBytesLE","fromBytesBE","w","wn","Offset","Table","SIZEOF_SHORT","SIZEOF_INT","FILE_IDENTIFIER_LENGTH","SIZE_PREFIX_LENGTH","Encoding","UTF8_BYTES","UTF16_STRING","int32","float32","buffer","float64","isLittleEndian","Long","toFloat64","Builder","bb","ByteBuffer","allocate","space","minalign","vtable","vtable_in_use","isNested","object_start","vtables","vector_num_elems","force_defaults","clear","capacity","forceDefaults","dataBuffer","asUint8Array","bytes","subarray","position","offset","prep","growByteBuffer","pad","writeInt8","writeInt16","writeInt32","writeInt64","writeFloat32","writeFloat64","addInt8","addInt16","addInt32","addInt64","addFloat32","addFloat64","addFieldInt8","slot","addFieldInt16","addFieldInt32","addFieldInt64","addFieldFloat32","addFieldFloat64","addFieldOffset","addOffset","addFieldStruct","nested","notNested","setPosition","startObject","endObject","readInt16","finish","charCodeAt","finishSizePrefixed","requiredField","readInt32","startVector","endVector","createString","createLong","bytes_","position_","readInt8","readUint8","readUint16","readUint32","readInt64","readUint64","readFloat32","readFloat64","writeUint8","writeUint16","writeUint32","writeUint64","getBufferIdentifier","String","fromCharCode","__offset","__union","bb_pos","__string","__indirect","__vector","__vector_len","__has_identifier","F","Pr","UNDEFINED","FLOAT","INT","STRING","TENSOR","GRAPH","FLOATS","INTS","STRINGS","TENSORS","GRAPHS","SPARSE_TENSOR","SPARSE_TENSORS","AttributeType","fbs","experimental","UNKNOWN","VALUE","PARAM","DimensionValueType","C","UINT8","INT8","UINT16","INT16","INT32","INT64","BOOL","FLOAT16","DOUBLE","UINT32","UINT64","COMPLEX64","COMPLEX128","BFLOAT16","FLOAT8E4M3FN","FLOAT8E4M3FNUZ","FLOAT8E5M2","FLOAT8E5M2FNUZ","TensorDataType","Primitive","Fused","NodeType","NONE","tensor_type","sequence_type","map_type","TypeInfoValue","__init","getRootAsShape","getSizePrefixedRootAsShape","dim","Dimension","dimLength","startShape","addDim","createDimVector","startDimVector","endShape","createShape","Shape","getRootAsDimension","getSizePrefixedRootAsDimension","DimensionValue","denotation","startDimension","addValue","addDenotation","endDimension","createDimension","getRootAsDimensionValue","getSizePrefixedRootAsDimensionValue","dimType","dimValue","dimParam","startDimensionValue","addDimType","addDimValue","addDimParam","endDimensionValue","createDimensionValue","getRootAsTensorTypeAndShape","getSizePrefixedRootAsTensorTypeAndShape","elemType","shape","startTensorTypeAndShape","addElemType","addShape","endTensorTypeAndShape","createTensorTypeAndShape","TensorTypeAndShape","getRootAsMapType","getSizePrefixedRootAsMapType","keyType","valueType","TypeInfo","startMapType","addKeyType","addValueType","endMapType","createMapType","MapType","getRootAsSequenceType","getSizePrefixedRootAsSequenceType","startSequenceType","endSequenceType","createSequenceType","SequenceType","nodeIndex","srcArgIndex","dstArgIndex","createEdgeEnd","EdgeEnd","getRootAsNodeEdge","getSizePrefixedRootAsNodeEdge","inputEdges","inputEdgesLength","outputEdges","outputEdgesLength","startNodeEdge","addNodeIndex","addInputEdges","startInputEdgesVector","addOutputEdges","startOutputEdgesVector","endNodeEdge","createNodeEdge","NodeEdge","getRootAsNode","getSizePrefixedRootAsNode","docString","sinceVersion","index","executionProviderType","inputs","inputsLength","outputs","outputsLength","attributes","Attribute","attributesLength","inputArgCounts","inputArgCountsLength","inputArgCountsArray","byteOffset","implicitInputs","implicitInputsLength","startNode","addName","addDocString","addDomain","addSinceVersion","addIndex","addOpType","addType","addExecutionProviderType","addInputs","createInputsVector","startInputsVector","addOutputs","createOutputsVector","startOutputsVector","addAttributes","createAttributesVector","startAttributesVector","addInputArgCounts","createInputArgCountsVector","startInputArgCountsVector","addImplicitInputs","createImplicitInputsVector","startImplicitInputsVector","endNode","createNode","Node","getRootAsValueInfo","getSizePrefixedRootAsValueInfo","startValueInfo","endValueInfo","createValueInfo","ValueInfo","getRootAsTypeInfo","getSizePrefixedRootAsTypeInfo","startTypeInfo","endTypeInfo","createTypeInfo","getRootAsOperatorSetId","getSizePrefixedRootAsOperatorSetId","startOperatorSetId","addVersion","endOperatorSetId","createOperatorSetId","OperatorSetId","getRootAsTensor","getSizePrefixedRootAsTensor","dimsLength","rawData","rawDataLength","rawDataArray","stringData","stringDataLength","startTensor","addDims","createDimsVector","startDimsVector","addDataType","addRawData","createRawDataVector","startRawDataVector","addStringData","createStringDataVector","startStringDataVector","endTensor","createTensor","getRootAsSparseTensor","getSizePrefixedRootAsSparseTensor","values","indices","startSparseTensor","addValues","addIndices","endSparseTensor","createSparseTensor","SparseTensor","getRootAsAttribute","getSizePrefixedRootAsAttribute","g","Graph","floats","floatsLength","floatsArray","ints","intsLength","strings","stringsLength","tensors","tensorsLength","graphs","graphsLength","startAttribute","addF","addI","addS","addT","addG","addFloats","createFloatsVector","startFloatsVector","addInts","createIntsVector","startIntsVector","addStrings","createStringsVector","startStringsVector","addTensors","createTensorsVector","startTensorsVector","addGraphs","createGraphsVector","startGraphsVector","endAttribute","createAttribute","getRootAsGraph","getSizePrefixedRootAsGraph","initializers","initializersLength","nodeArgs","nodeArgsLength","nodes","nodesLength","maxNodeIndex","nodeEdges","nodeEdgesLength","sparseInitializers","sparseInitializersLength","startGraph","addInitializers","createInitializersVector","startInitializersVector","addNodeArgs","createNodeArgsVector","startNodeArgsVector","addNodes","createNodesVector","startNodesVector","addMaxNodeIndex","addNodeEdges","createNodeEdgesVector","startNodeEdgesVector","addSparseInitializers","createSparseInitializersVector","startSparseInitializersVector","endGraph","createGraph","getRootAsModel","getSizePrefixedRootAsModel","irVersion","opsetImport","opsetImportLength","producerName","producerVersion","modelVersion","graph","graphDocString","startModel","addIrVersion","addOpsetImport","createOpsetImportVector","startOpsetImportVector","addProducerName","addProducerVersion","addModelVersion","addGraph","addGraphDocString","endModel","createModel","Model","getRootAsKernelCreateInfos","getSizePrefixedRootAsKernelCreateInfos","nodeIndices","nodeIndicesLength","nodeIndicesArray","kernelDefHashes","kernelDefHashesLength","startKernelCreateInfos","addNodeIndices","createNodeIndicesVector","startNodeIndicesVector","addKernelDefHashes","createKernelDefHashesVector","startKernelDefHashesVector","endKernelCreateInfos","createKernelCreateInfos","KernelCreateInfos","getRootAsSubGraphSessionState","getSizePrefixedRootAsSubGraphSessionState","graphId","sessionState","SessionState","startSubGraphSessionState","addGraphId","addSessionState","endSubGraphSessionState","createSubGraphSessionState","SubGraphSessionState","getRootAsSessionState","getSizePrefixedRootAsSessionState","kernels","subGraphSessionStates","subGraphSessionStatesLength","startSessionState","addKernels","addSubGraphSessionStates","createSubGraphSessionStatesVector","startSubGraphSessionStatesVector","endSessionState","createSessionState","getRootAsInferenceSession","getSizePrefixedRootAsInferenceSession","bufferHasIdentifier","ortVersion","model","startInferenceSession","addOrtVersion","addModel","endInferenceSession","finishInferenceSessionBuffer","finishSizePrefixedInferenceSessionBuffer","createInferenceSession","js","Vy","qs","ih","arguments","apply","Ys","Js","vn","charAt","ar","Ks","te","encode","slice","Xs","decode","Qs","Wy","Zs","In","_listeners","on","off","emit","au","Hy","iu","tu","writeFloatLE","writeFloatBE","readFloatLE","readFloatBE","round","eu","ru","NaN","nu","ou","writeDoubleLE","writeDoubleBE","readDoubleLE","readDoubleBE","su","module","inquire","moduleName","eval","replace","keys","lu","uu","jo","read","write","cu","jy","fu","ah","du","Xy","pu","vt","Er","Se","lo","hi","Re","zero","zzEncode","zzDecode","sh","zeroHash","isString","toLong","Oe","fromHash","toHash","Xo","N","asPromise","base64","EventEmitter","float","utf8","pool","LongBits","isNode","global","process","node","window","self","emptyArray","freeze","emptyObject","isInteger","isFinite","isObject","isset","isSet","Buffer","utf8Write","_Buffer_from","_Buffer_allocUnsafe","newBuffer","dcodeIO","key2Re","key32Re","key64Re","longToHash","longFromHash","hu","merge","lcFirst","toLowerCase","mu","captureStackTrace","writable","configurable","message","newError","ProtocolError","oneOfGetter","oneOfSetter","toJSONOptions","longs","enums","json","_configure","allocUnsafe","ei","Jy","xu","X","Wt","Ko","_n","bu","gu","Dr","len","next","val","Yo","uh","head","tail","states","yu","alloc","_push","Zo","lh","Qo","uint32","ti","sint32","uint64","int64","sint64","bool","Jo","fixed32","sfixed32","fixed64","sfixed64","double","fh","string","fork","ldelim","vu","Yy","wu","ce","Tu","Ae","writeBytesBuffer","copy","ch","oi","Zy","Au","ct","ee","ni","Ou","ph","re","pos","buf","Iu","Su","isBuffer","_slice","ri","On","_u","skip","skipType","Lu","Qy","Du","Ge","Eu","Pu","utf8Slice","ku","tx","$u","Lr","ii","rpcImpl","requestDelimited","responseDelimited","rpcCall","setTimeout","Fu","Bu","dh","Service","Nu","rx","Cu","Mu","Gu","Nt","build","Writer","BufferWriter","Reader","BufferReader","util","rpc","roots","configure","Ru","Vu","ox","Uu","sr","ix","zu","nt","$","pt","b","h","default","onnx","Version","AttributeProto","sparseTensors","typeProtos","refAttrName","sparseTensor","tp","TensorProto","GraphProto","TypeProto","SparseTensorProto","encodeDelimited","decodeDelimited","verify","fromObject","toObject","arrays","defaults","getTypeUrl","ValueInfoProto","NodeProto","input","output","attribute","TrainingInfoProto","initializationBinding","updateBinding","initialization","algorithm","StringStringEntryProto","ModelProto","metadataProps","trainingInfo","functions","OperatorSetIdProto","FunctionProto","key","TensorAnnotation","quantParameterTensorNames","tensorName","initializer","sparseInitializer","valueInfo","quantizationAnnotation","floatData","int32Data","int64Data","externalData","doubleData","uint64Data","segment","Segment","DataLocation","DataType","TensorShapeProto","oneofs","tensorType","sequenceType","mapType","optionalType","sparseTensorType","Sequence","Optional","OperatorStatus","attributeProto","ur","kr","TextDecoder","ot","Me","ai","kt","Sn","At","Rt","B","$r","Ue","Ve","ze","Y","rr","We","arraysEqual","preprocessInputShapes","postprocessOutputShape","pop","calcMatMulShape","calcShape","fillIndex","calc","areEqual","bt","isValidBroadcast","getBroadcastDims","unshift","getShapeOfGemmResult","tensorDataTypeFromProto","tensorDataTypeStringToEnum","tensorDimsFromProto","tensorValueTypeFromProto","tensorDimsFromORTFormat","longToNumber","tensorAttributesFromORTFormat","getSizeFromDimensionRange","sizeFromDimension","sizeToDimension","computeStrides","transpose","reverse","indicesToOffset","offsetToIndices","normalizeAxis","normalizeAxes","incrementIndex","calculateReshapedDims","sortBasedOnPerm","padShape","every","validateDimsAndCalcSize","flattenShape","reduce","squeezeShape","unsqueezeShape","fill","splitShape","determineSplit","adjustPoolAttributes","adjustPadsBasedOnAutoPad","adjustPadAndReturnShape","computePoolOutputShape","computeShapeHelper","computeConvOutputShape","hh","Wu","H","mh","ju","ui","si","Hu","getUint8","getInt8","getUint16","getInt16","getFloat32","getInt32","getUint32","getFloat64","qu","dataProvider","asyncDataProvider","cache","dataId","integerData","numberData","strides","_strides","fromProto","forEach","DataView","fromData","fromOrtTensor","G","bh","gh","Xu","varyingVertex","Ku","varyingFrag","outputDeclaration","Ju","ut","texture2D","j","li","tryFn","An","toUpperCase","Yu","lr","JSON","stringify","fr","Bt","pe","yh","cr","de","He","Th","wh","vh","Zu","xh","Qu","tl","inputTypes","createPackProgramInfo","session","glContext","hasMain","textureType","shaderSource","createPackProgramInfoLoader","fi","rl","Oh","Sh","Ih","_h","el","nl","cacheHint","createPackedReshape3DProgramInfo","createPackedReshape3DProgramInfoLoader","ci","ol","encodeAsUint8","tensor","executeProgram","Ph","il","Ah","al","sl","createUnpackProgramInfo","createUnpackProgramInfoLoader","Pn","Br","En","Fr","internalFormat","R32F","RED","channelSize","RGBA32F","RGBA","ALPHA","UNSIGNED_BYTE","Cr","ul","pi","ll","createTextureLayoutFromTextureType","isPacked","reverseWH","breakAxis","calculateTextureWidthAndHeight","createTextureLayoutFromShape","computeTextureWH","channels","unpackedShape","reversedWH","Dh","Dn","cl","getProgramInfoUniqueKey","packedTextureDataCache","unpackedTextureDataCache","layoutStrategy","getOrCreateTextureData","programManager","getArtifact","programInfo","createTextureData","setArtifact","runProgram","getTextureData","pack","unpack","createTextureDataFromLayoutBindTensor","textureManager","createTextureFromLayout","createTextureDataFromTexture","reshapeUnpacked","reshapePacked","cast","readTexture","readTextureAsync","setTextureData","isInitializer","isTextureLayoutCached","clearActiveTextures","releaseTexture","isFloat32DownloadSupported","readUint8TextureAsFloat","di","W","It","assign","cacheKey","sort","pl","dl","hl","Lh","$h","ml","batchNormalization","getFloat","getInt","epsilon","momentum","spatial","createBatchNormalizationProgramInfo","Ln","Ht","k","Nr","$n","Te","inputTextureLayouts","outputTextureLayout","context","routineBody","dependencies","addDependency","returnOrderedNodes","createOrderedNodes","dfsTraverse","delete","Bh","body","Fh","Ch","Nh","Rh","Gh","Mh","Uh","Vh","zh","Wh","qh","Hh","qt","jh","bl","gl","yl","xl","Tl","wl","vl","Il","_l","Ol","Sl","Al","Pl","createBinaryProgramInfoLoader","createBinaryProgramInfo","equal","greater","less","pRelu","El","Dl","Kh","Ll","Jh","Yh","$l","kn","kl","createPackedConcatProgramMetadata","createPackedConcatProgramInfo","wt","createPackedConcatProgramInfoLoader","axis","getShiftedChannelsSnippet","Bl","Zh","Qh","tm","Fl","em","rm","nm","Cl","om","Nl","concat","createUnpackedConcatProgramMetadata","createUnpackedConcatProgramInfo","createUnpackedConcatProgramInfoLoader","getFetchDataFromCorrectTextureMethod","im","jt","am","sm","um","lm","fm","cm","pm","dm","hm","mm","bm","gm","ym","xm","mi","bi","Tm","wm","vm","Im","dt","Rl","Gl","Ml","Ul","gi","Vl","zl","_m","Wl","Hl","ql","jl","Xl","Kl","yi","Jl","Yl","Zl","Ql","tf","ef","rf","nf","of","af","sf","xi","createElementwiseProgramInfo","createElementwiseProgramInfoLoader","abs","acos","asin","atan","clip","clipV11","generateClipAttributesFromInputs","cos","elu","alpha","exp","identity","leakyRelu","relu","sigmoid","sin","sqrt","tan","tanh","he","activation","clipMin","clipMax","activationFunction","applyActivation","pr","qe","getString","getFloats","activationCacheKey","Sm","Am","uf","lf","Bn","createUnpackedGroupedConvProgramMetadata","createUnpackedGroupedConvProgramInfo","group","autoPad","dilations","kernelShape","pads","dr","createUnpackedGroupedConvProgramInfoLoader","Pm","Em","ff","cf","createPackedIm2ColProgramInfo","createPackedIm2ColProgramInfoLoader","Lm","wi","Ti","Dm","pf","df","$m","Fn","vi","matMul","Cn","createMatmulProgramMetadata","Fm","Cm","Nm","km","Bm","createPackedMatmulProgramMetadata","createPackedMatmulProgramInfo","et","Dt","createPackedMatmulProgramInfoLoader","hf","mf","conv2DPacked","Rm","Gm","bf","Ii","_i","createIm2ColProgramInfo","createIm2ColProgramInfoLoader","calculateIm2ColDims","Mm","Um","gf","yf","createDotProductProgramMetadata","createDotProductProgramInfo","createDotProductProgramInfoLoader","Oi","Vm","zm","Wm","Hm","Si","qm","calculateOutputShape","conv","conv2d","conv2DUnpackedPointwise","conv2DUnpacked","getAdjustedConvAttributes","getInts","validateInputs","jm","Xm","Km","xf","Jm","Ym","Zm","Qm","tb","eb","Tf","rb","wf","computeTotalPad","distributePadding","calculateOutputShapeAndPads","convTranspose","convTranspose2d","createConvTransposeProgramMetadata","createUnpackedConvTransposeProgramInfo","outputShape","createUnpackedConvTransposeProgramInfoLoader","convTranspose2DUnpacked","getAdjustedConvTransposeAttributes","outputPadding","vf","je","If","nb","_f","ob","ib","ab","Nn","perm","createTransposeProgramInfo","getAdjustedPerm","getOutputShape","getPermFunctionBody","Of","Sf","sb","Af","depthToSpace","blocksize","mode","Pf","Ef","ub","Df","flatten","Pe","Rr","Lf","$f","lb","fb","cb","pb","kf","gather","createGatherProgramInfo","createGatherProgramInfoLoader","Ai","Bf","Ff","Cf","db","hb","mb","Nf","gemm","parseGemmAttributes","transA","transB","beta","isOptionalC","createGemmProgramInfoLoader","createGemmProgramInfo","variables","Rf","Gf","gb","yb","xb","Tb","Mf","imageScaler","scale","createImageScalerProgramInfo","arrayLength","createImageScalerProgramInfoLoader","Vf","zf","Uf","wb","vb","Ib","_b","Ob","Sb","Wf","instanceNormalization","createMeanAndVarianceProgramInfo","createComputeOutputProgramInfo","createComputeOutputProgramInfoLoader","Ab","jf","Pb","Hf","qf","Eb","Xf","lrn","Db","Pi","Kf","Jf","Yf","Lb","$b","kb","Bb","Fb","Cb","Nb","Rb","Zf","padV2","padV11","generatePadAttributesFromInputs","createPadProgramInfo","getPadFunction","getPadConstant","getPadReflect","getPadEdge","tc","ec","rc","nc","oc","ic","ac","sc","uc","Gb","Qf","lc","Gn","fc","Rn","Mb","cc","averagePool","ceilMode","countIncludePad","createAveragePoolProgramInfo","globalAveragePool","maxPool","storageOrder","createMaxPoolProgramInfo","getAdjustedPoolAttributesAndOutputShape","globalMaxPool","generatePoolingCode","copyArray","Xe","Ee","Ub","Vb","pc","dc","hc","mc","bc","gc","yc","xc","axes","keepDims","createReduceProgramInfo","reduceSum","reduceMean","reduceMax","reduceMin","reduceProd","reduceLogSum","reduceLogSumSquare","Tc","wc","vc","Ei","Ic","_c","Gr","zb","Di","Mn","Li","upsample","parseUpsampleAttributes","opset","isResize","scales","extrapolationValue","coordinateTransformMode","useExtrapolation","needRoiInput","nearestMode","cubicCoefficientA","excludeOutside","useNearest2xOptimization","roiInputIdx","scalesInputIdx","sizesInputIdx","createUpsampleProgramInfo","scalesValidation","$i","ki","Oc","Sc","Wb","Hb","qb","jb","Ac","resize","createPackedResizeProgramInfo","prepareInputs","parseScalesData","parseScalesDataFromOutputSize","Pc","Xb","Ec","Bi","Dc","Lc","$c","Kb","kc","Jb","Yb","Bc","starts","ends","createSliceProgramInfo","sliceV10","generateSliceAttributesFromInputs","some","Fc","Cc","Nc","Rc","Gc","Mc","Uc","Vc","Zb","Qb","tg","zc","Wc","softmax","softmaxV13","computeSoftmax","createComputeMaxProgramInfo","createComputScaleProgramInfo","createSoftMaxProgramInfo","Hc","qc","jc","eg","rg","ng","Xc","numOutputs","getProgramCount","createSplitProgramInfo","Fi","Kc","Jc","og","ig","Yc","squeeze","squeezeV13","Zc","ag","sg","Qc","sum","createSumProgramInfo","ug","lg","ep","tile","createTileProgramInfo","Ci","rp","np","fg","cg","op","unsqueeze","unsqueezeV13","ip","ap","up","sp","exec","params","pg","lp","hr","dg","newShape","keptDims","hg","mg","fp","Un","Ni","maxTextureSize","computeTexture","Vn","cp","getFunctions","offsetToCoords","coordsToOffset","toVec","valueFrom","getCommonUtilFuncs","getInputsSamplingSnippets","getOutputSamplingSnippet","getCustomTypes","getPackedOutputSamplingSnippet","getUnpackedOutputSamplingSnippet","getOutputScalarCoords","getOutputPacked1DCoords","getOutputPacked2DCoords","getOutputPacked3DCoords","getOutputPackedNDCoords","getOutputUnpacked1DCoords","getOutputUnpacked2DCoords","getOutputUnpacked3DCoords","getOutputUnpacked4DCoords","getOutputUnpacked5DCoords","getOutputUnpacked6DCoords","getPackedSamplerFromInput","getUnpackedSamplerFromInput","getPackedSamplerAtOutputCoords","getUnpackedSamplerAtOutputCoords","_t","getPackedSamplerScalar","getPackedSampler1D","getPackedSampler2D","getPackedSampler3D","getPackedSamplerND","getUnpackedSamplerScalar","getUnpackedSampler1D","getUnpackedSampler2D","getUnpackedSampler3D","getUnpackedSampler4D","getUnpackedSampler5D","getUnpackedSampler6D","getValueFromSingle","getPackedValueFrom","zn","pp","encodeFloat32","decodeFloat32","encodeUint8","decodeUint8","Wn","dp","setFragColor","getColorAsFloat","Hn","hp","bcastIndex","bcastMatmulIndex","incrementIndices","indexToOffsetSingle","offsetToIndicesSingle","qn","mp","binaryVecFunctions","copyVec","setVecItem","getVecItem","Ri","bp","encoding","fragcolor","vec","shapeUtils","coordinates","jn","gp","libs","glslLibRoutineDependencyGraph","preprocess","getUniforms","getImports","selectGlslLibRoutinesToBeIncluded","Xn","yp","profiler","textureLayoutStrategy","repo","attributesBound","program","useProgram","bindOutput","bindAttributes","attribLocations","bindUniforms","uniformLocations","draw","vertexShader","deleteShader","deleteProgram","compile","getUniformLocations","getAttribLocations","compileShader","VERTEX_SHADER","debug","FRAGMENT_SHADER","createProgram","attachFramebuffer","textureCoord","setVertexAttributes","find","bindTexture","uniform1fv","uniform1f","uniform1iv","uniform1i","bindTextureToUniform","getAttribLocation","getUniformLocation","Kn","xp","config","pendingRead","reuseTextures","inUseTextures","idleTextures","textureLookup","toEncoderType","getEncoder","updateTexture","toTextureData","allocateTexture","toTensorData","createAndWaitForFence","deleteTexture","Jn","Tp","textureCacheMode","pack2unpackMap","unpack2packMap","createInferenceHandler","onGraphInitialized","getValues","addInitializer","resolve","impl","bg","Mr","wp","frameBufferBound","itemsToPoll","getExtensions","vertexbuffer","createVertexbuffer","framebuffer","createFramebuffer","queryVitalParameters","createTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","checkError","texSubImage2D","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","viewport","scissor","readPixels","isFramebufferReady","getActiveTexture","getParameter","ACTIVE_TEXTURE","TEXTURE0","getTextureBinding","TEXTURE_BINDING_2D","getFramebufferBinding","FRAMEBUFFER_BINDING","vertexAttribPointer","enableVertexAttribArray","attachShader","linkProgram","createShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","activeTexture","drawArrays","TRIANGLE_STRIP","getError","NO_ERROR","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL","isRenderFloat32Supported","textureHalfFloatExtension","HALF_FLOAT_OES","maxTextureImageUnits","disposed","deleteFramebuffer","bindBuffer","ARRAY_BUFFER","deleteBuffer","ELEMENT_ARRAY_BUFFER","createDefaultGeometry","createBuffer","bufferData","STATIC_DRAW","isFloatTextureAttachableToFrameBuffer","checkFloatTextureAttachableToFrameBuffer","checkRenderFloat32","checkFloat32Download","isBlendSupported","checkFloat32Blend","MAX_TEXTURE_SIZE","MAX_TEXTURE_IMAGE_UNITS","colorBufferFloatExtension","getExtension","disjointTimerQueryWebgl2Extension","textureFloatExtension","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","enable","BLEND","POINTS","disable","createQuery","beginQuery","TIME_ELAPSED_EXT","endQuery","isTimerResultAvailable","getQueryParameter","QUERY_RESULT_AVAILABLE","GPU_DISJOINT_EXT","getTimerResult","QUERY_RESULT","deleteQuery","createFence","pollFence","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","isFencePassed","clientWaitSync","ALREADY_SIGNALED","CONDITION_SATISFIED","query","addItemToPoll","pollItems","isDoneFn","resolveFn","Gi","mr","webgl2","yg","vp","gg","isContextLost","DEPTH_TEST","STENCIL_TEST","DITHER","POLYGON_OFFSET_FILL","SAMPLE_COVERAGE","SCISSOR_TEST","CULL_FACE","cullFace","BACK","depth","antialias","stencil","preserveDrawingBuffer","premultipliedAlpha","failIfMajorPerformanceCaveat","Ip","Yn","_p","contextId","matmulMaxBatchSize","async","initialize","createSessionHandler","Mi","Op","Tg","xg","wg","Sp","Ui","Zn","Ap","getNodes","_ops","_starter","_values","getInputIndices","execute","to","getOutputIndices","q","Xt","Ur","Pp","_attributes","getValue","getType","getTensor","getStrings","getTensors","getValueNoCheck","getValueNoCheckFromOnnxFormat","getValueNoCheckFromOrtFormat","zi","Qn","Wi","me","Vi","Ep","_from","_to","executeNode","buildGraph","transformGraph","checkIsAcyclic","_allInputIndices","getInputNames","_allInputNames","_allOutputIndices","getOutputNames","_allOutputNames","_allData","_nodes","buildGraphFromOnnxFormat","buildGraphFromOrtFormat","removeAllIdentityNodes","removeAllDropoutNodes","fuseConvActivationNodes","finalizeGraph","deleteNode","isActivation","Dp","vg","eo","Lp","load","loadFromOnnxFormat","loadFromOrtFormat","_opsets","_graph","opsets","ro","$p","_initialized","backendHint","graphInputTypes","graphInputDims","_model","loadModel","sessionHandler","fetch","arrayBuffer","isView","initializeOps","_executionPlan","normalizeAndValidateInputs","createOutput","validateInputTensorDims","validateInputTensorTypes","compareTensorDims","no","kp","Bp","onnxjsBackend","Ig","Hi","Fp","oo","Rp","_g","Cp","Np","Gp","qi","Ke","Vr","globalThis","onmessage","in","io","ao","postMessage","epName","so","zr","out","options","uo","sessionId","inputIndices","outputIndices","fo","po","co","Worker","br","Up","Og","ji","Mp","Vp","import","meta","url","oe","it","be","Z","ae","c","m","importScripts","mountExternalData","startsWith","Ua","unmountExternalData","Memory","initial","maximum","shared","href","currentScript","substr","lastIndexOf","XMLHttpRequest","open","responseType","send","response","x","status","onerror","cmd","I","E","startWorker","handlers","proxy","R","Za","args","wasmMemory","wasmModule","$o","pthread_ptr","Ao","md","aa","bd","start_routine","arg","er","nn","target","tn","Ha","Vg","alert","text","instantiateWasm","Yr","onunhandledrejection","reason","wasmBinary","Kr","we","ie","se","HEAP8","HEAP16","HEAPU8","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAPF64","HEAP64","HEAPU64","Lt","Jr","Ye","ue","Ze","De","clearInterval","Mt","RuntimeError","ve","Ot","Jt","wr","credentials","ok","catch","instantiate","hd","yd","ca","ha","ma","ya","xa","Ta","wa","va","Ia","_a","Oa","Sa","U","Aa","Pa","_","xd","Td","wd","vd","Id","_d","Od","Sd","Ad","K","Pd","La","$a","Ed","Dd","Ld","$d","kd","Bd","Fd","ka","Cd","Nd","Rd","Gd","Md","Q","Ca","Na","So","Ra","Ga","Ma","Oo","Wa","zd","ea","Ir","wasmOffsetConverter","Io","_o","terminate","ra","Ie","ua","sa","Le","fe","vr","st","Fo","Bo","at","Pt","qa","na","oa","ia","ko","targetThread","transferList","thread","loaded","threadId","filename","lineno","URL","workerData","la","Zr","shift","Xa","Qr","gd","fa","pa","da","ba","ga","_r","Atomics","store","ja","Po","Wd","getUTCSeconds","getUTCMinutes","getUTCHours","getUTCDate","getUTCMonth","getUTCFullYear","getUTCDay","getTime","UTC","Qe","Ea","Da","getSeconds","getMinutes","getHours","getDate","getMonth","getFullYear","getDay","getTimezoneOffset","setTime","getYear","$t","toLocaleTimeString","hour12","timeZoneName","Eo","timeOrigin","navigator","hardwareConcurrency","grow","en","tr","Ba","Do","Lo","Fa","USER","LOGNAME","PATH","PWD","HOME","LANG","languages","Ud","Ft","Va","za","Vd","ft","$e","setDate","setMonth","setFullYear","Ya","Qa","Ja","%n","%t","%%","numThreads","all","emscripten_main_runtime_thread_id","locateFile","instantiateStreaming","instance","_OrtInit","_OrtGetLastError","_OrtCreateSessionOptions","_OrtAppendExecutionProvider","_OrtAddFreeDimensionOverride","_OrtAddSessionConfigEntry","_OrtReleaseSessionOptions","_OrtCreateSession","_OrtReleaseSession","_OrtGetInputOutputCount","_OrtGetInputName","_OrtGetOutputName","_OrtFree","_OrtCreateTensor","_OrtGetTensorData","_OrtReleaseTensor","_OrtCreateRunOptions","_OrtAddRunConfigEntry","_OrtReleaseRunOptions","_OrtCreateBinding","ta","_OrtBindInput","_OrtBindOutput","_OrtClearBoundOutputs","_OrtReleaseBinding","_OrtRunWithBinding","_OrtRun","_OrtEndProfiling","_malloc","_free","rn","Ka","calledRun","___start_em_js","___stop_em_js","stackSave","stackRestore","stackAlloc","UTF8ToString","stringToUTF8","lengthBytesUTF8","Sg","Ag","Pg","zp","Wp","Eg","Hp","origin","isSameOrigin","blob","createObjectURL","sn","importProxyWorker","importWasmModule","Xi","Ki","ho","qp","Dg","Lg","xt","isMultiThreadSupported","MessageChannel","port1","validate","isSimdSupported","initTimeout","crossOriginIsolated","wasmPaths","mjs","revokeObjectURL","race","getInstance","Tt","Wr","ht","mo","allocWasmString","iterateExtraOptions","entries","jp","Xp","logSeverityLevel","logVerbosityLevel","tag","extra","WeakSet","$g","kg","Bg","Fg","Kp","Jp","use_ort_model_bytes_directly","enableMemPattern","setExecutionProviders","deviceType","preferredLayout","graphOptimizationLevel","executionMode","logId","optimizedModelFilePath","enableCpuMemArena","enableProfiling","enableGraphCapture","freeDimensionOverrides","Hr","Yp","qr","Zp","Qp","bo","go","td","Ji","calculateTensorSizeInBytes","jr","Yi","readFile","Co","code","createReadStream","headers","getReader","done","Blob","Cg","yr","Ng","ed","initOrt","initEp","createSession","path","shouldTransferToMLTensor","currentContext","gpuDevice","powerPreference","createContext","jsepRegisterMLContext","handle","jsepOnReleaseSession","prepareInputOutputTensor","jsepRegisterBuffer","jsepRegisterMLTensor","jsepOnRunStart","outputPreferredLocations","jsepGetBuffer","jsepCreateDownloader","jsepEnsureTensor","jsepCreateMLTensorDownloader","jsepReleaseTensorId","Je","Kt","Xr","xo","To","yo","Zi","Qi","xr","Tr","Gg","rd","nd","od","id","ad","sd","ud","isProxy","enqueueCallbacks","ensureWorker","initializeWebAssemblyAndOrtRuntime","preferredOutputLocation","ld","Mg","wo","fd","encodeTensorMetadata","fetchModelAndCopyToWasmMemory","pd","OnnxruntimeWebAssemblyBackend","vo","initializeFlags","cd","wasmBackend","Ug","dd","simd","cpus","Ds","mO"],"sources":["/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/backend-impl.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/backend.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/version.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/env-impl.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/env.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/tensor-conversion-impl.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/tensor-factory-impl.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/tensor-impl-type-mapping.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/tensor-utils-impl.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/tensor-impl.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/tensor.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/trace.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/inference-session-impl.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/inference-session.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/tensor-conversion.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/tensor-factory.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/onnx-model.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/onnx-value.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/training-session-impl.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/training-session.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/common/lib/index.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/instrument.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/opset.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/guid-typescript/dist/guid.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/long/index.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/flatbuffers/js/flatbuffers.mjs","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/@protobufjs/aspromise/index.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/@protobufjs/base64/index.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/@protobufjs/eventemitter/index.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/@protobufjs/float/index.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/@protobufjs/inquire/index.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/@protobufjs/utf8/index.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/@protobufjs/pool/index.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/protobufjs/src/util/longbits.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/protobufjs/src/util/minimal.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/protobufjs/src/writer.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/protobufjs/src/writer_buffer.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/protobufjs/src/reader.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/protobufjs/src/reader_buffer.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/protobufjs/src/rpc/service.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/protobufjs/src/rpc.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/protobufjs/src/roots.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/protobufjs/src/index-minimal.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/node_modules/protobufjs/minimal.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/ort-schema/protobuf/onnx.js","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/util.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/tensor.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-source.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/types.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/utils.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/packing-utils.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/pack.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/reshape-packed.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/uint8-encode.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/unpack.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/texture-data-encoder.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/texture-layout.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/inference-handler.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/attribute-with-cache-key.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/batch-normalization.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-definitions.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/binary-op.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/cast.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/concat-packed.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/concat.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/unary-op.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/fuse-utils.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/conv-grouped.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/im2col-pack.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/matmul.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/matmul-pack.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/conv-pack.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/im2col.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/dot-product.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/conv.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/conv-transpose.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/transpose.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/depth-to-space.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/flatten.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/operators.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/gather.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/gemm.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/image-scaler.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/instance-normalization.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/lrn.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/pad.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/pool.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/reduce.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/reshape.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/upsample.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/resize-packed.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/shape.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/slice.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/softmax.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/split.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/squeeze.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/sum.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/tile.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/unsqueeze.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/op-resolve-rules.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-function-inliner.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/texture-layout-strategy.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-encoding-lib.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-vec-lib.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-registered-libs.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-preprocessor.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/program-manager.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/texture-manager.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/session-handler.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/webgl-context.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/webgl-context-factory.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backends/backend-webgl.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/backend.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/execution-plan.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/attribute.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/graph.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/model.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/session.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/onnxjs/session-handler-inference.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/backend-onnxjs.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/wasm/wasm-utils-env.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/wasm/proxy-worker/main.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.mjs","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/wasm/wasm-utils-import.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/wasm/wasm-factory.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/wasm/wasm-utils.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/wasm/run-options.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/wasm/session-options.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/wasm/wasm-common.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/wasm/wasm-utils-load-file.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/wasm/wasm-core-impl.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/wasm/proxy-wrapper.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/wasm/session-handler-inference.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/backend-wasm.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/index.ts","/Users/ventura/Desktop/EPFL/AI_Team/mist/mnistdeploytest/website/mnist-web/node_modules/onnxruntime-web/lib/version.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Backend } from './backend.js';\nimport { InferenceSession } from './inference-session.js';\n\ninterface BackendInfo {\n  backend: Backend;\n  priority: number;\n\n  initPromise?: Promise<void>;\n  initialized?: boolean;\n  aborted?: boolean;\n  error?: string;\n}\n\nconst backends: Map<string, BackendInfo> = new Map();\nconst backendsSortedByPriority: string[] = [];\n\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @ignore\n */\nexport const registerBackend = (name: string, backend: Backend, priority: number): void => {\n  if (backend && typeof backend.init === 'function' && typeof backend.createInferenceSessionHandler === 'function') {\n    const currentBackend = backends.get(name);\n    if (currentBackend === undefined) {\n      backends.set(name, { backend, priority });\n    } else if (currentBackend.priority > priority) {\n      // same name is already registered with a higher priority. skip registeration.\n      return;\n    } else if (currentBackend.priority === priority) {\n      if (currentBackend.backend !== backend) {\n        throw new Error(`cannot register backend \"${name}\" using priority ${priority}`);\n      }\n    }\n\n    if (priority >= 0) {\n      const i = backendsSortedByPriority.indexOf(name);\n      if (i !== -1) {\n        backendsSortedByPriority.splice(i, 1);\n      }\n\n      for (let i = 0; i < backendsSortedByPriority.length; i++) {\n        if (backends.get(backendsSortedByPriority[i])!.priority <= priority) {\n          backendsSortedByPriority.splice(i, 0, name);\n          return;\n        }\n      }\n      backendsSortedByPriority.push(name);\n    }\n    return;\n  }\n\n  throw new TypeError('not a valid backend');\n};\n\n/**\n * Try to resolve and initialize a backend.\n *\n * @param backendName - the name of the backend.\n * @returns the backend instance if resolved and initialized successfully, or an error message if failed.\n */\nconst tryResolveAndInitializeBackend = async (backendName: string): Promise<Backend | string> => {\n  const backendInfo = backends.get(backendName);\n  if (!backendInfo) {\n    return 'backend not found.';\n  }\n\n  if (backendInfo.initialized) {\n    return backendInfo.backend;\n  } else if (backendInfo.aborted) {\n    return backendInfo.error!;\n  } else {\n    const isInitializing = !!backendInfo.initPromise;\n    try {\n      if (!isInitializing) {\n        backendInfo.initPromise = backendInfo.backend.init(backendName);\n      }\n      await backendInfo.initPromise;\n      backendInfo.initialized = true;\n      return backendInfo.backend;\n    } catch (e) {\n      if (!isInitializing) {\n        backendInfo.error = `${e}`;\n        backendInfo.aborted = true;\n      }\n      return backendInfo.error!;\n    } finally {\n      delete backendInfo.initPromise;\n    }\n  }\n};\n\n/**\n * Resolve execution providers from the specific session options.\n *\n * @param options - the session options object.\n * @returns a promise that resolves to a tuple of an initialized backend instance and a session options object with\n * filtered EP list.\n *\n * @ignore\n */\nexport const resolveBackendAndExecutionProviders = async (\n  options: InferenceSession.SessionOptions,\n): Promise<[backend: Backend, options: InferenceSession.SessionOptions]> => {\n  // extract backend hints from session options\n  const eps = options.executionProviders || [];\n  const backendHints = eps.map((i) => (typeof i === 'string' ? i : i.name));\n  const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n\n  // try to resolve and initialize all requested backends\n  let backend: Backend | undefined;\n  const errors = [];\n  const availableBackendNames = new Set<string>();\n  for (const backendName of backendNames) {\n    const resolveResult = await tryResolveAndInitializeBackend(backendName);\n    if (typeof resolveResult === 'string') {\n      errors.push({ name: backendName, err: resolveResult });\n    } else {\n      if (!backend) {\n        backend = resolveResult;\n      }\n      if (backend === resolveResult) {\n        availableBackendNames.add(backendName);\n      }\n    }\n  }\n\n  // if no backend is available, throw error.\n  if (!backend) {\n    throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(', ')}`);\n  }\n\n  // for each explicitly requested backend, if it's not available, output warning message.\n  for (const { name, err } of errors) {\n    if (backendHints.includes(name)) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `removing requested execution provider \"${name}\" from session options because it is not available: ${err}`,\n      );\n    }\n  }\n\n  const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === 'string' ? i : i.name));\n\n  return [\n    backend,\n    new Proxy(options, {\n      get: (target, prop) => {\n        if (prop === 'executionProviders') {\n          return filteredEps;\n        }\n        return Reflect.get(target, prop);\n      },\n    }),\n  ];\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceSession } from './inference-session.js';\nimport { OnnxValue } from './onnx-value.js';\nimport { TrainingSession } from './training-session.js';\n\n/**\n * @ignore\n */\nexport declare namespace SessionHandler {\n  type FeedsType = { [name: string]: OnnxValue };\n  type FetchesType = { [name: string]: OnnxValue | null };\n  type ReturnType = { [name: string]: OnnxValue };\n}\n\n/**\n * Represents shared SessionHandler functionality\n *\n * @ignore\n */\ninterface SessionHandler {\n  dispose(): Promise<void>;\n\n  readonly inputNames: readonly string[];\n  readonly outputNames: readonly string[];\n}\n\n/**\n * Represent a handler instance of an inference session.\n *\n * @ignore\n */\nexport interface InferenceSessionHandler extends SessionHandler {\n  startProfiling(): void;\n  endProfiling(): void;\n\n  run(\n    feeds: SessionHandler.FeedsType,\n    fetches: SessionHandler.FetchesType,\n    options: InferenceSession.RunOptions,\n  ): Promise<SessionHandler.ReturnType>;\n}\n\n/**\n * Represent a handler instance of a training inference session.\n *\n * @ignore\n */\nexport interface TrainingSessionHandler extends SessionHandler {\n  readonly evalInputNames: readonly string[];\n  readonly evalOutputNames: readonly string[];\n\n  lazyResetGrad(): Promise<void>;\n  runTrainStep(\n    feeds: SessionHandler.FeedsType,\n    fetches: SessionHandler.FetchesType,\n    options: InferenceSession.RunOptions,\n  ): Promise<SessionHandler.ReturnType>;\n  runOptimizerStep(options: InferenceSession.RunOptions): Promise<void>;\n  runEvalStep(\n    feeds: SessionHandler.FeedsType,\n    fetches: SessionHandler.FetchesType,\n    options: InferenceSession.RunOptions,\n  ): Promise<SessionHandler.ReturnType>;\n\n  getParametersSize(trainableOnly: boolean): Promise<number>;\n  loadParametersBuffer(buffer: Uint8Array, trainableOnly: boolean): Promise<void>;\n  getContiguousParameters(trainableOnly: boolean): Promise<OnnxValue>;\n}\n\n/**\n * Represent a backend that provides implementation of model inferencing.\n *\n * @ignore\n */\nexport interface Backend {\n  /**\n   * Initialize the backend asynchronously. Should throw when failed.\n   */\n  init(backendName: string): Promise<void>;\n\n  createInferenceSessionHandler(\n    uriOrBuffer: string | Uint8Array,\n    options?: InferenceSession.SessionOptions,\n  ): Promise<InferenceSessionHandler>;\n\n  createTrainingSessionHandler?(\n    checkpointStateUriOrBuffer: TrainingSession.UriOrBuffer,\n    trainModelUriOrBuffer: TrainingSession.UriOrBuffer,\n    evalModelUriOrBuffer: TrainingSession.UriOrBuffer,\n    optimizerModelUriOrBuffer: TrainingSession.UriOrBuffer,\n    options: InferenceSession.SessionOptions,\n  ): Promise<TrainingSessionHandler>;\n}\n\nexport { registerBackend } from './backend-impl.js';\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// This file is generated by /js/scripts/update-version.ts\n// Do not modify file content manually.\n\nexport const version = '1.20.1';\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Env } from './env.js';\nimport { version } from './version.js';\n\ntype LogLevelType = Env['logLevel'];\n\nlet logLevelValue: Required<LogLevelType> = 'warning';\n\nexport const env: Env = {\n  wasm: {} as Env.WebAssemblyFlags,\n  webgl: {} as Env.WebGLFlags,\n  webgpu: {} as Env.WebGpuFlags,\n  versions: { common: version },\n\n  set logLevel(value: LogLevelType) {\n    if (value === undefined) {\n      return;\n    }\n    if (typeof value !== 'string' || ['verbose', 'info', 'warning', 'error', 'fatal'].indexOf(value) === -1) {\n      throw new Error(`Unsupported logging level: ${value}`);\n    }\n    logLevelValue = value;\n  },\n  get logLevel(): Required<LogLevelType> {\n    return logLevelValue;\n  },\n};\n\n// set property 'logLevel' so that they can be correctly transferred to worker by `postMessage()`.\nObject.defineProperty(env, 'logLevel', { enumerable: true });\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { env as envImpl } from './env-impl.js';\n\nexport declare namespace Env {\n  export type WasmPathPrefix = string;\n  export interface WasmFilePaths {\n    /**\n     * Specify the override path for the main .wasm file.\n     *\n     * This path should be an absolute path.\n     *\n     * If not modified, the filename of the .wasm file is:\n     * - `ort-wasm-simd-threaded.wasm` for default build\n     * - `ort-wasm-simd-threaded.jsep.wasm` for JSEP build (with WebGPU and WebNN)\n     * - `ort-training-wasm-simd-threaded.wasm` for training build\n     */\n    wasm?: URL | string;\n    /**\n     * Specify the override path for the main .mjs file.\n     *\n     * This path should be an absolute path.\n     *\n     * If not modified, the filename of the .mjs file is:\n     * - `ort-wasm-simd-threaded.mjs` for default build\n     * - `ort-wasm-simd-threaded.jsep.mjs` for JSEP build (with WebGPU and WebNN)\n     * - `ort-training-wasm-simd-threaded.mjs` for training build\n     */\n    mjs?: URL | string;\n  }\n  export type WasmPrefixOrFilePaths = WasmPathPrefix | WasmFilePaths;\n  export interface WebAssemblyFlags {\n    /**\n     * set or get number of thread(s). If omitted or set to 0, number of thread(s) will be determined by system. If set\n     * to 1, no worker thread will be spawned.\n     *\n     * This setting is available only when WebAssembly multithread feature is available in current context.\n     *\n     * @defaultValue `0`\n     */\n    numThreads?: number;\n\n    /**\n     * set or get a boolean value indicating whether to enable SIMD. If set to false, SIMD will be forcely disabled.\n     *\n     * This setting is available only when WebAssembly SIMD feature is available in current context.\n     *\n     * @deprecated This property is deprecated. Since SIMD is supported by all major JavaScript engines, non-SIMD\n     * build is no longer provided. This property will be removed in future release.\n     * @defaultValue `true`\n     */\n    simd?: boolean;\n\n    /**\n     * set or get a boolean value indicating whether to enable trace.\n     *\n     * @deprecated Use `env.trace` instead. If `env.trace` is set, this property will be ignored.\n     * @defaultValue `false`\n     */\n    trace?: boolean;\n\n    /**\n     * Set or get a number specifying the timeout for initialization of WebAssembly backend, in milliseconds. A zero\n     * value indicates no timeout is set.\n     *\n     * @defaultValue `0`\n     */\n    initTimeout?: number;\n\n    /**\n     * Set a custom URL prefix to the .wasm/.mjs files, or an object of overrides for both .wasm/.mjs file. The override\n     * path should be an absolute path.\n     */\n    wasmPaths?: WasmPrefixOrFilePaths;\n\n    /**\n     * Set a custom buffer which contains the WebAssembly binary. If this property is set, the `wasmPaths` property will\n     * be ignored.\n     */\n    wasmBinary?: ArrayBufferLike | Uint8Array;\n\n    /**\n     * Set or get a boolean value indicating whether to proxy the execution of main thread to a worker thread.\n     *\n     * @defaultValue `false`\n     */\n    proxy?: boolean;\n  }\n\n  export interface WebGLFlags {\n    /**\n     * Set or get the WebGL Context ID (webgl or webgl2).\n     *\n     * @defaultValue `'webgl2'`\n     */\n    contextId?: 'webgl' | 'webgl2';\n    /**\n     * Get the WebGL rendering context.\n     */\n    readonly context: WebGLRenderingContext;\n    /**\n     * Set or get the maximum batch size for matmul. 0 means to disable batching.\n     *\n     * @deprecated\n     */\n    matmulMaxBatchSize?: number;\n    /**\n     * Set or get the texture cache mode.\n     *\n     * @defaultValue `'full'`\n     */\n    textureCacheMode?: 'initializerOnly' | 'full';\n    /**\n     * Set or get the packed texture mode\n     *\n     * @defaultValue `false`\n     */\n    pack?: boolean;\n    /**\n     * Set or get whether enable async download.\n     *\n     * @defaultValue `false`\n     */\n    async?: boolean;\n  }\n\n  export interface WebGpuProfilingDataV1TensorMetadata {\n    dims: readonly number[];\n    dataType: string;\n  }\n  export interface WebGpuProfilingDataV1 {\n    version: 1;\n    inputsMetadata: readonly WebGpuProfilingDataV1TensorMetadata[];\n    outputsMetadata: readonly WebGpuProfilingDataV1TensorMetadata[];\n    kernelId: number;\n    kernelType: string;\n    kernelName: string;\n    programName: string;\n    startTime: number;\n    endTime: number;\n  }\n\n  export type WebGpuProfilingData = WebGpuProfilingDataV1;\n\n  export interface WebGpuFlags {\n    /**\n     * Set or get the profiling mode.\n     *\n     * @deprecated Use `env.webgpu.profiling.mode` instead. If `env.webgpu.profiling.mode` is set, this property will be\n     * ignored.\n     */\n    profilingMode?: 'off' | 'default';\n    /**\n     * Set or get the profiling configuration.\n     */\n    profiling?: {\n      /**\n       * Set or get the profiling mode.\n       *\n       * @defaultValue `'off'`\n       */\n      mode?: 'off' | 'default';\n\n      /**\n       * Set or get a callback function when a profiling data is received. If not set, the profiling data will be\n       * printed to console.\n       */\n      ondata?: (data: WebGpuProfilingData) => void;\n    };\n    /**\n     * Set or get the power preference.\n     *\n     * Setting this property only has effect before the first WebGPU inference session is created. The value will be\n     * used as options for `navigator.gpu.requestAdapter()`.\n     *\n     * See {@link https://gpuweb.github.io/gpuweb/#dictdef-gpurequestadapteroptions} for more details.\n     *\n     * @defaultValue `undefined`\n     */\n    powerPreference?: 'low-power' | 'high-performance';\n    /**\n     * Set or get the force fallback adapter flag.\n     *\n     * Setting this property only has effect before the first WebGPU inference session is created. The value will be\n     * used as options for `navigator.gpu.requestAdapter()`.\n     *\n     * See {@link https://gpuweb.github.io/gpuweb/#dictdef-gpurequestadapteroptions} for more details.\n     *\n     * @defaultValue `undefined`\n     */\n    forceFallbackAdapter?: boolean;\n    /**\n     * Set or get the adapter for WebGPU.\n     *\n     * Setting this property only has effect before the first WebGPU inference session is created. The value will be\n     * used as the GPU adapter for the underlying WebGPU backend to create GPU device.\n     *\n     * If this property is not set, it will be available to get after the first WebGPU inference session is created. The\n     * value will be the GPU adapter that created by the underlying WebGPU backend.\n     *\n     * When use with TypeScript, the type of this property is `GPUAdapter` defined in \"@webgpu/types\".\n     * Use `const adapter = env.webgpu.adapter as GPUAdapter;` in TypeScript to access this property with correct type.\n     *\n     * see comments on {@link Tensor.GpuBufferType}\n     */\n    adapter: unknown;\n    /**\n     * Get the device for WebGPU.\n     *\n     * This property is only available after the first WebGPU inference session is created.\n     *\n     * When use with TypeScript, the type of this property is `GPUDevice` defined in \"@webgpu/types\".\n     * Use `const device = env.webgpu.device as GPUDevice;` in TypeScript to access this property with correct type.\n     *\n     * see comments on {@link Tensor.GpuBufferType} for more details about why not use types defined in \"@webgpu/types\".\n     */\n    readonly device: unknown;\n    /**\n     * Set or get whether validate input content.\n     *\n     * @defaultValue `false`\n     */\n    validateInputContent?: boolean;\n  }\n}\n\nexport interface Env {\n  /**\n   * set the severity level for logging.\n   *\n   * @defaultValue `'warning'`\n   */\n  logLevel?: 'verbose' | 'info' | 'warning' | 'error' | 'fatal';\n\n  /**\n   * Indicate whether run in debug mode.\n   *\n   * @defaultValue `false`\n   */\n  debug?: boolean;\n\n  /**\n   * set or get a boolean value indicating whether to enable trace.\n   *\n   * @defaultValue `false`\n   */\n  trace?: boolean;\n\n  /**\n   * Get version of the current package.\n   */\n  readonly versions: {\n    readonly common: string;\n    readonly web?: string;\n    readonly node?: string;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    readonly 'react-native'?: string;\n  };\n\n  /**\n   * Represent a set of flags for WebAssembly\n   */\n  readonly wasm: Env.WebAssemblyFlags;\n\n  /**\n   * Represent a set of flags for WebGL\n   */\n  readonly webgl: Env.WebGLFlags;\n\n  /**\n   * Represent a set of flags for WebGPU\n   */\n  readonly webgpu: Env.WebGpuFlags;\n\n  [name: string]: unknown;\n}\n\n/**\n * Represent a set of flags as a global singleton.\n */\nexport const env: Env = envImpl;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { TensorToDataUrlOptions, TensorToImageDataOptions } from './tensor-conversion.js';\nimport { Tensor } from './tensor.js';\n\n/**\n * implementation of Tensor.toDataURL()\n */\nexport const tensorToDataURL = (tensor: Tensor, options?: TensorToDataUrlOptions): string => {\n  const canvas = typeof document !== 'undefined' ? document.createElement('canvas') : new OffscreenCanvas(1, 1);\n  canvas.width = tensor.dims[3];\n  canvas.height = tensor.dims[2];\n  const pixels2DContext = canvas.getContext('2d') as\n    | CanvasRenderingContext2D\n    | OffscreenCanvasRenderingContext2D\n    | null;\n\n  if (pixels2DContext != null) {\n    // Default values for height and width & format\n    let width: number;\n    let height: number;\n    if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {\n      width = tensor.dims[2];\n      height = tensor.dims[3];\n    } else {\n      // Default layout is NCWH\n      width = tensor.dims[3];\n      height = tensor.dims[2];\n    }\n\n    const inputformat = options?.format !== undefined ? options.format : 'RGB';\n\n    const norm = options?.norm;\n    let normMean: [number, number, number, number];\n    let normBias: [number, number, number, number];\n    if (norm === undefined || norm.mean === undefined) {\n      normMean = [255, 255, 255, 255];\n    } else {\n      if (typeof norm.mean === 'number') {\n        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n      } else {\n        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];\n        if (norm.mean[3] !== undefined) {\n          normMean[3] = norm.mean[3];\n        }\n      }\n    }\n    if (norm === undefined || norm.bias === undefined) {\n      normBias = [0, 0, 0, 0];\n    } else {\n      if (typeof norm.bias === 'number') {\n        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n      } else {\n        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];\n        if (norm.bias[3] !== undefined) {\n          normBias[3] = norm.bias[3];\n        }\n      }\n    }\n\n    const stride = height * width;\n    // Default pointer assignments\n    let rTensorPointer = 0,\n      gTensorPointer = stride,\n      bTensorPointer = stride * 2,\n      aTensorPointer = -1;\n\n    // Updating the pointer assignments based on the input image format\n    if (inputformat === 'RGBA') {\n      rTensorPointer = 0;\n      gTensorPointer = stride;\n      bTensorPointer = stride * 2;\n      aTensorPointer = stride * 3;\n    } else if (inputformat === 'RGB') {\n      rTensorPointer = 0;\n      gTensorPointer = stride;\n      bTensorPointer = stride * 2;\n    } else if (inputformat === 'RBG') {\n      rTensorPointer = 0;\n      bTensorPointer = stride;\n      gTensorPointer = stride * 2;\n    }\n\n    for (let i = 0; i < height; i++) {\n      for (let j = 0; j < width; j++) {\n        const R = ((tensor.data[rTensorPointer++] as number) - normBias[0]) * normMean[0]; // R value\n        const G = ((tensor.data[gTensorPointer++] as number) - normBias[1]) * normMean[1]; // G value\n        const B = ((tensor.data[bTensorPointer++] as number) - normBias[2]) * normMean[2]; // B value\n        const A = aTensorPointer === -1 ? 255 : ((tensor.data[aTensorPointer++] as number) - normBias[3]) * normMean[3]; // A value\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        pixels2DContext.fillStyle = 'rgba(' + R + ',' + G + ',' + B + ',' + A + ')';\n        pixels2DContext.fillRect(j, i, 1, 1);\n      }\n    }\n    if ('toDataURL' in canvas) {\n      return canvas.toDataURL();\n    } else {\n      throw new Error('toDataURL is not supported');\n    }\n  } else {\n    throw new Error('Can not access image data');\n  }\n};\n\n/**\n * implementation of Tensor.toImageData()\n */\nexport const tensorToImageData = (tensor: Tensor, options?: TensorToImageDataOptions): ImageData => {\n  const pixels2DContext =\n    typeof document !== 'undefined'\n      ? document.createElement('canvas').getContext('2d')\n      : (new OffscreenCanvas(1, 1).getContext('2d') as OffscreenCanvasRenderingContext2D);\n  let image: ImageData;\n  if (pixels2DContext != null) {\n    // Default values for height and width & format\n    let width: number;\n    let height: number;\n    let channels: number;\n    if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {\n      width = tensor.dims[2];\n      height = tensor.dims[1];\n      channels = tensor.dims[3];\n    } else {\n      // Default layout is NCWH\n      width = tensor.dims[3];\n      height = tensor.dims[2];\n      channels = tensor.dims[1];\n    }\n    const inputformat = options !== undefined ? (options.format !== undefined ? options.format : 'RGB') : 'RGB';\n\n    const norm = options?.norm;\n    let normMean: [number, number, number, number];\n    let normBias: [number, number, number, number];\n    if (norm === undefined || norm.mean === undefined) {\n      normMean = [255, 255, 255, 255];\n    } else {\n      if (typeof norm.mean === 'number') {\n        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n      } else {\n        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];\n        if (norm.mean[3] !== undefined) {\n          normMean[3] = norm.mean[3];\n        }\n      }\n    }\n    if (norm === undefined || norm.bias === undefined) {\n      normBias = [0, 0, 0, 0];\n    } else {\n      if (typeof norm.bias === 'number') {\n        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n      } else {\n        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];\n        if (norm.bias[3] !== undefined) {\n          normBias[3] = norm.bias[3];\n        }\n      }\n    }\n\n    const stride = height * width;\n    if (options !== undefined) {\n      if (\n        (options.format !== undefined && channels === 4 && options.format !== 'RGBA') ||\n        (channels === 3 && options.format !== 'RGB' && options.format !== 'BGR')\n      ) {\n        throw new Error(\"Tensor format doesn't match input tensor dims\");\n      }\n    }\n\n    // Default pointer assignments\n    const step = 4;\n    let rImagePointer = 0,\n      gImagePointer = 1,\n      bImagePointer = 2,\n      aImagePointer = 3;\n    let rTensorPointer = 0,\n      gTensorPointer = stride,\n      bTensorPointer = stride * 2,\n      aTensorPointer = -1;\n\n    // Updating the pointer assignments based on the input image format\n    if (inputformat === 'RGBA') {\n      rTensorPointer = 0;\n      gTensorPointer = stride;\n      bTensorPointer = stride * 2;\n      aTensorPointer = stride * 3;\n    } else if (inputformat === 'RGB') {\n      rTensorPointer = 0;\n      gTensorPointer = stride;\n      bTensorPointer = stride * 2;\n    } else if (inputformat === 'RBG') {\n      rTensorPointer = 0;\n      bTensorPointer = stride;\n      gTensorPointer = stride * 2;\n    }\n\n    image = pixels2DContext.createImageData(width, height);\n\n    for (\n      let i = 0;\n      i < height * width;\n      rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++\n    ) {\n      image.data[rImagePointer] = ((tensor.data[rTensorPointer++] as number) - normBias[0]) * normMean[0]; // R value\n      image.data[gImagePointer] = ((tensor.data[gTensorPointer++] as number) - normBias[1]) * normMean[1]; // G value\n      image.data[bImagePointer] = ((tensor.data[bTensorPointer++] as number) - normBias[2]) * normMean[2]; // B value\n      image.data[aImagePointer] =\n        aTensorPointer === -1 ? 255 : ((tensor.data[aTensorPointer++] as number) - normBias[3]) * normMean[3]; // A value\n    }\n  } else {\n    throw new Error('Can not access image data');\n  }\n  return image;\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {\n  OptionsDimensions,\n  OptionsFormat,\n  OptionsNormalizationParameters,\n  OptionsTensorFormat,\n  OptionsTensorLayout,\n  TensorFromGpuBufferOptions,\n  TensorFromImageBitmapOptions,\n  TensorFromImageDataOptions,\n  TensorFromImageElementOptions,\n  TensorFromMLTensorOptions,\n  TensorFromTextureOptions,\n  TensorFromUrlOptions,\n} from './tensor-factory.js';\nimport { Tensor } from './tensor-impl.js';\nimport { Tensor as TensorInterface } from './tensor.js';\n\ninterface BufferToTensorOptions\n  extends OptionsDimensions,\n    OptionsTensorLayout,\n    OptionsNormalizationParameters,\n    OptionsFormat,\n    OptionsTensorFormat {}\n\n/**\n * Create a new tensor object from image object\n *\n * @param buffer - Extracted image buffer data - assuming RGBA format\n * @param imageFormat - input image configuration - required configurations height, width, format\n * @param tensorFormat - output tensor configuration - Default is RGB format\n */\nexport const bufferToTensor = (buffer: Uint8ClampedArray | undefined, options: BufferToTensorOptions): Tensor => {\n  if (buffer === undefined) {\n    throw new Error('Image buffer must be defined');\n  }\n  if (options.height === undefined || options.width === undefined) {\n    throw new Error('Image height and width must be defined');\n  }\n  if (options.tensorLayout === 'NHWC') {\n    throw new Error('NHWC Tensor layout is not supported yet');\n  }\n\n  const { height, width } = options;\n\n  const norm = options.norm ?? { mean: 255, bias: 0 };\n  let normMean: [number, number, number, number];\n  let normBias: [number, number, number, number];\n\n  if (typeof norm.mean === 'number') {\n    normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n  } else {\n    normMean = [norm.mean![0], norm.mean![1], norm.mean![2], norm.mean![3] ?? 255];\n  }\n\n  if (typeof norm.bias === 'number') {\n    normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n  } else {\n    normBias = [norm.bias![0], norm.bias![1], norm.bias![2], norm.bias![3] ?? 0];\n  }\n\n  const inputformat = options.format !== undefined ? options.format : 'RGBA';\n  // default value is RGBA since imagedata and HTMLImageElement uses it\n\n  const outputformat =\n    options.tensorFormat !== undefined ? (options.tensorFormat !== undefined ? options.tensorFormat : 'RGB') : 'RGB';\n  const stride = height * width;\n  const float32Data = outputformat === 'RGBA' ? new Float32Array(stride * 4) : new Float32Array(stride * 3);\n\n  // Default pointer assignments\n  let step = 4,\n    rImagePointer = 0,\n    gImagePointer = 1,\n    bImagePointer = 2,\n    aImagePointer = 3;\n  let rTensorPointer = 0,\n    gTensorPointer = stride,\n    bTensorPointer = stride * 2,\n    aTensorPointer = -1;\n\n  // Updating the pointer assignments based on the input image format\n  if (inputformat === 'RGB') {\n    step = 3;\n    rImagePointer = 0;\n    gImagePointer = 1;\n    bImagePointer = 2;\n    aImagePointer = -1;\n  }\n\n  // Updating the pointer assignments based on the output tensor format\n  if (outputformat === 'RGBA') {\n    aTensorPointer = stride * 3;\n  } else if (outputformat === 'RBG') {\n    rTensorPointer = 0;\n    bTensorPointer = stride;\n    gTensorPointer = stride * 2;\n  } else if (outputformat === 'BGR') {\n    bTensorPointer = 0;\n    gTensorPointer = stride;\n    rTensorPointer = stride * 2;\n  }\n\n  for (\n    let i = 0;\n    i < stride;\n    i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step\n  ) {\n    float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];\n    float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];\n    float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];\n    if (aTensorPointer !== -1 && aImagePointer !== -1) {\n      float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];\n    }\n  }\n\n  // Float32Array -> ort.Tensor\n  const outputTensor =\n    outputformat === 'RGBA'\n      ? new Tensor('float32', float32Data, [1, 4, height, width])\n      : new Tensor('float32', float32Data, [1, 3, height, width]);\n  return outputTensor;\n};\n\n/**\n * implementation of Tensor.fromImage().\n */\nexport const tensorFromImage = async (\n  image: ImageData | HTMLImageElement | ImageBitmap | string,\n  options?:\n    | TensorFromImageDataOptions\n    | TensorFromImageElementOptions\n    | TensorFromImageBitmapOptions\n    | TensorFromUrlOptions,\n): Promise<Tensor> => {\n  // checking the type of image object\n  const isHTMLImageEle = typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement;\n  const isImageDataEle = typeof ImageData !== 'undefined' && image instanceof ImageData;\n  const isImageBitmap = typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap;\n  const isString = typeof image === 'string';\n\n  let data: Uint8ClampedArray | undefined;\n  let bufferToTensorOptions: BufferToTensorOptions = options ?? {};\n\n  const createCanvas = () => {\n    if (typeof document !== 'undefined') {\n      return document.createElement('canvas');\n    } else if (typeof OffscreenCanvas !== 'undefined') {\n      return new OffscreenCanvas(1, 1);\n    } else {\n      throw new Error('Canvas is not supported');\n    }\n  };\n  const createCanvasContext = (canvas: HTMLCanvasElement | OffscreenCanvas) => {\n    if (typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement) {\n      return canvas.getContext('2d');\n    } else if (canvas instanceof OffscreenCanvas) {\n      return canvas.getContext('2d') as OffscreenCanvasRenderingContext2D;\n    } else {\n      return null;\n    }\n  };\n  // filling and checking image configuration options\n  if (isHTMLImageEle) {\n    // HTMLImageElement - image object - format is RGBA by default\n    const canvas = createCanvas();\n    canvas.width = image.width;\n    canvas.height = image.height;\n    const pixels2DContext = createCanvasContext(canvas);\n\n    if (pixels2DContext != null) {\n      let height = image.height;\n      let width = image.width;\n      if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {\n        height = options.resizedHeight;\n        width = options.resizedWidth;\n      }\n\n      if (options !== undefined) {\n        bufferToTensorOptions = options;\n        if (options.tensorFormat !== undefined) {\n          throw new Error('Image input config format must be RGBA for HTMLImageElement');\n        } else {\n          bufferToTensorOptions.tensorFormat = 'RGBA';\n        }\n        bufferToTensorOptions.height = height;\n        bufferToTensorOptions.width = width;\n      } else {\n        bufferToTensorOptions.tensorFormat = 'RGBA';\n        bufferToTensorOptions.height = height;\n        bufferToTensorOptions.width = width;\n      }\n\n      pixels2DContext.drawImage(image, 0, 0);\n      data = pixels2DContext.getImageData(0, 0, width, height).data;\n    } else {\n      throw new Error('Can not access image data');\n    }\n  } else if (isImageDataEle) {\n    let height: number;\n    let width: number;\n\n    if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {\n      height = options.resizedHeight;\n      width = options.resizedWidth;\n    } else {\n      height = image.height;\n      width = image.width;\n    }\n\n    if (options !== undefined) {\n      bufferToTensorOptions = options;\n    }\n    bufferToTensorOptions.format = 'RGBA';\n    bufferToTensorOptions.height = height;\n    bufferToTensorOptions.width = width;\n\n    if (options !== undefined) {\n      const tempCanvas = createCanvas();\n\n      tempCanvas.width = width;\n      tempCanvas.height = height;\n\n      const pixels2DContext = createCanvasContext(tempCanvas);\n\n      if (pixels2DContext != null) {\n        pixels2DContext.putImageData(image, 0, 0);\n        data = pixels2DContext.getImageData(0, 0, width, height).data;\n      } else {\n        throw new Error('Can not access image data');\n      }\n    } else {\n      data = image.data;\n    }\n  } else if (isImageBitmap) {\n    // ImageBitmap - image object - format must be provided by user\n    if (options === undefined) {\n      throw new Error('Please provide image config with format for Imagebitmap');\n    }\n\n    const canvas = createCanvas();\n    canvas.width = image.width;\n    canvas.height = image.height;\n    const pixels2DContext = createCanvasContext(canvas);\n\n    if (pixels2DContext != null) {\n      const height = image.height;\n      const width = image.width;\n      pixels2DContext.drawImage(image, 0, 0, width, height);\n      data = pixels2DContext.getImageData(0, 0, width, height).data;\n      bufferToTensorOptions.height = height;\n      bufferToTensorOptions.width = width;\n      return bufferToTensor(data, bufferToTensorOptions);\n    } else {\n      throw new Error('Can not access image data');\n    }\n  } else if (isString) {\n    return new Promise((resolve, reject) => {\n      const canvas = createCanvas();\n      const context = createCanvasContext(canvas);\n      if (!image || !context) {\n        return reject();\n      }\n      const newImage = new Image();\n      newImage.crossOrigin = 'Anonymous';\n      newImage.src = image;\n      newImage.onload = () => {\n        canvas.width = newImage.width;\n        canvas.height = newImage.height;\n        context.drawImage(newImage, 0, 0, canvas.width, canvas.height);\n        const img = context.getImageData(0, 0, canvas.width, canvas.height);\n\n        bufferToTensorOptions.height = canvas.height;\n        bufferToTensorOptions.width = canvas.width;\n        resolve(bufferToTensor(img.data, bufferToTensorOptions));\n      };\n    });\n  } else {\n    throw new Error('Input data provided is not supported - aborted tensor creation');\n  }\n\n  if (data !== undefined) {\n    return bufferToTensor(data, bufferToTensorOptions);\n  } else {\n    throw new Error('Input data provided is not supported - aborted tensor creation');\n  }\n};\n\n/**\n * implementation of Tensor.fromTexture().\n */\nexport const tensorFromTexture = <T extends TensorInterface.TextureDataTypes>(\n  texture: TensorInterface.TextureType,\n  options: TensorFromTextureOptions<T>,\n): Tensor => {\n  const { width, height, download, dispose } = options;\n  // Always assume RGBAF32. TODO: support different texture format\n  const dims = [1, height, width, 4];\n  return new Tensor({ location: 'texture', type: 'float32', texture, dims, download, dispose });\n};\n\n/**\n * implementation of Tensor.fromGpuBuffer().\n */\nexport const tensorFromGpuBuffer = <T extends TensorInterface.GpuBufferDataTypes>(\n  gpuBuffer: TensorInterface.GpuBufferType,\n  options: TensorFromGpuBufferOptions<T>,\n): Tensor => {\n  const { dataType, dims, download, dispose } = options;\n  return new Tensor({ location: 'gpu-buffer', type: dataType ?? 'float32', gpuBuffer, dims, download, dispose });\n};\n\n/**\n * implementation of Tensor.fromMLTensor().\n */\nexport const tensorFromMLTensor = <T extends TensorInterface.MLTensorDataTypes>(\n  mlTensor: TensorInterface.MLTensorType,\n  options: TensorFromMLTensorOptions<T>,\n): Tensor => {\n  const { dataType, dims, download, dispose } = options;\n  return new Tensor({ location: 'ml-tensor', type: dataType ?? 'float32', mlTensor, dims, download, dispose });\n};\n\n/**\n * implementation of Tensor.fromPinnedBuffer().\n */\nexport const tensorFromPinnedBuffer = <T extends TensorInterface.CpuPinnedDataTypes>(\n  type: T,\n  buffer: TensorInterface.DataTypeMap[T],\n  dims?: readonly number[],\n): Tensor => new Tensor({ location: 'cpu-pinned', type, data: buffer, dims: dims ?? [buffer.length] });\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from './tensor.js';\n\nexport type SupportedTypedArrayConstructors =\n  | Float32ArrayConstructor\n  | Uint8ArrayConstructor\n  | Int8ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int16ArrayConstructor\n  | Int32ArrayConstructor\n  | BigInt64ArrayConstructor\n  | Uint8ArrayConstructor\n  | Float64ArrayConstructor\n  | Uint32ArrayConstructor\n  | BigUint64ArrayConstructor;\nexport type SupportedTypedArray = InstanceType<SupportedTypedArrayConstructors>;\n\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nexport const NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map<string, SupportedTypedArrayConstructors>([\n  ['float32', Float32Array],\n  ['uint8', Uint8Array],\n  ['int8', Int8Array],\n  ['uint16', Uint16Array],\n  ['int16', Int16Array],\n  ['int32', Int32Array],\n  ['bool', Uint8Array],\n  ['float64', Float64Array],\n  ['uint32', Uint32Array],\n  ['int4', Uint8Array],\n  ['uint4', Uint8Array],\n]);\n\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nexport const NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map<SupportedTypedArrayConstructors, Tensor.Type>([\n  [Float32Array, 'float32'],\n  [Uint8Array, 'uint8'],\n  [Int8Array, 'int8'],\n  [Uint16Array, 'uint16'],\n  [Int16Array, 'int16'],\n  [Int32Array, 'int32'],\n  [Float64Array, 'float64'],\n  [Uint32Array, 'uint32'],\n]);\n\n// a dummy type declaration for Float16Array in case any polyfill is available.\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-explicit-any\n  const Float16Array: any;\n}\n\n// the following code allows delaying execution of BigInt/Float16Array checking. This allows lazy initialization for\n// NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP and NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, which allows BigInt/Float16Array\n// polyfill if available.\nlet isTypedArrayChecked = false;\nexport const checkTypedArray = () => {\n  if (!isTypedArrayChecked) {\n    isTypedArrayChecked = true;\n    const isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && BigInt64Array.from;\n    const isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && BigUint64Array.from;\n    const isFloat16ArrayAvailable = typeof Float16Array !== 'undefined' && Float16Array.from;\n\n    if (isBigInt64ArrayAvailable) {\n      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);\n      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');\n    }\n    if (isBigUint64ArrayAvailable) {\n      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);\n      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');\n    }\n    if (isFloat16ArrayAvailable) {\n      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('float16', Float16Array);\n      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array, 'float16');\n    } else {\n      // if Float16Array is not available, use 'Uint16Array' to store the data.\n      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('float16', Uint16Array);\n    }\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {\n  CpuPinnedConstructorParameters,\n  GpuBufferConstructorParameters,\n  MLTensorConstructorParameters,\n  TextureConstructorParameters,\n} from './tensor-factory.js';\nimport { Tensor } from './tensor-impl.js';\n\n/**\n * calculate size from dims.\n *\n * @param dims the dims array. May be an illegal input.\n */\nexport const calculateSize = (dims: readonly unknown[]): number => {\n  let size = 1;\n  for (let i = 0; i < dims.length; i++) {\n    const dim = dims[i];\n    if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {\n      throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);\n    }\n    if (dim < 0) {\n      throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);\n    }\n    size *= dim;\n  }\n  return size;\n};\n\n/**\n * implementation of Tensor.reshape()\n */\nexport const tensorReshape = (tensor: Tensor, dims: readonly number[]): Tensor => {\n  switch (tensor.location) {\n    case 'cpu':\n      return new Tensor(tensor.type, tensor.data, dims);\n    case 'cpu-pinned':\n      return new Tensor({\n        location: 'cpu-pinned',\n        data: tensor.data as CpuPinnedConstructorParameters['data'],\n        type: tensor.type as CpuPinnedConstructorParameters['type'],\n        dims,\n      });\n    case 'texture':\n      return new Tensor({\n        location: 'texture',\n        texture: tensor.texture,\n        type: tensor.type as TextureConstructorParameters['type'],\n        dims,\n      });\n    case 'gpu-buffer':\n      return new Tensor({\n        location: 'gpu-buffer',\n        gpuBuffer: tensor.gpuBuffer,\n        type: tensor.type as GpuBufferConstructorParameters['type'],\n        dims,\n      });\n    case 'ml-tensor':\n      return new Tensor({\n        location: 'ml-tensor',\n        mlTensor: tensor.mlTensor,\n        type: tensor.type as MLTensorConstructorParameters['type'],\n        dims,\n      });\n    default:\n      throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { tensorToDataURL, tensorToImageData } from './tensor-conversion-impl.js';\nimport { TensorToDataUrlOptions, TensorToImageDataOptions } from './tensor-conversion.js';\nimport {\n  tensorFromGpuBuffer,\n  tensorFromImage,\n  tensorFromMLTensor,\n  tensorFromPinnedBuffer,\n  tensorFromTexture,\n} from './tensor-factory-impl.js';\nimport {\n  CpuPinnedConstructorParameters,\n  GpuBufferConstructorParameters,\n  MLTensorConstructorParameters,\n  TensorFromGpuBufferOptions,\n  TensorFromImageBitmapOptions,\n  TensorFromImageDataOptions,\n  TensorFromImageElementOptions,\n  TensorFromMLTensorOptions,\n  TensorFromTextureOptions,\n  TensorFromUrlOptions,\n  TextureConstructorParameters,\n} from './tensor-factory.js';\nimport {\n  checkTypedArray,\n  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP,\n  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP,\n  SupportedTypedArray,\n  SupportedTypedArrayConstructors,\n} from './tensor-impl-type-mapping.js';\nimport { calculateSize, tensorReshape } from './tensor-utils-impl.js';\nimport { Tensor as TensorInterface } from './tensor.js';\n\n// type aliases for those exported from Tensor interface\n\ntype TensorType = TensorInterface.Type;\ntype TensorDataType = TensorInterface.DataType;\ntype TensorDataLocation = TensorInterface.DataLocation;\ntype TensorTextureType = TensorInterface.TextureType;\ntype TensorGpuBufferType = TensorInterface.GpuBufferType;\ntype TensorMLTensorType = TensorInterface.MLTensorType;\n\n/**\n * the implementation of Tensor interface.\n *\n * @ignore\n */\nexport class Tensor implements TensorInterface {\n  // #region constructors\n\n  /**\n   * Construct a new CPU tensor object from the given type, data and dims.\n   */\n  constructor(\n    type: TensorType,\n    data: TensorDataType | Uint8ClampedArray | readonly string[] | readonly number[] | readonly boolean[],\n    dims?: readonly number[],\n  );\n  /**\n   * Construct a new CPU tensor object from the given data and dims. Type is inferred from data.\n   */\n  constructor(\n    data: TensorDataType | Uint8ClampedArray | readonly string[] | readonly boolean[],\n    dims?: readonly number[],\n  );\n  /**\n   * Construct a new tensor object from the pinned CPU data with the given type and dims.\n   *\n   * Tensor's location will be set to 'cpu-pinned'.\n   *\n   * @param params - Specify the parameters to construct the tensor.\n   */\n  constructor(params: CpuPinnedConstructorParameters);\n  /**\n   * Construct a new tensor object from the WebGL texture with the given type and dims.\n   *\n   * Tensor's location will be set to 'texture'.\n   *\n   * @param params - Specify the parameters to construct the tensor.\n   */\n  constructor(params: TextureConstructorParameters);\n  /**\n   * Construct a new tensor object from the WebGPU buffer with the given type and dims.\n   *\n   * Tensor's location will be set to 'gpu-buffer'.\n   *\n   * @param params - Specify the parameters to construct the tensor.\n   */\n  constructor(params: GpuBufferConstructorParameters);\n\n  /**\n   * Construct a new tensor object from the WebNN MLTensor with the given type and dims.\n   *\n   * Tensor's location will be set to 'ml-tensor'.\n   *\n   * @param params - Specify the parameters to construct the tensor.\n   */\n  constructor(params: MLTensorConstructorParameters);\n\n  /**\n   * implementation.\n   */\n  constructor(\n    arg0:\n      | TensorType\n      | TensorDataType\n      | Uint8ClampedArray\n      | readonly string[]\n      | readonly boolean[]\n      | CpuPinnedConstructorParameters\n      | TextureConstructorParameters\n      | GpuBufferConstructorParameters\n      | MLTensorConstructorParameters,\n    arg1?: TensorDataType | Uint8ClampedArray | readonly number[] | readonly string[] | readonly boolean[],\n    arg2?: readonly number[],\n  ) {\n    // perform one-time check for BigInt/Float16Array support\n    checkTypedArray();\n\n    let type: TensorType;\n    let dims: readonly number[];\n\n    if (typeof arg0 === 'object' && 'location' in arg0) {\n      //\n      // constructing tensor from specific location\n      //\n      this.dataLocation = arg0.location;\n      type = arg0.type;\n      dims = arg0.dims;\n      switch (arg0.location) {\n        case 'cpu-pinned': {\n          const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);\n          if (!expectedTypedArrayConstructor) {\n            throw new TypeError(`unsupported type \"${type}\" to create tensor from pinned buffer`);\n          }\n          if (!(arg0.data instanceof expectedTypedArrayConstructor)) {\n            throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);\n          }\n          this.cpuData = arg0.data;\n          break;\n        }\n        case 'texture': {\n          if (type !== 'float32') {\n            throw new TypeError(`unsupported type \"${type}\" to create tensor from texture`);\n          }\n          this.gpuTextureData = arg0.texture;\n          this.downloader = arg0.download;\n          this.disposer = arg0.dispose;\n          break;\n        }\n        case 'gpu-buffer': {\n          if (\n            type !== 'float32' &&\n            type !== 'float16' &&\n            type !== 'int32' &&\n            type !== 'int64' &&\n            type !== 'uint32' &&\n            type !== 'uint8' &&\n            type !== 'bool' &&\n            type !== 'uint4' &&\n            type !== 'int4'\n          ) {\n            throw new TypeError(`unsupported type \"${type}\" to create tensor from gpu buffer`);\n          }\n          this.gpuBufferData = arg0.gpuBuffer;\n          this.downloader = arg0.download;\n          this.disposer = arg0.dispose;\n          break;\n        }\n        case 'ml-tensor': {\n          if (\n            type !== 'float32' &&\n            type !== 'float16' &&\n            type !== 'int32' &&\n            type !== 'int64' &&\n            type !== 'uint32' &&\n            type !== 'uint64' &&\n            type !== 'int8' &&\n            type !== 'uint8' &&\n            type !== 'bool'\n          ) {\n            throw new TypeError(`unsupported type \"${type}\" to create tensor from MLTensor`);\n          }\n          this.mlTensorData = arg0.mlTensor;\n          this.downloader = arg0.download;\n          this.disposer = arg0.dispose;\n          break;\n        }\n        default:\n          throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);\n      }\n    } else {\n      //\n      // constructing tensor of location 'cpu'\n      //\n      let data: TensorDataType;\n      let maybeDims: typeof arg1 | typeof arg2;\n      // check whether arg0 is type or data\n      if (typeof arg0 === 'string') {\n        //\n        // Override: constructor(type, data, ...)\n        //\n        type = arg0;\n        maybeDims = arg2;\n        if (arg0 === 'string') {\n          // string tensor\n          if (!Array.isArray(arg1)) {\n            throw new TypeError(\"A string tensor's data must be a string array.\");\n          }\n          // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\n          // error will be populated at inference\n          data = arg1;\n        } else {\n          // numeric tensor\n          const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\n          if (typedArrayConstructor === undefined) {\n            throw new TypeError(`Unsupported tensor type: ${arg0}.`);\n          }\n          if (Array.isArray(arg1)) {\n            if ((arg0 === 'float16' && typedArrayConstructor === Uint16Array) || arg0 === 'uint4' || arg0 === 'int4') {\n              // - 'float16':\n              //   When no Float16Array polyfill is used, we cannot create 'float16' tensor from number array.\n              //\n              //   Throw error here because when user try to use number array as data,\n              //   e.g. new Tensor('float16', [1, 2, 3, 4], dims)), it will actually call\n              //   Uint16Array.from(arg1) which generates wrong data.\n              //\n              // - 'uint4' and 'int4':\n              //   Uint8Array.from(arg1) will generate wrong data for 'uint4' and 'int4' tensor.\n              //\n              throw new TypeError(\n                `Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`,\n              );\n            } else if (arg0 === 'uint64' || arg0 === 'int64') {\n              // use 'as any' here because:\n              // 1. TypeScript's check on type of 'Array.isArray()' does not work with readonly arrays.\n              // see https://github.com/microsoft/TypeScript/issues/17002\n              // 2. TypeScript's check on union type of '(BigInt64ArrayConstructor|BigUint64ArrayConstructor).from()'\n              // does not accept parameter mapFn.\n              // 3. parameters of 'SupportedTypedArrayConstructors.from()' does not match the requirement of the union\n              // type.\n\n              // assume 'arg1' is of type \"readonly number[]|readonly bigint[]\" here.\n\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              data = (typedArrayConstructor as any).from(arg1, BigInt);\n            } else {\n              // assume 'arg1' is of type \"readonly number[]\" here.\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              data = (typedArrayConstructor as any).from(arg1);\n            }\n          } else if (arg1 instanceof typedArrayConstructor) {\n            data = arg1;\n          } else if (arg1 instanceof Uint8ClampedArray) {\n            if (arg0 === 'uint8') {\n              data = Uint8Array.from(arg1);\n            } else {\n              throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);\n            }\n          } else {\n            throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);\n          }\n        }\n      } else {\n        //\n        // Override: constructor(data, ...)\n        //\n        maybeDims = arg1;\n        if (Array.isArray(arg0)) {\n          // only boolean[] and string[] is supported\n          if (arg0.length === 0) {\n            throw new TypeError('Tensor type cannot be inferred from an empty array.');\n          }\n          const firstElementType = typeof arg0[0];\n          if (firstElementType === 'string') {\n            type = 'string';\n            data = arg0;\n          } else if (firstElementType === 'boolean') {\n            type = 'bool';\n            // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\n            // wrong type. We use 'as any' to make it happy.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            data = Uint8Array.from(arg0 as any[]);\n          } else {\n            throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);\n          }\n        } else if (arg0 instanceof Uint8ClampedArray) {\n          type = 'uint8';\n          data = Uint8Array.from(arg0);\n        } else {\n          // get tensor type from TypedArray\n          const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(\n            arg0.constructor as SupportedTypedArrayConstructors,\n          );\n          if (mappedType === undefined) {\n            throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);\n          }\n          type = mappedType;\n          data = arg0 as SupportedTypedArray;\n        }\n      }\n\n      // type and data is processed, now processing dims\n      if (maybeDims === undefined) {\n        // assume 1-D tensor if dims omitted\n        maybeDims = [data.length];\n      } else if (!Array.isArray(maybeDims)) {\n        throw new TypeError(\"A tensor's dims must be a number array\");\n      }\n      dims = maybeDims as readonly number[];\n\n      this.cpuData = data;\n      this.dataLocation = 'cpu';\n    }\n\n    // perform check on dims\n    const size = calculateSize(dims);\n    // if data is on CPU, check whether data length matches tensor size\n    if (this.cpuData && size !== this.cpuData.length) {\n      if ((type === 'uint4' || type === 'int4') && Math.ceil(size / 2) === this.cpuData.length) {\n        // for (u)int4, the data length is half of the tensor size. So we check this special case when size is odd.\n      } else {\n        throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);\n      }\n    }\n\n    this.type = type;\n    this.dims = dims;\n    this.size = size;\n  }\n  // #endregion\n\n  // #region factory\n  static async fromImage(\n    image: ImageData | HTMLImageElement | ImageBitmap | string,\n    options?:\n      | TensorFromImageDataOptions\n      | TensorFromImageElementOptions\n      | TensorFromImageBitmapOptions\n      | TensorFromUrlOptions,\n  ): Promise<TensorInterface> {\n    return tensorFromImage(image, options);\n  }\n\n  static fromTexture<T extends TensorInterface.TextureDataTypes>(\n    texture: TensorTextureType,\n    options: TensorFromTextureOptions<T>,\n  ): TensorInterface {\n    return tensorFromTexture(texture, options);\n  }\n\n  static fromGpuBuffer<T extends TensorInterface.GpuBufferDataTypes>(\n    gpuBuffer: TensorGpuBufferType,\n    options: TensorFromGpuBufferOptions<T>,\n  ): TensorInterface {\n    return tensorFromGpuBuffer(gpuBuffer, options);\n  }\n\n  static fromMLTensor<T extends TensorInterface.MLTensorDataTypes>(\n    mlTensor: TensorMLTensorType,\n    options: TensorFromMLTensorOptions<T>,\n  ): TensorInterface {\n    return tensorFromMLTensor(mlTensor, options);\n  }\n\n  static fromPinnedBuffer<T extends TensorInterface.CpuPinnedDataTypes>(\n    type: T,\n    buffer: TensorInterface.DataTypeMap[T],\n    dims?: readonly number[],\n  ): Tensor {\n    return tensorFromPinnedBuffer(type, buffer, dims);\n  }\n\n  // #endregion\n\n  // #region conversions\n  toDataURL(options?: TensorToDataUrlOptions): string {\n    return tensorToDataURL(this, options);\n  }\n\n  toImageData(options?: TensorToImageDataOptions): ImageData {\n    return tensorToImageData(this, options);\n  }\n  // #endregion\n\n  // #region public fields\n  readonly dims: readonly number[];\n  readonly type: TensorType;\n  readonly size: number;\n  // #endregion\n\n  // #region private fields\n\n  /**\n   * stores the location of the data.\n   */\n  private dataLocation: TensorDataLocation;\n\n  /**\n   * stores the data on CPU, if location is 'cpu' or 'cpu-pinned'. otherwise empty.\n   */\n  private cpuData?: TensorDataType;\n\n  /**\n   * stores the underlying texture when location is 'texture'. otherwise empty.\n   */\n  private gpuTextureData?: TensorTextureType;\n\n  /**\n   * stores the underlying GPU buffer when location is 'gpu-buffer'. otherwise empty.\n   */\n  private gpuBufferData?: TensorGpuBufferType;\n\n  /**\n   * stores the underlying WebNN MLTensor when location is 'ml-tensor'. otherwise empty.\n   */\n  private mlTensorData?: TensorMLTensorType;\n\n  /**\n   * stores an optional downloader function to download data from GPU to CPU.\n   */\n  private downloader?(): Promise<TensorDataType>;\n\n  /**\n   * a flag indicating whether the data is being downloaded from GPU to CPU.\n   */\n  private isDownloading?: boolean;\n\n  /**\n   * stores an optional disposer function to dispose the underlying data.\n   */\n  private disposer?(): void;\n  // #endregion\n\n  // #region properties\n  get data(): TensorDataType {\n    this.ensureValid();\n    if (!this.cpuData) {\n      throw new Error(\n        'The data is not on CPU. Use `getData()` to download GPU data to CPU, ' +\n          'or use `texture` or `gpuBuffer` property to access the GPU data directly.',\n      );\n    }\n    return this.cpuData;\n  }\n\n  get location(): TensorDataLocation {\n    return this.dataLocation;\n  }\n\n  get texture(): TensorTextureType {\n    this.ensureValid();\n    if (!this.gpuTextureData) {\n      throw new Error('The data is not stored as a WebGL texture.');\n    }\n    return this.gpuTextureData;\n  }\n\n  get gpuBuffer(): TensorGpuBufferType {\n    this.ensureValid();\n    if (!this.gpuBufferData) {\n      throw new Error('The data is not stored as a WebGPU buffer.');\n    }\n    return this.gpuBufferData;\n  }\n\n  get mlTensor(): TensorMLTensorType {\n    this.ensureValid();\n    if (!this.mlTensorData) {\n      throw new Error('The data is not stored as a WebNN MLTensor.');\n    }\n    return this.mlTensorData;\n  }\n  // #endregion\n\n  // #region methods\n\n  async getData(releaseData?: boolean): Promise<TensorDataType> {\n    this.ensureValid();\n    switch (this.dataLocation) {\n      case 'cpu':\n      case 'cpu-pinned':\n        return this.data;\n      case 'texture':\n      case 'gpu-buffer':\n      case 'ml-tensor': {\n        if (!this.downloader) {\n          throw new Error('The current tensor is not created with a specified data downloader.');\n        }\n        if (this.isDownloading) {\n          throw new Error('The current tensor is being downloaded.');\n        }\n        try {\n          this.isDownloading = true;\n          const data = await this.downloader();\n          this.downloader = undefined;\n          this.dataLocation = 'cpu';\n          this.cpuData = data;\n\n          if (releaseData && this.disposer) {\n            this.disposer();\n            this.disposer = undefined;\n          }\n\n          return data;\n        } finally {\n          this.isDownloading = false;\n        }\n      }\n      default:\n        throw new Error(`cannot get data from location: ${this.dataLocation}`);\n    }\n  }\n\n  dispose(): void {\n    if (this.isDownloading) {\n      throw new Error('The current tensor is being downloaded.');\n    }\n\n    if (this.disposer) {\n      this.disposer();\n      this.disposer = undefined;\n    }\n    this.cpuData = undefined;\n    this.gpuTextureData = undefined;\n    this.gpuBufferData = undefined;\n    this.mlTensorData = undefined;\n    this.downloader = undefined;\n    this.isDownloading = undefined;\n\n    this.dataLocation = 'none';\n  }\n\n  // #endregion\n\n  // #region tensor utilities\n  private ensureValid(): void {\n    if (this.dataLocation === 'none') {\n      throw new Error('The tensor is disposed.');\n    }\n  }\n\n  reshape(dims: readonly number[]): TensorInterface {\n    this.ensureValid();\n    if (this.downloader || this.disposer) {\n      throw new Error('Cannot reshape a tensor that owns GPU resource.');\n    }\n    return tensorReshape(this, dims);\n  }\n  // #endregion\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { TensorFactory } from './tensor-factory.js';\nimport { Tensor as TensorImpl } from './tensor-impl.js';\nimport { TypedTensorUtils } from './tensor-utils.js';\n\n/* eslint-disable @typescript-eslint/no-redeclare */\n\n/**\n * represent a basic tensor with specified dimensions and data type.\n */\ninterface TypedTensorBase<T extends Tensor.Type> {\n  /**\n   * Get the dimensions of the tensor.\n   */\n  readonly dims: readonly number[];\n  /**\n   * Get the data type of the tensor.\n   */\n  readonly type: T;\n  /**\n   * Get the buffer data of the tensor.\n   *\n   * If the data is not on CPU (eg. it's in the form of WebGL texture or WebGPU buffer), throw error.\n   */\n  readonly data: Tensor.DataTypeMap[T];\n  /**\n   * Get the location of the data.\n   */\n  readonly location: Tensor.DataLocation;\n  /**\n   * Get the WebGL texture that holds the tensor data.\n   *\n   * If the data is not on GPU as WebGL texture, throw error.\n   */\n  readonly texture: Tensor.TextureType;\n  /**\n   * Get the WebGPU buffer that holds the tensor data.\n   *\n   * If the data is not on GPU as WebGPU buffer, throw error.\n   */\n  readonly gpuBuffer: Tensor.GpuBufferType;\n\n  /**\n   * Get the WebNN MLTensor that holds the tensor data.\n   *\n   * If the data is not in a WebNN MLTensor, throw error.\n   */\n  readonly mlTensor: Tensor.MLTensorType;\n\n  /**\n   * Get the buffer data of the tensor.\n   *\n   * If the data is on CPU, returns the data immediately.\n   * If the data is on GPU, downloads the data and returns the promise.\n   *\n   * @param releaseData - whether release the data on GPU. Ignore if data is already on CPU.\n   */\n  getData(releaseData?: boolean): Promise<Tensor.DataTypeMap[T]>;\n\n  /**\n   * Dispose the tensor data.\n   *\n   * If the data is on CPU, remove its internal reference to the underlying data.\n   * If the data is on GPU, release the data on GPU.\n   *\n   * After calling this function, the tensor is considered no longer valid. Its location will be set to 'none'.\n   */\n  dispose(): void;\n}\n\nexport declare namespace Tensor {\n  interface DataTypeMap {\n    float32: Float32Array;\n    uint8: Uint8Array;\n    int8: Int8Array;\n    uint16: Uint16Array;\n    int16: Int16Array;\n    int32: Int32Array;\n    int64: BigInt64Array;\n    string: string[];\n    bool: Uint8Array;\n    float16: Uint16Array; // Keep using Uint16Array until we have a concrete solution for float 16.\n    float64: Float64Array;\n    uint32: Uint32Array;\n    uint64: BigUint64Array;\n    // complex64: never;\n    // complex128: never;\n    // bfloat16: never;\n    uint4: Uint8Array;\n    int4: Int8Array;\n  }\n\n  interface ElementTypeMap {\n    float32: number;\n    uint8: number;\n    int8: number;\n    uint16: number;\n    int16: number;\n    int32: number;\n    int64: bigint;\n    string: string;\n    bool: boolean;\n    float16: number; // Keep using Uint16Array until we have a concrete solution for float 16.\n    float64: number;\n    uint32: number;\n    uint64: bigint;\n    // complex64: never;\n    // complex128: never;\n    // bfloat16: never;\n    uint4: number;\n    int4: number;\n  }\n\n  type DataType = DataTypeMap[Type];\n  type ElementType = ElementTypeMap[Type];\n\n  /**\n   * supported data types for constructing a tensor from a pinned CPU buffer\n   */\n  export type CpuPinnedDataTypes = Exclude<Tensor.Type, 'string'>;\n\n  /**\n   * type alias for WebGL texture\n   */\n  export type TextureType = WebGLTexture;\n\n  /**\n   * supported data types for constructing a tensor from a WebGL texture\n   */\n  export type TextureDataTypes = 'float32';\n\n  /**\n   * type alias for WebGPU buffer\n   *\n   * The reason why we don't use type \"GPUBuffer\" defined in webgpu.d.ts from @webgpu/types is because \"@webgpu/types\"\n   * requires \"@types/dom-webcodecs\" as peer dependency when using TypeScript < v5.1 and its version need to be chosen\n   * carefully according to the TypeScript version being used. This means so far there is not a way to keep every\n   * TypeScript version happy. It turns out that we will easily broke users on some TypeScript version.\n   *\n   * for more info see https://github.com/gpuweb/types/issues/127\n   */\n  export type GpuBufferType = { size: number; mapState: 'unmapped' | 'pending' | 'mapped' };\n\n  /**\n   * type alias for WebNN MLTensor\n   *\n   * The specification for WebNN's MLTensor is currently in flux.\n   */\n  export type MLTensorType = unknown;\n\n  /**\n   * supported data types for constructing a tensor from a WebGPU buffer\n   */\n  export type GpuBufferDataTypes = 'float32' | 'float16' | 'int32' | 'int64' | 'uint32' | 'uint8' | 'bool';\n\n  /**\n   * supported data types for constructing a tensor from a WebNN MLTensor\n   */\n  export type MLTensorDataTypes =\n    | 'float32'\n    | 'float16'\n    | 'int8'\n    | 'uint8'\n    | 'int32'\n    | 'uint32'\n    | 'int64'\n    | 'uint64'\n    | 'bool';\n\n  /**\n   * represent where the tensor data is stored\n   */\n  export type DataLocation = 'none' | 'cpu' | 'cpu-pinned' | 'texture' | 'gpu-buffer' | 'ml-tensor';\n\n  /**\n   * represent the data type of a tensor\n   */\n  export type Type = keyof DataTypeMap;\n}\n\n/**\n * Represent multi-dimensional arrays to feed to or fetch from model inferencing.\n */\nexport interface TypedTensor<T extends Tensor.Type> extends TypedTensorBase<T>, TypedTensorUtils<T> {}\n/**\n * Represent multi-dimensional arrays to feed to or fetch from model inferencing.\n */\nexport interface Tensor extends TypedTensorBase<Tensor.Type>, TypedTensorUtils<Tensor.Type> {}\n\n/**\n * type TensorConstructor defines the constructors of 'Tensor' to create CPU tensor instances.\n */\nexport interface TensorConstructor extends TensorFactory {\n  // #region CPU tensor - specify element type\n  /**\n   * Construct a new string tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (\n    type: 'string',\n    data: Tensor.DataTypeMap['string'] | readonly string[],\n    dims?: readonly number[],\n  ): TypedTensor<'string'>;\n\n  /**\n   * Construct a new bool tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (\n    type: 'bool',\n    data: Tensor.DataTypeMap['bool'] | readonly boolean[],\n    dims?: readonly number[],\n  ): TypedTensor<'bool'>;\n\n  /**\n   * Construct a new uint8 tensor object from a Uint8ClampedArray, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (type: 'uint8', data: Uint8ClampedArray, dims?: readonly number[]): TypedTensor<'uint8'>;\n\n  /**\n   * Construct a new 64-bit integer typed tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new <T extends 'uint64' | 'int64'>(\n    type: T,\n    data: Tensor.DataTypeMap[T] | readonly bigint[] | readonly number[],\n    dims?: readonly number[],\n  ): TypedTensor<T>;\n\n  /**\n   * Construct a new numeric tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new <T extends Exclude<Tensor.Type, 'string' | 'bool' | 'uint64' | 'int64'>>(\n    type: T,\n    data: Tensor.DataTypeMap[T] | readonly number[],\n    dims?: readonly number[],\n  ): TypedTensor<T>;\n  // #endregion\n\n  // #region CPU tensor - infer element types\n\n  /**\n   * Construct a new float32 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Float32Array, dims?: readonly number[]): TypedTensor<'float32'>;\n\n  /**\n   * Construct a new int8 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Int8Array, dims?: readonly number[]): TypedTensor<'int8'>;\n\n  /**\n   * Construct a new uint8 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Uint8Array, dims?: readonly number[]): TypedTensor<'uint8'>;\n\n  /**\n   * Construct a new uint8 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Uint8ClampedArray, dims?: readonly number[]): TypedTensor<'uint8'>;\n\n  /**\n   * Construct a new uint16 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Uint16Array, dims?: readonly number[]): TypedTensor<'uint16'>;\n\n  /**\n   * Construct a new int16 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Int16Array, dims?: readonly number[]): TypedTensor<'int16'>;\n\n  /**\n   * Construct a new int32 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Int32Array, dims?: readonly number[]): TypedTensor<'int32'>;\n\n  /**\n   * Construct a new int64 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: BigInt64Array, dims?: readonly number[]): TypedTensor<'int64'>;\n\n  /**\n   * Construct a new string tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: readonly string[], dims?: readonly number[]): TypedTensor<'string'>;\n\n  /**\n   * Construct a new bool tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: readonly boolean[], dims?: readonly number[]): TypedTensor<'bool'>;\n\n  /**\n   * Construct a new float64 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Float64Array, dims?: readonly number[]): TypedTensor<'float64'>;\n\n  /**\n   * Construct a new uint32 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Uint32Array, dims?: readonly number[]): TypedTensor<'uint32'>;\n\n  /**\n   * Construct a new uint64 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: BigUint64Array, dims?: readonly number[]): TypedTensor<'uint64'>;\n\n  // #endregion\n\n  // #region CPU tensor - fall back to non-generic tensor type declaration\n\n  /**\n   * Construct a new tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (\n    type: Tensor.Type,\n    data: Tensor.DataType | readonly number[] | readonly string[] | readonly bigint[] | readonly boolean[],\n    dims?: readonly number[],\n  ): Tensor;\n\n  /**\n   * Construct a new tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Tensor.DataType, dims?: readonly number[]): Tensor;\n  // #endregion\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Tensor = TensorImpl as TensorConstructor;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { env } from './env-impl.js';\n\n/**\n * @ignore\n */\nexport const TRACE = (deviceType: string, label: string) => {\n  if (typeof env.trace === 'undefined' ? !env.wasm.trace : !env.trace) {\n    return;\n  }\n  // eslint-disable-next-line no-console\n  console.timeStamp(`${deviceType}::ORT::${label}`);\n};\n\nconst TRACE_FUNC = (msg: string, extraMsg?: string) => {\n  const stack = new Error().stack?.split(/\\r\\n|\\r|\\n/g) || [];\n  let hasTraceFunc = false;\n  for (let i = 0; i < stack.length; i++) {\n    if (hasTraceFunc && !stack[i].includes('TRACE_FUNC')) {\n      let label = `FUNC_${msg}::${stack[i].trim().split(' ')[1]}`;\n      if (extraMsg) {\n        label += `::${extraMsg}`;\n      }\n      TRACE('CPU', label);\n      return;\n    }\n    if (stack[i].includes('TRACE_FUNC')) {\n      hasTraceFunc = true;\n    }\n  }\n};\n\n/**\n * @ignore\n */\nexport const TRACE_FUNC_BEGIN = (extraMsg?: string) => {\n  if (typeof env.trace === 'undefined' ? !env.wasm.trace : !env.trace) {\n    return;\n  }\n  TRACE_FUNC('BEGIN', extraMsg);\n};\n\n/**\n * @ignore\n */\nexport const TRACE_FUNC_END = (extraMsg?: string) => {\n  if (typeof env.trace === 'undefined' ? !env.wasm.trace : !env.trace) {\n    return;\n  }\n  TRACE_FUNC('END', extraMsg);\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { resolveBackendAndExecutionProviders } from './backend-impl.js';\nimport { InferenceSessionHandler } from './backend.js';\nimport { InferenceSession as InferenceSessionInterface } from './inference-session.js';\nimport { OnnxValue } from './onnx-value.js';\nimport { Tensor } from './tensor.js';\nimport { TRACE_FUNC_BEGIN, TRACE_FUNC_END } from './trace.js';\n\ntype SessionOptions = InferenceSessionInterface.SessionOptions;\ntype RunOptions = InferenceSessionInterface.RunOptions;\ntype FeedsType = InferenceSessionInterface.FeedsType;\ntype FetchesType = InferenceSessionInterface.FetchesType;\ntype ReturnType = InferenceSessionInterface.ReturnType;\n\nexport class InferenceSession implements InferenceSessionInterface {\n  private constructor(handler: InferenceSessionHandler) {\n    this.handler = handler;\n  }\n  run(feeds: FeedsType, options?: RunOptions): Promise<ReturnType>;\n  run(feeds: FeedsType, fetches: FetchesType, options?: RunOptions): Promise<ReturnType>;\n  async run(feeds: FeedsType, arg1?: FetchesType | RunOptions, arg2?: RunOptions): Promise<ReturnType> {\n    TRACE_FUNC_BEGIN();\n    const fetches: { [name: string]: OnnxValue | null } = {};\n    let options: RunOptions = {};\n    // check inputs\n    if (typeof feeds !== 'object' || feeds === null || feeds instanceof Tensor || Array.isArray(feeds)) {\n      throw new TypeError(\n        \"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\",\n      );\n    }\n\n    let isFetchesEmpty = true;\n    // determine which override is being used\n    if (typeof arg1 === 'object') {\n      if (arg1 === null) {\n        throw new TypeError('Unexpected argument[1]: cannot be null.');\n      }\n      if (arg1 instanceof Tensor) {\n        throw new TypeError(\"'fetches' cannot be a Tensor\");\n      }\n\n      if (Array.isArray(arg1)) {\n        if (arg1.length === 0) {\n          throw new TypeError(\"'fetches' cannot be an empty array.\");\n        }\n        isFetchesEmpty = false;\n        // output names\n        for (const name of arg1) {\n          if (typeof name !== 'string') {\n            throw new TypeError(\"'fetches' must be a string array or an object.\");\n          }\n          if (this.outputNames.indexOf(name) === -1) {\n            throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n          }\n          fetches[name] = null;\n        }\n\n        if (typeof arg2 === 'object' && arg2 !== null) {\n          options = arg2;\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError(\"'options' must be an object.\");\n        }\n      } else {\n        // decide whether arg1 is fetches or options\n        // if any output name is present and its value is valid OnnxValue, we consider it fetches\n        let isFetches = false;\n        const arg1Keys = Object.getOwnPropertyNames(arg1);\n        for (const name of this.outputNames) {\n          if (arg1Keys.indexOf(name) !== -1) {\n            const v = (arg1 as InferenceSessionInterface.NullableOnnxValueMapType)[name];\n            if (v === null || v instanceof Tensor) {\n              isFetches = true;\n              isFetchesEmpty = false;\n              fetches[name] = v;\n            }\n          }\n        }\n\n        if (isFetches) {\n          if (typeof arg2 === 'object' && arg2 !== null) {\n            options = arg2;\n          } else if (typeof arg2 !== 'undefined') {\n            throw new TypeError(\"'options' must be an object.\");\n          }\n        } else {\n          options = arg1 as RunOptions;\n        }\n      }\n    } else if (typeof arg1 !== 'undefined') {\n      throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n    }\n\n    // check if all inputs are in feed\n    for (const name of this.inputNames) {\n      if (typeof feeds[name] === 'undefined') {\n        throw new Error(`input '${name}' is missing in 'feeds'.`);\n      }\n    }\n\n    // if no fetches is specified, we use the full output names list\n    if (isFetchesEmpty) {\n      for (const name of this.outputNames) {\n        fetches[name] = null;\n      }\n    }\n\n    // feeds, fetches and options are prepared\n\n    const results = await this.handler.run(feeds, fetches, options);\n    const returnValue: { [name: string]: OnnxValue } = {};\n    for (const key in results) {\n      if (Object.hasOwnProperty.call(results, key)) {\n        const result = results[key];\n        if (result instanceof Tensor) {\n          returnValue[key] = result;\n        } else {\n          returnValue[key] = new Tensor(result.type, result.data, result.dims);\n        }\n      }\n    }\n    TRACE_FUNC_END();\n    return returnValue;\n  }\n\n  async release(): Promise<void> {\n    return this.handler.dispose();\n  }\n\n  static create(path: string, options?: SessionOptions): Promise<InferenceSessionInterface>;\n  static create(buffer: ArrayBufferLike, options?: SessionOptions): Promise<InferenceSessionInterface>;\n  static create(\n    buffer: ArrayBufferLike,\n    byteOffset: number,\n    byteLength?: number,\n    options?: SessionOptions,\n  ): Promise<InferenceSessionInterface>;\n  static create(buffer: Uint8Array, options?: SessionOptions): Promise<InferenceSessionInterface>;\n  static async create(\n    arg0: string | ArrayBufferLike | Uint8Array,\n    arg1?: SessionOptions | number,\n    arg2?: number,\n    arg3?: SessionOptions,\n  ): Promise<InferenceSessionInterface> {\n    TRACE_FUNC_BEGIN();\n    // either load from a file or buffer\n    let filePathOrUint8Array: string | Uint8Array;\n    let options: SessionOptions = {};\n\n    if (typeof arg0 === 'string') {\n      filePathOrUint8Array = arg0;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError(\"'options' must be an object.\");\n      }\n    } else if (arg0 instanceof Uint8Array) {\n      filePathOrUint8Array = arg0;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError(\"'options' must be an object.\");\n      }\n    } else if (\n      arg0 instanceof ArrayBuffer ||\n      (typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer)\n    ) {\n      const buffer = arg0;\n      let byteOffset = 0;\n      let byteLength = arg0.byteLength;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 === 'number') {\n        byteOffset = arg1;\n        if (!Number.isSafeInteger(byteOffset)) {\n          throw new RangeError(\"'byteOffset' must be an integer.\");\n        }\n        if (byteOffset < 0 || byteOffset >= buffer.byteLength) {\n          throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);\n        }\n        byteLength = arg0.byteLength - byteOffset;\n        if (typeof arg2 === 'number') {\n          byteLength = arg2;\n          if (!Number.isSafeInteger(byteLength)) {\n            throw new RangeError(\"'byteLength' must be an integer.\");\n          }\n          if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {\n            throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);\n          }\n          if (typeof arg3 === 'object' && arg3 !== null) {\n            options = arg3;\n          } else if (typeof arg3 !== 'undefined') {\n            throw new TypeError(\"'options' must be an object.\");\n          }\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError(\"'byteLength' must be a number.\");\n        }\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError(\"'options' must be an object.\");\n      }\n      filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\n    } else {\n      throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");\n    }\n\n    // resolve backend, update session options with validated EPs, and create session handler\n    const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);\n    const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);\n    TRACE_FUNC_END();\n    return new InferenceSession(handler);\n  }\n\n  startProfiling(): void {\n    this.handler.startProfiling();\n  }\n  endProfiling(): void {\n    this.handler.endProfiling();\n  }\n\n  get inputNames(): readonly string[] {\n    return this.handler.inputNames;\n  }\n  get outputNames(): readonly string[] {\n    return this.handler.outputNames;\n  }\n\n  private handler: InferenceSessionHandler;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceSession as InferenceSessionImpl } from './inference-session-impl.js';\nimport { OnnxModelOptions } from './onnx-model.js';\nimport { OnnxValue, OnnxValueDataLocation } from './onnx-value.js';\n\n/* eslint-disable @typescript-eslint/no-redeclare */\n\nexport declare namespace InferenceSession {\n  // #region input/output types\n\n  type OnnxValueMapType = { readonly [name: string]: OnnxValue };\n  type NullableOnnxValueMapType = { readonly [name: string]: OnnxValue | null };\n\n  /**\n   * A feeds (model inputs) is an object that uses input names as keys and OnnxValue as corresponding values.\n   */\n  type FeedsType = OnnxValueMapType;\n\n  /**\n   * A fetches (model outputs) could be one of the following:\n   *\n   * - Omitted. Use model's output names definition.\n   * - An array of string indicating the output names.\n   * - An object that use output names as keys and OnnxValue or null as corresponding values.\n   *\n   * @remark\n   * different from input argument, in output, OnnxValue is optional. If an OnnxValue is present it will be\n   * used as a pre-allocated value by the inference engine; if omitted, inference engine will allocate buffer\n   * internally.\n   */\n  type FetchesType = readonly string[] | NullableOnnxValueMapType;\n\n  /**\n   * A inferencing return type is an object that uses output names as keys and OnnxValue as corresponding values.\n   */\n  type ReturnType = OnnxValueMapType;\n\n  // #endregion\n\n  // #region session options\n\n  /**\n   * A set of configurations for session behavior.\n   */\n  export interface SessionOptions extends OnnxModelOptions {\n    /**\n     * An array of execution provider options.\n     *\n     * An execution provider option can be a string indicating the name of the execution provider,\n     * or an object of corresponding type.\n     */\n    executionProviders?: readonly ExecutionProviderConfig[];\n\n    /**\n     * The intra OP threads number.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native).\n     */\n    intraOpNumThreads?: number;\n\n    /**\n     * The inter OP threads number.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native).\n     */\n    interOpNumThreads?: number;\n\n    /**\n     * The free dimension override.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    freeDimensionOverrides?: { readonly [dimensionName: string]: number };\n\n    /**\n     * The optimization level.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    graphOptimizationLevel?: 'disabled' | 'basic' | 'extended' | 'all';\n\n    /**\n     * Whether enable CPU memory arena.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    enableCpuMemArena?: boolean;\n\n    /**\n     * Whether enable memory pattern.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    enableMemPattern?: boolean;\n\n    /**\n     * Execution mode.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    executionMode?: 'sequential' | 'parallel';\n\n    /**\n     * Optimized model file path.\n     *\n     * If this setting is specified, the optimized model will be dumped. In browser, a blob will be created\n     * with a pop-up window.\n     */\n    optimizedModelFilePath?: string;\n\n    /**\n     * Whether enable profiling.\n     *\n     * This setting is a placeholder for a future use.\n     */\n    enableProfiling?: boolean;\n\n    /**\n     * File prefix for profiling.\n     *\n     * This setting is a placeholder for a future use.\n     */\n    profileFilePrefix?: string;\n\n    /**\n     * Log ID.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    logId?: string;\n\n    /**\n     * Log severity level. See\n     * https://github.com/microsoft/onnxruntime/blob/main/include/onnxruntime/core/common/logging/severity.h\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    logSeverityLevel?: 0 | 1 | 2 | 3 | 4;\n\n    /**\n     * Log verbosity level.\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     */\n    logVerbosityLevel?: number;\n\n    /**\n     * Specify string as a preferred data location for all outputs, or an object that use output names as keys and a\n     * preferred data location as corresponding values.\n     *\n     * This setting is available only in ONNXRuntime Web for WebGL and WebGPU EP.\n     */\n    preferredOutputLocation?: OnnxValueDataLocation | { readonly [outputName: string]: OnnxValueDataLocation };\n\n    /**\n     * Whether enable graph capture.\n     * This setting is available only in ONNXRuntime Web for WebGPU EP.\n     */\n    enableGraphCapture?: boolean;\n\n    /**\n     * Store configurations for a session. See\n     * https://github.com/microsoft/onnxruntime/blob/main/include/onnxruntime/core/session/\n     * onnxruntime_session_options_config_keys.h\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     *\n     * @example\n     * ```js\n     * extra: {\n     *   session: {\n     *     set_denormal_as_zero: \"1\",\n     *     disable_prepacking: \"1\"\n     *   },\n     *   optimization: {\n     *     enable_gelu_approximation: \"1\"\n     *   }\n     * }\n     * ```\n     */\n    extra?: Record<string, unknown>;\n  }\n\n  // #region execution providers\n\n  // Currently, we have the following backends to support execution providers:\n  // Backend Node.js binding: supports 'cpu', 'dml' (win32), 'coreml' (macOS) and 'cuda' (linux).\n  // Backend WebAssembly: supports 'cpu', 'wasm', 'webgpu' and 'webnn'.\n  // Backend ONNX.js: supports 'webgl'.\n  // Backend React Native: supports 'cpu', 'xnnpack', 'coreml' (iOS), 'nnapi' (Android).\n  interface ExecutionProviderOptionMap {\n    coreml: CoreMLExecutionProviderOption;\n    cpu: CpuExecutionProviderOption;\n    cuda: CudaExecutionProviderOption;\n    dml: DmlExecutionProviderOption;\n    nnapi: NnapiExecutionProviderOption;\n    tensorrt: TensorRtExecutionProviderOption;\n    wasm: WebAssemblyExecutionProviderOption;\n    webgl: WebGLExecutionProviderOption;\n    webgpu: WebGpuExecutionProviderOption;\n    webnn: WebNNExecutionProviderOption;\n    qnn: QnnExecutionProviderOption;\n    xnnpack: XnnpackExecutionProviderOption;\n  }\n\n  type ExecutionProviderName = keyof ExecutionProviderOptionMap;\n  type ExecutionProviderConfig =\n    | ExecutionProviderOptionMap[ExecutionProviderName]\n    | ExecutionProviderOption\n    | ExecutionProviderName\n    | string;\n\n  export interface ExecutionProviderOption {\n    readonly name: string;\n  }\n  export interface CpuExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'cpu';\n    useArena?: boolean;\n  }\n  export interface CudaExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'cuda';\n    deviceId?: number;\n  }\n  export interface DmlExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'dml';\n    deviceId?: number;\n  }\n  export interface TensorRtExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'tensorrt';\n    deviceId?: number;\n  }\n  export interface WebAssemblyExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'wasm';\n  }\n  export interface WebGLExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'webgl';\n    // TODO: add flags\n  }\n  export interface XnnpackExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'xnnpack';\n  }\n  export interface WebGpuExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'webgpu';\n    preferredLayout?: 'NCHW' | 'NHWC';\n  }\n\n  // #region WebNN options\n\n  interface WebNNExecutionProviderName extends ExecutionProviderOption {\n    readonly name: 'webnn';\n  }\n\n  /**\n   * Represents a set of options for creating a WebNN MLContext.\n   *\n   * @see https://www.w3.org/TR/webnn/#dictdef-mlcontextoptions\n   */\n  export interface WebNNContextOptions {\n    deviceType?: 'cpu' | 'gpu' | 'npu';\n    numThreads?: number;\n    powerPreference?: 'default' | 'low-power' | 'high-performance';\n  }\n\n  /**\n   * Represents a set of options for WebNN execution provider without MLContext.\n   */\n  export interface WebNNOptionsWithoutMLContext extends WebNNExecutionProviderName, WebNNContextOptions {\n    context?: never;\n  }\n\n  /**\n   * Represents a set of options for WebNN execution provider with MLContext.\n   *\n   * When MLContext is provided, the deviceType is also required so that the WebNN EP can determine the preferred\n   * channel layout.\n   *\n   * @see https://www.w3.org/TR/webnn/#dom-ml-createcontext\n   */\n  export interface WebNNOptionsWithMLContext\n    extends WebNNExecutionProviderName,\n      Omit<WebNNContextOptions, 'deviceType'>,\n      Required<Pick<WebNNContextOptions, 'deviceType'>> {\n    context: unknown /* MLContext */;\n  }\n\n  /**\n   * Represents a set of options for WebNN execution provider with MLContext which is created from GPUDevice.\n   *\n   * @see https://www.w3.org/TR/webnn/#dom-ml-createcontext-gpudevice\n   */\n  export interface WebNNOptionsWebGpu extends WebNNExecutionProviderName {\n    context: unknown /* MLContext */;\n    gpuDevice: unknown /* GPUDevice */;\n  }\n\n  /**\n   * Options for WebNN execution provider.\n   */\n  export type WebNNExecutionProviderOption =\n    | WebNNOptionsWithoutMLContext\n    | WebNNOptionsWithMLContext\n    | WebNNOptionsWebGpu;\n\n  // #endregion\n\n  export interface QnnExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'qnn';\n    // TODO add flags\n  }\n  export interface CoreMLExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'coreml';\n    /**\n     * The bit flags for CoreML execution provider.\n     *\n     * ```\n     * COREML_FLAG_USE_CPU_ONLY = 0x001\n     * COREML_FLAG_ENABLE_ON_SUBGRAPH = 0x002\n     * COREML_FLAG_ONLY_ENABLE_DEVICE_WITH_ANE = 0x004\n     * COREML_FLAG_ONLY_ALLOW_STATIC_INPUT_SHAPES = 0x008\n     * COREML_FLAG_CREATE_MLPROGRAM = 0x010\n     * COREML_FLAG_USE_CPU_AND_GPU = 0x020\n     * ```\n     *\n     * See include/onnxruntime/core/providers/coreml/coreml_provider_factory.h for more details.\n     *\n     * This flag is available only in ONNXRuntime (Node.js binding).\n     */\n    coreMlFlags?: number;\n    /**\n     * Specify whether to use CPU only in CoreML EP.\n     *\n     * This setting is available only in ONNXRuntime (react-native).\n     */\n    useCPUOnly?: boolean;\n    useCPUAndGPU?: boolean;\n    /**\n     * Specify whether to enable CoreML EP on subgraph.\n     *\n     * This setting is available only in ONNXRuntime (react-native).\n     */\n    enableOnSubgraph?: boolean;\n    /**\n     * Specify whether to only enable CoreML EP for Apple devices with ANE (Apple Neural Engine).\n     *\n     * This setting is available only in ONNXRuntime (react-native).\n     */\n    onlyEnableDeviceWithANE?: boolean;\n  }\n  export interface NnapiExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'nnapi';\n    useFP16?: boolean;\n    useNCHW?: boolean;\n    cpuDisabled?: boolean;\n    cpuOnly?: boolean;\n  }\n  // #endregion\n\n  // #endregion\n\n  // #region run options\n\n  /**\n   * A set of configurations for inference run behavior\n   */\n  export interface RunOptions {\n    /**\n     * Log severity level. See\n     * https://github.com/microsoft/onnxruntime/blob/main/include/onnxruntime/core/common/logging/severity.h\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    logSeverityLevel?: 0 | 1 | 2 | 3 | 4;\n\n    /**\n     * Log verbosity level.\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     */\n    logVerbosityLevel?: number;\n\n    /**\n     * Terminate all incomplete OrtRun calls as soon as possible if true\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     */\n    terminate?: boolean;\n\n    /**\n     * A tag for the Run() calls using this\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    tag?: string;\n\n    /**\n     * Set a single run configuration entry. See\n     * https://github.com/microsoft/onnxruntime/blob/main/include/onnxruntime/core/session/\n     * onnxruntime_run_options_config_keys.h\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     *\n     * @example\n     *\n     * ```js\n     * extra: {\n     *   memory: {\n     *     enable_memory_arena_shrinkage: \"1\",\n     *   }\n     * }\n     * ```\n     */\n    extra?: Record<string, unknown>;\n  }\n\n  // #endregion\n\n  // #region value metadata\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-interface\n  interface ValueMetadata {\n    // TBD\n  }\n\n  // #endregion\n}\n\n/**\n * Represent a runtime instance of an ONNX model.\n */\nexport interface InferenceSession {\n  // #region run()\n\n  /**\n   * Execute the model asynchronously with the given feeds and options.\n   *\n   * @param feeds - Representation of the model input. See type description of `InferenceSession.InputType` for detail.\n   * @param options - Optional. A set of options that controls the behavior of model inference.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding values.\n   */\n  run(feeds: InferenceSession.FeedsType, options?: InferenceSession.RunOptions): Promise<InferenceSession.ReturnType>;\n\n  /**\n   * Execute the model asynchronously with the given feeds, fetches and options.\n   *\n   * @param feeds - Representation of the model input. See type description of `InferenceSession.InputType` for detail.\n   * @param fetches - Representation of the model output. See type description of `InferenceSession.OutputType` for\n   * detail.\n   * @param options - Optional. A set of options that controls the behavior of model inference.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding values.\n   */\n  run(\n    feeds: InferenceSession.FeedsType,\n    fetches: InferenceSession.FetchesType,\n    options?: InferenceSession.RunOptions,\n  ): Promise<InferenceSession.ReturnType>;\n\n  // #endregion\n\n  // #region release()\n\n  /**\n   * Release the inference session and the underlying resources.\n   */\n  release(): Promise<void>;\n\n  // #endregion\n\n  // #region profiling\n\n  /**\n   * Start profiling.\n   */\n  startProfiling(): void;\n\n  /**\n   * End profiling.\n   */\n  endProfiling(): void;\n\n  // #endregion\n\n  // #region metadata\n\n  /**\n   * Get input names of the loaded model.\n   */\n  readonly inputNames: readonly string[];\n\n  /**\n   * Get output names of the loaded model.\n   */\n  readonly outputNames: readonly string[];\n\n  // /**\n  //  * Get input metadata of the loaded model.\n  //  */\n  // readonly inputMetadata: ReadonlyArray<Readonly<InferenceSession.ValueMetadata>>;\n\n  // /**\n  //  * Get output metadata of the loaded model.\n  //  */\n  // readonly outputMetadata: ReadonlyArray<Readonly<InferenceSession.ValueMetadata>>;\n\n  // #endregion\n}\n\nexport interface InferenceSessionFactory {\n  // #region create()\n\n  /**\n   * Create a new inference session and load model asynchronously from an ONNX model file.\n   *\n   * @param uri - The URI or file path of the model to load.\n   * @param options - specify configuration for creating a new inference session.\n   * @returns A promise that resolves to an InferenceSession object.\n   */\n  create(uri: string, options?: InferenceSession.SessionOptions): Promise<InferenceSession>;\n\n  /**\n   * Create a new inference session and load model asynchronously from an array bufer.\n   *\n   * @param buffer - An ArrayBuffer representation of an ONNX model.\n   * @param options - specify configuration for creating a new inference session.\n   * @returns A promise that resolves to an InferenceSession object.\n   */\n  create(buffer: ArrayBufferLike, options?: InferenceSession.SessionOptions): Promise<InferenceSession>;\n\n  /**\n   * Create a new inference session and load model asynchronously from segment of an array bufer.\n   *\n   * @param buffer - An ArrayBuffer representation of an ONNX model.\n   * @param byteOffset - The beginning of the specified portion of the array buffer.\n   * @param byteLength - The length in bytes of the array buffer.\n   * @param options - specify configuration for creating a new inference session.\n   * @returns A promise that resolves to an InferenceSession object.\n   */\n  create(\n    buffer: ArrayBufferLike,\n    byteOffset: number,\n    byteLength?: number,\n    options?: InferenceSession.SessionOptions,\n  ): Promise<InferenceSession>;\n\n  /**\n   * Create a new inference session and load model asynchronously from a Uint8Array.\n   *\n   * @param buffer - A Uint8Array representation of an ONNX model.\n   * @param options - specify configuration for creating a new inference session.\n   * @returns A promise that resolves to an InferenceSession object.\n   */\n  create(buffer: Uint8Array, options?: InferenceSession.SessionOptions): Promise<InferenceSession>;\n\n  // #endregion\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const InferenceSession: InferenceSessionFactory = InferenceSessionImpl;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { OptionsFormat, OptionsNormalizationParameters, OptionsTensorLayout } from './tensor-factory.js';\n\nexport interface TensorToDataUrlOptions extends OptionsTensorLayout, OptionsFormat, OptionsNormalizationParameters {}\n\nexport interface TensorToImageDataOptions extends OptionsTensorLayout, OptionsFormat, OptionsNormalizationParameters {}\n\nexport interface ConversionUtils {\n  /**\n   * creates a DataURL instance from tensor\n   *\n   * @param options - An optional object representing options for creating a DataURL instance from the tensor.\n   *\n   * The following default settings will be applied:\n   * - `format`: `'RGB'`\n   * - `tensorLayout`: `'NCHW'`\n   * @returns a DataURL string representing the image converted from tensor data\n   */\n  toDataURL(options?: TensorToDataUrlOptions): string;\n\n  /**\n   * creates an ImageData instance from tensor\n   *\n   * @param options - An optional object representing options for creating an ImageData instance from the tensor.\n   *\n   * The following default settings will be applied:\n   * - `format`: `'RGB'`\n   * - `tensorLayout`: `'NCHW'`\n   * @returns an ImageData instance representing the image converted from tensor data\n   */\n  toImageData(options?: TensorToImageDataOptions): ImageData;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor, TypedTensor } from './tensor.js';\n\nexport type ImageFormat = 'RGB' | 'RGBA' | 'BGR' | 'RBG';\nexport type ImageTensorLayout = 'NHWC' | 'NCHW';\n\n// the following region contains type definitions for constructing tensor from a specific location.\n\n// #region types for constructing a tensor from a specific location\n\n/**\n * represent common properties of the parameter for constructing a tensor from a specific location.\n */\ninterface CommonConstructorParameters<T> extends Pick<Tensor, 'dims'> {\n  /**\n   * Specify the data type of the tensor.\n   */\n  readonly type: T;\n}\n\n/**\n * represent the parameter for constructing a tensor from a GPU resource.\n */\ninterface GpuResourceConstructorParameters<T extends Tensor.Type> {\n  /**\n   * an optional callback function to download data from GPU to CPU.\n   *\n   * If not provided, the tensor treat the GPU data as external resource.\n   */\n  download?(): Promise<Tensor.DataTypeMap[T]>;\n\n  /**\n   * an optional callback function that will be called when the tensor is disposed.\n   *\n   * If not provided, the tensor treat the GPU data as external resource.\n   */\n  dispose?(): void;\n}\n\n/**\n * represent the parameter for constructing a tensor from a pinned CPU buffer\n */\nexport interface CpuPinnedConstructorParameters<T extends Tensor.CpuPinnedDataTypes = Tensor.CpuPinnedDataTypes>\n  extends CommonConstructorParameters<T> {\n  /**\n   * Specify the location of the data to be 'cpu-pinned'.\n   */\n  readonly location: 'cpu-pinned';\n  /**\n   * Specify the CPU pinned buffer that holds the tensor data.\n   */\n  readonly data: Tensor.DataTypeMap[T];\n}\n\n/**\n * represent the parameter for constructing a tensor from a WebGL texture\n */\nexport interface TextureConstructorParameters<T extends Tensor.TextureDataTypes = Tensor.TextureDataTypes>\n  extends CommonConstructorParameters<T>,\n    GpuResourceConstructorParameters<T> {\n  /**\n   * Specify the location of the data to be 'texture'.\n   */\n  readonly location: 'texture';\n  /**\n   * Specify the WebGL texture that holds the tensor data.\n   */\n  readonly texture: Tensor.TextureType;\n}\n\n/**\n * represent the parameter for constructing a tensor from a WebGPU buffer\n */\nexport interface GpuBufferConstructorParameters<T extends Tensor.GpuBufferDataTypes = Tensor.GpuBufferDataTypes>\n  extends CommonConstructorParameters<T>,\n    GpuResourceConstructorParameters<T> {\n  /**\n   * Specify the location of the data to be 'gpu-buffer'.\n   */\n  readonly location: 'gpu-buffer';\n  /**\n   * Specify the WebGPU buffer that holds the tensor data.\n   */\n  readonly gpuBuffer: Tensor.GpuBufferType;\n}\n\nexport interface MLTensorConstructorParameters<T extends Tensor.MLTensorDataTypes = Tensor.MLTensorDataTypes>\n  extends CommonConstructorParameters<T>,\n    GpuResourceConstructorParameters<T> {\n  /**\n   * Specify the location of the data to be 'ml-tensor'.\n   */\n  readonly location: 'ml-tensor';\n\n  /**\n   * Specify the WebNN MLTensor that holds the tensor data.\n   */\n  readonly mlTensor: Tensor.MLTensorType;\n}\n\n// #endregion\n\n// the following region contains type definitions of each individual options.\n// the tensor factory functions use a composition of those options as the parameter type.\n\n// #region Options fields\n\nexport interface OptionsFormat {\n  /**\n   * Describes the image format represented in RGBA color space.\n   */\n  format?: ImageFormat;\n}\n\nexport interface OptionsTensorFormat {\n  /**\n   * Describes the image format of the tensor.\n   *\n   * NOTE: this is different from option 'format'. While option 'format' represents the original image, 'tensorFormat'\n   * represents the target format of the tensor. A transpose will be performed if they are different.\n   */\n  tensorFormat?: ImageFormat;\n}\n\nexport interface OptionsTensorDataType {\n  /**\n   * Describes the data type of the tensor.\n   */\n  dataType?: 'float32' | 'uint8';\n}\n\nexport interface OptionsTensorLayout {\n  /**\n   * Describes the tensor layout when representing data of one or more image(s).\n   */\n  tensorLayout?: ImageTensorLayout;\n}\n\nexport interface OptionsDimensions {\n  /**\n   * Describes the image height in pixel\n   */\n  height?: number;\n  /**\n   * Describes the image width in pixel\n   */\n  width?: number;\n}\n\nexport interface OptionResizedDimensions {\n  /**\n   * Describes the resized height. If omitted, original height will be used.\n   */\n  resizedHeight?: number;\n  /**\n   * Describes resized width - can be accessed via tensor dimensions as well\n   */\n  resizedWidth?: number;\n}\n\nexport interface OptionsNormalizationParameters {\n  /**\n   * Describes normalization parameters when preprocessing the image as model input.\n   *\n   * Data element are ranged from 0 to 255.\n   */\n  norm?: {\n    /**\n     * The 'bias' value for image normalization.\n     * - If omitted, use default value 0.\n     * - If it's a single number, apply to each channel\n     * - If it's an array of 3 or 4 numbers, apply element-wise. Number of elements need to match the number of channels\n     * for the corresponding image format\n     */\n    bias?: number | [number, number, number] | [number, number, number, number];\n    /**\n     * The 'mean' value for image normalization.\n     * - If omitted, use default value 255.\n     * - If it's a single number, apply to each channel\n     * - If it's an array of 3 or 4 numbers, apply element-wise. Number of elements need to match the number of channels\n     * for the corresponding image format\n     */\n    mean?: number | [number, number, number] | [number, number, number, number];\n  };\n}\n\n// #endregion\n\n// #region Options composition\n\nexport interface TensorFromImageDataOptions\n  extends OptionResizedDimensions,\n    OptionsTensorFormat,\n    OptionsTensorLayout,\n    OptionsTensorDataType,\n    OptionsNormalizationParameters {}\n\nexport interface TensorFromImageElementOptions\n  extends OptionResizedDimensions,\n    OptionsTensorFormat,\n    OptionsTensorLayout,\n    OptionsTensorDataType,\n    OptionsNormalizationParameters {}\n\nexport interface TensorFromUrlOptions\n  extends OptionsDimensions,\n    OptionResizedDimensions,\n    OptionsTensorFormat,\n    OptionsTensorLayout,\n    OptionsTensorDataType,\n    OptionsNormalizationParameters {}\n\nexport interface TensorFromImageBitmapOptions\n  extends OptionResizedDimensions,\n    OptionsTensorFormat,\n    OptionsTensorLayout,\n    OptionsTensorDataType,\n    OptionsNormalizationParameters {}\n\nexport interface TensorFromTextureOptions<T extends Tensor.TextureDataTypes>\n  extends Required<OptionsDimensions>,\n    OptionsFormat,\n    GpuResourceConstructorParameters<T> /* TODO: add more */ {}\n\nexport interface TensorFromGpuBufferOptions<T extends Tensor.GpuBufferDataTypes>\n  extends Pick<Tensor, 'dims'>,\n    GpuResourceConstructorParameters<T> {\n  /**\n   * Describes the data type of the tensor.\n   */\n  dataType?: T;\n}\n\nexport interface TensorFromMLTensorOptions<T extends Tensor.MLTensorDataTypes>\n  extends Pick<Tensor, 'dims'>,\n    GpuResourceConstructorParameters<T> {\n  /**\n   * Describes the data type of the tensor.\n   */\n  dataType?: T;\n}\n\n// #endregion\n\n/**\n * type TensorFactory defines the factory functions of 'Tensor' to create tensor instances from existing data or\n * resources.\n */\nexport interface TensorFactory {\n  /**\n   * create a tensor from an ImageData object\n   *\n   * @param imageData - the ImageData object to create tensor from\n   * @param options - An optional object representing options for creating tensor from ImageData.\n   *\n   * The following default settings will be applied:\n   * - `tensorFormat`: `'RGB'`\n   * - `tensorLayout`: `'NCHW'`\n   * - `dataType`: `'float32'`\n   * @returns A promise that resolves to a tensor object\n   */\n  fromImage(\n    imageData: ImageData,\n    options?: TensorFromImageDataOptions,\n  ): Promise<TypedTensor<'float32'> | TypedTensor<'uint8'>>;\n\n  /**\n   * create a tensor from a HTMLImageElement object\n   *\n   * @param imageElement - the HTMLImageElement object to create tensor from\n   * @param options - An optional object representing options for creating tensor from HTMLImageElement.\n   *\n   * The following default settings will be applied:\n   * - `tensorFormat`: `'RGB'`\n   * - `tensorLayout`: `'NCHW'`\n   * - `dataType`: `'float32'`\n   * @returns A promise that resolves to a tensor object\n   */\n  fromImage(\n    imageElement: HTMLImageElement,\n    options?: TensorFromImageElementOptions,\n  ): Promise<TypedTensor<'float32'> | TypedTensor<'uint8'>>;\n\n  /**\n   * create a tensor from URL\n   *\n   * @param urlSource - a string as a URL to the image or a data URL containing the image data.\n   * @param options - An optional object representing options for creating tensor from URL.\n   *\n   * The following default settings will be applied:\n   * - `tensorFormat`: `'RGB'`\n   * - `tensorLayout`: `'NCHW'`\n   * - `dataType`: `'float32'`\n   * @returns A promise that resolves to a tensor object\n   */\n  fromImage(urlSource: string, options?: TensorFromUrlOptions): Promise<TypedTensor<'float32'> | TypedTensor<'uint8'>>;\n\n  /**\n   * create a tensor from an ImageBitmap object\n   *\n   * @param bitmap - the ImageBitmap object to create tensor from\n   * @param options - An optional object representing options for creating tensor from URL.\n   *\n   * The following default settings will be applied:\n   * - `tensorFormat`: `'RGB'`\n   * - `tensorLayout`: `'NCHW'`\n   * - `dataType`: `'float32'`\n   * @returns A promise that resolves to a tensor object\n   */\n  fromImage(\n    bitmap: ImageBitmap,\n    options: TensorFromImageBitmapOptions,\n  ): Promise<TypedTensor<'float32'> | TypedTensor<'uint8'>>;\n\n  /**\n   * create a tensor from a WebGL texture\n   *\n   * @param texture - the WebGLTexture object to create tensor from\n   * @param options - An optional object representing options for creating tensor from WebGL texture.\n   *\n   * The options include following properties:\n   * - `width`: the width of the texture. Required.\n   * - `height`: the height of the texture. Required.\n   * - `format`: the format of the texture. If omitted, assume 'RGBA'.\n   * - `download`: an optional function to download the tensor data from GPU to CPU. If omitted, the GPU data\n   * will not be able to download. Usually, this is provided by a GPU backend for the inference outputs. Users don't\n   * need to provide this function.\n   * - `dispose`: an optional function to dispose the tensor data on GPU. If omitted, the GPU data will not be disposed.\n   * Usually, this is provided by a GPU backend for the inference outputs. Users don't need to provide this function.\n   *\n   * @returns a tensor object\n   */\n  fromTexture<T extends Tensor.TextureDataTypes = 'float32'>(\n    texture: Tensor.TextureType,\n    options: TensorFromTextureOptions<T>,\n  ): TypedTensor<'float32'>;\n\n  /**\n   * create a tensor from a WebGPU buffer\n   *\n   * @param buffer - the GPUBuffer object to create tensor from\n   * @param options - An optional object representing options for creating tensor from WebGPU buffer.\n   *\n   * The options include following properties:\n   * - `dataType`: the data type of the tensor. If omitted, assume 'float32'.\n   * - `dims`: the dimension of the tensor. Required.\n   * - `download`: an optional function to download the tensor data from GPU to CPU. If omitted, the GPU data\n   * will not be able to download. Usually, this is provided by a GPU backend for the inference outputs. Users don't\n   * need to provide this function.\n   * - `dispose`: an optional function to dispose the tensor data on GPU. If omitted, the GPU data will not be disposed.\n   * Usually, this is provided by a GPU backend for the inference outputs. Users don't need to provide this function.\n   *\n   * @returns a tensor object\n   */\n  fromGpuBuffer<T extends Tensor.GpuBufferDataTypes>(\n    buffer: Tensor.GpuBufferType,\n    options: TensorFromGpuBufferOptions<T>,\n  ): TypedTensor<T>;\n\n  /**\n   * create a tensor from a WebNN MLTensor\n   *\n   * @param tensor - the MLTensor object to create tensor from\n   * @param options - An optional object representing options for creating tensor from a WebNN MLTensor.\n   *\n   * The options include following properties:\n   * - `dataType`: the data type of the tensor. If omitted, assume 'float32'.\n   * - `dims`: the dimension of the tensor. Required.\n   * - `download`: an optional function to download the tensor data from the MLTensor to CPU. If omitted, the MLTensor\n   * data will not be able to download. Usually, this is provided by the WebNN backend for the inference outputs.\n   * Users don't need to provide this function.\n   * - `dispose`: an optional function to dispose the tensor data on the WebNN MLTensor. If omitted, the MLTensor will\n   * not be disposed. Usually, this is provided by the WebNN backend for the inference outputs. Users don't need to\n   * provide this function.\n   *\n   * @returns a tensor object\n   */\n  fromMLTensor<T extends Tensor.MLTensorDataTypes>(\n    tensor: Tensor.MLTensorType,\n    options: TensorFromMLTensorOptions<T>,\n  ): TypedTensor<T>;\n\n  /**\n   * create a tensor from a pre-allocated buffer. The buffer will be used as a pinned buffer.\n   *\n   * @param type - the tensor element type.\n   * @param buffer - a TypedArray corresponding to the type.\n   * @param dims - specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   *\n   * @returns a tensor object\n   */\n  fromPinnedBuffer<T extends Exclude<Tensor.Type, 'string'>>(\n    type: T,\n    buffer: Tensor.DataTypeMap[T],\n    dims?: readonly number[],\n  ): TypedTensor<T>;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * A string that represents a file's URL or path.\n *\n * Path is vailable only in onnxruntime-node or onnxruntime-web running in Node.js.\n */\nexport type FileUrlOrPath = string;\n\n/**\n * A Blob object that represents a file.\n */\nexport type FileBlob = Blob;\n\n/**\n * A Uint8Array, ArrayBuffer or SharedArrayBuffer object that represents a file content.\n *\n * When it is an ArrayBuffer or SharedArrayBuffer, the whole buffer is assumed to be the file content.\n */\nexport type FileData = Uint8Array | ArrayBufferLike;\n\n/**\n * Represents a file that can be loaded by the ONNX Runtime JavaScript API.\n */\nexport type FileType = FileUrlOrPath | FileBlob | FileData;\n\n/**\n * Represents an external data file.\n */\nexport interface ExternalDataFileDescription {\n  /**\n   * Specify the external data file.\n   */\n  data: FileType;\n  /**\n   * Specify the file path.\n   */\n  path: string;\n}\n\n/**\n * Represents an external data file.\n *\n * When using a string, it should be a file URL or path that in the same directory as the model file.\n */\nexport type ExternalDataFileType = ExternalDataFileDescription | FileUrlOrPath;\n\n/**\n * Options for model loading.\n */\nexport interface OnnxModelOptions {\n  /**\n   * Specifying a list of files that represents the external data.\n   */\n  externalData?: readonly ExternalDataFileType[];\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from './tensor.js';\n\nexport type NonTensorType = never;\n\n/**\n * Type OnnxValue Represents both tensors and non-tensors value for model's inputs/outputs.\n *\n * NOTE: currently not support non-tensor\n */\nexport type OnnxValue = Tensor | NonTensorType;\n\n/**\n * Type OnnxValueDataLocation represents the location of the data of an OnnxValue.\n */\nexport type OnnxValueDataLocation = Tensor.DataLocation;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { resolveBackendAndExecutionProviders } from './backend-impl.js';\nimport { SessionHandler, TrainingSessionHandler } from './backend.js';\nimport { InferenceSession as InferenceSession } from './inference-session.js';\nimport { OnnxValue } from './onnx-value.js';\nimport { Tensor } from './tensor.js';\nimport { TrainingSession as TrainingSessionInterface, TrainingSessionCreateOptions } from './training-session.js';\n\ntype SessionOptions = InferenceSession.SessionOptions;\ntype FeedsType = InferenceSession.FeedsType;\ntype FetchesType = InferenceSession.FetchesType;\ntype ReturnType = InferenceSession.ReturnType;\ntype RunOptions = InferenceSession.RunOptions;\n\nconst noBackendErrMsg: string =\n  'Training backend could not be resolved. ' + \"Make sure you're using the correct configuration & WebAssembly files.\";\n\nexport class TrainingSession implements TrainingSessionInterface {\n  private constructor(handler: TrainingSessionHandler, hasOptimizerModel: boolean, hasEvalModel: boolean) {\n    this.handler = handler;\n    this.hasOptimizerModel = hasOptimizerModel;\n    this.hasEvalModel = hasEvalModel;\n  }\n  private handler: TrainingSessionHandler;\n  private hasOptimizerModel: boolean;\n  private hasEvalModel: boolean;\n\n  get trainingInputNames(): readonly string[] {\n    return this.handler.inputNames;\n  }\n  get trainingOutputNames(): readonly string[] {\n    return this.handler.outputNames;\n  }\n\n  get evalInputNames(): readonly string[] {\n    if (this.hasEvalModel) {\n      return this.handler.evalInputNames;\n    } else {\n      throw new Error('This training session has no evalModel loaded.');\n    }\n  }\n  get evalOutputNames(): readonly string[] {\n    if (this.hasEvalModel) {\n      return this.handler.evalOutputNames;\n    } else {\n      throw new Error('This training session has no evalModel loaded.');\n    }\n  }\n\n  static async create(\n    trainingOptions: TrainingSessionCreateOptions,\n    sessionOptions?: SessionOptions,\n  ): Promise<TrainingSession> {\n    const evalModel: string | Uint8Array = trainingOptions.evalModel || '';\n    const optimizerModel: string | Uint8Array = trainingOptions.optimizerModel || '';\n    const options: SessionOptions = sessionOptions || {};\n\n    // resolve backend, update session options with validated EPs, and create session handler\n    const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);\n    if (backend.createTrainingSessionHandler) {\n      const handler = await backend.createTrainingSessionHandler(\n        trainingOptions.checkpointState,\n        trainingOptions.trainModel,\n        evalModel,\n        optimizerModel,\n        optionsWithValidatedEPs,\n      );\n      return new TrainingSession(handler, !!trainingOptions.optimizerModel, !!trainingOptions.evalModel);\n    } else {\n      throw new Error(noBackendErrMsg);\n    }\n  }\n\n  /**\n   * Helper function for runTrainStep and future runStep methods that handles the type-narrowing conversion from\n   * the given parameters to SessionHandler.FetchesType and RunOptions.\n   *\n   * @param inputNames the feeds object is checked that they contain all input names in the provided list of input\n   * names.\n   * @param outputNames the fetches object is checked that their keys match up with valid names in the list of output\n   * names.\n   * @param feeds the required input\n   * @param arg1 narrowed & converted into the SessionHandler.FetchesType or RunOptions object\n   * @param arg2 optional RunOptions object.\n   * @returns\n   */\n  typeNarrowingForRunStep(\n    inputNames: readonly string[],\n    outputNames: readonly string[],\n    feeds: FeedsType,\n    arg1?: FetchesType | RunOptions,\n    arg2?: RunOptions,\n  ): [SessionHandler.FetchesType, RunOptions] {\n    const fetches: { [name: string]: OnnxValue | null } = {};\n    let options: RunOptions = {};\n    // check inputs\n    if (typeof feeds !== 'object' || feeds === null || feeds instanceof Tensor || Array.isArray(feeds)) {\n      throw new TypeError(\n        \"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\",\n      );\n    }\n\n    let isFetchesEmpty = true;\n    // determine which override is being used\n    if (typeof arg1 === 'object') {\n      if (arg1 === null) {\n        throw new TypeError('Unexpected argument[1]: cannot be null.');\n      }\n      if (arg1 instanceof Tensor) {\n        throw new TypeError(\"'fetches' cannot be a Tensor\");\n      }\n\n      if (Array.isArray(arg1)) {\n        if (arg1.length === 0) {\n          throw new TypeError(\"'fetches' cannot be an empty array.\");\n        }\n        isFetchesEmpty = false;\n        // output names\n        for (const name of arg1) {\n          if (typeof name !== 'string') {\n            throw new TypeError(\"'fetches' must be a string array or an object.\");\n          }\n          if (outputNames.indexOf(name) === -1) {\n            throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n          }\n          fetches[name] = null;\n        }\n\n        if (typeof arg2 === 'object' && arg2 !== null) {\n          options = arg2;\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError(\"'options' must be an object.\");\n        }\n      } else {\n        // decide whether arg1 is fetches or options\n        // if any output name is present and its value is valid OnnxValue, we consider it fetches\n        let isFetches = false;\n        const arg1Keys = Object.getOwnPropertyNames(arg1);\n        for (const name of outputNames) {\n          if (arg1Keys.indexOf(name) !== -1) {\n            const v = (arg1 as InferenceSession.NullableOnnxValueMapType)[name];\n            if (v === null || v instanceof Tensor) {\n              isFetches = true;\n              isFetchesEmpty = false;\n              fetches[name] = v;\n            }\n          }\n        }\n\n        if (isFetches) {\n          if (typeof arg2 === 'object' && arg2 !== null) {\n            options = arg2;\n          } else if (typeof arg2 !== 'undefined') {\n            throw new TypeError(\"'options' must be an object.\");\n          }\n        } else {\n          options = arg1 as RunOptions;\n        }\n      }\n    } else if (typeof arg1 !== 'undefined') {\n      throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n    }\n\n    // check if all inputs are in feed\n    for (const name of inputNames) {\n      if (typeof feeds[name] === 'undefined') {\n        throw new Error(`input '${name}' is missing in 'feeds'.`);\n      }\n    }\n\n    // if no fetches is specified, we use the full output names list\n    if (isFetchesEmpty) {\n      for (const name of outputNames) {\n        fetches[name] = null;\n      }\n    }\n\n    return [fetches, options];\n  }\n\n  /**\n   * Helper method for runTrainStep and any other runStep methods. Takes the ReturnType result from the SessionHandler\n   * and changes it into a map of Tensors.\n   *\n   * @param results\n   * @returns\n   */\n  convertHandlerReturnTypeToMapOfTensors(results: SessionHandler.ReturnType): ReturnType {\n    const returnValue: { [name: string]: OnnxValue } = {};\n    for (const key in results) {\n      if (Object.hasOwnProperty.call(results, key)) {\n        const result = results[key];\n        if (result instanceof Tensor) {\n          returnValue[key] = result;\n        } else {\n          returnValue[key] = new Tensor(result.type, result.data, result.dims);\n        }\n      }\n    }\n    return returnValue;\n  }\n\n  async lazyResetGrad(): Promise<void> {\n    await this.handler.lazyResetGrad();\n  }\n\n  runTrainStep(feeds: FeedsType, options?: RunOptions): Promise<ReturnType>;\n  runTrainStep(feeds: FeedsType, fetches: FetchesType, options?: RunOptions): Promise<ReturnType>;\n  async runTrainStep(feeds: FeedsType, arg1?: FetchesType | RunOptions, arg2?: RunOptions): Promise<ReturnType> {\n    const [fetches, options] = this.typeNarrowingForRunStep(\n      this.trainingInputNames,\n      this.trainingOutputNames,\n      feeds,\n      arg1,\n      arg2,\n    );\n    const results = await this.handler.runTrainStep(feeds, fetches, options);\n    return this.convertHandlerReturnTypeToMapOfTensors(results);\n  }\n\n  async runOptimizerStep(options?: InferenceSession.RunOptions | undefined): Promise<void> {\n    if (this.hasOptimizerModel) {\n      await this.handler.runOptimizerStep(options || {});\n    } else {\n      throw new Error('This TrainingSession has no OptimizerModel loaded.');\n    }\n  }\n\n  runEvalStep(feeds: FeedsType, options?: RunOptions | undefined): Promise<ReturnType>;\n  runEvalStep(feeds: FeedsType, fetches: FetchesType, options?: RunOptions | undefined): Promise<ReturnType>;\n  async runEvalStep(feeds: FeedsType, arg1?: FetchesType | RunOptions, arg2?: RunOptions): Promise<ReturnType> {\n    if (this.hasEvalModel) {\n      const [fetches, options] = this.typeNarrowingForRunStep(\n        this.evalInputNames,\n        this.evalOutputNames,\n        feeds,\n        arg1,\n        arg2,\n      );\n      const results = await this.handler.runEvalStep(feeds, fetches, options);\n      return this.convertHandlerReturnTypeToMapOfTensors(results);\n    } else {\n      throw new Error('This TrainingSession has no EvalModel loaded.');\n    }\n  }\n\n  async getParametersSize(trainableOnly = true): Promise<number> {\n    return this.handler.getParametersSize(trainableOnly);\n  }\n\n  async loadParametersBuffer(array: Uint8Array, trainableOnly = true): Promise<void> {\n    const paramsSize = await this.getParametersSize(trainableOnly);\n    // checking that the size of the Uint8Array is equivalent to the byte length of a Float32Array of the number\n    // of parameters\n    if (array.length !== 4 * paramsSize) {\n      throw new Error(\n        'Size of the buffer passed into loadParametersBuffer must match the number of parameters in ' +\n          'the model. Please use getParametersSize method to check.',\n      );\n    }\n    return this.handler.loadParametersBuffer(array, trainableOnly);\n  }\n\n  async getContiguousParameters(trainableOnly = true): Promise<OnnxValue> {\n    return this.handler.getContiguousParameters(trainableOnly);\n  }\n\n  async release(): Promise<void> {\n    return this.handler.dispose();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceSession } from './inference-session.js';\nimport { OnnxValue } from './onnx-value.js';\nimport { TrainingSession as TrainingSessionImpl } from './training-session-impl.js';\n\n/* eslint-disable @typescript-eslint/no-redeclare */\n\nexport declare namespace TrainingSession {\n  /**\n   * Either URI file path (string) or Uint8Array containing model or checkpoint information.\n   */\n  type UriOrBuffer = string | Uint8Array;\n}\n\n/**\n * Represent a runtime instance of an ONNX training session,\n * which contains a model that can be trained, and, optionally,\n * an eval and optimizer model.\n */\nexport interface TrainingSession {\n  // #region run()\n\n  /**\n   * Lazily resets the gradients of all trainable parameters to zero. Should happen after the invocation of\n   * runOptimizerStep.\n   */\n  lazyResetGrad(): Promise<void>;\n\n  /**\n   * Run TrainStep asynchronously with the given feeds and options.\n   *\n   * @param feeds - Representation of the model input. See type description of `InferenceSession.InputType` for\n   detail.\n   * @param options - Optional. A set of options that controls the behavior of model training.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding values.\n   */\n  runTrainStep(\n    feeds: InferenceSession.FeedsType,\n    options?: InferenceSession.RunOptions,\n  ): Promise<InferenceSession.ReturnType>;\n\n  /**\n   * Run a single train step with the given inputs and options.\n   *\n   * @param feeds - Representation of the model input.\n   * @param fetches - Representation of the model output.\n   * detail.\n   * @param options - Optional. A set of options that controls the behavior of model training.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding\n   values.\n   */\n  runTrainStep(\n    feeds: InferenceSession.FeedsType,\n    fetches: InferenceSession.FetchesType,\n    options?: InferenceSession.RunOptions,\n  ): Promise<InferenceSession.ReturnType>;\n\n  /**\n   * Runs a single optimizer step, which performs weight updates for the trainable parameters using the optimizer model.\n   *\n   * @param options - Optional. A set of options that controls the behavior of model optimizing.\n   */\n  runOptimizerStep(options?: InferenceSession.RunOptions): Promise<void>;\n\n  /**\n   * Run a single eval step with the given inputs and options using the eval model.\n   *\n   * @param feeds - Representation of the model input.\n   * @param options - Optional. A set of options that controls the behavior of model eval step.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding\n   values.\n   */\n  runEvalStep(\n    feeds: InferenceSession.FeedsType,\n    options?: InferenceSession.RunOptions,\n  ): Promise<InferenceSession.ReturnType>;\n\n  /**\n   * Run a single eval step with the given inputs and options using the eval model.\n   *\n   * @param feeds - Representation of the model input.\n   * @param fetches - Representation of the model output.\n   * detail.\n   * @param options - Optional. A set of options that controls the behavior of model eval step.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding\n   values.\n   */\n  runEvalStep(\n    feeds: InferenceSession.FeedsType,\n    fetches: InferenceSession.FetchesType,\n    options?: InferenceSession.RunOptions,\n  ): Promise<InferenceSession.ReturnType>;\n\n  // #endregion\n\n  // #region copy parameters\n\n  /**\n   * Retrieves the size of all parameters for the training state. Calculates the total number of primitive (datatype of\n   * the parameters) elements of all the parameters in the training state.\n   *\n   * @param trainableOnly - When set to true, the size is calculated for trainable params only. Default value is true.\n   */\n  getParametersSize(trainableOnly: boolean): Promise<number>;\n\n  /**\n   * Copies parameter values from the given buffer to the training state. Currently, only supporting models with\n   * parameters of type Float32.\n   *\n   * @param buffer - A Uint8Array representation of Float32 parameters.\n   * @param trainableOnly - True if trainable parameters only to be modified, false otherwise. Default value is true.\n   */\n  loadParametersBuffer(buffer: Uint8Array, trainableOnly: boolean): Promise<void>;\n\n  /**\n   * Copies the model parameters to a contiguous buffer. Usually used in the context of Federated Learning.\n   * Currently, only supporting models with parameters of type Float32.\n   *\n   * @param trainableOnly - When set to true, only trainable parameters are copied. Trainable parameters are parameters\n   * for which requires_grad is set to true. Default value is true.\n   * @returns A promise that resolves to a Float32 OnnxValue of the requested parameters.\n   */\n  getContiguousParameters(trainableOnly: boolean): Promise<OnnxValue>;\n  // #endregion\n\n  // #region release()\n\n  /**\n   * Release the inference session and the underlying resources.\n   */\n  release(): Promise<void>;\n  // #endregion\n\n  // #region metadata\n\n  /**\n   * Get input names of the loaded training model.\n   */\n  readonly trainingInputNames: readonly string[];\n\n  /**\n   * Get output names of the loaded training model.\n   */\n  readonly trainingOutputNames: readonly string[];\n\n  /**\n   * Get input names of the loaded eval model. Is an empty array if no eval model is loaded.\n   */\n  readonly evalInputNames: readonly string[];\n\n  /**\n   * Get output names of the loaded eval model. Is an empty array if no eval model is loaded.\n   */\n  readonly evalOutputNames: readonly string[];\n\n  // #endregion\n}\n\n/**\n * Represents the optional parameters that can be passed into the TrainingSessionFactory.\n */\nexport interface TrainingSessionCreateOptions {\n  /**\n   * URI or buffer for a .ckpt file that contains the checkpoint for the training model.\n   */\n  checkpointState: TrainingSession.UriOrBuffer;\n  /**\n   * URI or buffer for the .onnx training file.\n   */\n  trainModel: TrainingSession.UriOrBuffer;\n  /**\n   * Optional. URI or buffer for the .onnx optimizer model file.\n   */\n  optimizerModel?: TrainingSession.UriOrBuffer;\n  /**\n   * Optional. URI or buffer for the .onnx eval model file.\n   */\n  evalModel?: TrainingSession.UriOrBuffer;\n}\n\n/**\n * Defines method overload possibilities for creating a TrainingSession.\n */\nexport interface TrainingSessionFactory {\n  // #region create()\n\n  /**\n   * Creates a new TrainingSession and asynchronously loads any models passed in through trainingOptions\n   *\n   * @param trainingOptions specify models and checkpoints to load into the Training Session\n   * @param sessionOptions specify configuration for training session behavior\n   *\n   * @returns Promise that resolves to a TrainingSession object\n   */\n  create(\n    trainingOptions: TrainingSessionCreateOptions,\n    sessionOptions?: InferenceSession.SessionOptions,\n  ): Promise<TrainingSession>;\n\n  // #endregion\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const TrainingSession: TrainingSessionFactory = TrainingSessionImpl;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * # ONNX Runtime JavaScript API\n *\n * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:\n *\n * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)\n * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)\n * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)\n *\n * See also:\n * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript/)\n * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)\n *\n * @packageDocumentation\n */\n\nexport * from './backend.js';\nexport * from './env.js';\nexport * from './inference-session.js';\nexport * from './tensor.js';\nexport * from './tensor-conversion.js';\nexport * from './tensor-factory.js';\nexport * from './trace.js';\nexport * from './onnx-model.js';\nexport * from './onnx-value.js';\nexport * from './training-session.js';\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Env } from 'onnxruntime-common';\n\nimport { WebGLContext } from './backends/webgl/webgl-context';\n\nexport declare namespace Logger {\n  export interface SeverityTypeMap {\n    verbose: 'v';\n    info: 'i';\n    warning: 'w';\n    error: 'e';\n    fatal: 'f';\n  }\n\n  export type Severity = keyof SeverityTypeMap;\n\n  export type Provider = 'none' | 'console';\n\n  /**\n   * Logging config that used to control the behavior of logger\n   */\n  export interface Config {\n    /**\n     * Specify the logging provider. 'console' by default\n     */\n    provider?: Provider;\n    /**\n     * Specify the minimal logger serverity. 'warning' by default\n     */\n    minimalSeverity?: Logger.Severity;\n    /**\n     * Whether to output date time in log. true by default\n     */\n    logDateTime?: boolean;\n    /**\n     * Whether to output source information (Not yet supported). false by default\n     */\n    logSourceLocation?: boolean;\n  }\n\n  export interface CategorizedLogger {\n    verbose(content: string): void;\n    info(content: string): void;\n    warning(content: string): void;\n    error(content: string): void;\n    fatal(content: string): void;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport interface Logger {\n  (category: string): Logger.CategorizedLogger;\n\n  verbose(content: string): void;\n  verbose(category: string, content: string): void;\n  info(content: string): void;\n  info(category: string, content: string): void;\n  warning(content: string): void;\n  warning(category: string, content: string): void;\n  error(content: string): void;\n  error(category: string, content: string): void;\n  fatal(content: string): void;\n  fatal(category: string, content: string): void;\n\n  /**\n   * Reset the logger configuration.\n   * @param config specify an optional default config\n   */\n  reset(config?: Logger.Config): void;\n  /**\n   * Set the logger's behavior on the given category\n   * @param category specify a category string. If '*' is specified, all previous configuration will be overwritten. If\n   * '' is specified, the default behavior will be updated.\n   * @param config the config object to indicate the logger's behavior\n   */\n  set(category: string, config: Logger.Config): void;\n\n  /**\n   * Set the logger's behavior from ort-common env\n   * @param env the env used to set logger. Currently only setting loglevel is supported through Env.\n   */\n  setWithEnv(env: Env): void;\n}\n\ninterface LoggerProvider {\n  log(severity: Logger.Severity, content: string, category?: string): void;\n}\nclass NoOpLoggerProvider implements LoggerProvider {\n  log(_severity: Logger.Severity, _content: string, _category?: string) {\n    // do nothing\n  }\n}\nclass ConsoleLoggerProvider implements LoggerProvider {\n  log(severity: Logger.Severity, content: string, category?: string) {\n    // eslint-disable-next-line no-console\n    console.log(`${this.color(severity)} ${category ? '\\x1b[35m' + category + '\\x1b[0m ' : ''}${content}`);\n  }\n\n  private color(severity: Logger.Severity) {\n    switch (severity) {\n      case 'verbose':\n        return '\\x1b[34;40mv\\x1b[0m';\n      case 'info':\n        return '\\x1b[32mi\\x1b[0m';\n      case 'warning':\n        return '\\x1b[30;43mw\\x1b[0m';\n      case 'error':\n        return '\\x1b[31;40me\\x1b[0m';\n      case 'fatal':\n        return '\\x1b[101mf\\x1b[0m';\n      default:\n        throw new Error(`unsupported severity: ${severity}`);\n    }\n  }\n}\n\nconst SEVERITY_VALUE = {\n  verbose: 1000,\n  info: 2000,\n  warning: 4000,\n  error: 5000,\n  fatal: 6000,\n};\n\nconst LOGGER_PROVIDER_MAP: { readonly [provider: string]: Readonly<LoggerProvider> } = {\n  ['none']: new NoOpLoggerProvider(),\n  ['console']: new ConsoleLoggerProvider(),\n};\nconst LOGGER_DEFAULT_CONFIG = {\n  provider: 'console',\n  minimalSeverity: 'warning',\n  logDateTime: true,\n  logSourceLocation: false,\n};\nlet LOGGER_CONFIG_MAP: { [category: string]: Readonly<Required<Logger.Config>> } = {\n  ['']: LOGGER_DEFAULT_CONFIG as Required<Logger.Config>,\n};\n\nfunction log(category: string): Logger.CategorizedLogger;\nfunction log(severity: Logger.Severity, content: string): void;\nfunction log(severity: Logger.Severity, category: string, content: string): void;\nfunction log(severity: Logger.Severity, arg1: string, arg2?: string): void;\nfunction log(\n  arg0: string | Logger.Severity,\n  arg1?: string,\n  arg2?: string | number,\n  arg3?: number,\n): Logger.CategorizedLogger | void {\n  if (arg1 === undefined) {\n    // log(category: string): Logger.CategorizedLogger;\n    return createCategorizedLogger(arg0);\n  } else if (arg2 === undefined) {\n    // log(severity, content);\n    logInternal(arg0 as Logger.Severity, arg1, 1);\n  } else if (typeof arg2 === 'number' && arg3 === undefined) {\n    // log(severity, content, stack)\n    logInternal(arg0 as Logger.Severity, arg1, arg2);\n  } else if (typeof arg2 === 'string' && arg3 === undefined) {\n    // log(severity, category, content)\n    logInternal(arg0 as Logger.Severity, arg2, 1, arg1);\n  } else if (typeof arg2 === 'string' && typeof arg3 === 'number') {\n    // log(severity, category, content, stack)\n    logInternal(arg0 as Logger.Severity, arg2, arg3, arg1);\n  } else {\n    throw new TypeError('input is valid');\n  }\n}\n\nfunction createCategorizedLogger(category: string): Logger.CategorizedLogger {\n  return {\n    verbose: log.verbose.bind(null, category),\n    info: log.info.bind(null, category),\n    warning: log.warning.bind(null, category),\n    error: log.error.bind(null, category),\n    fatal: log.fatal.bind(null, category),\n  };\n}\n\n// NOTE: argument 'category' is put the last parameter beacause typescript\n// doesn't allow optional argument put in front of required argument. This\n// order is different from a usual logging API.\nfunction logInternal(severity: Logger.Severity, content: string, _stack: number, category?: string) {\n  const config = LOGGER_CONFIG_MAP[category || ''] || LOGGER_CONFIG_MAP[''];\n  if (SEVERITY_VALUE[severity] < SEVERITY_VALUE[config.minimalSeverity]) {\n    return;\n  }\n\n  if (config.logDateTime) {\n    content = `${new Date().toISOString()}|${content}`;\n  }\n\n  if (config.logSourceLocation) {\n    // TODO: calculate source location from 'stack'\n  }\n\n  LOGGER_PROVIDER_MAP[config.provider].log(severity, content, category);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nnamespace log {\n  export function verbose(content: string): void;\n  export function verbose(category: string, content: string): void;\n  export function verbose(arg0: string, arg1?: string) {\n    log('verbose', arg0, arg1);\n  }\n  export function info(content: string): void;\n  export function info(category: string, content: string): void;\n  export function info(arg0: string, arg1?: string) {\n    log('info', arg0, arg1);\n  }\n  export function warning(content: string): void;\n  export function warning(category: string, content: string): void;\n  export function warning(arg0: string, arg1?: string) {\n    log('warning', arg0, arg1);\n  }\n  export function error(content: string): void;\n  export function error(category: string, content: string): void;\n  export function error(arg0: string, arg1?: string) {\n    log('error', arg0, arg1);\n  }\n  export function fatal(content: string): void;\n  export function fatal(category: string, content: string): void;\n  export function fatal(arg0: string, arg1?: string) {\n    log('fatal', arg0, arg1);\n  }\n\n  export function reset(config?: Logger.Config): void {\n    LOGGER_CONFIG_MAP = {};\n    set('', config || {});\n  }\n  export function set(category: string, config: Logger.Config): void {\n    if (category === '*') {\n      reset(config);\n    } else {\n      const previousConfig = LOGGER_CONFIG_MAP[category] || LOGGER_DEFAULT_CONFIG;\n      LOGGER_CONFIG_MAP[category] = {\n        provider: config.provider || previousConfig.provider,\n        minimalSeverity: config.minimalSeverity || previousConfig.minimalSeverity,\n        logDateTime: config.logDateTime === undefined ? previousConfig.logDateTime : config.logDateTime,\n        logSourceLocation:\n          config.logSourceLocation === undefined ? previousConfig.logSourceLocation : config.logSourceLocation,\n      };\n    }\n\n    // TODO: we want to support wildcard or regex?\n  }\n\n  export function setWithEnv(env: Env): void {\n    const config: Logger.Config = {};\n    if (env.logLevel) {\n      config.minimalSeverity = env.logLevel as Logger.Severity;\n    }\n    set('', config);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare, @typescript-eslint/naming-convention\nexport const Logger: Logger = log;\n\nexport declare namespace Profiler {\n  export interface Config {\n    maxNumberEvents?: number;\n    flushBatchSize?: number;\n    flushIntervalInMilliseconds?: number;\n  }\n\n  export type EventCategory = 'session' | 'node' | 'op' | 'backend';\n\n  export interface Event {\n    end(): void | Promise<void>;\n  }\n}\n// TODO\n// class WebGLEvent implements Profiler.Event {}\n\nclass Event implements Profiler.Event {\n  constructor(\n    public category: Profiler.EventCategory,\n    public name: string,\n    public startTime: number,\n    private endCallback: (e: Event) => void | Promise<void>,\n    public timer?: WebGLQuery,\n    public ctx?: WebGLContext,\n  ) {}\n\n  async end() {\n    return this.endCallback(this);\n  }\n\n  async checkTimer(): Promise<number> {\n    if (this.ctx === undefined || this.timer === undefined) {\n      throw new Error('No webgl timer found');\n    } else {\n      this.ctx.endTimer();\n      return this.ctx.waitForQueryAndGetTime(this.timer);\n    }\n  }\n}\n\nclass EventRecord {\n  constructor(\n    public category: Profiler.EventCategory,\n    public name: string,\n    public startTime: number,\n    public endTime: number,\n  ) {}\n}\n\nexport class Profiler {\n  static create(config?: Profiler.Config): Profiler {\n    if (config === undefined) {\n      return new this();\n    }\n    return new this(config.maxNumberEvents, config.flushBatchSize, config.flushIntervalInMilliseconds);\n  }\n\n  private constructor(maxNumberEvents?: number, flushBatchSize?: number, flushIntervalInMilliseconds?: number) {\n    this._started = false;\n    this._maxNumberEvents = maxNumberEvents === undefined ? 10000 : maxNumberEvents;\n    this._flushBatchSize = flushBatchSize === undefined ? 10 : flushBatchSize;\n    this._flushIntervalInMilliseconds = flushIntervalInMilliseconds === undefined ? 5000 : flushIntervalInMilliseconds;\n  }\n\n  // start profiling\n  start() {\n    this._started = true;\n    this._timingEvents = [];\n    this._flushTime = now();\n    this._flushPointer = 0;\n  }\n\n  // stop profiling\n  stop() {\n    this._started = false;\n    for (; this._flushPointer < this._timingEvents.length; this._flushPointer++) {\n      this.logOneEvent(this._timingEvents[this._flushPointer]);\n    }\n  }\n\n  // create an event scope for the specific function\n  event<T>(category: Profiler.EventCategory, name: string, func: () => T, ctx?: WebGLContext): T;\n  event<T>(category: Profiler.EventCategory, name: string, func: () => Promise<T>, ctx?: WebGLContext): Promise<T>;\n\n  event<T>(\n    category: Profiler.EventCategory,\n    name: string,\n    func: () => T | Promise<T>,\n    ctx?: WebGLContext,\n  ): T | Promise<T> {\n    const event = this._started ? this.begin(category, name, ctx) : undefined;\n    let isPromise = false;\n\n    const res = func();\n\n    // we consider a then-able object is a promise\n    if (res && typeof (res as Promise<T>).then === 'function') {\n      isPromise = true;\n      return new Promise<T>((resolve, reject) => {\n        (res as Promise<T>).then(\n          async (value) => {\n            // fulfilled\n            if (event) {\n              await event.end();\n            }\n            resolve(value);\n          },\n          async (reason) => {\n            // rejected\n            if (event) {\n              await event.end();\n            }\n            reject(reason);\n          },\n        );\n      });\n    }\n    if (!isPromise && event) {\n      const eventRes = event.end();\n      if (eventRes && typeof eventRes.then === 'function') {\n        return new Promise<T>((resolve, reject) => {\n          eventRes.then(\n            () => {\n              // fulfilled\n              resolve(res);\n            },\n            (reason) => {\n              // rejected\n              reject(reason);\n            },\n          );\n        });\n      }\n    }\n    return res;\n  }\n\n  // begin an event\n  begin(category: Profiler.EventCategory, name: string, ctx?: WebGLContext): Event {\n    if (!this._started) {\n      throw new Error('profiler is not started yet');\n    }\n    if (ctx === undefined) {\n      const startTime = now();\n      this.flush(startTime);\n      return new Event(category, name, startTime, (e) => this.endSync(e));\n    } else {\n      const timer: WebGLQuery = ctx.beginTimer();\n      return new Event(category, name, 0, async (e) => this.end(e), timer, ctx);\n    }\n  }\n\n  // end the specific event\n  private async end(event: Event): Promise<void> {\n    const endTime: number = await event.checkTimer();\n    if (this._timingEvents.length < this._maxNumberEvents) {\n      this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));\n      this.flush(endTime);\n    }\n  }\n\n  private endSync(event: Event): void {\n    const endTime: number = now();\n    if (this._timingEvents.length < this._maxNumberEvents) {\n      this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));\n      this.flush(endTime);\n    }\n  }\n\n  private logOneEvent(event: EventRecord) {\n    Logger.verbose(\n      `Profiler.${event.category}`,\n      `${(event.endTime - event.startTime).toFixed(2)}ms on event '${event.name}' at ${event.endTime.toFixed(2)}`,\n    );\n  }\n\n  private flush(currentTime: number) {\n    if (\n      this._timingEvents.length - this._flushPointer >= this._flushBatchSize ||\n      currentTime - this._flushTime >= this._flushIntervalInMilliseconds\n    ) {\n      // should flush when either batch size accumlated or interval elepsed\n\n      for (\n        const previousPointer = this._flushPointer;\n        this._flushPointer < previousPointer + this._flushBatchSize && this._flushPointer < this._timingEvents.length;\n        this._flushPointer++\n      ) {\n        this.logOneEvent(this._timingEvents[this._flushPointer]);\n      }\n\n      this._flushTime = now();\n    }\n  }\n\n  get started() {\n    return this._started;\n  }\n  private _started = false;\n  private _timingEvents: EventRecord[];\n\n  private readonly _maxNumberEvents: number;\n\n  private readonly _flushBatchSize: number;\n  private readonly _flushIntervalInMilliseconds: number;\n\n  private _flushTime: number;\n  private _flushPointer = 0;\n}\n\n/**\n * returns a number to represent the current timestamp in a resolution as high as possible.\n */\nexport const now = typeof performance !== 'undefined' && performance.now ? () => performance.now() : Date.now;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from './graph';\nimport { OperatorImplementation, OperatorInitialization } from './operators';\n\nexport interface OpSet {\n  domain: string;\n  version: number;\n}\nexport declare namespace OpSet {\n  /**\n   * Domain of an opset, it can be an empty string(default value, represent for ai.onnx), or 'ai.onnx.ml'\n   */\n  type Domain = '' | 'ai.onnx.ml' | 'com.microsoft';\n  /**\n   * A resolve rule consists of 4 or 5 items: opType, opSetDomain, versionSelector, operatorImplementation and\n   * operatorInitialization (optional)\n   */\n  type ResolveRule =\n    | [string, Domain, string, OperatorImplementation<Graph.Node>]\n    | [string, Domain, string, OperatorImplementation<unknown>, OperatorInitialization<unknown>];\n}\n\nexport function resolveOperator(node: Graph.Node, opsets: readonly OpSet[], rules: readonly OpSet.ResolveRule[]) {\n  for (const rule of rules) {\n    const opType = rule[0];\n    const domain = rule[1];\n    const versionSelector = rule[2];\n    const opImpl = rule[3];\n    const opInit = rule[4];\n\n    if (node.opType === opType) {\n      // operator type matches\n      for (const opset of opsets) {\n        // opset '' and 'ai.onnx' are considered the same.\n        if (opset.domain === domain || (opset.domain === 'ai.onnx' && domain === '')) {\n          // opset domain found\n          if (matchSelector(opset.version, versionSelector)) {\n            return { opImpl, opInit };\n          }\n        }\n      }\n    }\n  }\n\n  throw new TypeError(\n    `cannot resolve operator '${node.opType}' with opsets: ${opsets\n      .map((set) => `${set.domain || 'ai.onnx'} v${set.version}`)\n      .join(', ')}`,\n  );\n}\n\nfunction matchSelector(version: number, selector: string): boolean {\n  if (selector.endsWith('+')) {\n    // minimum version match ('7+' expects version>=7)\n    const rangeStart = Number.parseInt(selector.substring(0, selector.length - 1), 10);\n    return !isNaN(rangeStart) && rangeStart <= version;\n  } else if (selector.split('-').length === 2) {\n    // range match ('6-8' expects 6<=version<=8)\n    const pair = selector.split('-');\n    const rangeStart = Number.parseInt(pair[0], 10);\n    const rangeEnd = Number.parseInt(pair[1], 10);\n    return !isNaN(rangeStart) && !isNaN(rangeEnd) && rangeStart <= version && version <= rangeEnd;\n  } else {\n    // exact match ('7' expects version===7)\n    return Number.parseInt(selector, 10) === version;\n  }\n}\n","\"use strict\";\r\nexports.__esModule = true;\r\nvar Guid = /** @class */ (function () {\r\n    function Guid(guid) {\r\n        if (!guid) {\r\n            throw new TypeError(\"Invalid argument; `value` has no value.\");\r\n        }\r\n        this.value = Guid.EMPTY;\r\n        if (guid && Guid.isGuid(guid)) {\r\n            this.value = guid;\r\n        }\r\n    }\r\n    Guid.isGuid = function (guid) {\r\n        var value = guid.toString();\r\n        return guid && (guid instanceof Guid || Guid.validator.test(value));\r\n    };\r\n    Guid.create = function () {\r\n        return new Guid([Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join(\"-\"));\r\n    };\r\n    Guid.createEmpty = function () {\r\n        return new Guid(\"emptyguid\");\r\n    };\r\n    Guid.parse = function (guid) {\r\n        return new Guid(guid);\r\n    };\r\n    Guid.raw = function () {\r\n        return [Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join(\"-\");\r\n    };\r\n    Guid.gen = function (count) {\r\n        var out = \"\";\r\n        for (var i = 0; i < count; i++) {\r\n            // tslint:disable-next-line:no-bitwise\r\n            out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\r\n        }\r\n        return out;\r\n    };\r\n    Guid.prototype.equals = function (other) {\r\n        // Comparing string `value` against provided `guid` will auto-call\r\n        // toString on `guid` for comparison\r\n        return Guid.isGuid(other) && this.value === other.toString();\r\n    };\r\n    Guid.prototype.isEmpty = function () {\r\n        return this.value === Guid.EMPTY;\r\n    };\r\n    Guid.prototype.toString = function () {\r\n        return this.value;\r\n    };\r\n    Guid.prototype.toJSON = function () {\r\n        return {\r\n            value: this.value\r\n        };\r\n    };\r\n    Guid.validator = new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\", \"i\");\r\n    Guid.EMPTY = \"00000000-0000-0000-0000-000000000000\";\r\n    return Guid;\r\n}());\r\nexports.Guid = Guid;\r\n","/**\n * @license\n * Copyright 2009 The Closure Library Authors\n * Copyright 2020 Daniel Wirtz / The long.js Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// WebAssembly optimizations to do native i64 multiplication and divide\nvar wasm = null;\ntry {\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\n  ])), {}).exports;\n} catch (e) {\n  // no wasm support :(\n}\n\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n *  See the from* functions below for more convenient ways of constructing Longs.\n * @exports Long\n * @class A Long class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @constructor\n */\nfunction Long(low, high, unsigned) {\n\n  /**\n   * The low 32 bits as a signed value.\n   * @type {number}\n   */\n  this.low = low | 0;\n\n  /**\n   * The high 32 bits as a signed value.\n   * @type {number}\n   */\n  this.high = high | 0;\n\n  /**\n   * Whether unsigned or not.\n   * @type {boolean}\n   */\n  this.unsigned = !!unsigned;\n}\n\n// The internal representation of a long is the two given signed, 32-bit values.\n// We use 32-bit pieces because these are the size of integers on which\n// Javascript performs bit-operations.  For operations like addition and\n// multiplication, we split each number into 16 bit pieces, which can easily be\n// multiplied within Javascript's floating-point representation without overflow\n// or change in sign.\n//\n// In the algorithms below, we frequently reduce the negative case to the\n// positive case by negating the input(s) and then post-processing the result.\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n// a positive number, it overflows back into a negative).  Not handling this\n// case would often result in infinite recursion.\n//\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n// methods on which they depend.\n\n/**\n * An indicator used to reliably determine if an object is a Long or not.\n * @type {boolean}\n * @const\n * @private\n */\nLong.prototype.__isLong__;\n\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\n\n/**\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n * @inner\n */\nfunction isLong(obj) {\n  return (obj && obj[\"__isLong__\"]) === true;\n}\n\n/**\n * @function\n * @param {*} value number\n * @returns {number}\n * @inner\n */\nfunction ctz32(value) {\n  var c = Math.clz32(value & -value);\n  return value ? 31 - c : c;\n}\n\n/**\n * Tests if the specified object is a Long.\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n */\nLong.isLong = isLong;\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @inner\n */\nvar INT_CACHE = {};\n\n/**\n * A cache of the Long representations of small unsigned integer values.\n * @type {!Object}\n * @inner\n */\nvar UINT_CACHE = {};\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromInt(value, unsigned) {\n  var obj, cachedObj, cache;\n  if (unsigned) {\n    value >>>= 0;\n    if (cache = (0 <= value && value < 256)) {\n      cachedObj = UINT_CACHE[value];\n      if (cachedObj)\n        return cachedObj;\n    }\n    obj = fromBits(value, 0, true);\n    if (cache)\n      UINT_CACHE[value] = obj;\n    return obj;\n  } else {\n    value |= 0;\n    if (cache = (-128 <= value && value < 128)) {\n      cachedObj = INT_CACHE[value];\n      if (cachedObj)\n        return cachedObj;\n    }\n    obj = fromBits(value, value < 0 ? -1 : 0, false);\n    if (cache)\n      INT_CACHE[value] = obj;\n    return obj;\n  }\n}\n\n/**\n * Returns a Long representing the given 32 bit integer value.\n * @function\n * @param {number} value The 32 bit integer in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromInt = fromInt;\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromNumber(value, unsigned) {\n  if (isNaN(value))\n    return unsigned ? UZERO : ZERO;\n  if (unsigned) {\n    if (value < 0)\n      return UZERO;\n    if (value >= TWO_PWR_64_DBL)\n      return MAX_UNSIGNED_VALUE;\n  } else {\n    if (value <= -TWO_PWR_63_DBL)\n      return MIN_VALUE;\n    if (value + 1 >= TWO_PWR_63_DBL)\n      return MAX_VALUE;\n  }\n  if (value < 0)\n    return fromNumber(-value, unsigned).neg();\n  return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\n}\n\n/**\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @function\n * @param {number} value The number in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromNumber = fromNumber;\n\n/**\n * @param {number} lowBits\n * @param {number} highBits\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromBits(lowBits, highBits, unsigned) {\n  return new Long(lowBits, highBits, unsigned);\n}\n\n/**\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @function\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromBits = fromBits;\n\n/**\n * @function\n * @param {number} base\n * @param {number} exponent\n * @returns {number}\n * @inner\n */\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n\n/**\n * @param {string} str\n * @param {(boolean|number)=} unsigned\n * @param {number=} radix\n * @returns {!Long}\n * @inner\n */\nfunction fromString(str, unsigned, radix) {\n  if (str.length === 0)\n    throw Error('empty string');\n  if (typeof unsigned === 'number') {\n    // For goog.math.long compatibility\n    radix = unsigned;\n    unsigned = false;\n  } else {\n    unsigned = !!unsigned;\n  }\n  if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n    return unsigned ? UZERO : ZERO;\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix)\n    throw RangeError('radix');\n\n  var p;\n  if ((p = str.indexOf('-')) > 0)\n    throw Error('interior hyphen');\n  else if (p === 0) {\n    return fromString(str.substring(1), unsigned, radix).neg();\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = fromNumber(pow_dbl(radix, 8));\n\n  var result = ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i),\n      value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = fromNumber(pow_dbl(radix, size));\n      result = result.mul(power).add(fromNumber(value));\n    } else {\n      result = result.mul(radixToPower);\n      result = result.add(fromNumber(value));\n    }\n  }\n  result.unsigned = unsigned;\n  return result;\n}\n\n/**\n * Returns a Long representation of the given string, written using the specified radix.\n * @function\n * @param {string} str The textual representation of the Long\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Long} The corresponding Long value\n */\nLong.fromString = fromString;\n\n/**\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromValue(val, unsigned) {\n  if (typeof val === 'number')\n    return fromNumber(val, unsigned);\n  if (typeof val === 'string')\n    return fromString(val, unsigned);\n  // Throws for non-objects, converts non-instanceof Long:\n  return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n}\n\n/**\n * Converts the specified value to a Long using the appropriate from* function for its type.\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long}\n */\nLong.fromValue = fromValue;\n\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n// no runtime penalty for these.\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_16_DBL = 1 << 16;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_24_DBL = 1 << 24;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n\n/**\n * @type {!Long}\n * @const\n * @inner\n */\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ZERO = fromInt(0);\n\n/**\n * Signed zero.\n * @type {!Long}\n */\nLong.ZERO = ZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UZERO = fromInt(0, true);\n\n/**\n * Unsigned zero.\n * @type {!Long}\n */\nLong.UZERO = UZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ONE = fromInt(1);\n\n/**\n * Signed one.\n * @type {!Long}\n */\nLong.ONE = ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UONE = fromInt(1, true);\n\n/**\n * Unsigned one.\n * @type {!Long}\n */\nLong.UONE = UONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar NEG_ONE = fromInt(-1);\n\n/**\n * Signed negative one.\n * @type {!Long}\n */\nLong.NEG_ONE = NEG_ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n\n/**\n * Maximum signed value.\n * @type {!Long}\n */\nLong.MAX_VALUE = MAX_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n\n/**\n * Maximum unsigned value.\n * @type {!Long}\n */\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n\n/**\n * Minimum signed value.\n * @type {!Long}\n */\nLong.MIN_VALUE = MIN_VALUE;\n\n/**\n * @alias Long.prototype\n * @inner\n */\nvar LongPrototype = Long.prototype;\n\n/**\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toInt = function toInt() {\n  return this.unsigned ? this.low >>> 0 : this.low;\n};\n\n/**\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toNumber = function toNumber() {\n  if (this.unsigned)\n    return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\n  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n};\n\n/**\n * Converts the Long to a string written in the specified radix.\n * @this {!Long}\n * @param {number=} radix Radix (2-36), defaults to 10\n * @returns {string}\n * @override\n * @throws {RangeError} If `radix` is out of range\n */\nLongPrototype.toString = function toString(radix) {\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix)\n    throw RangeError('radix');\n  if (this.isZero())\n    return '0';\n  if (this.isNegative()) { // Unsigned Longs are never negative\n    if (this.eq(MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = fromNumber(radix),\n        div = this.div(radixLong),\n        rem1 = div.mul(radixLong).sub(this);\n      return div.toString(radix) + rem1.toInt().toString(radix);\n    } else\n      return '-' + this.neg().toString(radix);\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\n    rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower),\n      intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\n      digits = intval.toString(radix);\n    rem = remDiv;\n    if (rem.isZero())\n      return digits + result;\n    else {\n      while (digits.length < 6)\n        digits = '0' + digits;\n      result = '' + digits + result;\n    }\n  }\n};\n\n/**\n * Gets the high 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed high bits\n */\nLongPrototype.getHighBits = function getHighBits() {\n  return this.high;\n};\n\n/**\n * Gets the high 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned high bits\n */\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n  return this.high >>> 0;\n};\n\n/**\n * Gets the low 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed low bits\n */\nLongPrototype.getLowBits = function getLowBits() {\n  return this.low;\n};\n\n/**\n * Gets the low 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned low bits\n */\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n  return this.low >>> 0;\n};\n\n/**\n * Gets the number of bits needed to represent the absolute value of this Long.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n  if (this.isNegative()) // Unsigned Longs are never negative\n    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n  var val = this.high != 0 ? this.high : this.low;\n  for (var bit = 31; bit > 0; bit--)\n    if ((val & (1 << bit)) != 0)\n      break;\n  return this.high != 0 ? bit + 33 : bit + 1;\n};\n\n/**\n * Tests if this Long's value equals zero.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isZero = function isZero() {\n  return this.high === 0 && this.low === 0;\n};\n\n/**\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n * @returns {boolean}\n */\nLongPrototype.eqz = LongPrototype.isZero;\n\n/**\n * Tests if this Long's value is negative.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isNegative = function isNegative() {\n  return !this.unsigned && this.high < 0;\n};\n\n/**\n * Tests if this Long's value is positive or zero.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isPositive = function isPositive() {\n  return this.unsigned || this.high >= 0;\n};\n\n/**\n * Tests if this Long's value is odd.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isOdd = function isOdd() {\n  return (this.low & 1) === 1;\n};\n\n/**\n * Tests if this Long's value is even.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isEven = function isEven() {\n  return (this.low & 1) === 0;\n};\n\n/**\n * Tests if this Long's value equals the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.equals = function equals(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\n    return false;\n  return this.high === other.high && this.low === other.low;\n};\n\n/**\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.eq = LongPrototype.equals;\n\n/**\n * Tests if this Long's value differs from the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.notEquals = function notEquals(other) {\n  return !this.eq(/* validates */ other);\n};\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.neq = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ne = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value is less than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThan = function lessThan(other) {\n  return this.comp(/* validates */ other) < 0;\n};\n\n/**\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lt = LongPrototype.lessThan;\n\n/**\n * Tests if this Long's value is less than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n  return this.comp(/* validates */ other) <= 0;\n};\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.le = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThan = function greaterThan(other) {\n  return this.comp(/* validates */ other) > 0;\n};\n\n/**\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gt = LongPrototype.greaterThan;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n  return this.comp(/* validates */ other) >= 0;\n};\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\n\n/**\n * Compares this Long's value with the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.compare = function compare(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  if (this.eq(other))\n    return 0;\n  var thisNeg = this.isNegative(),\n    otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg)\n    return -1;\n  if (!thisNeg && otherNeg)\n    return 1;\n  // At this point the sign bits are the same\n  if (!this.unsigned)\n    return this.sub(other).isNegative() ? -1 : 1;\n  // Both are positive if at least one is unsigned\n  return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\n};\n\n/**\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.comp = LongPrototype.compare;\n\n/**\n * Negates this Long's value.\n * @this {!Long}\n * @returns {!Long} Negated Long\n */\nLongPrototype.negate = function negate() {\n  if (!this.unsigned && this.eq(MIN_VALUE))\n    return MIN_VALUE;\n  return this.not().add(ONE);\n};\n\n/**\n * Negates this Long's value. This is an alias of {@link Long#negate}.\n * @function\n * @returns {!Long} Negated Long\n */\nLongPrototype.neg = LongPrototype.negate;\n\n/**\n * Returns the sum of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} addend Addend\n * @returns {!Long} Sum\n */\nLongPrototype.add = function add(addend) {\n  if (!isLong(addend))\n    addend = fromValue(addend);\n\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 0xFFFF;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 0xFFFF;\n\n  var b48 = addend.high >>> 16;\n  var b32 = addend.high & 0xFFFF;\n  var b16 = addend.low >>> 16;\n  var b00 = addend.low & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the difference of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.subtract = function subtract(subtrahend) {\n  if (!isLong(subtrahend))\n    subtrahend = fromValue(subtrahend);\n  return this.add(subtrahend.neg());\n};\n\n/**\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n * @function\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.sub = LongPrototype.subtract;\n\n/**\n * Returns the product of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.multiply = function multiply(multiplier) {\n  if (this.isZero())\n    return this;\n  if (!isLong(multiplier))\n    multiplier = fromValue(multiplier);\n\n  // use wasm support if present\n  if (wasm) {\n    var low = wasm[\"mul\"](this.low,\n      this.high,\n      multiplier.low,\n      multiplier.high);\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  if (multiplier.isZero())\n    return this.unsigned ? UZERO : ZERO;\n  if (this.eq(MIN_VALUE))\n    return multiplier.isOdd() ? MIN_VALUE : ZERO;\n  if (multiplier.eq(MIN_VALUE))\n    return this.isOdd() ? MIN_VALUE : ZERO;\n\n  if (this.isNegative()) {\n    if (multiplier.isNegative())\n      return this.neg().mul(multiplier.neg());\n    else\n      return this.neg().mul(multiplier).neg();\n  } else if (multiplier.isNegative())\n    return this.mul(multiplier.neg()).neg();\n\n  // If both longs are small, use float multiplication\n  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 0xFFFF;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 0xFFFF;\n\n  var b48 = multiplier.high >>> 16;\n  var b32 = multiplier.high & 0xFFFF;\n  var b16 = multiplier.low >>> 16;\n  var b00 = multiplier.low & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n * @function\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.mul = LongPrototype.multiply;\n\n/**\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\n *  unsigned if this Long is unsigned.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.divide = function divide(divisor) {\n  if (!isLong(divisor))\n    divisor = fromValue(divisor);\n  if (divisor.isZero())\n    throw Error('division by zero');\n\n  // use wasm support if present\n  if (wasm) {\n    // guard against signed division overflow: the largest\n    // negative number / -1 would be 1 larger than the largest\n    // positive number, due to two's complement.\n    if (!this.unsigned &&\n      this.high === -0x80000000 &&\n      divisor.low === -1 && divisor.high === -1) {\n      // be consistent with non-wasm code path\n      return this;\n    }\n    var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(\n      this.low,\n      this.high,\n      divisor.low,\n      divisor.high\n    );\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  if (this.isZero())\n    return this.unsigned ? UZERO : ZERO;\n  var approx, rem, res;\n  if (!this.unsigned) {\n    // This section is only relevant for signed longs and is derived from the\n    // closure library as a whole.\n    if (this.eq(MIN_VALUE)) {\n      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n        return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n      else if (divisor.eq(MIN_VALUE))\n        return ONE;\n      else {\n        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n        var halfThis = this.shr(1);\n        approx = halfThis.div(divisor).shl(1);\n        if (approx.eq(ZERO)) {\n          return divisor.isNegative() ? ONE : NEG_ONE;\n        } else {\n          rem = this.sub(divisor.mul(approx));\n          res = approx.add(rem.div(divisor));\n          return res;\n        }\n      }\n    } else if (divisor.eq(MIN_VALUE))\n      return this.unsigned ? UZERO : ZERO;\n    if (this.isNegative()) {\n      if (divisor.isNegative())\n        return this.neg().div(divisor.neg());\n      return this.neg().div(divisor).neg();\n    } else if (divisor.isNegative())\n      return this.div(divisor.neg()).neg();\n    res = ZERO;\n  } else {\n    // The algorithm below has not been made for unsigned longs. It's therefore\n    // required to take special care of the MSB prior to running it.\n    if (!divisor.unsigned)\n      divisor = divisor.toUnsigned();\n    if (divisor.gt(this))\n      return UZERO;\n    if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n      return UONE;\n    res = UZERO;\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  rem = this;\n  while (rem.gte(divisor)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2),\n      delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\n\n      // Decrease the approximation until it is smaller than the remainder.  Note\n      // that if it is too large, the product overflows and is negative.\n      approxRes = fromNumber(approx),\n      approxRem = approxRes.mul(divisor);\n    while (approxRem.isNegative() || approxRem.gt(rem)) {\n      approx -= delta;\n      approxRes = fromNumber(approx, this.unsigned);\n      approxRem = approxRes.mul(divisor);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero())\n      approxRes = ONE;\n\n    res = res.add(approxRes);\n    rem = rem.sub(approxRem);\n  }\n  return res;\n};\n\n/**\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.div = LongPrototype.divide;\n\n/**\n * Returns this Long modulo the specified.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.modulo = function modulo(divisor) {\n  if (!isLong(divisor))\n    divisor = fromValue(divisor);\n\n  // use wasm support if present\n  if (wasm) {\n    var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(\n      this.low,\n      this.high,\n      divisor.low,\n      divisor.high\n    );\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  return this.sub(this.div(divisor).mul(divisor));\n};\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.mod = LongPrototype.modulo;\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.rem = LongPrototype.modulo;\n\n/**\n * Returns the bitwise NOT of this Long.\n * @this {!Long}\n * @returns {!Long}\n */\nLongPrototype.not = function not() {\n  return fromBits(~this.low, ~this.high, this.unsigned);\n};\n\n/**\n * Returns count leading zeros of this Long.\n * @this {!Long}\n * @returns {!number}\n */\nLongPrototype.countLeadingZeros = function countLeadingZeros() {\n  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n};\n\n/**\n * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.\n * @function\n * @param {!Long}\n * @returns {!number}\n */\nLongPrototype.clz = LongPrototype.countLeadingZeros;\n\n/**\n * Returns count trailing zeros of this Long.\n * @this {!Long}\n * @returns {!number}\n */\nLongPrototype.countTrailingZeros = function countTrailingZeros() {\n  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n};\n\n/**\n * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.\n * @function\n * @param {!Long}\n * @returns {!number}\n */\nLongPrototype.ctz = LongPrototype.countTrailingZeros;\n\n/**\n * Returns the bitwise AND of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.and = function and(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise OR of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.or = function or(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise XOR of this Long and the given one.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.xor = function xor(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\n  if (isLong(numBits))\n    numBits = numBits.toInt();\n  if ((numBits &= 63) === 0)\n    return this;\n  else if (numBits < 32)\n    return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\n  else\n    return fromBits(0, this.low << (numBits - 32), this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shl = LongPrototype.shiftLeft;\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRight = function shiftRight(numBits) {\n  if (isLong(numBits))\n    numBits = numBits.toInt();\n  if ((numBits &= 63) === 0)\n    return this;\n  else if (numBits < 32)\n    return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\n  else\n    return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\n};\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr = LongPrototype.shiftRight;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits < 32) return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >>> numBits, this.unsigned);\n  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n  return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);\n};\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits rotated to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateLeft = function rotateLeft(numBits) {\n  var b;\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  if (numBits < 32) {\n    b = (32 - numBits);\n    return fromBits(((this.low << numBits) | (this.high >>> b)), ((this.high << numBits) | (this.low >>> b)), this.unsigned);\n  }\n  numBits -= 32;\n  b = (32 - numBits);\n  return fromBits(((this.high << numBits) | (this.low >>> b)), ((this.low << numBits) | (this.high >>> b)), this.unsigned);\n}\n/**\n * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotl = LongPrototype.rotateLeft;\n\n/**\n * Returns this Long with bits rotated to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateRight = function rotateRight(numBits) {\n  var b;\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  if (numBits < 32) {\n    b = (32 - numBits);\n    return fromBits(((this.high << b) | (this.low >>> numBits)), ((this.low << b) | (this.high >>> numBits)), this.unsigned);\n  }\n  numBits -= 32;\n  b = (32 - numBits);\n  return fromBits(((this.low << b) | (this.high >>> numBits)), ((this.high << b) | (this.low >>> numBits)), this.unsigned);\n}\n/**\n * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotr = LongPrototype.rotateRight;\n\n/**\n * Converts this Long to signed.\n * @this {!Long}\n * @returns {!Long} Signed long\n */\nLongPrototype.toSigned = function toSigned() {\n  if (!this.unsigned)\n    return this;\n  return fromBits(this.low, this.high, false);\n};\n\n/**\n * Converts this Long to unsigned.\n * @this {!Long}\n * @returns {!Long} Unsigned long\n */\nLongPrototype.toUnsigned = function toUnsigned() {\n  if (this.unsigned)\n    return this;\n  return fromBits(this.low, this.high, true);\n};\n\n/**\n * Converts this Long to its byte representation.\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @this {!Long}\n * @returns {!Array.<number>} Byte representation\n */\nLongPrototype.toBytes = function toBytes(le) {\n  return le ? this.toBytesLE() : this.toBytesBE();\n};\n\n/**\n * Converts this Long to its little endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Little endian byte representation\n */\nLongPrototype.toBytesLE = function toBytesLE() {\n  var hi = this.high,\n    lo = this.low;\n  return [\n    lo & 0xff,\n    lo >>> 8 & 0xff,\n    lo >>> 16 & 0xff,\n    lo >>> 24,\n    hi & 0xff,\n    hi >>> 8 & 0xff,\n    hi >>> 16 & 0xff,\n    hi >>> 24\n  ];\n};\n\n/**\n * Converts this Long to its big endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Big endian byte representation\n */\nLongPrototype.toBytesBE = function toBytesBE() {\n  var hi = this.high,\n    lo = this.low;\n  return [\n    hi >>> 24,\n    hi >>> 16 & 0xff,\n    hi >>> 8 & 0xff,\n    hi & 0xff,\n    lo >>> 24,\n    lo >>> 16 & 0xff,\n    lo >>> 8 & 0xff,\n    lo & 0xff\n  ];\n};\n\n/**\n * Creates a Long from its byte representation.\n * @param {!Array.<number>} bytes Byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\n  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n};\n\n/**\n * Creates a Long from its little endian byte representation.\n * @param {!Array.<number>} bytes Little endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n  return new Long(\n    bytes[0] |\n    bytes[1] << 8 |\n    bytes[2] << 16 |\n    bytes[3] << 24,\n    bytes[4] |\n    bytes[5] << 8 |\n    bytes[6] << 16 |\n    bytes[7] << 24,\n    unsigned\n  );\n};\n\n/**\n * Creates a Long from its big endian byte representation.\n * @param {!Array.<number>} bytes Big endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n  return new Long(\n    bytes[4] << 24 |\n    bytes[5] << 16 |\n    bytes[6] << 8 |\n    bytes[7],\n    bytes[0] << 24 |\n    bytes[1] << 16 |\n    bytes[2] << 8 |\n    bytes[3],\n    unsigned\n  );\n};\n\nexport default Long;\n","/// @file\n/// @addtogroup flatbuffers_javascript_api\n/// @{\n/// @cond FLATBUFFERS_INTERNAL\n\n/**\n * @fileoverview\n *\n * Need to suppress 'global this' error so the Node.js export line doesn't cause\n * closure compile to error out.\n * @suppress {globalThis}\n */\n\n/**\n * @const\n * @namespace\n */\nvar flatbuffers = {};\n\n/**\n * @typedef {number}\n */\nflatbuffers.Offset;\n\n/**\n * @typedef {{\n *   bb: flatbuffers.ByteBuffer,\n *   bb_pos: number\n * }}\n */\nflatbuffers.Table;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_SHORT = 2;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_INT = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.FILE_IDENTIFIER_LENGTH = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZE_PREFIX_LENGTH = 4;\n\n/**\n * @enum {number}\n */\nflatbuffers.Encoding = {\n  UTF8_BYTES: 1,\n  UTF16_STRING: 2\n};\n\n/**\n * @type {Int32Array}\n * @const\n */\nflatbuffers.int32 = new Int32Array(2);\n\n/**\n * @type {Float32Array}\n * @const\n */\nflatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);\n\n/**\n * @type {Float64Array}\n * @const\n */\nflatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);\n\n/**\n * @type {boolean}\n * @const\n */\nflatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @constructor\n * @param {number} low\n * @param {number} high\n */\nflatbuffers.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @const\n   */\n  this.low = low | 0;\n\n  /**\n   * @type {number}\n   * @const\n   */\n  this.high = high | 0;\n};\n\n/**\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.Long.create = function(low, high) {\n  // Special-case zero to avoid GC overhead for default values\n  return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);\n};\n\n/**\n * @returns {number}\n */\nflatbuffers.Long.prototype.toFloat64 = function() {\n  return (this.low >>> 0) + this.high * 0x100000000;\n};\n\n/**\n * @param {flatbuffers.Long} other\n * @returns {boolean}\n */\nflatbuffers.Long.prototype.equals = function(other) {\n  return this.low == other.low && this.high == other.high;\n};\n\n/**\n * @type {!flatbuffers.Long}\n * @const\n */\nflatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);\n\n/// @endcond\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a FlatBufferBuilder.\n *\n * @constructor\n * @param {number=} opt_initial_size\n */\nflatbuffers.Builder = function(opt_initial_size) {\n  if (!opt_initial_size) {\n    var initial_size = 1024;\n  } else {\n    var initial_size = opt_initial_size;\n  }\n\n  /**\n   * @type {flatbuffers.ByteBuffer}\n   * @private\n   */\n  this.bb = flatbuffers.ByteBuffer.allocate(initial_size);\n\n  /**\n   * Remaining space in the ByteBuffer.\n   *\n   * @type {number}\n   * @private\n   */\n  this.space = initial_size;\n\n  /**\n   * Minimum alignment encountered so far.\n   *\n   * @type {number}\n   * @private\n   */\n  this.minalign = 1;\n\n  /**\n   * The vtable for the current table.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtable = null;\n\n  /**\n   * The amount of fields we're actually using.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vtable_in_use = 0;\n\n  /**\n   * Whether we are currently serializing a table.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.isNested = false;\n\n  /**\n   * Starting offset of the current struct/table.\n   *\n   * @type {number}\n   * @private\n   */\n  this.object_start = 0;\n\n  /**\n   * List of offsets of all vtables.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtables = [];\n\n  /**\n   * For the current vector being built.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vector_num_elems = 0;\n\n  /**\n   * False omits default values from the serialized data\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.force_defaults = false;\n};\n\nflatbuffers.Builder.prototype.clear = function() {\n  this.bb.clear();\n  this.space = this.bb.capacity();\n  this.minalign = 1;\n  this.vtable = null;\n  this.vtable_in_use = 0;\n  this.isNested = false;\n  this.object_start = 0;\n  this.vtables = [];\n  this.vector_num_elems = 0;\n  this.force_defaults = false;\n};\n\n/**\n * In order to save space, fields that are set to their default value\n * don't get serialized into the buffer. Forcing defaults provides a\n * way to manually disable this optimization.\n *\n * @param {boolean} forceDefaults true always serializes default values\n */\nflatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {\n  this.force_defaults = forceDefaults;\n};\n\n/**\n * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n * called finish(). The actual data starts at the ByteBuffer's current position,\n * not necessarily at 0.\n *\n * @returns {flatbuffers.ByteBuffer}\n */\nflatbuffers.Builder.prototype.dataBuffer = function() {\n  return this.bb;\n};\n\n/**\n * Get the bytes representing the FlatBuffer. Only call this after you've\n * called finish().\n *\n * @returns {!Uint8Array}\n */\nflatbuffers.Builder.prototype.asUint8Array = function() {\n  return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Prepare to write an element of `size` after `additional_bytes` have been\n * written, e.g. if you write a string, you need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * you need to do is alignment, `additional_bytes` will be 0.\n *\n * @param {number} size This is the of the new element to write\n * @param {number} additional_bytes The padding size\n */\nflatbuffers.Builder.prototype.prep = function(size, additional_bytes) {\n  // Track the biggest thing we've ever aligned to.\n  if (size > this.minalign) {\n    this.minalign = size;\n  }\n\n  // Find the amount of alignment needed such that `size` is properly\n  // aligned after `additional_bytes`\n  var align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);\n\n  // Reallocate the buffer if needed.\n  while (this.space < align_size + size + additional_bytes) {\n    var old_buf_size = this.bb.capacity();\n    this.bb = flatbuffers.Builder.growByteBuffer(this.bb);\n    this.space += this.bb.capacity() - old_buf_size;\n  }\n\n  this.pad(align_size);\n};\n\n/**\n * @param {number} byte_size\n */\nflatbuffers.Builder.prototype.pad = function(byte_size) {\n  for (var i = 0; i < byte_size; i++) {\n    this.bb.writeInt8(--this.space, 0);\n  }\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt8 = function(value) {\n  this.bb.writeInt8(this.space -= 1, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt16 = function(value) {\n  this.bb.writeInt16(this.space -= 2, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt32 = function(value) {\n  this.bb.writeInt32(this.space -= 4, value);\n};\n\n/**\n * @param {flatbuffers.Long} value\n */\nflatbuffers.Builder.prototype.writeInt64 = function(value) {\n  this.bb.writeInt64(this.space -= 8, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat32 = function(value) {\n  this.bb.writeFloat32(this.space -= 4, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat64 = function(value) {\n  this.bb.writeFloat64(this.space -= 8, value);\n};\n/// @endcond\n\n/**\n * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int8` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt8 = function(value) {\n  this.prep(1, 0);\n  this.writeInt8(value);\n};\n\n/**\n * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int16` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt16 = function(value) {\n  this.prep(2, 0);\n  this.writeInt16(value);\n};\n\n/**\n * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt32 = function(value) {\n  this.prep(4, 0);\n  this.writeInt32(value);\n};\n\n/**\n * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {flatbuffers.Long} value The `int64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt64 = function(value) {\n  this.prep(8, 0);\n  this.writeInt64(value);\n};\n\n/**\n * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat32 = function(value) {\n  this.prep(4, 0);\n  this.writeFloat32(value);\n};\n\n/**\n * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat64 = function(value) {\n  this.prep(8, 0);\n  this.writeFloat64(value);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt8(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt16(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Long} value\n * @param {flatbuffers.Long} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || !value.equals(defaultValue)) {\n    this.addInt64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addOffset(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n *\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {\n  if (value != defaultValue) {\n    this.nested(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structures are always stored inline, they need to be created right\n * where they're used.  You'll get this assertion failure if you\n * created it elsewhere.\n *\n * @param {flatbuffers.Offset} obj The offset of the created object\n */\nflatbuffers.Builder.prototype.nested = function(obj) {\n  if (obj != this.offset()) {\n    throw new Error('FlatBuffers: struct must be serialized inline.');\n  }\n};\n\n/**\n * Should not be creating any other object, string or vector\n * while an object is being constructed\n */\nflatbuffers.Builder.prototype.notNested = function() {\n  if (this.isNested) {\n    throw new Error('FlatBuffers: object serialization must not be nested.');\n  }\n};\n\n/**\n * Set the current vtable at `voffset` to the current location in the buffer.\n *\n * @param {number} voffset\n */\nflatbuffers.Builder.prototype.slot = function(voffset) {\n  this.vtable[voffset] = this.offset();\n};\n\n/**\n * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.\n */\nflatbuffers.Builder.prototype.offset = function() {\n  return this.bb.capacity() - this.space;\n};\n\n/**\n * Doubles the size of the backing ByteBuffer and copies the old data towards\n * the end of the new buffer (since we build the buffer backwards).\n *\n * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data\n * @returns {!flatbuffers.ByteBuffer} A new byte buffer with the old data copied\n * to it. The data is located at the end of the buffer.\n *\n * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n * it a uint8Array we need to suppress the type check:\n * @suppress {checkTypes}\n */\nflatbuffers.Builder.growByteBuffer = function(bb) {\n  var old_buf_size = bb.capacity();\n\n  // Ensure we don't grow beyond what fits in an int.\n  if (old_buf_size & 0xC0000000) {\n    throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n  }\n\n  var new_buf_size = old_buf_size << 1;\n  var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);\n  nbb.setPosition(new_buf_size - old_buf_size);\n  nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n  return nbb;\n};\n/// @endcond\n\n/**\n * Adds on offset, relative to where it will be written.\n *\n * @param {flatbuffers.Offset} offset The offset to add.\n */\nflatbuffers.Builder.prototype.addOffset = function(offset) {\n  this.prep(flatbuffers.SIZEOF_INT, 0); // Ensure alignment is already done.\n  this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Start encoding a new object in the buffer.  Users will not usually need to\n * call this directly. The FlatBuffers compiler will generate helper methods\n * that call this method internally.\n *\n * @param {number} numfields\n */\nflatbuffers.Builder.prototype.startObject = function(numfields) {\n  this.notNested();\n  if (this.vtable == null) {\n    this.vtable = [];\n  }\n  this.vtable_in_use = numfields;\n  for (var i = 0; i < numfields; i++) {\n    this.vtable[i] = 0; // This will push additional elements as needed\n  }\n  this.isNested = true;\n  this.object_start = this.offset();\n};\n\n/**\n * Finish off writing the object that is under construction.\n *\n * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`\n */\nflatbuffers.Builder.prototype.endObject = function() {\n  if (this.vtable == null || !this.isNested) {\n    throw new Error('FlatBuffers: endObject called without startObject');\n  }\n\n  this.addInt32(0);\n  var vtableloc = this.offset();\n\n  // Trim trailing zeroes.\n  var i = this.vtable_in_use - 1;\n  for (; i >= 0 && this.vtable[i] == 0; i--) {}\n  var trimmed_size = i + 1;\n\n  // Write out the current vtable.\n  for (; i >= 0; i--) {\n    // Offset relative to the start of the table.\n    this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n  }\n\n  var standard_fields = 2; // The fields below:\n  this.addInt16(vtableloc - this.object_start);\n  var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;\n  this.addInt16(len);\n\n  // Search for an existing vtable that matches the current one.\n  var existing_vtable = 0;\n  var vt1 = this.space;\nouter_loop:\n  for (i = 0; i < this.vtables.length; i++) {\n    var vt2 = this.bb.capacity() - this.vtables[i];\n    if (len == this.bb.readInt16(vt2)) {\n      for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {\n        if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n          continue outer_loop;\n        }\n      }\n      existing_vtable = this.vtables[i];\n      break;\n    }\n  }\n\n  if (existing_vtable) {\n    // Found a match:\n    // Remove the current vtable.\n    this.space = this.bb.capacity() - vtableloc;\n\n    // Point table to existing vtable.\n    this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n  } else {\n    // No match:\n    // Add the location of the current vtable to the list of vtables.\n    this.vtables.push(this.offset());\n\n    // Point table to current vtable.\n    this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n  }\n\n  this.isNested = false;\n  return vtableloc;\n};\n/// @endcond\n\n/**\n * Finalize a buffer, poiting to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n * @param {boolean=} opt_size_prefix\n */\nflatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier, opt_size_prefix) {\n  var size_prefix = opt_size_prefix ? flatbuffers.SIZE_PREFIX_LENGTH : 0;\n  if (opt_file_identifier) {\n    var file_identifier = opt_file_identifier;\n    this.prep(this.minalign, flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH + size_prefix);\n    if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: file identifier must be length ' +\n        flatbuffers.FILE_IDENTIFIER_LENGTH);\n    }\n    for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n      this.writeInt8(file_identifier.charCodeAt(i));\n    }\n  }\n  this.prep(this.minalign, flatbuffers.SIZEOF_INT + size_prefix);\n  this.addOffset(root_table);\n  if (size_prefix) {\n    this.addInt32(this.bb.capacity() - this.space);\n  }\n  this.bb.setPosition(this.space);\n};\n\n/**\n * Finalize a size prefixed buffer, pointing to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n */\nflatbuffers.Builder.prototype.finishSizePrefixed = function (root_table, opt_file_identifier) {\n  this.finish(root_table, opt_file_identifier, true);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * This checks a required field has been set in a given table that has\n * just been constructed.\n *\n * @param {flatbuffers.Offset} table\n * @param {number} field\n */\nflatbuffers.Builder.prototype.requiredField = function(table, field) {\n  var table_start = this.bb.capacity() - table;\n  var vtable_start = table_start - this.bb.readInt32(table_start);\n  var ok = this.bb.readInt16(vtable_start + field) != 0;\n\n  // If this fails, the caller will show what field needs to be set.\n  if (!ok) {\n    throw new Error('FlatBuffers: field ' + field + ' must be set');\n  }\n};\n\n/**\n * Start a new array/vector of objects.  Users usually will not call\n * this directly. The FlatBuffers compiler will create a start/end\n * method for vector types in generated code.\n *\n * @param {number} elem_size The size of each element in the array\n * @param {number} num_elems The number of elements in the array\n * @param {number} alignment The alignment of the array\n */\nflatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {\n  this.notNested();\n  this.vector_num_elems = num_elems;\n  this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);\n  this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n};\n\n/**\n * Finish off the creation of an array and all its elements. The array must be\n * created with `startVector`.\n *\n * @returns {flatbuffers.Offset} The offset at which the newly created array\n * starts.\n */\nflatbuffers.Builder.prototype.endVector = function() {\n  this.writeInt32(this.vector_num_elems);\n  return this.offset();\n};\n/// @endcond\n\n/**\n * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n *\n * @param {string|Uint8Array} s The string to encode\n * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts\n */\nflatbuffers.Builder.prototype.createString = function(s) {\n  if (s instanceof Uint8Array) {\n    var utf8 = s;\n  } else {\n    var utf8 = [];\n    var i = 0;\n\n    while (i < s.length) {\n      var codePoint;\n\n      // Decode UTF-16\n      var a = s.charCodeAt(i++);\n      if (a < 0xD800 || a >= 0xDC00) {\n        codePoint = a;\n      } else {\n        var b = s.charCodeAt(i++);\n        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);\n      }\n\n      // Encode UTF-8\n      if (codePoint < 0x80) {\n        utf8.push(codePoint);\n      } else {\n        if (codePoint < 0x800) {\n          utf8.push(((codePoint >> 6) & 0x1F) | 0xC0);\n        } else {\n          if (codePoint < 0x10000) {\n            utf8.push(((codePoint >> 12) & 0x0F) | 0xE0);\n          } else {\n            utf8.push(\n              ((codePoint >> 18) & 0x07) | 0xF0,\n              ((codePoint >> 12) & 0x3F) | 0x80);\n          }\n          utf8.push(((codePoint >> 6) & 0x3F) | 0x80);\n        }\n        utf8.push((codePoint & 0x3F) | 0x80);\n      }\n    }\n  }\n\n  this.addInt8(0);\n  this.startVector(1, utf8.length, 1);\n  this.bb.setPosition(this.space -= utf8.length);\n  for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n    bytes[offset++] = utf8[i];\n  }\n  return this.endVector();\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.Builder.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n////////////////////////////////////////////////////////////////////////////////\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Create a new ByteBuffer with a given array of bytes (`Uint8Array`).\n *\n * @constructor\n * @param {Uint8Array} bytes\n */\nflatbuffers.ByteBuffer = function(bytes) {\n  /**\n   * @type {Uint8Array}\n   * @private\n   */\n  this.bytes_ = bytes;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * Create and allocate a new ByteBuffer with a given size.\n *\n * @param {number} byte_size\n * @returns {!flatbuffers.ByteBuffer}\n */\nflatbuffers.ByteBuffer.allocate = function(byte_size) {\n  return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));\n};\n\nflatbuffers.ByteBuffer.prototype.clear = function() {\n  this.position_ = 0;\n};\n\n/**\n * Get the underlying `Uint8Array`.\n *\n * @returns {Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.bytes = function() {\n  return this.bytes_;\n};\n\n/**\n * Get the buffer's position.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.position = function() {\n  return this.position_;\n};\n\n/**\n * Set the buffer's position.\n *\n * @param {number} position\n */\nflatbuffers.ByteBuffer.prototype.setPosition = function(position) {\n  this.position_ = position;\n};\n\n/**\n * Get the buffer's capacity.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.capacity = function() {\n  return this.bytes_.length;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {\n  return this.readUint8(offset) << 24 >> 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {\n  return this.bytes_[offset];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {\n  return this.readUint16(offset) << 16 >> 16;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {\n  return this.readInt32(offset) >>> 0;\n};\n\n/**\n * @param {number} offset\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {\n  return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {\n  return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {\n  flatbuffers.int32[0] = this.readInt32(offset);\n  return flatbuffers.float32[0];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n  return flatbuffers.float64[0];\n};\n\n/**\n * @param {number} offset\n * @param {number|boolean} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {\n  this.bytes_[offset] = /** @type {number} */(value);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {\n  this.bytes_[offset] = value;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n  this.bytes_[offset + 2] = value >> 16;\n  this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n    this.bytes_[offset + 2] = value >> 16;\n    this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {\n  this.writeInt32(offset, value.low);\n  this.writeInt32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {\n    this.writeUint32(offset, value.low);\n    this.writeUint32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {\n  flatbuffers.float32[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[0]);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {\n  flatbuffers.float64[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);\n  this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);\n};\n\n/**\n * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n * schema does not include a file_identifier (likely points at padding or the\n * start of a the root vtable).\n * @returns {string}\n */\nflatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {\n  if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error(\n        'FlatBuffers: ByteBuffer is too short to contain an identifier.');\n  }\n  var result = \"\";\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    result += String.fromCharCode(\n        this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));\n  }\n  return result;\n};\n\n/**\n * Look up a field in the vtable, return an offset into the object, or 0 if the\n * field is not present.\n *\n * @param {number} bb_pos\n * @param {number} vtable_offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {\n  var vtable = bb_pos - this.readInt32(bb_pos);\n  return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n};\n\n/**\n * Initialize any Table-derived type to point to the union at the given offset.\n *\n * @param {flatbuffers.Table} t\n * @param {number} offset\n * @returns {flatbuffers.Table}\n */\nflatbuffers.ByteBuffer.prototype.__union = function(t, offset) {\n  t.bb_pos = offset + this.readInt32(offset);\n  t.bb = this;\n  return t;\n};\n\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n *\n * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as\n * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n * and from UTF-16 when the data will just be packaged back up in another\n * FlatBuffer later on.\n *\n * @param {number} offset\n * @param {flatbuffers.Encoding=} opt_encoding Defaults to UTF16_STRING\n * @returns {string|!Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {\n  offset += this.readInt32(offset);\n\n  var length = this.readInt32(offset);\n  var result = '';\n  var i = 0;\n\n  offset += flatbuffers.SIZEOF_INT;\n\n  if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {\n    return this.bytes_.subarray(offset, offset + length);\n  }\n\n  while (i < length) {\n    var codePoint;\n\n    // Decode UTF-8\n    var a = this.readUint8(offset + i++);\n    if (a < 0xC0) {\n      codePoint = a;\n    } else {\n      var b = this.readUint8(offset + i++);\n      if (a < 0xE0) {\n        codePoint =\n          ((a & 0x1F) << 6) |\n          (b & 0x3F);\n      } else {\n        var c = this.readUint8(offset + i++);\n        if (a < 0xF0) {\n          codePoint =\n            ((a & 0x0F) << 12) |\n            ((b & 0x3F) << 6) |\n            (c & 0x3F);\n        } else {\n          var d = this.readUint8(offset + i++);\n          codePoint =\n            ((a & 0x07) << 18) |\n            ((b & 0x3F) << 12) |\n            ((c & 0x3F) << 6) |\n            (d & 0x3F);\n        }\n      }\n    }\n\n    // Encode UTF-16\n    if (codePoint < 0x10000) {\n      result += String.fromCharCode(codePoint);\n    } else {\n      codePoint -= 0x10000;\n      result += String.fromCharCode(\n        (codePoint >> 10) + 0xD800,\n        (codePoint & ((1 << 10) - 1)) + 0xDC00);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Retrieve the relative offset stored at \"offset\"\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__indirect = function(offset) {\n  return offset + this.readInt32(offset);\n};\n\n/**\n * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector = function(offset) {\n  return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT; // data starts after the length\n};\n\n/**\n * Get the length of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {\n  return this.readInt32(offset + this.readInt32(offset));\n};\n\n/**\n * @param {string} ident\n * @returns {boolean}\n */\nflatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {\n  if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error('FlatBuffers: file identifier must be length ' +\n                    flatbuffers.FILE_IDENTIFIER_LENGTH);\n  }\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n\n// Exports for Node.js and RequireJS\nexport { flatbuffers };\n\n/// @endcond\n/// @}\n","// automatically generated by the FlatBuffers compiler, do not modify\n/* eslint-disable */\n\nimport { flatbuffers } from 'flatbuffers';\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum AttributeType {\n    UNDEFINED = 0,\n    FLOAT = 1,\n    INT = 2,\n    STRING = 3,\n    TENSOR = 4,\n    GRAPH = 5,\n    FLOATS = 6,\n    INTS = 7,\n    STRINGS = 8,\n    TENSORS = 9,\n    GRAPHS = 10,\n    SPARSE_TENSOR = 11,\n    SPARSE_TENSORS = 12,\n  }\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum DimensionValueType {\n    UNKNOWN = 0,\n    VALUE = 1,\n    PARAM = 2,\n  }\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum TensorDataType {\n    UNDEFINED = 0,\n    FLOAT = 1,\n    UINT8 = 2,\n    INT8 = 3,\n    UINT16 = 4,\n    INT16 = 5,\n    INT32 = 6,\n    INT64 = 7,\n    STRING = 8,\n    BOOL = 9,\n    FLOAT16 = 10,\n    DOUBLE = 11,\n    UINT32 = 12,\n    UINT64 = 13,\n    COMPLEX64 = 14,\n    COMPLEX128 = 15,\n    BFLOAT16 = 16,\n    FLOAT8E4M3FN = 17,\n    FLOAT8E4M3FNUZ = 18,\n    FLOAT8E5M2 = 19,\n    FLOAT8E5M2FNUZ = 20,\n  }\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum NodeType {\n    Primitive = 0,\n    Fused = 1,\n  }\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum TypeInfoValue {\n    NONE = 0,\n    tensor_type = 1,\n    sequence_type = 2,\n    map_type = 3,\n  }\n}\n\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Shape {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Shape\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Shape {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Shape= obj\n     * @returns Shape\n     */\n    static getRootAsShape(bb: flatbuffers.ByteBuffer, obj?: Shape): Shape {\n      return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Shape= obj\n     * @returns Shape\n     */\n    static getSizePrefixedRootAsShape(bb: flatbuffers.ByteBuffer, obj?: Shape): Shape {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Dimension= obj\n     * @returns onnxruntime.experimental.fbs.Dimension\n     */\n    dim(index: number, obj?: onnxruntime.experimental.fbs.Dimension): onnxruntime.experimental.fbs.Dimension | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Dimension()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    dimLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startShape(builder: flatbuffers.Builder) {\n      builder.startObject(1);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimOffset\n     */\n    static addDim(builder: flatbuffers.Builder, dimOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, dimOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createDimVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startDimVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endShape(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createShape(builder: flatbuffers.Builder, dimOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Shape.startShape(builder);\n      Shape.addDim(builder, dimOffset);\n      return Shape.endShape(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Dimension {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Dimension\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Dimension {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Dimension= obj\n     * @returns Dimension\n     */\n    static getRootAsDimension(bb: flatbuffers.ByteBuffer, obj?: Dimension): Dimension {\n      return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Dimension= obj\n     * @returns Dimension\n     */\n    static getSizePrefixedRootAsDimension(bb: flatbuffers.ByteBuffer, obj?: Dimension): Dimension {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.DimensionValue= obj\n     * @returns onnxruntime.experimental.fbs.DimensionValue|null\n     */\n    value(obj?: onnxruntime.experimental.fbs.DimensionValue): onnxruntime.experimental.fbs.DimensionValue | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.DimensionValue()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    denotation(): string | null;\n    denotation(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    denotation(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startDimension(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valueOffset\n     */\n    static addValue(builder: flatbuffers.Builder, valueOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, valueOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset denotationOffset\n     */\n    static addDenotation(builder: flatbuffers.Builder, denotationOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, denotationOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endDimension(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createDimension(\n      builder: flatbuffers.Builder,\n      valueOffset: flatbuffers.Offset,\n      denotationOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      Dimension.startDimension(builder);\n      Dimension.addValue(builder, valueOffset);\n      Dimension.addDenotation(builder, denotationOffset);\n      return Dimension.endDimension(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class DimensionValue {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns DimensionValue\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): DimensionValue {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param DimensionValue= obj\n     * @returns DimensionValue\n     */\n    static getRootAsDimensionValue(bb: flatbuffers.ByteBuffer, obj?: DimensionValue): DimensionValue {\n      return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param DimensionValue= obj\n     * @returns DimensionValue\n     */\n    static getSizePrefixedRootAsDimensionValue(bb: flatbuffers.ByteBuffer, obj?: DimensionValue): DimensionValue {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.DimensionValueType\n     */\n    dimType(): onnxruntime.experimental.fbs.DimensionValueType {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? /**  */ this.bb!.readInt8(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    dimValue(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    dimParam(): string | null;\n    dimParam(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    dimParam(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startDimensionValue(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.DimensionValueType dimType\n     */\n    static addDimType(builder: flatbuffers.Builder, dimType: onnxruntime.experimental.fbs.DimensionValueType) {\n      builder.addFieldInt8(0, dimType, onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long dimValue\n     */\n    static addDimValue(builder: flatbuffers.Builder, dimValue: flatbuffers.Long) {\n      builder.addFieldInt64(1, dimValue, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimParamOffset\n     */\n    static addDimParam(builder: flatbuffers.Builder, dimParamOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, dimParamOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endDimensionValue(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createDimensionValue(\n      builder: flatbuffers.Builder,\n      dimType: onnxruntime.experimental.fbs.DimensionValueType,\n      dimValue: flatbuffers.Long,\n      dimParamOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      DimensionValue.startDimensionValue(builder);\n      DimensionValue.addDimType(builder, dimType);\n      DimensionValue.addDimValue(builder, dimValue);\n      DimensionValue.addDimParam(builder, dimParamOffset);\n      return DimensionValue.endDimensionValue(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class TensorTypeAndShape {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns TensorTypeAndShape\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): TensorTypeAndShape {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TensorTypeAndShape= obj\n     * @returns TensorTypeAndShape\n     */\n    static getRootAsTensorTypeAndShape(bb: flatbuffers.ByteBuffer, obj?: TensorTypeAndShape): TensorTypeAndShape {\n      return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TensorTypeAndShape= obj\n     * @returns TensorTypeAndShape\n     */\n    static getSizePrefixedRootAsTensorTypeAndShape(\n      bb: flatbuffers.ByteBuffer,\n      obj?: TensorTypeAndShape,\n    ): TensorTypeAndShape {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TensorDataType\n     */\n    elemType(): onnxruntime.experimental.fbs.TensorDataType {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? /**  */ this.bb!.readInt32(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Shape= obj\n     * @returns onnxruntime.experimental.fbs.Shape|null\n     */\n    shape(obj?: onnxruntime.experimental.fbs.Shape): onnxruntime.experimental.fbs.Shape | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Shape()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startTensorTypeAndShape(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TensorDataType elemType\n     */\n    static addElemType(builder: flatbuffers.Builder, elemType: onnxruntime.experimental.fbs.TensorDataType) {\n      builder.addFieldInt32(0, elemType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset shapeOffset\n     */\n    static addShape(builder: flatbuffers.Builder, shapeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, shapeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endTensorTypeAndShape(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createTensorTypeAndShape(\n      builder: flatbuffers.Builder,\n      elemType: onnxruntime.experimental.fbs.TensorDataType,\n      shapeOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      TensorTypeAndShape.startTensorTypeAndShape(builder);\n      TensorTypeAndShape.addElemType(builder, elemType);\n      TensorTypeAndShape.addShape(builder, shapeOffset);\n      return TensorTypeAndShape.endTensorTypeAndShape(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class MapType {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns MapType\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): MapType {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param MapType= obj\n     * @returns MapType\n     */\n    static getRootAsMapType(bb: flatbuffers.ByteBuffer, obj?: MapType): MapType {\n      return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param MapType= obj\n     * @returns MapType\n     */\n    static getSizePrefixedRootAsMapType(bb: flatbuffers.ByteBuffer, obj?: MapType): MapType {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TensorDataType\n     */\n    keyType(): onnxruntime.experimental.fbs.TensorDataType {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? /**  */ this.bb!.readInt32(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.TypeInfo= obj\n     * @returns onnxruntime.experimental.fbs.TypeInfo|null\n     */\n    valueType(obj?: onnxruntime.experimental.fbs.TypeInfo): onnxruntime.experimental.fbs.TypeInfo | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.TypeInfo()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startMapType(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TensorDataType keyType\n     */\n    static addKeyType(builder: flatbuffers.Builder, keyType: onnxruntime.experimental.fbs.TensorDataType) {\n      builder.addFieldInt32(0, keyType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valueTypeOffset\n     */\n    static addValueType(builder: flatbuffers.Builder, valueTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, valueTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endMapType(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createMapType(\n      builder: flatbuffers.Builder,\n      keyType: onnxruntime.experimental.fbs.TensorDataType,\n      valueTypeOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      MapType.startMapType(builder);\n      MapType.addKeyType(builder, keyType);\n      MapType.addValueType(builder, valueTypeOffset);\n      return MapType.endMapType(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SequenceType {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SequenceType\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SequenceType {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SequenceType= obj\n     * @returns SequenceType\n     */\n    static getRootAsSequenceType(bb: flatbuffers.ByteBuffer, obj?: SequenceType): SequenceType {\n      return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SequenceType= obj\n     * @returns SequenceType\n     */\n    static getSizePrefixedRootAsSequenceType(bb: flatbuffers.ByteBuffer, obj?: SequenceType): SequenceType {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.TypeInfo= obj\n     * @returns onnxruntime.experimental.fbs.TypeInfo|null\n     */\n    elemType(obj?: onnxruntime.experimental.fbs.TypeInfo): onnxruntime.experimental.fbs.TypeInfo | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.TypeInfo()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSequenceType(builder: flatbuffers.Builder) {\n      builder.startObject(1);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset elemTypeOffset\n     */\n    static addElemType(builder: flatbuffers.Builder, elemTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, elemTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSequenceType(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createSequenceType(builder: flatbuffers.Builder, elemTypeOffset: flatbuffers.Offset): flatbuffers.Offset {\n      SequenceType.startSequenceType(builder);\n      SequenceType.addElemType(builder, elemTypeOffset);\n      return SequenceType.endSequenceType(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class EdgeEnd {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns EdgeEnd\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): EdgeEnd {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeIndex(): number {\n      return this.bb!.readUint32(this.bb_pos);\n    }\n\n    /**\n     * @returns number\n     */\n    srcArgIndex(): number {\n      return this.bb!.readInt32(this.bb_pos + 4);\n    }\n\n    /**\n     * @returns number\n     */\n    dstArgIndex(): number {\n      return this.bb!.readInt32(this.bb_pos + 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number node_index\n     * @param number src_arg_index\n     * @param number dst_arg_index\n     * @returns flatbuffers.Offset\n     */\n    static createEdgeEnd(\n      builder: flatbuffers.Builder,\n      node_index: number,\n      src_arg_index: number,\n      dst_arg_index: number,\n    ): flatbuffers.Offset {\n      builder.prep(4, 12);\n      builder.writeInt32(dst_arg_index);\n      builder.writeInt32(src_arg_index);\n      builder.writeInt32(node_index);\n      return builder.offset();\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class NodeEdge {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns NodeEdge\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): NodeEdge {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param NodeEdge= obj\n     * @returns NodeEdge\n     */\n    static getRootAsNodeEdge(bb: flatbuffers.ByteBuffer, obj?: NodeEdge): NodeEdge {\n      return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param NodeEdge= obj\n     * @returns NodeEdge\n     */\n    static getSizePrefixedRootAsNodeEdge(bb: flatbuffers.ByteBuffer, obj?: NodeEdge): NodeEdge {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns number\n     */\n    nodeIndex(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.EdgeEnd= obj\n     * @returns onnxruntime.experimental.fbs.EdgeEnd\n     */\n    inputEdges(index: number, obj?: onnxruntime.experimental.fbs.EdgeEnd): onnxruntime.experimental.fbs.EdgeEnd | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.EdgeEnd()).__init(\n            this.bb!.__vector(this.bb_pos + offset) + index * 12,\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    inputEdgesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.EdgeEnd= obj\n     * @returns onnxruntime.experimental.fbs.EdgeEnd\n     */\n    outputEdges(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.EdgeEnd,\n    ): onnxruntime.experimental.fbs.EdgeEnd | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.EdgeEnd()).__init(\n            this.bb!.__vector(this.bb_pos + offset) + index * 12,\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    outputEdgesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startNodeEdge(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number nodeIndex\n     */\n    static addNodeIndex(builder: flatbuffers.Builder, nodeIndex: number) {\n      builder.addFieldInt32(0, nodeIndex, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputEdgesOffset\n     */\n    static addInputEdges(builder: flatbuffers.Builder, inputEdgesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, inputEdgesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputEdgesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(12, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset outputEdgesOffset\n     */\n    static addOutputEdges(builder: flatbuffers.Builder, outputEdgesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, outputEdgesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOutputEdgesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(12, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endNodeEdge(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createNodeEdge(\n      builder: flatbuffers.Builder,\n      nodeIndex: number,\n      inputEdgesOffset: flatbuffers.Offset,\n      outputEdgesOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      NodeEdge.startNodeEdge(builder);\n      NodeEdge.addNodeIndex(builder, nodeIndex);\n      NodeEdge.addInputEdges(builder, inputEdgesOffset);\n      NodeEdge.addOutputEdges(builder, outputEdgesOffset);\n      return NodeEdge.endNodeEdge(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Node {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Node\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Node {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Node= obj\n     * @returns Node\n     */\n    static getRootAsNode(bb: flatbuffers.ByteBuffer, obj?: Node): Node {\n      return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Node= obj\n     * @returns Node\n     */\n    static getSizePrefixedRootAsNode(bb: flatbuffers.ByteBuffer, obj?: Node): Node {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string | null;\n    name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    name(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string | null;\n    docString(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    docString(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    domain(): string | null;\n    domain(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    domain(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    sinceVersion(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    index(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    opType(): string | null;\n    opType(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    opType(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.NodeType\n     */\n    type(): onnxruntime.experimental.fbs.NodeType {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset\n        ? /**  */ this.bb!.readInt32(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.NodeType.Primitive;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    executionProviderType(): string | null;\n    executionProviderType(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    executionProviderType(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    inputs(index: number): string;\n    inputs(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    inputs(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    inputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    outputs(index: number): string;\n    outputs(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    outputs(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    outputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Attribute= obj\n     * @returns onnxruntime.experimental.fbs.Attribute\n     */\n    attributes(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.Attribute,\n    ): onnxruntime.experimental.fbs.Attribute | null {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Attribute()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    attributesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    inputArgCounts(index: number): number | null {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    inputArgCountsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Int32Array\n     */\n    inputArgCountsArray(): Int32Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset\n        ? new Int32Array(\n            this.bb!.bytes().buffer,\n            this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n            this.bb!.__vector_len(this.bb_pos + offset),\n          )\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    implicitInputs(index: number): string;\n    implicitInputs(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    implicitInputs(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    implicitInputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startNode(builder: flatbuffers.Builder) {\n      builder.startObject(13);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset domainOffset\n     */\n    static addDomain(builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, domainOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number sinceVersion\n     */\n    static addSinceVersion(builder: flatbuffers.Builder, sinceVersion: number) {\n      builder.addFieldInt32(3, sinceVersion, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number index\n     */\n    static addIndex(builder: flatbuffers.Builder, index: number) {\n      builder.addFieldInt32(4, index, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset opTypeOffset\n     */\n    static addOpType(builder: flatbuffers.Builder, opTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, opTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.NodeType type\n     */\n    static addType(builder: flatbuffers.Builder, type: onnxruntime.experimental.fbs.NodeType) {\n      builder.addFieldInt32(6, type, onnxruntime.experimental.fbs.NodeType.Primitive);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset executionProviderTypeOffset\n     */\n    static addExecutionProviderType(builder: flatbuffers.Builder, executionProviderTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, executionProviderTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputsOffset\n     */\n    static addInputs(builder: flatbuffers.Builder, inputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(8, inputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createInputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset outputsOffset\n     */\n    static addOutputs(builder: flatbuffers.Builder, outputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(9, outputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createOutputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOutputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset attributesOffset\n     */\n    static addAttributes(builder: flatbuffers.Builder, attributesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(10, attributesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createAttributesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startAttributesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputArgCountsOffset\n     */\n    static addInputArgCounts(builder: flatbuffers.Builder, inputArgCountsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(11, inputArgCountsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createInputArgCountsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt32(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputArgCountsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset implicitInputsOffset\n     */\n    static addImplicitInputs(builder: flatbuffers.Builder, implicitInputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(12, implicitInputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createImplicitInputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startImplicitInputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endNode(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createNode(\n      builder: flatbuffers.Builder,\n      nameOffset: flatbuffers.Offset,\n      docStringOffset: flatbuffers.Offset,\n      domainOffset: flatbuffers.Offset,\n      sinceVersion: number,\n      index: number,\n      opTypeOffset: flatbuffers.Offset,\n      type: onnxruntime.experimental.fbs.NodeType,\n      executionProviderTypeOffset: flatbuffers.Offset,\n      inputsOffset: flatbuffers.Offset,\n      outputsOffset: flatbuffers.Offset,\n      attributesOffset: flatbuffers.Offset,\n      inputArgCountsOffset: flatbuffers.Offset,\n      implicitInputsOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      Node.startNode(builder);\n      Node.addName(builder, nameOffset);\n      Node.addDocString(builder, docStringOffset);\n      Node.addDomain(builder, domainOffset);\n      Node.addSinceVersion(builder, sinceVersion);\n      Node.addIndex(builder, index);\n      Node.addOpType(builder, opTypeOffset);\n      Node.addType(builder, type);\n      Node.addExecutionProviderType(builder, executionProviderTypeOffset);\n      Node.addInputs(builder, inputsOffset);\n      Node.addOutputs(builder, outputsOffset);\n      Node.addAttributes(builder, attributesOffset);\n      Node.addInputArgCounts(builder, inputArgCountsOffset);\n      Node.addImplicitInputs(builder, implicitInputsOffset);\n      return Node.endNode(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class ValueInfo {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns ValueInfo\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): ValueInfo {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param ValueInfo= obj\n     * @returns ValueInfo\n     */\n    static getRootAsValueInfo(bb: flatbuffers.ByteBuffer, obj?: ValueInfo): ValueInfo {\n      return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param ValueInfo= obj\n     * @returns ValueInfo\n     */\n    static getSizePrefixedRootAsValueInfo(bb: flatbuffers.ByteBuffer, obj?: ValueInfo): ValueInfo {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string | null;\n    name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    name(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string | null;\n    docString(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    docString(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.TypeInfo= obj\n     * @returns onnxruntime.experimental.fbs.TypeInfo|null\n     */\n    type(obj?: onnxruntime.experimental.fbs.TypeInfo): onnxruntime.experimental.fbs.TypeInfo | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.TypeInfo()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startValueInfo(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset typeOffset\n     */\n    static addType(builder: flatbuffers.Builder, typeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, typeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endValueInfo(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createValueInfo(\n      builder: flatbuffers.Builder,\n      nameOffset: flatbuffers.Offset,\n      docStringOffset: flatbuffers.Offset,\n      typeOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      ValueInfo.startValueInfo(builder);\n      ValueInfo.addName(builder, nameOffset);\n      ValueInfo.addDocString(builder, docStringOffset);\n      ValueInfo.addType(builder, typeOffset);\n      return ValueInfo.endValueInfo(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class TypeInfo {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns TypeInfo\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): TypeInfo {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TypeInfo= obj\n     * @returns TypeInfo\n     */\n    static getRootAsTypeInfo(bb: flatbuffers.ByteBuffer, obj?: TypeInfo): TypeInfo {\n      return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TypeInfo= obj\n     * @returns TypeInfo\n     */\n    static getSizePrefixedRootAsTypeInfo(bb: flatbuffers.ByteBuffer, obj?: TypeInfo): TypeInfo {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    denotation(): string | null;\n    denotation(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    denotation(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TypeInfoValue\n     */\n    valueType(): onnxruntime.experimental.fbs.TypeInfoValue {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? /**  */ this.bb!.readUint8(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.TypeInfoValue.NONE;\n    }\n\n    /**\n     * @param flatbuffers.Table obj\n     * @returns ?flatbuffers.Table\n     */\n    value<T extends flatbuffers.Table>(obj: T): T | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startTypeInfo(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset denotationOffset\n     */\n    static addDenotation(builder: flatbuffers.Builder, denotationOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, denotationOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TypeInfoValue valueType\n     */\n    static addValueType(builder: flatbuffers.Builder, valueType: onnxruntime.experimental.fbs.TypeInfoValue) {\n      builder.addFieldInt8(1, valueType, onnxruntime.experimental.fbs.TypeInfoValue.NONE);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valueOffset\n     */\n    static addValue(builder: flatbuffers.Builder, valueOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, valueOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endTypeInfo(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createTypeInfo(\n      builder: flatbuffers.Builder,\n      denotationOffset: flatbuffers.Offset,\n      valueType: onnxruntime.experimental.fbs.TypeInfoValue,\n      valueOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      TypeInfo.startTypeInfo(builder);\n      TypeInfo.addDenotation(builder, denotationOffset);\n      TypeInfo.addValueType(builder, valueType);\n      TypeInfo.addValue(builder, valueOffset);\n      return TypeInfo.endTypeInfo(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class OperatorSetId {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns OperatorSetId\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): OperatorSetId {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param OperatorSetId= obj\n     * @returns OperatorSetId\n     */\n    static getRootAsOperatorSetId(bb: flatbuffers.ByteBuffer, obj?: OperatorSetId): OperatorSetId {\n      return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param OperatorSetId= obj\n     * @returns OperatorSetId\n     */\n    static getSizePrefixedRootAsOperatorSetId(bb: flatbuffers.ByteBuffer, obj?: OperatorSetId): OperatorSetId {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    domain(): string | null;\n    domain(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    domain(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    version(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startOperatorSetId(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset domainOffset\n     */\n    static addDomain(builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, domainOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long version\n     */\n    static addVersion(builder: flatbuffers.Builder, version: flatbuffers.Long) {\n      builder.addFieldInt64(1, version, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endOperatorSetId(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createOperatorSetId(\n      builder: flatbuffers.Builder,\n      domainOffset: flatbuffers.Offset,\n      version: flatbuffers.Long,\n    ): flatbuffers.Offset {\n      OperatorSetId.startOperatorSetId(builder);\n      OperatorSetId.addDomain(builder, domainOffset);\n      OperatorSetId.addVersion(builder, version);\n      return OperatorSetId.endOperatorSetId(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Tensor {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Tensor\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Tensor {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Tensor= obj\n     * @returns Tensor\n     */\n    static getRootAsTensor(bb: flatbuffers.ByteBuffer, obj?: Tensor): Tensor {\n      return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Tensor= obj\n     * @returns Tensor\n     */\n    static getSizePrefixedRootAsTensor(bb: flatbuffers.ByteBuffer, obj?: Tensor): Tensor {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string | null;\n    name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    name(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string | null;\n    docString(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    docString(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    dims(index: number): flatbuffers.Long | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8)\n        : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    dimsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TensorDataType\n     */\n    dataType(): onnxruntime.experimental.fbs.TensorDataType {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset\n        ? /**  */ this.bb!.readInt32(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    rawData(index: number): number | null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    rawDataLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Uint8Array\n     */\n    rawDataArray(): Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset\n        ? new Uint8Array(\n            this.bb!.bytes().buffer,\n            this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n            this.bb!.__vector_len(this.bb_pos + offset),\n          )\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    stringData(index: number): string;\n    stringData(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    stringData(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    stringDataLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startTensor(builder: flatbuffers.Builder) {\n      builder.startObject(6);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimsOffset\n     */\n    static addDims(builder: flatbuffers.Builder, dimsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, dimsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createDimsVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startDimsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TensorDataType dataType\n     */\n    static addDataType(builder: flatbuffers.Builder, dataType: onnxruntime.experimental.fbs.TensorDataType) {\n      builder.addFieldInt32(3, dataType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset rawDataOffset\n     */\n    static addRawData(builder: flatbuffers.Builder, rawDataOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(4, rawDataOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createRawDataVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset {\n      builder.startVector(1, data.length, 1);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt8(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startRawDataVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(1, numElems, 1);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset stringDataOffset\n     */\n    static addStringData(builder: flatbuffers.Builder, stringDataOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, stringDataOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createStringDataVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startStringDataVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endTensor(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createTensor(\n      builder: flatbuffers.Builder,\n      nameOffset: flatbuffers.Offset,\n      docStringOffset: flatbuffers.Offset,\n      dimsOffset: flatbuffers.Offset,\n      dataType: onnxruntime.experimental.fbs.TensorDataType,\n      rawDataOffset: flatbuffers.Offset,\n      stringDataOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      Tensor.startTensor(builder);\n      Tensor.addName(builder, nameOffset);\n      Tensor.addDocString(builder, docStringOffset);\n      Tensor.addDims(builder, dimsOffset);\n      Tensor.addDataType(builder, dataType);\n      Tensor.addRawData(builder, rawDataOffset);\n      Tensor.addStringData(builder, stringDataOffset);\n      return Tensor.endTensor(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SparseTensor {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SparseTensor\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SparseTensor {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SparseTensor= obj\n     * @returns SparseTensor\n     */\n    static getRootAsSparseTensor(bb: flatbuffers.ByteBuffer, obj?: SparseTensor): SparseTensor {\n      return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SparseTensor= obj\n     * @returns SparseTensor\n     */\n    static getSizePrefixedRootAsSparseTensor(bb: flatbuffers.ByteBuffer, obj?: SparseTensor): SparseTensor {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor|null\n     */\n    values(obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Tensor()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor|null\n     */\n    indices(obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Tensor()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    dims(index: number): flatbuffers.Long | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8)\n        : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    dimsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSparseTensor(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valuesOffset\n     */\n    static addValues(builder: flatbuffers.Builder, valuesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, valuesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset indicesOffset\n     */\n    static addIndices(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, indicesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimsOffset\n     */\n    static addDims(builder: flatbuffers.Builder, dimsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, dimsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createDimsVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startDimsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSparseTensor(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createSparseTensor(\n      builder: flatbuffers.Builder,\n      valuesOffset: flatbuffers.Offset,\n      indicesOffset: flatbuffers.Offset,\n      dimsOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      SparseTensor.startSparseTensor(builder);\n      SparseTensor.addValues(builder, valuesOffset);\n      SparseTensor.addIndices(builder, indicesOffset);\n      SparseTensor.addDims(builder, dimsOffset);\n      return SparseTensor.endSparseTensor(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Attribute {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Attribute\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Attribute {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Attribute= obj\n     * @returns Attribute\n     */\n    static getRootAsAttribute(bb: flatbuffers.ByteBuffer, obj?: Attribute): Attribute {\n      return (obj || new Attribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Attribute= obj\n     * @returns Attribute\n     */\n    static getSizePrefixedRootAsAttribute(bb: flatbuffers.ByteBuffer, obj?: Attribute): Attribute {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Attribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string | null;\n    name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    name(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string | null;\n    docString(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    docString(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.AttributeType\n     */\n    type(): onnxruntime.experimental.fbs.AttributeType {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? /**  */ this.bb!.readInt32(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.AttributeType.UNDEFINED;\n    }\n\n    /**\n     * @returns number\n     */\n    f(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    i(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    s(): string | null;\n    s(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    s(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor|null\n     */\n    t(obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor | null {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Tensor()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Graph= obj\n     * @returns onnxruntime.experimental.fbs.Graph|null\n     */\n    g(obj?: onnxruntime.experimental.fbs.Graph): onnxruntime.experimental.fbs.Graph | null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Graph()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    floats(index: number): number | null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    floatsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Float32Array\n     */\n    floatsArray(): Float32Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset\n        ? new Float32Array(\n            this.bb!.bytes().buffer,\n            this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n            this.bb!.__vector_len(this.bb_pos + offset),\n          )\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    ints(index: number): flatbuffers.Long | null {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset\n        ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8)\n        : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    intsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    strings(index: number): string;\n    strings(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    strings(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    stringsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor\n     */\n    tensors(index: number, obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor | null {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Tensor()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    tensorsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Graph= obj\n     * @returns onnxruntime.experimental.fbs.Graph\n     */\n    graphs(index: number, obj?: onnxruntime.experimental.fbs.Graph): onnxruntime.experimental.fbs.Graph | null {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Graph()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    graphsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startAttribute(builder: flatbuffers.Builder) {\n      builder.startObject(13);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.AttributeType type\n     */\n    static addType(builder: flatbuffers.Builder, type: onnxruntime.experimental.fbs.AttributeType) {\n      builder.addFieldInt32(2, type, onnxruntime.experimental.fbs.AttributeType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number f\n     */\n    static addF(builder: flatbuffers.Builder, f: number) {\n      builder.addFieldFloat32(3, f, 0.0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long i\n     */\n    static addI(builder: flatbuffers.Builder, i: flatbuffers.Long) {\n      builder.addFieldInt64(4, i, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sOffset\n     */\n    static addS(builder: flatbuffers.Builder, sOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, sOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset tOffset\n     */\n    static addT(builder: flatbuffers.Builder, tOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(6, tOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset gOffset\n     */\n    static addG(builder: flatbuffers.Builder, gOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, gOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset floatsOffset\n     */\n    static addFloats(builder: flatbuffers.Builder, floatsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(8, floatsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createFloatsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addFloat32(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startFloatsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset intsOffset\n     */\n    static addInts(builder: flatbuffers.Builder, intsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(9, intsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createIntsVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startIntsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset stringsOffset\n     */\n    static addStrings(builder: flatbuffers.Builder, stringsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(10, stringsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createStringsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startStringsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset tensorsOffset\n     */\n    static addTensors(builder: flatbuffers.Builder, tensorsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(11, tensorsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createTensorsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startTensorsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphsOffset\n     */\n    static addGraphs(builder: flatbuffers.Builder, graphsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(12, graphsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createGraphsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startGraphsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endAttribute(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createAttribute(\n      builder: flatbuffers.Builder,\n      nameOffset: flatbuffers.Offset,\n      docStringOffset: flatbuffers.Offset,\n      type: onnxruntime.experimental.fbs.AttributeType,\n      f: number,\n      i: flatbuffers.Long,\n      sOffset: flatbuffers.Offset,\n      tOffset: flatbuffers.Offset,\n      gOffset: flatbuffers.Offset,\n      floatsOffset: flatbuffers.Offset,\n      intsOffset: flatbuffers.Offset,\n      stringsOffset: flatbuffers.Offset,\n      tensorsOffset: flatbuffers.Offset,\n      graphsOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      Attribute.startAttribute(builder);\n      Attribute.addName(builder, nameOffset);\n      Attribute.addDocString(builder, docStringOffset);\n      Attribute.addType(builder, type);\n      Attribute.addF(builder, f);\n      Attribute.addI(builder, i);\n      Attribute.addS(builder, sOffset);\n      Attribute.addT(builder, tOffset);\n      Attribute.addG(builder, gOffset);\n      Attribute.addFloats(builder, floatsOffset);\n      Attribute.addInts(builder, intsOffset);\n      Attribute.addStrings(builder, stringsOffset);\n      Attribute.addTensors(builder, tensorsOffset);\n      Attribute.addGraphs(builder, graphsOffset);\n      return Attribute.endAttribute(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Graph {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Graph\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Graph {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Graph= obj\n     * @returns Graph\n     */\n    static getRootAsGraph(bb: flatbuffers.ByteBuffer, obj?: Graph): Graph {\n      return (obj || new Graph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Graph= obj\n     * @returns Graph\n     */\n    static getSizePrefixedRootAsGraph(bb: flatbuffers.ByteBuffer, obj?: Graph): Graph {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Graph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor\n     */\n    initializers(index: number, obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Tensor()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    initializersLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.ValueInfo= obj\n     * @returns onnxruntime.experimental.fbs.ValueInfo\n     */\n    nodeArgs(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.ValueInfo,\n    ): onnxruntime.experimental.fbs.ValueInfo | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.ValueInfo()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeArgsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Node= obj\n     * @returns onnxruntime.experimental.fbs.Node\n     */\n    nodes(index: number, obj?: onnxruntime.experimental.fbs.Node): onnxruntime.experimental.fbs.Node | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Node()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    nodesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    maxNodeIndex(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.NodeEdge= obj\n     * @returns onnxruntime.experimental.fbs.NodeEdge\n     */\n    nodeEdges(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.NodeEdge,\n    ): onnxruntime.experimental.fbs.NodeEdge | null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.NodeEdge()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeEdgesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    inputs(index: number): string;\n    inputs(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    inputs(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    inputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    outputs(index: number): string;\n    outputs(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    outputs(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    outputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.SparseTensor= obj\n     * @returns onnxruntime.experimental.fbs.SparseTensor\n     */\n    sparseInitializers(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.SparseTensor,\n    ): onnxruntime.experimental.fbs.SparseTensor | null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.SparseTensor()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    sparseInitializersLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startGraph(builder: flatbuffers.Builder) {\n      builder.startObject(8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset initializersOffset\n     */\n    static addInitializers(builder: flatbuffers.Builder, initializersOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, initializersOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createInitializersVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInitializersVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodeArgsOffset\n     */\n    static addNodeArgs(builder: flatbuffers.Builder, nodeArgsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, nodeArgsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodeArgsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodeArgsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodesOffset\n     */\n    static addNodes(builder: flatbuffers.Builder, nodesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, nodesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number maxNodeIndex\n     */\n    static addMaxNodeIndex(builder: flatbuffers.Builder, maxNodeIndex: number) {\n      builder.addFieldInt32(3, maxNodeIndex, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodeEdgesOffset\n     */\n    static addNodeEdges(builder: flatbuffers.Builder, nodeEdgesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(4, nodeEdgesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodeEdgesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodeEdgesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputsOffset\n     */\n    static addInputs(builder: flatbuffers.Builder, inputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, inputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createInputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset outputsOffset\n     */\n    static addOutputs(builder: flatbuffers.Builder, outputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(6, outputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createOutputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOutputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sparseInitializersOffset\n     */\n    static addSparseInitializers(builder: flatbuffers.Builder, sparseInitializersOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, sparseInitializersOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createSparseInitializersVector(\n      builder: flatbuffers.Builder,\n      data: flatbuffers.Offset[],\n    ): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startSparseInitializersVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endGraph(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createGraph(\n      builder: flatbuffers.Builder,\n      initializersOffset: flatbuffers.Offset,\n      nodeArgsOffset: flatbuffers.Offset,\n      nodesOffset: flatbuffers.Offset,\n      maxNodeIndex: number,\n      nodeEdgesOffset: flatbuffers.Offset,\n      inputsOffset: flatbuffers.Offset,\n      outputsOffset: flatbuffers.Offset,\n      sparseInitializersOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      Graph.startGraph(builder);\n      Graph.addInitializers(builder, initializersOffset);\n      Graph.addNodeArgs(builder, nodeArgsOffset);\n      Graph.addNodes(builder, nodesOffset);\n      Graph.addMaxNodeIndex(builder, maxNodeIndex);\n      Graph.addNodeEdges(builder, nodeEdgesOffset);\n      Graph.addInputs(builder, inputsOffset);\n      Graph.addOutputs(builder, outputsOffset);\n      Graph.addSparseInitializers(builder, sparseInitializersOffset);\n      return Graph.endGraph(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Model {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Model\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Model {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Model= obj\n     * @returns Model\n     */\n    static getRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model {\n      return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Model= obj\n     * @returns Model\n     */\n    static getSizePrefixedRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    irVersion(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.OperatorSetId= obj\n     * @returns onnxruntime.experimental.fbs.OperatorSetId\n     */\n    opsetImport(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.OperatorSetId,\n    ): onnxruntime.experimental.fbs.OperatorSetId | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.OperatorSetId()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    opsetImportLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    producerName(): string | null;\n    producerName(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    producerName(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    producerVersion(): string | null;\n    producerVersion(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    producerVersion(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    domain(): string | null;\n    domain(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    domain(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    modelVersion(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string | null;\n    docString(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    docString(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Graph= obj\n     * @returns onnxruntime.experimental.fbs.Graph|null\n     */\n    graph(obj?: onnxruntime.experimental.fbs.Graph): onnxruntime.experimental.fbs.Graph | null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Graph()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    graphDocString(): string | null;\n    graphDocString(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    graphDocString(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startModel(builder: flatbuffers.Builder) {\n      builder.startObject(9);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long irVersion\n     */\n    static addIrVersion(builder: flatbuffers.Builder, irVersion: flatbuffers.Long) {\n      builder.addFieldInt64(0, irVersion, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset opsetImportOffset\n     */\n    static addOpsetImport(builder: flatbuffers.Builder, opsetImportOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, opsetImportOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createOpsetImportVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOpsetImportVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset producerNameOffset\n     */\n    static addProducerName(builder: flatbuffers.Builder, producerNameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, producerNameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset producerVersionOffset\n     */\n    static addProducerVersion(builder: flatbuffers.Builder, producerVersionOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(3, producerVersionOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset domainOffset\n     */\n    static addDomain(builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(4, domainOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long modelVersion\n     */\n    static addModelVersion(builder: flatbuffers.Builder, modelVersion: flatbuffers.Long) {\n      builder.addFieldInt64(5, modelVersion, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(6, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphOffset\n     */\n    static addGraph(builder: flatbuffers.Builder, graphOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, graphOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphDocStringOffset\n     */\n    static addGraphDocString(builder: flatbuffers.Builder, graphDocStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(8, graphDocStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endModel(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createModel(\n      builder: flatbuffers.Builder,\n      irVersion: flatbuffers.Long,\n      opsetImportOffset: flatbuffers.Offset,\n      producerNameOffset: flatbuffers.Offset,\n      producerVersionOffset: flatbuffers.Offset,\n      domainOffset: flatbuffers.Offset,\n      modelVersion: flatbuffers.Long,\n      docStringOffset: flatbuffers.Offset,\n      graphOffset: flatbuffers.Offset,\n      graphDocStringOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      Model.startModel(builder);\n      Model.addIrVersion(builder, irVersion);\n      Model.addOpsetImport(builder, opsetImportOffset);\n      Model.addProducerName(builder, producerNameOffset);\n      Model.addProducerVersion(builder, producerVersionOffset);\n      Model.addDomain(builder, domainOffset);\n      Model.addModelVersion(builder, modelVersion);\n      Model.addDocString(builder, docStringOffset);\n      Model.addGraph(builder, graphOffset);\n      Model.addGraphDocString(builder, graphDocStringOffset);\n      return Model.endModel(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class KernelCreateInfos {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns KernelCreateInfos\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): KernelCreateInfos {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param KernelCreateInfos= obj\n     * @returns KernelCreateInfos\n     */\n    static getRootAsKernelCreateInfos(bb: flatbuffers.ByteBuffer, obj?: KernelCreateInfos): KernelCreateInfos {\n      return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param KernelCreateInfos= obj\n     * @returns KernelCreateInfos\n     */\n    static getSizePrefixedRootAsKernelCreateInfos(\n      bb: flatbuffers.ByteBuffer,\n      obj?: KernelCreateInfos,\n    ): KernelCreateInfos {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    nodeIndices(index: number): number | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.readUint32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeIndicesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Uint32Array\n     */\n    nodeIndicesArray(): Uint32Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? new Uint32Array(\n            this.bb!.bytes().buffer,\n            this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n            this.bb!.__vector_len(this.bb_pos + offset),\n          )\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    kernelDefHashes(index: number): flatbuffers.Long | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? this.bb!.readUint64(this.bb!.__vector(this.bb_pos + offset) + index * 8)\n        : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    kernelDefHashesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startKernelCreateInfos(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodeIndicesOffset\n     */\n    static addNodeIndices(builder: flatbuffers.Builder, nodeIndicesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nodeIndicesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodeIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt32(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodeIndicesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset kernelDefHashesOffset\n     */\n    static addKernelDefHashes(builder: flatbuffers.Builder, kernelDefHashesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, kernelDefHashesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createKernelDefHashesVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startKernelDefHashesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endKernelCreateInfos(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createKernelCreateInfos(\n      builder: flatbuffers.Builder,\n      nodeIndicesOffset: flatbuffers.Offset,\n      kernelDefHashesOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      KernelCreateInfos.startKernelCreateInfos(builder);\n      KernelCreateInfos.addNodeIndices(builder, nodeIndicesOffset);\n      KernelCreateInfos.addKernelDefHashes(builder, kernelDefHashesOffset);\n      return KernelCreateInfos.endKernelCreateInfos(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SubGraphSessionState {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SubGraphSessionState\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SubGraphSessionState {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SubGraphSessionState= obj\n     * @returns SubGraphSessionState\n     */\n    static getRootAsSubGraphSessionState(bb: flatbuffers.ByteBuffer, obj?: SubGraphSessionState): SubGraphSessionState {\n      return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SubGraphSessionState= obj\n     * @returns SubGraphSessionState\n     */\n    static getSizePrefixedRootAsSubGraphSessionState(\n      bb: flatbuffers.ByteBuffer,\n      obj?: SubGraphSessionState,\n    ): SubGraphSessionState {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    graphId(): string | null;\n    graphId(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    graphId(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.SessionState= obj\n     * @returns onnxruntime.experimental.fbs.SessionState|null\n     */\n    sessionState(obj?: onnxruntime.experimental.fbs.SessionState): onnxruntime.experimental.fbs.SessionState | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.SessionState()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSubGraphSessionState(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphIdOffset\n     */\n    static addGraphId(builder: flatbuffers.Builder, graphIdOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, graphIdOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sessionStateOffset\n     */\n    static addSessionState(builder: flatbuffers.Builder, sessionStateOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, sessionStateOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSubGraphSessionState(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      builder.requiredField(offset, 4); // graph_id\n      return offset;\n    }\n\n    static createSubGraphSessionState(\n      builder: flatbuffers.Builder,\n      graphIdOffset: flatbuffers.Offset,\n      sessionStateOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      SubGraphSessionState.startSubGraphSessionState(builder);\n      SubGraphSessionState.addGraphId(builder, graphIdOffset);\n      SubGraphSessionState.addSessionState(builder, sessionStateOffset);\n      return SubGraphSessionState.endSubGraphSessionState(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SessionState {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SessionState\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SessionState {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SessionState= obj\n     * @returns SessionState\n     */\n    static getRootAsSessionState(bb: flatbuffers.ByteBuffer, obj?: SessionState): SessionState {\n      return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SessionState= obj\n     * @returns SessionState\n     */\n    static getSizePrefixedRootAsSessionState(bb: flatbuffers.ByteBuffer, obj?: SessionState): SessionState {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.KernelCreateInfos= obj\n     * @returns onnxruntime.experimental.fbs.KernelCreateInfos|null\n     */\n    kernels(\n      obj?: onnxruntime.experimental.fbs.KernelCreateInfos,\n    ): onnxruntime.experimental.fbs.KernelCreateInfos | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.KernelCreateInfos()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.SubGraphSessionState= obj\n     * @returns onnxruntime.experimental.fbs.SubGraphSessionState\n     */\n    subGraphSessionStates(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.SubGraphSessionState,\n    ): onnxruntime.experimental.fbs.SubGraphSessionState | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.SubGraphSessionState()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    subGraphSessionStatesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSessionState(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset kernelsOffset\n     */\n    static addKernels(builder: flatbuffers.Builder, kernelsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, kernelsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset subGraphSessionStatesOffset\n     */\n    static addSubGraphSessionStates(builder: flatbuffers.Builder, subGraphSessionStatesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, subGraphSessionStatesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createSubGraphSessionStatesVector(\n      builder: flatbuffers.Builder,\n      data: flatbuffers.Offset[],\n    ): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startSubGraphSessionStatesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSessionState(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createSessionState(\n      builder: flatbuffers.Builder,\n      kernelsOffset: flatbuffers.Offset,\n      subGraphSessionStatesOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      SessionState.startSessionState(builder);\n      SessionState.addKernels(builder, kernelsOffset);\n      SessionState.addSubGraphSessionStates(builder, subGraphSessionStatesOffset);\n      return SessionState.endSessionState(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class InferenceSession {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns InferenceSession\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): InferenceSession {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param InferenceSession= obj\n     * @returns InferenceSession\n     */\n    static getRootAsInferenceSession(bb: flatbuffers.ByteBuffer, obj?: InferenceSession): InferenceSession {\n      return (obj || new InferenceSession()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param InferenceSession= obj\n     * @returns InferenceSession\n     */\n    static getSizePrefixedRootAsInferenceSession(bb: flatbuffers.ByteBuffer, obj?: InferenceSession): InferenceSession {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new InferenceSession()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @returns boolean\n     */\n    static bufferHasIdentifier(bb: flatbuffers.ByteBuffer): boolean {\n      return bb.__has_identifier('ORTM');\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    ortVersion(): string | null;\n    ortVersion(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    ortVersion(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Model= obj\n     * @returns onnxruntime.experimental.fbs.Model|null\n     */\n    model(obj?: onnxruntime.experimental.fbs.Model): onnxruntime.experimental.fbs.Model | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Model()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.SessionState= obj\n     * @returns onnxruntime.experimental.fbs.SessionState|null\n     */\n    sessionState(obj?: onnxruntime.experimental.fbs.SessionState): onnxruntime.experimental.fbs.SessionState | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.SessionState()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startInferenceSession(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset ortVersionOffset\n     */\n    static addOrtVersion(builder: flatbuffers.Builder, ortVersionOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, ortVersionOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset modelOffset\n     */\n    static addModel(builder: flatbuffers.Builder, modelOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, modelOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sessionStateOffset\n     */\n    static addSessionState(builder: flatbuffers.Builder, sessionStateOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, sessionStateOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endInferenceSession(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset offset\n     */\n    static finishInferenceSessionBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {\n      builder.finish(offset, 'ORTM');\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset offset\n     */\n    static finishSizePrefixedInferenceSessionBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {\n      builder.finish(offset, 'ORTM', true);\n    }\n\n    static createInferenceSession(\n      builder: flatbuffers.Builder,\n      ortVersionOffset: flatbuffers.Offset,\n      modelOffset: flatbuffers.Offset,\n      sessionStateOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      InferenceSession.startInferenceSession(builder);\n      InferenceSession.addOrtVersion(builder, ortVersionOffset);\n      InferenceSession.addModel(builder, modelOffset);\n      InferenceSession.addSessionState(builder, sessionStateOffset);\n      return InferenceSession.endInferenceSession(builder);\n    }\n  }\n}\n","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n'use strict';\n\nvar $protobuf = require('protobufjs/minimal');\n\n// Common aliases\nvar $Reader = $protobuf.Reader,\n  $Writer = $protobuf.Writer,\n  $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots['default'] || ($protobuf.roots['default'] = {});\n\n$root.onnx = (function () {\n  /**\n   * Namespace onnx.\n   * @exports onnx\n   * @namespace\n   */\n  var onnx = {};\n\n  /**\n   * Version enum.\n   * @name onnx.Version\n   * @enum {number}\n   * @property {number} _START_VERSION=0 _START_VERSION value\n   * @property {number} IR_VERSION_2017_10_10=1 IR_VERSION_2017_10_10 value\n   * @property {number} IR_VERSION_2017_10_30=2 IR_VERSION_2017_10_30 value\n   * @property {number} IR_VERSION_2017_11_3=3 IR_VERSION_2017_11_3 value\n   * @property {number} IR_VERSION_2019_1_22=4 IR_VERSION_2019_1_22 value\n   * @property {number} IR_VERSION_2019_3_18=5 IR_VERSION_2019_3_18 value\n   * @property {number} IR_VERSION_2019_9_19=6 IR_VERSION_2019_9_19 value\n   * @property {number} IR_VERSION_2020_5_8=7 IR_VERSION_2020_5_8 value\n   * @property {number} IR_VERSION_2021_7_30=8 IR_VERSION_2021_7_30 value\n   * @property {number} IR_VERSION=9 IR_VERSION value\n   */\n  onnx.Version = (function () {\n    var valuesById = {},\n      values = Object.create(valuesById);\n    values[(valuesById[0] = '_START_VERSION')] = 0;\n    values[(valuesById[1] = 'IR_VERSION_2017_10_10')] = 1;\n    values[(valuesById[2] = 'IR_VERSION_2017_10_30')] = 2;\n    values[(valuesById[3] = 'IR_VERSION_2017_11_3')] = 3;\n    values[(valuesById[4] = 'IR_VERSION_2019_1_22')] = 4;\n    values[(valuesById[5] = 'IR_VERSION_2019_3_18')] = 5;\n    values[(valuesById[6] = 'IR_VERSION_2019_9_19')] = 6;\n    values[(valuesById[7] = 'IR_VERSION_2020_5_8')] = 7;\n    values[(valuesById[8] = 'IR_VERSION_2021_7_30')] = 8;\n    values[(valuesById[9] = 'IR_VERSION')] = 9;\n    return values;\n  })();\n\n  onnx.AttributeProto = (function () {\n    /**\n     * Properties of an AttributeProto.\n     * @memberof onnx\n     * @interface IAttributeProto\n     * @property {string|null} [name] AttributeProto name\n     * @property {string|null} [refAttrName] AttributeProto refAttrName\n     * @property {string|null} [docString] AttributeProto docString\n     * @property {onnx.AttributeProto.AttributeType|null} [type] AttributeProto type\n     * @property {number|null} [f] AttributeProto f\n     * @property {number|Long|null} [i] AttributeProto i\n     * @property {Uint8Array|null} [s] AttributeProto s\n     * @property {onnx.ITensorProto|null} [t] AttributeProto t\n     * @property {onnx.IGraphProto|null} [g] AttributeProto g\n     * @property {onnx.ISparseTensorProto|null} [sparseTensor] AttributeProto sparseTensor\n     * @property {onnx.ITypeProto|null} [tp] AttributeProto tp\n     * @property {Array.<number>|null} [floats] AttributeProto floats\n     * @property {Array.<number|Long>|null} [ints] AttributeProto ints\n     * @property {Array.<Uint8Array>|null} [strings] AttributeProto strings\n     * @property {Array.<onnx.ITensorProto>|null} [tensors] AttributeProto tensors\n     * @property {Array.<onnx.IGraphProto>|null} [graphs] AttributeProto graphs\n     * @property {Array.<onnx.ISparseTensorProto>|null} [sparseTensors] AttributeProto sparseTensors\n     * @property {Array.<onnx.ITypeProto>|null} [typeProtos] AttributeProto typeProtos\n     */\n\n    /**\n     * Constructs a new AttributeProto.\n     * @memberof onnx\n     * @classdesc Represents an AttributeProto.\n     * @implements IAttributeProto\n     * @constructor\n     * @param {onnx.IAttributeProto=} [properties] Properties to set\n     */\n    function AttributeProto(properties) {\n      this.floats = [];\n      this.ints = [];\n      this.strings = [];\n      this.tensors = [];\n      this.graphs = [];\n      this.sparseTensors = [];\n      this.typeProtos = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * AttributeProto name.\n     * @member {string} name\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.name = '';\n\n    /**\n     * AttributeProto refAttrName.\n     * @member {string} refAttrName\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.refAttrName = '';\n\n    /**\n     * AttributeProto docString.\n     * @member {string} docString\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.docString = '';\n\n    /**\n     * AttributeProto type.\n     * @member {onnx.AttributeProto.AttributeType} type\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.type = 0;\n\n    /**\n     * AttributeProto f.\n     * @member {number} f\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.f = 0;\n\n    /**\n     * AttributeProto i.\n     * @member {number|Long} i\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.i = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n    /**\n     * AttributeProto s.\n     * @member {Uint8Array} s\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.s = $util.newBuffer([]);\n\n    /**\n     * AttributeProto t.\n     * @member {onnx.ITensorProto|null|undefined} t\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.t = null;\n\n    /**\n     * AttributeProto g.\n     * @member {onnx.IGraphProto|null|undefined} g\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.g = null;\n\n    /**\n     * AttributeProto sparseTensor.\n     * @member {onnx.ISparseTensorProto|null|undefined} sparseTensor\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.sparseTensor = null;\n\n    /**\n     * AttributeProto tp.\n     * @member {onnx.ITypeProto|null|undefined} tp\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.tp = null;\n\n    /**\n     * AttributeProto floats.\n     * @member {Array.<number>} floats\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.floats = $util.emptyArray;\n\n    /**\n     * AttributeProto ints.\n     * @member {Array.<number|Long>} ints\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.ints = $util.emptyArray;\n\n    /**\n     * AttributeProto strings.\n     * @member {Array.<Uint8Array>} strings\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.strings = $util.emptyArray;\n\n    /**\n     * AttributeProto tensors.\n     * @member {Array.<onnx.ITensorProto>} tensors\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.tensors = $util.emptyArray;\n\n    /**\n     * AttributeProto graphs.\n     * @member {Array.<onnx.IGraphProto>} graphs\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.graphs = $util.emptyArray;\n\n    /**\n     * AttributeProto sparseTensors.\n     * @member {Array.<onnx.ISparseTensorProto>} sparseTensors\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.sparseTensors = $util.emptyArray;\n\n    /**\n     * AttributeProto typeProtos.\n     * @member {Array.<onnx.ITypeProto>} typeProtos\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.typeProtos = $util.emptyArray;\n\n    /**\n     * Creates a new AttributeProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {onnx.IAttributeProto=} [properties] Properties to set\n     * @returns {onnx.AttributeProto} AttributeProto instance\n     */\n    AttributeProto.create = function create(properties) {\n      return new AttributeProto(properties);\n    };\n\n    /**\n     * Encodes the specified AttributeProto message. Does not implicitly {@link onnx.AttributeProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {onnx.IAttributeProto} message AttributeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    AttributeProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);\n      if (message.f != null && Object.hasOwnProperty.call(message, 'f'))\n        writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.f);\n      if (message.i != null && Object.hasOwnProperty.call(message, 'i'))\n        writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.i);\n      if (message.s != null && Object.hasOwnProperty.call(message, 's'))\n        writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.s);\n      if (message.t != null && Object.hasOwnProperty.call(message, 't'))\n        $root.onnx.TensorProto.encode(message.t, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();\n      if (message.g != null && Object.hasOwnProperty.call(message, 'g'))\n        $root.onnx.GraphProto.encode(message.g, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();\n      if (message.floats != null && message.floats.length) {\n        writer.uint32(/* id 7, wireType 2 =*/ 58).fork();\n        for (var i = 0; i < message.floats.length; ++i) writer.float(message.floats[i]);\n        writer.ldelim();\n      }\n      if (message.ints != null && message.ints.length) {\n        writer.uint32(/* id 8, wireType 2 =*/ 66).fork();\n        for (var i = 0; i < message.ints.length; ++i) writer.int64(message.ints[i]);\n        writer.ldelim();\n      }\n      if (message.strings != null && message.strings.length)\n        for (var i = 0; i < message.strings.length; ++i)\n          writer.uint32(/* id 9, wireType 2 =*/ 74).bytes(message.strings[i]);\n      if (message.tensors != null && message.tensors.length)\n        for (var i = 0; i < message.tensors.length; ++i)\n          $root.onnx.TensorProto.encode(message.tensors[i], writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();\n      if (message.graphs != null && message.graphs.length)\n        for (var i = 0; i < message.graphs.length; ++i)\n          $root.onnx.GraphProto.encode(message.graphs[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 13, wireType 2 =*/ 106).string(message.docString);\n      if (message.tp != null && Object.hasOwnProperty.call(message, 'tp'))\n        $root.onnx.TypeProto.encode(message.tp, writer.uint32(/* id 14, wireType 2 =*/ 114).fork()).ldelim();\n      if (message.typeProtos != null && message.typeProtos.length)\n        for (var i = 0; i < message.typeProtos.length; ++i)\n          $root.onnx.TypeProto.encode(\n            message.typeProtos[i],\n            writer.uint32(/* id 15, wireType 2 =*/ 122).fork(),\n          ).ldelim();\n      if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n        writer.uint32(/* id 20, wireType 0 =*/ 160).int32(message.type);\n      if (message.refAttrName != null && Object.hasOwnProperty.call(message, 'refAttrName'))\n        writer.uint32(/* id 21, wireType 2 =*/ 170).string(message.refAttrName);\n      if (message.sparseTensor != null && Object.hasOwnProperty.call(message, 'sparseTensor'))\n        $root.onnx.SparseTensorProto.encode(\n          message.sparseTensor,\n          writer.uint32(/* id 22, wireType 2 =*/ 178).fork(),\n        ).ldelim();\n      if (message.sparseTensors != null && message.sparseTensors.length)\n        for (var i = 0; i < message.sparseTensors.length; ++i)\n          $root.onnx.SparseTensorProto.encode(\n            message.sparseTensors[i],\n            writer.uint32(/* id 23, wireType 2 =*/ 186).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified AttributeProto message, length delimited. Does not implicitly {@link onnx.AttributeProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {onnx.IAttributeProto} message AttributeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    AttributeProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an AttributeProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.AttributeProto} AttributeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    AttributeProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.AttributeProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.name = reader.string();\n            break;\n          }\n          case 21: {\n            message.refAttrName = reader.string();\n            break;\n          }\n          case 13: {\n            message.docString = reader.string();\n            break;\n          }\n          case 20: {\n            message.type = reader.int32();\n            break;\n          }\n          case 2: {\n            message.f = reader.float();\n            break;\n          }\n          case 3: {\n            message.i = reader.int64();\n            break;\n          }\n          case 4: {\n            message.s = reader.bytes();\n            break;\n          }\n          case 5: {\n            message.t = $root.onnx.TensorProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 6: {\n            message.g = $root.onnx.GraphProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 22: {\n            message.sparseTensor = $root.onnx.SparseTensorProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 14: {\n            message.tp = $root.onnx.TypeProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 7: {\n            if (!(message.floats && message.floats.length)) message.floats = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.floats.push(reader.float());\n            } else message.floats.push(reader.float());\n            break;\n          }\n          case 8: {\n            if (!(message.ints && message.ints.length)) message.ints = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.ints.push(reader.int64());\n            } else message.ints.push(reader.int64());\n            break;\n          }\n          case 9: {\n            if (!(message.strings && message.strings.length)) message.strings = [];\n            message.strings.push(reader.bytes());\n            break;\n          }\n          case 10: {\n            if (!(message.tensors && message.tensors.length)) message.tensors = [];\n            message.tensors.push($root.onnx.TensorProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 11: {\n            if (!(message.graphs && message.graphs.length)) message.graphs = [];\n            message.graphs.push($root.onnx.GraphProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 23: {\n            if (!(message.sparseTensors && message.sparseTensors.length)) message.sparseTensors = [];\n            message.sparseTensors.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 15: {\n            if (!(message.typeProtos && message.typeProtos.length)) message.typeProtos = [];\n            message.typeProtos.push($root.onnx.TypeProto.decode(reader, reader.uint32()));\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes an AttributeProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.AttributeProto} AttributeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    AttributeProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an AttributeProto message.\n     * @function verify\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    AttributeProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.name != null && message.hasOwnProperty('name'))\n        if (!$util.isString(message.name)) return 'name: string expected';\n      if (message.refAttrName != null && message.hasOwnProperty('refAttrName'))\n        if (!$util.isString(message.refAttrName)) return 'refAttrName: string expected';\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      if (message.type != null && message.hasOwnProperty('type'))\n        switch (message.type) {\n          default:\n            return 'type: enum value expected';\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 11:\n          case 13:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 12:\n          case 14:\n            break;\n        }\n      if (message.f != null && message.hasOwnProperty('f'))\n        if (typeof message.f !== 'number') return 'f: number expected';\n      if (message.i != null && message.hasOwnProperty('i'))\n        if (\n          !$util.isInteger(message.i) &&\n          !(message.i && $util.isInteger(message.i.low) && $util.isInteger(message.i.high))\n        )\n          return 'i: integer|Long expected';\n      if (message.s != null && message.hasOwnProperty('s'))\n        if (!((message.s && typeof message.s.length === 'number') || $util.isString(message.s)))\n          return 's: buffer expected';\n      if (message.t != null && message.hasOwnProperty('t')) {\n        var error = $root.onnx.TensorProto.verify(message.t);\n        if (error) return 't.' + error;\n      }\n      if (message.g != null && message.hasOwnProperty('g')) {\n        var error = $root.onnx.GraphProto.verify(message.g);\n        if (error) return 'g.' + error;\n      }\n      if (message.sparseTensor != null && message.hasOwnProperty('sparseTensor')) {\n        var error = $root.onnx.SparseTensorProto.verify(message.sparseTensor);\n        if (error) return 'sparseTensor.' + error;\n      }\n      if (message.tp != null && message.hasOwnProperty('tp')) {\n        var error = $root.onnx.TypeProto.verify(message.tp);\n        if (error) return 'tp.' + error;\n      }\n      if (message.floats != null && message.hasOwnProperty('floats')) {\n        if (!Array.isArray(message.floats)) return 'floats: array expected';\n        for (var i = 0; i < message.floats.length; ++i)\n          if (typeof message.floats[i] !== 'number') return 'floats: number[] expected';\n      }\n      if (message.ints != null && message.hasOwnProperty('ints')) {\n        if (!Array.isArray(message.ints)) return 'ints: array expected';\n        for (var i = 0; i < message.ints.length; ++i)\n          if (\n            !$util.isInteger(message.ints[i]) &&\n            !(message.ints[i] && $util.isInteger(message.ints[i].low) && $util.isInteger(message.ints[i].high))\n          )\n            return 'ints: integer|Long[] expected';\n      }\n      if (message.strings != null && message.hasOwnProperty('strings')) {\n        if (!Array.isArray(message.strings)) return 'strings: array expected';\n        for (var i = 0; i < message.strings.length; ++i)\n          if (\n            !(\n              (message.strings[i] && typeof message.strings[i].length === 'number') ||\n              $util.isString(message.strings[i])\n            )\n          )\n            return 'strings: buffer[] expected';\n      }\n      if (message.tensors != null && message.hasOwnProperty('tensors')) {\n        if (!Array.isArray(message.tensors)) return 'tensors: array expected';\n        for (var i = 0; i < message.tensors.length; ++i) {\n          var error = $root.onnx.TensorProto.verify(message.tensors[i]);\n          if (error) return 'tensors.' + error;\n        }\n      }\n      if (message.graphs != null && message.hasOwnProperty('graphs')) {\n        if (!Array.isArray(message.graphs)) return 'graphs: array expected';\n        for (var i = 0; i < message.graphs.length; ++i) {\n          var error = $root.onnx.GraphProto.verify(message.graphs[i]);\n          if (error) return 'graphs.' + error;\n        }\n      }\n      if (message.sparseTensors != null && message.hasOwnProperty('sparseTensors')) {\n        if (!Array.isArray(message.sparseTensors)) return 'sparseTensors: array expected';\n        for (var i = 0; i < message.sparseTensors.length; ++i) {\n          var error = $root.onnx.SparseTensorProto.verify(message.sparseTensors[i]);\n          if (error) return 'sparseTensors.' + error;\n        }\n      }\n      if (message.typeProtos != null && message.hasOwnProperty('typeProtos')) {\n        if (!Array.isArray(message.typeProtos)) return 'typeProtos: array expected';\n        for (var i = 0; i < message.typeProtos.length; ++i) {\n          var error = $root.onnx.TypeProto.verify(message.typeProtos[i]);\n          if (error) return 'typeProtos.' + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates an AttributeProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.AttributeProto} AttributeProto\n     */\n    AttributeProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.AttributeProto) return object;\n      var message = new $root.onnx.AttributeProto();\n      if (object.name != null) message.name = String(object.name);\n      if (object.refAttrName != null) message.refAttrName = String(object.refAttrName);\n      if (object.docString != null) message.docString = String(object.docString);\n      switch (object.type) {\n        default:\n          if (typeof object.type === 'number') {\n            message.type = object.type;\n            break;\n          }\n          break;\n        case 'UNDEFINED':\n        case 0:\n          message.type = 0;\n          break;\n        case 'FLOAT':\n        case 1:\n          message.type = 1;\n          break;\n        case 'INT':\n        case 2:\n          message.type = 2;\n          break;\n        case 'STRING':\n        case 3:\n          message.type = 3;\n          break;\n        case 'TENSOR':\n        case 4:\n          message.type = 4;\n          break;\n        case 'GRAPH':\n        case 5:\n          message.type = 5;\n          break;\n        case 'SPARSE_TENSOR':\n        case 11:\n          message.type = 11;\n          break;\n        case 'TYPE_PROTO':\n        case 13:\n          message.type = 13;\n          break;\n        case 'FLOATS':\n        case 6:\n          message.type = 6;\n          break;\n        case 'INTS':\n        case 7:\n          message.type = 7;\n          break;\n        case 'STRINGS':\n        case 8:\n          message.type = 8;\n          break;\n        case 'TENSORS':\n        case 9:\n          message.type = 9;\n          break;\n        case 'GRAPHS':\n        case 10:\n          message.type = 10;\n          break;\n        case 'SPARSE_TENSORS':\n        case 12:\n          message.type = 12;\n          break;\n        case 'TYPE_PROTOS':\n        case 14:\n          message.type = 14;\n          break;\n      }\n      if (object.f != null) message.f = Number(object.f);\n      if (object.i != null)\n        if ($util.Long) (message.i = $util.Long.fromValue(object.i)).unsigned = false;\n        else if (typeof object.i === 'string') message.i = parseInt(object.i, 10);\n        else if (typeof object.i === 'number') message.i = object.i;\n        else if (typeof object.i === 'object')\n          message.i = new $util.LongBits(object.i.low >>> 0, object.i.high >>> 0).toNumber();\n      if (object.s != null)\n        if (typeof object.s === 'string')\n          $util.base64.decode(object.s, (message.s = $util.newBuffer($util.base64.length(object.s))), 0);\n        else if (object.s.length >= 0) message.s = object.s;\n      if (object.t != null) {\n        if (typeof object.t !== 'object') throw TypeError('.onnx.AttributeProto.t: object expected');\n        message.t = $root.onnx.TensorProto.fromObject(object.t);\n      }\n      if (object.g != null) {\n        if (typeof object.g !== 'object') throw TypeError('.onnx.AttributeProto.g: object expected');\n        message.g = $root.onnx.GraphProto.fromObject(object.g);\n      }\n      if (object.sparseTensor != null) {\n        if (typeof object.sparseTensor !== 'object')\n          throw TypeError('.onnx.AttributeProto.sparseTensor: object expected');\n        message.sparseTensor = $root.onnx.SparseTensorProto.fromObject(object.sparseTensor);\n      }\n      if (object.tp != null) {\n        if (typeof object.tp !== 'object') throw TypeError('.onnx.AttributeProto.tp: object expected');\n        message.tp = $root.onnx.TypeProto.fromObject(object.tp);\n      }\n      if (object.floats) {\n        if (!Array.isArray(object.floats)) throw TypeError('.onnx.AttributeProto.floats: array expected');\n        message.floats = [];\n        for (var i = 0; i < object.floats.length; ++i) message.floats[i] = Number(object.floats[i]);\n      }\n      if (object.ints) {\n        if (!Array.isArray(object.ints)) throw TypeError('.onnx.AttributeProto.ints: array expected');\n        message.ints = [];\n        for (var i = 0; i < object.ints.length; ++i)\n          if ($util.Long) (message.ints[i] = $util.Long.fromValue(object.ints[i])).unsigned = false;\n          else if (typeof object.ints[i] === 'string') message.ints[i] = parseInt(object.ints[i], 10);\n          else if (typeof object.ints[i] === 'number') message.ints[i] = object.ints[i];\n          else if (typeof object.ints[i] === 'object')\n            message.ints[i] = new $util.LongBits(object.ints[i].low >>> 0, object.ints[i].high >>> 0).toNumber();\n      }\n      if (object.strings) {\n        if (!Array.isArray(object.strings)) throw TypeError('.onnx.AttributeProto.strings: array expected');\n        message.strings = [];\n        for (var i = 0; i < object.strings.length; ++i)\n          if (typeof object.strings[i] === 'string')\n            $util.base64.decode(\n              object.strings[i],\n              (message.strings[i] = $util.newBuffer($util.base64.length(object.strings[i]))),\n              0,\n            );\n          else if (object.strings[i].length >= 0) message.strings[i] = object.strings[i];\n      }\n      if (object.tensors) {\n        if (!Array.isArray(object.tensors)) throw TypeError('.onnx.AttributeProto.tensors: array expected');\n        message.tensors = [];\n        for (var i = 0; i < object.tensors.length; ++i) {\n          if (typeof object.tensors[i] !== 'object') throw TypeError('.onnx.AttributeProto.tensors: object expected');\n          message.tensors[i] = $root.onnx.TensorProto.fromObject(object.tensors[i]);\n        }\n      }\n      if (object.graphs) {\n        if (!Array.isArray(object.graphs)) throw TypeError('.onnx.AttributeProto.graphs: array expected');\n        message.graphs = [];\n        for (var i = 0; i < object.graphs.length; ++i) {\n          if (typeof object.graphs[i] !== 'object') throw TypeError('.onnx.AttributeProto.graphs: object expected');\n          message.graphs[i] = $root.onnx.GraphProto.fromObject(object.graphs[i]);\n        }\n      }\n      if (object.sparseTensors) {\n        if (!Array.isArray(object.sparseTensors)) throw TypeError('.onnx.AttributeProto.sparseTensors: array expected');\n        message.sparseTensors = [];\n        for (var i = 0; i < object.sparseTensors.length; ++i) {\n          if (typeof object.sparseTensors[i] !== 'object')\n            throw TypeError('.onnx.AttributeProto.sparseTensors: object expected');\n          message.sparseTensors[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseTensors[i]);\n        }\n      }\n      if (object.typeProtos) {\n        if (!Array.isArray(object.typeProtos)) throw TypeError('.onnx.AttributeProto.typeProtos: array expected');\n        message.typeProtos = [];\n        for (var i = 0; i < object.typeProtos.length; ++i) {\n          if (typeof object.typeProtos[i] !== 'object')\n            throw TypeError('.onnx.AttributeProto.typeProtos: object expected');\n          message.typeProtos[i] = $root.onnx.TypeProto.fromObject(object.typeProtos[i]);\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from an AttributeProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {onnx.AttributeProto} message AttributeProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    AttributeProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.floats = [];\n        object.ints = [];\n        object.strings = [];\n        object.tensors = [];\n        object.graphs = [];\n        object.typeProtos = [];\n        object.sparseTensors = [];\n      }\n      if (options.defaults) {\n        object.name = '';\n        object.f = 0;\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, false);\n          object.i = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.i = options.longs === String ? '0' : 0;\n        if (options.bytes === String) object.s = '';\n        else {\n          object.s = [];\n          if (options.bytes !== Array) object.s = $util.newBuffer(object.s);\n        }\n        object.t = null;\n        object.g = null;\n        object.docString = '';\n        object.tp = null;\n        object.type = options.enums === String ? 'UNDEFINED' : 0;\n        object.refAttrName = '';\n        object.sparseTensor = null;\n      }\n      if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;\n      if (message.f != null && message.hasOwnProperty('f'))\n        object.f = options.json && !isFinite(message.f) ? String(message.f) : message.f;\n      if (message.i != null && message.hasOwnProperty('i'))\n        if (typeof message.i === 'number') object.i = options.longs === String ? String(message.i) : message.i;\n        else\n          object.i =\n            options.longs === String\n              ? $util.Long.prototype.toString.call(message.i)\n              : options.longs === Number\n                ? new $util.LongBits(message.i.low >>> 0, message.i.high >>> 0).toNumber()\n                : message.i;\n      if (message.s != null && message.hasOwnProperty('s'))\n        object.s =\n          options.bytes === String\n            ? $util.base64.encode(message.s, 0, message.s.length)\n            : options.bytes === Array\n              ? Array.prototype.slice.call(message.s)\n              : message.s;\n      if (message.t != null && message.hasOwnProperty('t'))\n        object.t = $root.onnx.TensorProto.toObject(message.t, options);\n      if (message.g != null && message.hasOwnProperty('g'))\n        object.g = $root.onnx.GraphProto.toObject(message.g, options);\n      if (message.floats && message.floats.length) {\n        object.floats = [];\n        for (var j = 0; j < message.floats.length; ++j)\n          object.floats[j] =\n            options.json && !isFinite(message.floats[j]) ? String(message.floats[j]) : message.floats[j];\n      }\n      if (message.ints && message.ints.length) {\n        object.ints = [];\n        for (var j = 0; j < message.ints.length; ++j)\n          if (typeof message.ints[j] === 'number')\n            object.ints[j] = options.longs === String ? String(message.ints[j]) : message.ints[j];\n          else\n            object.ints[j] =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.ints[j])\n                : options.longs === Number\n                  ? new $util.LongBits(message.ints[j].low >>> 0, message.ints[j].high >>> 0).toNumber()\n                  : message.ints[j];\n      }\n      if (message.strings && message.strings.length) {\n        object.strings = [];\n        for (var j = 0; j < message.strings.length; ++j)\n          object.strings[j] =\n            options.bytes === String\n              ? $util.base64.encode(message.strings[j], 0, message.strings[j].length)\n              : options.bytes === Array\n                ? Array.prototype.slice.call(message.strings[j])\n                : message.strings[j];\n      }\n      if (message.tensors && message.tensors.length) {\n        object.tensors = [];\n        for (var j = 0; j < message.tensors.length; ++j)\n          object.tensors[j] = $root.onnx.TensorProto.toObject(message.tensors[j], options);\n      }\n      if (message.graphs && message.graphs.length) {\n        object.graphs = [];\n        for (var j = 0; j < message.graphs.length; ++j)\n          object.graphs[j] = $root.onnx.GraphProto.toObject(message.graphs[j], options);\n      }\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      if (message.tp != null && message.hasOwnProperty('tp'))\n        object.tp = $root.onnx.TypeProto.toObject(message.tp, options);\n      if (message.typeProtos && message.typeProtos.length) {\n        object.typeProtos = [];\n        for (var j = 0; j < message.typeProtos.length; ++j)\n          object.typeProtos[j] = $root.onnx.TypeProto.toObject(message.typeProtos[j], options);\n      }\n      if (message.type != null && message.hasOwnProperty('type'))\n        object.type =\n          options.enums === String\n            ? $root.onnx.AttributeProto.AttributeType[message.type] === undefined\n              ? message.type\n              : $root.onnx.AttributeProto.AttributeType[message.type]\n            : message.type;\n      if (message.refAttrName != null && message.hasOwnProperty('refAttrName'))\n        object.refAttrName = message.refAttrName;\n      if (message.sparseTensor != null && message.hasOwnProperty('sparseTensor'))\n        object.sparseTensor = $root.onnx.SparseTensorProto.toObject(message.sparseTensor, options);\n      if (message.sparseTensors && message.sparseTensors.length) {\n        object.sparseTensors = [];\n        for (var j = 0; j < message.sparseTensors.length; ++j)\n          object.sparseTensors[j] = $root.onnx.SparseTensorProto.toObject(message.sparseTensors[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this AttributeProto to JSON.\n     * @function toJSON\n     * @memberof onnx.AttributeProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    AttributeProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for AttributeProto\n     * @function getTypeUrl\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    AttributeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.AttributeProto';\n    };\n\n    /**\n     * AttributeType enum.\n     * @name onnx.AttributeProto.AttributeType\n     * @enum {number}\n     * @property {number} UNDEFINED=0 UNDEFINED value\n     * @property {number} FLOAT=1 FLOAT value\n     * @property {number} INT=2 INT value\n     * @property {number} STRING=3 STRING value\n     * @property {number} TENSOR=4 TENSOR value\n     * @property {number} GRAPH=5 GRAPH value\n     * @property {number} SPARSE_TENSOR=11 SPARSE_TENSOR value\n     * @property {number} TYPE_PROTO=13 TYPE_PROTO value\n     * @property {number} FLOATS=6 FLOATS value\n     * @property {number} INTS=7 INTS value\n     * @property {number} STRINGS=8 STRINGS value\n     * @property {number} TENSORS=9 TENSORS value\n     * @property {number} GRAPHS=10 GRAPHS value\n     * @property {number} SPARSE_TENSORS=12 SPARSE_TENSORS value\n     * @property {number} TYPE_PROTOS=14 TYPE_PROTOS value\n     */\n    AttributeProto.AttributeType = (function () {\n      var valuesById = {},\n        values = Object.create(valuesById);\n      values[(valuesById[0] = 'UNDEFINED')] = 0;\n      values[(valuesById[1] = 'FLOAT')] = 1;\n      values[(valuesById[2] = 'INT')] = 2;\n      values[(valuesById[3] = 'STRING')] = 3;\n      values[(valuesById[4] = 'TENSOR')] = 4;\n      values[(valuesById[5] = 'GRAPH')] = 5;\n      values[(valuesById[11] = 'SPARSE_TENSOR')] = 11;\n      values[(valuesById[13] = 'TYPE_PROTO')] = 13;\n      values[(valuesById[6] = 'FLOATS')] = 6;\n      values[(valuesById[7] = 'INTS')] = 7;\n      values[(valuesById[8] = 'STRINGS')] = 8;\n      values[(valuesById[9] = 'TENSORS')] = 9;\n      values[(valuesById[10] = 'GRAPHS')] = 10;\n      values[(valuesById[12] = 'SPARSE_TENSORS')] = 12;\n      values[(valuesById[14] = 'TYPE_PROTOS')] = 14;\n      return values;\n    })();\n\n    return AttributeProto;\n  })();\n\n  onnx.ValueInfoProto = (function () {\n    /**\n     * Properties of a ValueInfoProto.\n     * @memberof onnx\n     * @interface IValueInfoProto\n     * @property {string|null} [name] ValueInfoProto name\n     * @property {onnx.ITypeProto|null} [type] ValueInfoProto type\n     * @property {string|null} [docString] ValueInfoProto docString\n     */\n\n    /**\n     * Constructs a new ValueInfoProto.\n     * @memberof onnx\n     * @classdesc Represents a ValueInfoProto.\n     * @implements IValueInfoProto\n     * @constructor\n     * @param {onnx.IValueInfoProto=} [properties] Properties to set\n     */\n    function ValueInfoProto(properties) {\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ValueInfoProto name.\n     * @member {string} name\n     * @memberof onnx.ValueInfoProto\n     * @instance\n     */\n    ValueInfoProto.prototype.name = '';\n\n    /**\n     * ValueInfoProto type.\n     * @member {onnx.ITypeProto|null|undefined} type\n     * @memberof onnx.ValueInfoProto\n     * @instance\n     */\n    ValueInfoProto.prototype.type = null;\n\n    /**\n     * ValueInfoProto docString.\n     * @member {string} docString\n     * @memberof onnx.ValueInfoProto\n     * @instance\n     */\n    ValueInfoProto.prototype.docString = '';\n\n    /**\n     * Creates a new ValueInfoProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {onnx.IValueInfoProto=} [properties] Properties to set\n     * @returns {onnx.ValueInfoProto} ValueInfoProto instance\n     */\n    ValueInfoProto.create = function create(properties) {\n      return new ValueInfoProto(properties);\n    };\n\n    /**\n     * Encodes the specified ValueInfoProto message. Does not implicitly {@link onnx.ValueInfoProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {onnx.IValueInfoProto} message ValueInfoProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ValueInfoProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);\n      if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n        $root.onnx.TypeProto.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.docString);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified ValueInfoProto message, length delimited. Does not implicitly {@link onnx.ValueInfoProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {onnx.IValueInfoProto} message ValueInfoProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ValueInfoProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ValueInfoProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.ValueInfoProto} ValueInfoProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ValueInfoProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.ValueInfoProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.name = reader.string();\n            break;\n          }\n          case 2: {\n            message.type = $root.onnx.TypeProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 3: {\n            message.docString = reader.string();\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a ValueInfoProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.ValueInfoProto} ValueInfoProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ValueInfoProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ValueInfoProto message.\n     * @function verify\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ValueInfoProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.name != null && message.hasOwnProperty('name'))\n        if (!$util.isString(message.name)) return 'name: string expected';\n      if (message.type != null && message.hasOwnProperty('type')) {\n        var error = $root.onnx.TypeProto.verify(message.type);\n        if (error) return 'type.' + error;\n      }\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      return null;\n    };\n\n    /**\n     * Creates a ValueInfoProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.ValueInfoProto} ValueInfoProto\n     */\n    ValueInfoProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.ValueInfoProto) return object;\n      var message = new $root.onnx.ValueInfoProto();\n      if (object.name != null) message.name = String(object.name);\n      if (object.type != null) {\n        if (typeof object.type !== 'object') throw TypeError('.onnx.ValueInfoProto.type: object expected');\n        message.type = $root.onnx.TypeProto.fromObject(object.type);\n      }\n      if (object.docString != null) message.docString = String(object.docString);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a ValueInfoProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {onnx.ValueInfoProto} message ValueInfoProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ValueInfoProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) {\n        object.name = '';\n        object.type = null;\n        object.docString = '';\n      }\n      if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;\n      if (message.type != null && message.hasOwnProperty('type'))\n        object.type = $root.onnx.TypeProto.toObject(message.type, options);\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      return object;\n    };\n\n    /**\n     * Converts this ValueInfoProto to JSON.\n     * @function toJSON\n     * @memberof onnx.ValueInfoProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ValueInfoProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for ValueInfoProto\n     * @function getTypeUrl\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    ValueInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.ValueInfoProto';\n    };\n\n    return ValueInfoProto;\n  })();\n\n  onnx.NodeProto = (function () {\n    /**\n     * Properties of a NodeProto.\n     * @memberof onnx\n     * @interface INodeProto\n     * @property {Array.<string>|null} [input] NodeProto input\n     * @property {Array.<string>|null} [output] NodeProto output\n     * @property {string|null} [name] NodeProto name\n     * @property {string|null} [opType] NodeProto opType\n     * @property {string|null} [domain] NodeProto domain\n     * @property {Array.<onnx.IAttributeProto>|null} [attribute] NodeProto attribute\n     * @property {string|null} [docString] NodeProto docString\n     */\n\n    /**\n     * Constructs a new NodeProto.\n     * @memberof onnx\n     * @classdesc Represents a NodeProto.\n     * @implements INodeProto\n     * @constructor\n     * @param {onnx.INodeProto=} [properties] Properties to set\n     */\n    function NodeProto(properties) {\n      this.input = [];\n      this.output = [];\n      this.attribute = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * NodeProto input.\n     * @member {Array.<string>} input\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.input = $util.emptyArray;\n\n    /**\n     * NodeProto output.\n     * @member {Array.<string>} output\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.output = $util.emptyArray;\n\n    /**\n     * NodeProto name.\n     * @member {string} name\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.name = '';\n\n    /**\n     * NodeProto opType.\n     * @member {string} opType\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.opType = '';\n\n    /**\n     * NodeProto domain.\n     * @member {string} domain\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.domain = '';\n\n    /**\n     * NodeProto attribute.\n     * @member {Array.<onnx.IAttributeProto>} attribute\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.attribute = $util.emptyArray;\n\n    /**\n     * NodeProto docString.\n     * @member {string} docString\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.docString = '';\n\n    /**\n     * Creates a new NodeProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {onnx.INodeProto=} [properties] Properties to set\n     * @returns {onnx.NodeProto} NodeProto instance\n     */\n    NodeProto.create = function create(properties) {\n      return new NodeProto(properties);\n    };\n\n    /**\n     * Encodes the specified NodeProto message. Does not implicitly {@link onnx.NodeProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {onnx.INodeProto} message NodeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    NodeProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.input != null && message.input.length)\n        for (var i = 0; i < message.input.length; ++i)\n          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.input[i]);\n      if (message.output != null && message.output.length)\n        for (var i = 0; i < message.output.length; ++i)\n          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.output[i]);\n      if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.name);\n      if (message.opType != null && Object.hasOwnProperty.call(message, 'opType'))\n        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.opType);\n      if (message.attribute != null && message.attribute.length)\n        for (var i = 0; i < message.attribute.length; ++i)\n          $root.onnx.AttributeProto.encode(\n            message.attribute[i],\n            writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),\n          ).ldelim();\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.docString);\n      if (message.domain != null && Object.hasOwnProperty.call(message, 'domain'))\n        writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.domain);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified NodeProto message, length delimited. Does not implicitly {@link onnx.NodeProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {onnx.INodeProto} message NodeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    NodeProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a NodeProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.NodeProto} NodeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    NodeProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.NodeProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            if (!(message.input && message.input.length)) message.input = [];\n            message.input.push(reader.string());\n            break;\n          }\n          case 2: {\n            if (!(message.output && message.output.length)) message.output = [];\n            message.output.push(reader.string());\n            break;\n          }\n          case 3: {\n            message.name = reader.string();\n            break;\n          }\n          case 4: {\n            message.opType = reader.string();\n            break;\n          }\n          case 7: {\n            message.domain = reader.string();\n            break;\n          }\n          case 5: {\n            if (!(message.attribute && message.attribute.length)) message.attribute = [];\n            message.attribute.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 6: {\n            message.docString = reader.string();\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a NodeProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.NodeProto} NodeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    NodeProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a NodeProto message.\n     * @function verify\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    NodeProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.input != null && message.hasOwnProperty('input')) {\n        if (!Array.isArray(message.input)) return 'input: array expected';\n        for (var i = 0; i < message.input.length; ++i)\n          if (!$util.isString(message.input[i])) return 'input: string[] expected';\n      }\n      if (message.output != null && message.hasOwnProperty('output')) {\n        if (!Array.isArray(message.output)) return 'output: array expected';\n        for (var i = 0; i < message.output.length; ++i)\n          if (!$util.isString(message.output[i])) return 'output: string[] expected';\n      }\n      if (message.name != null && message.hasOwnProperty('name'))\n        if (!$util.isString(message.name)) return 'name: string expected';\n      if (message.opType != null && message.hasOwnProperty('opType'))\n        if (!$util.isString(message.opType)) return 'opType: string expected';\n      if (message.domain != null && message.hasOwnProperty('domain'))\n        if (!$util.isString(message.domain)) return 'domain: string expected';\n      if (message.attribute != null && message.hasOwnProperty('attribute')) {\n        if (!Array.isArray(message.attribute)) return 'attribute: array expected';\n        for (var i = 0; i < message.attribute.length; ++i) {\n          var error = $root.onnx.AttributeProto.verify(message.attribute[i]);\n          if (error) return 'attribute.' + error;\n        }\n      }\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      return null;\n    };\n\n    /**\n     * Creates a NodeProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.NodeProto} NodeProto\n     */\n    NodeProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.NodeProto) return object;\n      var message = new $root.onnx.NodeProto();\n      if (object.input) {\n        if (!Array.isArray(object.input)) throw TypeError('.onnx.NodeProto.input: array expected');\n        message.input = [];\n        for (var i = 0; i < object.input.length; ++i) message.input[i] = String(object.input[i]);\n      }\n      if (object.output) {\n        if (!Array.isArray(object.output)) throw TypeError('.onnx.NodeProto.output: array expected');\n        message.output = [];\n        for (var i = 0; i < object.output.length; ++i) message.output[i] = String(object.output[i]);\n      }\n      if (object.name != null) message.name = String(object.name);\n      if (object.opType != null) message.opType = String(object.opType);\n      if (object.domain != null) message.domain = String(object.domain);\n      if (object.attribute) {\n        if (!Array.isArray(object.attribute)) throw TypeError('.onnx.NodeProto.attribute: array expected');\n        message.attribute = [];\n        for (var i = 0; i < object.attribute.length; ++i) {\n          if (typeof object.attribute[i] !== 'object') throw TypeError('.onnx.NodeProto.attribute: object expected');\n          message.attribute[i] = $root.onnx.AttributeProto.fromObject(object.attribute[i]);\n        }\n      }\n      if (object.docString != null) message.docString = String(object.docString);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a NodeProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {onnx.NodeProto} message NodeProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    NodeProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.input = [];\n        object.output = [];\n        object.attribute = [];\n      }\n      if (options.defaults) {\n        object.name = '';\n        object.opType = '';\n        object.docString = '';\n        object.domain = '';\n      }\n      if (message.input && message.input.length) {\n        object.input = [];\n        for (var j = 0; j < message.input.length; ++j) object.input[j] = message.input[j];\n      }\n      if (message.output && message.output.length) {\n        object.output = [];\n        for (var j = 0; j < message.output.length; ++j) object.output[j] = message.output[j];\n      }\n      if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;\n      if (message.opType != null && message.hasOwnProperty('opType')) object.opType = message.opType;\n      if (message.attribute && message.attribute.length) {\n        object.attribute = [];\n        for (var j = 0; j < message.attribute.length; ++j)\n          object.attribute[j] = $root.onnx.AttributeProto.toObject(message.attribute[j], options);\n      }\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      if (message.domain != null && message.hasOwnProperty('domain')) object.domain = message.domain;\n      return object;\n    };\n\n    /**\n     * Converts this NodeProto to JSON.\n     * @function toJSON\n     * @memberof onnx.NodeProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    NodeProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for NodeProto\n     * @function getTypeUrl\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    NodeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.NodeProto';\n    };\n\n    return NodeProto;\n  })();\n\n  onnx.TrainingInfoProto = (function () {\n    /**\n     * Properties of a TrainingInfoProto.\n     * @memberof onnx\n     * @interface ITrainingInfoProto\n     * @property {onnx.IGraphProto|null} [initialization] TrainingInfoProto initialization\n     * @property {onnx.IGraphProto|null} [algorithm] TrainingInfoProto algorithm\n     * @property {Array.<onnx.IStringStringEntryProto>|null} [initializationBinding] TrainingInfoProto initializationBinding\n     * @property {Array.<onnx.IStringStringEntryProto>|null} [updateBinding] TrainingInfoProto updateBinding\n     */\n\n    /**\n     * Constructs a new TrainingInfoProto.\n     * @memberof onnx\n     * @classdesc Represents a TrainingInfoProto.\n     * @implements ITrainingInfoProto\n     * @constructor\n     * @param {onnx.ITrainingInfoProto=} [properties] Properties to set\n     */\n    function TrainingInfoProto(properties) {\n      this.initializationBinding = [];\n      this.updateBinding = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TrainingInfoProto initialization.\n     * @member {onnx.IGraphProto|null|undefined} initialization\n     * @memberof onnx.TrainingInfoProto\n     * @instance\n     */\n    TrainingInfoProto.prototype.initialization = null;\n\n    /**\n     * TrainingInfoProto algorithm.\n     * @member {onnx.IGraphProto|null|undefined} algorithm\n     * @memberof onnx.TrainingInfoProto\n     * @instance\n     */\n    TrainingInfoProto.prototype.algorithm = null;\n\n    /**\n     * TrainingInfoProto initializationBinding.\n     * @member {Array.<onnx.IStringStringEntryProto>} initializationBinding\n     * @memberof onnx.TrainingInfoProto\n     * @instance\n     */\n    TrainingInfoProto.prototype.initializationBinding = $util.emptyArray;\n\n    /**\n     * TrainingInfoProto updateBinding.\n     * @member {Array.<onnx.IStringStringEntryProto>} updateBinding\n     * @memberof onnx.TrainingInfoProto\n     * @instance\n     */\n    TrainingInfoProto.prototype.updateBinding = $util.emptyArray;\n\n    /**\n     * Creates a new TrainingInfoProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {onnx.ITrainingInfoProto=} [properties] Properties to set\n     * @returns {onnx.TrainingInfoProto} TrainingInfoProto instance\n     */\n    TrainingInfoProto.create = function create(properties) {\n      return new TrainingInfoProto(properties);\n    };\n\n    /**\n     * Encodes the specified TrainingInfoProto message. Does not implicitly {@link onnx.TrainingInfoProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {onnx.ITrainingInfoProto} message TrainingInfoProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TrainingInfoProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.initialization != null && Object.hasOwnProperty.call(message, 'initialization'))\n        $root.onnx.GraphProto.encode(message.initialization, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n      if (message.algorithm != null && Object.hasOwnProperty.call(message, 'algorithm'))\n        $root.onnx.GraphProto.encode(message.algorithm, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n      if (message.initializationBinding != null && message.initializationBinding.length)\n        for (var i = 0; i < message.initializationBinding.length; ++i)\n          $root.onnx.StringStringEntryProto.encode(\n            message.initializationBinding[i],\n            writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n          ).ldelim();\n      if (message.updateBinding != null && message.updateBinding.length)\n        for (var i = 0; i < message.updateBinding.length; ++i)\n          $root.onnx.StringStringEntryProto.encode(\n            message.updateBinding[i],\n            writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified TrainingInfoProto message, length delimited. Does not implicitly {@link onnx.TrainingInfoProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {onnx.ITrainingInfoProto} message TrainingInfoProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TrainingInfoProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TrainingInfoProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.TrainingInfoProto} TrainingInfoProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TrainingInfoProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.TrainingInfoProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.initialization = $root.onnx.GraphProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 2: {\n            message.algorithm = $root.onnx.GraphProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 3: {\n            if (!(message.initializationBinding && message.initializationBinding.length))\n              message.initializationBinding = [];\n            message.initializationBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 4: {\n            if (!(message.updateBinding && message.updateBinding.length)) message.updateBinding = [];\n            message.updateBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a TrainingInfoProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.TrainingInfoProto} TrainingInfoProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TrainingInfoProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TrainingInfoProto message.\n     * @function verify\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TrainingInfoProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.initialization != null && message.hasOwnProperty('initialization')) {\n        var error = $root.onnx.GraphProto.verify(message.initialization);\n        if (error) return 'initialization.' + error;\n      }\n      if (message.algorithm != null && message.hasOwnProperty('algorithm')) {\n        var error = $root.onnx.GraphProto.verify(message.algorithm);\n        if (error) return 'algorithm.' + error;\n      }\n      if (message.initializationBinding != null && message.hasOwnProperty('initializationBinding')) {\n        if (!Array.isArray(message.initializationBinding)) return 'initializationBinding: array expected';\n        for (var i = 0; i < message.initializationBinding.length; ++i) {\n          var error = $root.onnx.StringStringEntryProto.verify(message.initializationBinding[i]);\n          if (error) return 'initializationBinding.' + error;\n        }\n      }\n      if (message.updateBinding != null && message.hasOwnProperty('updateBinding')) {\n        if (!Array.isArray(message.updateBinding)) return 'updateBinding: array expected';\n        for (var i = 0; i < message.updateBinding.length; ++i) {\n          var error = $root.onnx.StringStringEntryProto.verify(message.updateBinding[i]);\n          if (error) return 'updateBinding.' + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates a TrainingInfoProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.TrainingInfoProto} TrainingInfoProto\n     */\n    TrainingInfoProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.TrainingInfoProto) return object;\n      var message = new $root.onnx.TrainingInfoProto();\n      if (object.initialization != null) {\n        if (typeof object.initialization !== 'object')\n          throw TypeError('.onnx.TrainingInfoProto.initialization: object expected');\n        message.initialization = $root.onnx.GraphProto.fromObject(object.initialization);\n      }\n      if (object.algorithm != null) {\n        if (typeof object.algorithm !== 'object') throw TypeError('.onnx.TrainingInfoProto.algorithm: object expected');\n        message.algorithm = $root.onnx.GraphProto.fromObject(object.algorithm);\n      }\n      if (object.initializationBinding) {\n        if (!Array.isArray(object.initializationBinding))\n          throw TypeError('.onnx.TrainingInfoProto.initializationBinding: array expected');\n        message.initializationBinding = [];\n        for (var i = 0; i < object.initializationBinding.length; ++i) {\n          if (typeof object.initializationBinding[i] !== 'object')\n            throw TypeError('.onnx.TrainingInfoProto.initializationBinding: object expected');\n          message.initializationBinding[i] = $root.onnx.StringStringEntryProto.fromObject(\n            object.initializationBinding[i],\n          );\n        }\n      }\n      if (object.updateBinding) {\n        if (!Array.isArray(object.updateBinding))\n          throw TypeError('.onnx.TrainingInfoProto.updateBinding: array expected');\n        message.updateBinding = [];\n        for (var i = 0; i < object.updateBinding.length; ++i) {\n          if (typeof object.updateBinding[i] !== 'object')\n            throw TypeError('.onnx.TrainingInfoProto.updateBinding: object expected');\n          message.updateBinding[i] = $root.onnx.StringStringEntryProto.fromObject(object.updateBinding[i]);\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a TrainingInfoProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {onnx.TrainingInfoProto} message TrainingInfoProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TrainingInfoProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.initializationBinding = [];\n        object.updateBinding = [];\n      }\n      if (options.defaults) {\n        object.initialization = null;\n        object.algorithm = null;\n      }\n      if (message.initialization != null && message.hasOwnProperty('initialization'))\n        object.initialization = $root.onnx.GraphProto.toObject(message.initialization, options);\n      if (message.algorithm != null && message.hasOwnProperty('algorithm'))\n        object.algorithm = $root.onnx.GraphProto.toObject(message.algorithm, options);\n      if (message.initializationBinding && message.initializationBinding.length) {\n        object.initializationBinding = [];\n        for (var j = 0; j < message.initializationBinding.length; ++j)\n          object.initializationBinding[j] = $root.onnx.StringStringEntryProto.toObject(\n            message.initializationBinding[j],\n            options,\n          );\n      }\n      if (message.updateBinding && message.updateBinding.length) {\n        object.updateBinding = [];\n        for (var j = 0; j < message.updateBinding.length; ++j)\n          object.updateBinding[j] = $root.onnx.StringStringEntryProto.toObject(message.updateBinding[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this TrainingInfoProto to JSON.\n     * @function toJSON\n     * @memberof onnx.TrainingInfoProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TrainingInfoProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for TrainingInfoProto\n     * @function getTypeUrl\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    TrainingInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.TrainingInfoProto';\n    };\n\n    return TrainingInfoProto;\n  })();\n\n  onnx.ModelProto = (function () {\n    /**\n     * Properties of a ModelProto.\n     * @memberof onnx\n     * @interface IModelProto\n     * @property {number|Long|null} [irVersion] ModelProto irVersion\n     * @property {Array.<onnx.IOperatorSetIdProto>|null} [opsetImport] ModelProto opsetImport\n     * @property {string|null} [producerName] ModelProto producerName\n     * @property {string|null} [producerVersion] ModelProto producerVersion\n     * @property {string|null} [domain] ModelProto domain\n     * @property {number|Long|null} [modelVersion] ModelProto modelVersion\n     * @property {string|null} [docString] ModelProto docString\n     * @property {onnx.IGraphProto|null} [graph] ModelProto graph\n     * @property {Array.<onnx.IStringStringEntryProto>|null} [metadataProps] ModelProto metadataProps\n     * @property {Array.<onnx.ITrainingInfoProto>|null} [trainingInfo] ModelProto trainingInfo\n     * @property {Array.<onnx.IFunctionProto>|null} [functions] ModelProto functions\n     */\n\n    /**\n     * Constructs a new ModelProto.\n     * @memberof onnx\n     * @classdesc Represents a ModelProto.\n     * @implements IModelProto\n     * @constructor\n     * @param {onnx.IModelProto=} [properties] Properties to set\n     */\n    function ModelProto(properties) {\n      this.opsetImport = [];\n      this.metadataProps = [];\n      this.trainingInfo = [];\n      this.functions = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ModelProto irVersion.\n     * @member {number|Long} irVersion\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.irVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n    /**\n     * ModelProto opsetImport.\n     * @member {Array.<onnx.IOperatorSetIdProto>} opsetImport\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.opsetImport = $util.emptyArray;\n\n    /**\n     * ModelProto producerName.\n     * @member {string} producerName\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.producerName = '';\n\n    /**\n     * ModelProto producerVersion.\n     * @member {string} producerVersion\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.producerVersion = '';\n\n    /**\n     * ModelProto domain.\n     * @member {string} domain\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.domain = '';\n\n    /**\n     * ModelProto modelVersion.\n     * @member {number|Long} modelVersion\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.modelVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n    /**\n     * ModelProto docString.\n     * @member {string} docString\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.docString = '';\n\n    /**\n     * ModelProto graph.\n     * @member {onnx.IGraphProto|null|undefined} graph\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.graph = null;\n\n    /**\n     * ModelProto metadataProps.\n     * @member {Array.<onnx.IStringStringEntryProto>} metadataProps\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.metadataProps = $util.emptyArray;\n\n    /**\n     * ModelProto trainingInfo.\n     * @member {Array.<onnx.ITrainingInfoProto>} trainingInfo\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.trainingInfo = $util.emptyArray;\n\n    /**\n     * ModelProto functions.\n     * @member {Array.<onnx.IFunctionProto>} functions\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.functions = $util.emptyArray;\n\n    /**\n     * Creates a new ModelProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {onnx.IModelProto=} [properties] Properties to set\n     * @returns {onnx.ModelProto} ModelProto instance\n     */\n    ModelProto.create = function create(properties) {\n      return new ModelProto(properties);\n    };\n\n    /**\n     * Encodes the specified ModelProto message. Does not implicitly {@link onnx.ModelProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {onnx.IModelProto} message ModelProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ModelProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.irVersion != null && Object.hasOwnProperty.call(message, 'irVersion'))\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.irVersion);\n      if (message.producerName != null && Object.hasOwnProperty.call(message, 'producerName'))\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.producerName);\n      if (message.producerVersion != null && Object.hasOwnProperty.call(message, 'producerVersion'))\n        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.producerVersion);\n      if (message.domain != null && Object.hasOwnProperty.call(message, 'domain'))\n        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.domain);\n      if (message.modelVersion != null && Object.hasOwnProperty.call(message, 'modelVersion'))\n        writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.modelVersion);\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.docString);\n      if (message.graph != null && Object.hasOwnProperty.call(message, 'graph'))\n        $root.onnx.GraphProto.encode(message.graph, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();\n      if (message.opsetImport != null && message.opsetImport.length)\n        for (var i = 0; i < message.opsetImport.length; ++i)\n          $root.onnx.OperatorSetIdProto.encode(\n            message.opsetImport[i],\n            writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),\n          ).ldelim();\n      if (message.metadataProps != null && message.metadataProps.length)\n        for (var i = 0; i < message.metadataProps.length; ++i)\n          $root.onnx.StringStringEntryProto.encode(\n            message.metadataProps[i],\n            writer.uint32(/* id 14, wireType 2 =*/ 114).fork(),\n          ).ldelim();\n      if (message.trainingInfo != null && message.trainingInfo.length)\n        for (var i = 0; i < message.trainingInfo.length; ++i)\n          $root.onnx.TrainingInfoProto.encode(\n            message.trainingInfo[i],\n            writer.uint32(/* id 20, wireType 2 =*/ 162).fork(),\n          ).ldelim();\n      if (message.functions != null && message.functions.length)\n        for (var i = 0; i < message.functions.length; ++i)\n          $root.onnx.FunctionProto.encode(\n            message.functions[i],\n            writer.uint32(/* id 25, wireType 2 =*/ 202).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified ModelProto message, length delimited. Does not implicitly {@link onnx.ModelProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {onnx.IModelProto} message ModelProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ModelProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ModelProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.ModelProto} ModelProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ModelProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.ModelProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.irVersion = reader.int64();\n            break;\n          }\n          case 8: {\n            if (!(message.opsetImport && message.opsetImport.length)) message.opsetImport = [];\n            message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 2: {\n            message.producerName = reader.string();\n            break;\n          }\n          case 3: {\n            message.producerVersion = reader.string();\n            break;\n          }\n          case 4: {\n            message.domain = reader.string();\n            break;\n          }\n          case 5: {\n            message.modelVersion = reader.int64();\n            break;\n          }\n          case 6: {\n            message.docString = reader.string();\n            break;\n          }\n          case 7: {\n            message.graph = $root.onnx.GraphProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 14: {\n            if (!(message.metadataProps && message.metadataProps.length)) message.metadataProps = [];\n            message.metadataProps.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 20: {\n            if (!(message.trainingInfo && message.trainingInfo.length)) message.trainingInfo = [];\n            message.trainingInfo.push($root.onnx.TrainingInfoProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 25: {\n            if (!(message.functions && message.functions.length)) message.functions = [];\n            message.functions.push($root.onnx.FunctionProto.decode(reader, reader.uint32()));\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a ModelProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.ModelProto} ModelProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ModelProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ModelProto message.\n     * @function verify\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ModelProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.irVersion != null && message.hasOwnProperty('irVersion'))\n        if (\n          !$util.isInteger(message.irVersion) &&\n          !(message.irVersion && $util.isInteger(message.irVersion.low) && $util.isInteger(message.irVersion.high))\n        )\n          return 'irVersion: integer|Long expected';\n      if (message.opsetImport != null && message.hasOwnProperty('opsetImport')) {\n        if (!Array.isArray(message.opsetImport)) return 'opsetImport: array expected';\n        for (var i = 0; i < message.opsetImport.length; ++i) {\n          var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);\n          if (error) return 'opsetImport.' + error;\n        }\n      }\n      if (message.producerName != null && message.hasOwnProperty('producerName'))\n        if (!$util.isString(message.producerName)) return 'producerName: string expected';\n      if (message.producerVersion != null && message.hasOwnProperty('producerVersion'))\n        if (!$util.isString(message.producerVersion)) return 'producerVersion: string expected';\n      if (message.domain != null && message.hasOwnProperty('domain'))\n        if (!$util.isString(message.domain)) return 'domain: string expected';\n      if (message.modelVersion != null && message.hasOwnProperty('modelVersion'))\n        if (\n          !$util.isInteger(message.modelVersion) &&\n          !(\n            message.modelVersion &&\n            $util.isInteger(message.modelVersion.low) &&\n            $util.isInteger(message.modelVersion.high)\n          )\n        )\n          return 'modelVersion: integer|Long expected';\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      if (message.graph != null && message.hasOwnProperty('graph')) {\n        var error = $root.onnx.GraphProto.verify(message.graph);\n        if (error) return 'graph.' + error;\n      }\n      if (message.metadataProps != null && message.hasOwnProperty('metadataProps')) {\n        if (!Array.isArray(message.metadataProps)) return 'metadataProps: array expected';\n        for (var i = 0; i < message.metadataProps.length; ++i) {\n          var error = $root.onnx.StringStringEntryProto.verify(message.metadataProps[i]);\n          if (error) return 'metadataProps.' + error;\n        }\n      }\n      if (message.trainingInfo != null && message.hasOwnProperty('trainingInfo')) {\n        if (!Array.isArray(message.trainingInfo)) return 'trainingInfo: array expected';\n        for (var i = 0; i < message.trainingInfo.length; ++i) {\n          var error = $root.onnx.TrainingInfoProto.verify(message.trainingInfo[i]);\n          if (error) return 'trainingInfo.' + error;\n        }\n      }\n      if (message.functions != null && message.hasOwnProperty('functions')) {\n        if (!Array.isArray(message.functions)) return 'functions: array expected';\n        for (var i = 0; i < message.functions.length; ++i) {\n          var error = $root.onnx.FunctionProto.verify(message.functions[i]);\n          if (error) return 'functions.' + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates a ModelProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.ModelProto} ModelProto\n     */\n    ModelProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.ModelProto) return object;\n      var message = new $root.onnx.ModelProto();\n      if (object.irVersion != null)\n        if ($util.Long) (message.irVersion = $util.Long.fromValue(object.irVersion)).unsigned = false;\n        else if (typeof object.irVersion === 'string') message.irVersion = parseInt(object.irVersion, 10);\n        else if (typeof object.irVersion === 'number') message.irVersion = object.irVersion;\n        else if (typeof object.irVersion === 'object')\n          message.irVersion = new $util.LongBits(object.irVersion.low >>> 0, object.irVersion.high >>> 0).toNumber();\n      if (object.opsetImport) {\n        if (!Array.isArray(object.opsetImport)) throw TypeError('.onnx.ModelProto.opsetImport: array expected');\n        message.opsetImport = [];\n        for (var i = 0; i < object.opsetImport.length; ++i) {\n          if (typeof object.opsetImport[i] !== 'object')\n            throw TypeError('.onnx.ModelProto.opsetImport: object expected');\n          message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);\n        }\n      }\n      if (object.producerName != null) message.producerName = String(object.producerName);\n      if (object.producerVersion != null) message.producerVersion = String(object.producerVersion);\n      if (object.domain != null) message.domain = String(object.domain);\n      if (object.modelVersion != null)\n        if ($util.Long) (message.modelVersion = $util.Long.fromValue(object.modelVersion)).unsigned = false;\n        else if (typeof object.modelVersion === 'string') message.modelVersion = parseInt(object.modelVersion, 10);\n        else if (typeof object.modelVersion === 'number') message.modelVersion = object.modelVersion;\n        else if (typeof object.modelVersion === 'object')\n          message.modelVersion = new $util.LongBits(\n            object.modelVersion.low >>> 0,\n            object.modelVersion.high >>> 0,\n          ).toNumber();\n      if (object.docString != null) message.docString = String(object.docString);\n      if (object.graph != null) {\n        if (typeof object.graph !== 'object') throw TypeError('.onnx.ModelProto.graph: object expected');\n        message.graph = $root.onnx.GraphProto.fromObject(object.graph);\n      }\n      if (object.metadataProps) {\n        if (!Array.isArray(object.metadataProps)) throw TypeError('.onnx.ModelProto.metadataProps: array expected');\n        message.metadataProps = [];\n        for (var i = 0; i < object.metadataProps.length; ++i) {\n          if (typeof object.metadataProps[i] !== 'object')\n            throw TypeError('.onnx.ModelProto.metadataProps: object expected');\n          message.metadataProps[i] = $root.onnx.StringStringEntryProto.fromObject(object.metadataProps[i]);\n        }\n      }\n      if (object.trainingInfo) {\n        if (!Array.isArray(object.trainingInfo)) throw TypeError('.onnx.ModelProto.trainingInfo: array expected');\n        message.trainingInfo = [];\n        for (var i = 0; i < object.trainingInfo.length; ++i) {\n          if (typeof object.trainingInfo[i] !== 'object')\n            throw TypeError('.onnx.ModelProto.trainingInfo: object expected');\n          message.trainingInfo[i] = $root.onnx.TrainingInfoProto.fromObject(object.trainingInfo[i]);\n        }\n      }\n      if (object.functions) {\n        if (!Array.isArray(object.functions)) throw TypeError('.onnx.ModelProto.functions: array expected');\n        message.functions = [];\n        for (var i = 0; i < object.functions.length; ++i) {\n          if (typeof object.functions[i] !== 'object') throw TypeError('.onnx.ModelProto.functions: object expected');\n          message.functions[i] = $root.onnx.FunctionProto.fromObject(object.functions[i]);\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a ModelProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {onnx.ModelProto} message ModelProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ModelProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.opsetImport = [];\n        object.metadataProps = [];\n        object.trainingInfo = [];\n        object.functions = [];\n      }\n      if (options.defaults) {\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, false);\n          object.irVersion =\n            options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.irVersion = options.longs === String ? '0' : 0;\n        object.producerName = '';\n        object.producerVersion = '';\n        object.domain = '';\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, false);\n          object.modelVersion =\n            options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.modelVersion = options.longs === String ? '0' : 0;\n        object.docString = '';\n        object.graph = null;\n      }\n      if (message.irVersion != null && message.hasOwnProperty('irVersion'))\n        if (typeof message.irVersion === 'number')\n          object.irVersion = options.longs === String ? String(message.irVersion) : message.irVersion;\n        else\n          object.irVersion =\n            options.longs === String\n              ? $util.Long.prototype.toString.call(message.irVersion)\n              : options.longs === Number\n                ? new $util.LongBits(message.irVersion.low >>> 0, message.irVersion.high >>> 0).toNumber()\n                : message.irVersion;\n      if (message.producerName != null && message.hasOwnProperty('producerName'))\n        object.producerName = message.producerName;\n      if (message.producerVersion != null && message.hasOwnProperty('producerVersion'))\n        object.producerVersion = message.producerVersion;\n      if (message.domain != null && message.hasOwnProperty('domain')) object.domain = message.domain;\n      if (message.modelVersion != null && message.hasOwnProperty('modelVersion'))\n        if (typeof message.modelVersion === 'number')\n          object.modelVersion = options.longs === String ? String(message.modelVersion) : message.modelVersion;\n        else\n          object.modelVersion =\n            options.longs === String\n              ? $util.Long.prototype.toString.call(message.modelVersion)\n              : options.longs === Number\n                ? new $util.LongBits(message.modelVersion.low >>> 0, message.modelVersion.high >>> 0).toNumber()\n                : message.modelVersion;\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      if (message.graph != null && message.hasOwnProperty('graph'))\n        object.graph = $root.onnx.GraphProto.toObject(message.graph, options);\n      if (message.opsetImport && message.opsetImport.length) {\n        object.opsetImport = [];\n        for (var j = 0; j < message.opsetImport.length; ++j)\n          object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);\n      }\n      if (message.metadataProps && message.metadataProps.length) {\n        object.metadataProps = [];\n        for (var j = 0; j < message.metadataProps.length; ++j)\n          object.metadataProps[j] = $root.onnx.StringStringEntryProto.toObject(message.metadataProps[j], options);\n      }\n      if (message.trainingInfo && message.trainingInfo.length) {\n        object.trainingInfo = [];\n        for (var j = 0; j < message.trainingInfo.length; ++j)\n          object.trainingInfo[j] = $root.onnx.TrainingInfoProto.toObject(message.trainingInfo[j], options);\n      }\n      if (message.functions && message.functions.length) {\n        object.functions = [];\n        for (var j = 0; j < message.functions.length; ++j)\n          object.functions[j] = $root.onnx.FunctionProto.toObject(message.functions[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this ModelProto to JSON.\n     * @function toJSON\n     * @memberof onnx.ModelProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ModelProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for ModelProto\n     * @function getTypeUrl\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    ModelProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.ModelProto';\n    };\n\n    return ModelProto;\n  })();\n\n  onnx.StringStringEntryProto = (function () {\n    /**\n     * Properties of a StringStringEntryProto.\n     * @memberof onnx\n     * @interface IStringStringEntryProto\n     * @property {string|null} [key] StringStringEntryProto key\n     * @property {string|null} [value] StringStringEntryProto value\n     */\n\n    /**\n     * Constructs a new StringStringEntryProto.\n     * @memberof onnx\n     * @classdesc Represents a StringStringEntryProto.\n     * @implements IStringStringEntryProto\n     * @constructor\n     * @param {onnx.IStringStringEntryProto=} [properties] Properties to set\n     */\n    function StringStringEntryProto(properties) {\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * StringStringEntryProto key.\n     * @member {string} key\n     * @memberof onnx.StringStringEntryProto\n     * @instance\n     */\n    StringStringEntryProto.prototype.key = '';\n\n    /**\n     * StringStringEntryProto value.\n     * @member {string} value\n     * @memberof onnx.StringStringEntryProto\n     * @instance\n     */\n    StringStringEntryProto.prototype.value = '';\n\n    /**\n     * Creates a new StringStringEntryProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {onnx.IStringStringEntryProto=} [properties] Properties to set\n     * @returns {onnx.StringStringEntryProto} StringStringEntryProto instance\n     */\n    StringStringEntryProto.create = function create(properties) {\n      return new StringStringEntryProto(properties);\n    };\n\n    /**\n     * Encodes the specified StringStringEntryProto message. Does not implicitly {@link onnx.StringStringEntryProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {onnx.IStringStringEntryProto} message StringStringEntryProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    StringStringEntryProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.key != null && Object.hasOwnProperty.call(message, 'key'))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);\n      if (message.value != null && Object.hasOwnProperty.call(message, 'value'))\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.value);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified StringStringEntryProto message, length delimited. Does not implicitly {@link onnx.StringStringEntryProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {onnx.IStringStringEntryProto} message StringStringEntryProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    StringStringEntryProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a StringStringEntryProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.StringStringEntryProto} StringStringEntryProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    StringStringEntryProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.StringStringEntryProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.key = reader.string();\n            break;\n          }\n          case 2: {\n            message.value = reader.string();\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a StringStringEntryProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.StringStringEntryProto} StringStringEntryProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    StringStringEntryProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a StringStringEntryProto message.\n     * @function verify\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    StringStringEntryProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.key != null && message.hasOwnProperty('key'))\n        if (!$util.isString(message.key)) return 'key: string expected';\n      if (message.value != null && message.hasOwnProperty('value'))\n        if (!$util.isString(message.value)) return 'value: string expected';\n      return null;\n    };\n\n    /**\n     * Creates a StringStringEntryProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.StringStringEntryProto} StringStringEntryProto\n     */\n    StringStringEntryProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.StringStringEntryProto) return object;\n      var message = new $root.onnx.StringStringEntryProto();\n      if (object.key != null) message.key = String(object.key);\n      if (object.value != null) message.value = String(object.value);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a StringStringEntryProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {onnx.StringStringEntryProto} message StringStringEntryProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    StringStringEntryProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) {\n        object.key = '';\n        object.value = '';\n      }\n      if (message.key != null && message.hasOwnProperty('key')) object.key = message.key;\n      if (message.value != null && message.hasOwnProperty('value')) object.value = message.value;\n      return object;\n    };\n\n    /**\n     * Converts this StringStringEntryProto to JSON.\n     * @function toJSON\n     * @memberof onnx.StringStringEntryProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    StringStringEntryProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for StringStringEntryProto\n     * @function getTypeUrl\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    StringStringEntryProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.StringStringEntryProto';\n    };\n\n    return StringStringEntryProto;\n  })();\n\n  onnx.TensorAnnotation = (function () {\n    /**\n     * Properties of a TensorAnnotation.\n     * @memberof onnx\n     * @interface ITensorAnnotation\n     * @property {string|null} [tensorName] TensorAnnotation tensorName\n     * @property {Array.<onnx.IStringStringEntryProto>|null} [quantParameterTensorNames] TensorAnnotation quantParameterTensorNames\n     */\n\n    /**\n     * Constructs a new TensorAnnotation.\n     * @memberof onnx\n     * @classdesc Represents a TensorAnnotation.\n     * @implements ITensorAnnotation\n     * @constructor\n     * @param {onnx.ITensorAnnotation=} [properties] Properties to set\n     */\n    function TensorAnnotation(properties) {\n      this.quantParameterTensorNames = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TensorAnnotation tensorName.\n     * @member {string} tensorName\n     * @memberof onnx.TensorAnnotation\n     * @instance\n     */\n    TensorAnnotation.prototype.tensorName = '';\n\n    /**\n     * TensorAnnotation quantParameterTensorNames.\n     * @member {Array.<onnx.IStringStringEntryProto>} quantParameterTensorNames\n     * @memberof onnx.TensorAnnotation\n     * @instance\n     */\n    TensorAnnotation.prototype.quantParameterTensorNames = $util.emptyArray;\n\n    /**\n     * Creates a new TensorAnnotation instance using the specified properties.\n     * @function create\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {onnx.ITensorAnnotation=} [properties] Properties to set\n     * @returns {onnx.TensorAnnotation} TensorAnnotation instance\n     */\n    TensorAnnotation.create = function create(properties) {\n      return new TensorAnnotation(properties);\n    };\n\n    /**\n     * Encodes the specified TensorAnnotation message. Does not implicitly {@link onnx.TensorAnnotation.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {onnx.ITensorAnnotation} message TensorAnnotation message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TensorAnnotation.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.tensorName != null && Object.hasOwnProperty.call(message, 'tensorName'))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.tensorName);\n      if (message.quantParameterTensorNames != null && message.quantParameterTensorNames.length)\n        for (var i = 0; i < message.quantParameterTensorNames.length; ++i)\n          $root.onnx.StringStringEntryProto.encode(\n            message.quantParameterTensorNames[i],\n            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified TensorAnnotation message, length delimited. Does not implicitly {@link onnx.TensorAnnotation.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {onnx.ITensorAnnotation} message TensorAnnotation message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TensorAnnotation.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TensorAnnotation message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.TensorAnnotation} TensorAnnotation\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TensorAnnotation.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.TensorAnnotation();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.tensorName = reader.string();\n            break;\n          }\n          case 2: {\n            if (!(message.quantParameterTensorNames && message.quantParameterTensorNames.length))\n              message.quantParameterTensorNames = [];\n            message.quantParameterTensorNames.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a TensorAnnotation message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.TensorAnnotation} TensorAnnotation\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TensorAnnotation.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TensorAnnotation message.\n     * @function verify\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TensorAnnotation.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.tensorName != null && message.hasOwnProperty('tensorName'))\n        if (!$util.isString(message.tensorName)) return 'tensorName: string expected';\n      if (message.quantParameterTensorNames != null && message.hasOwnProperty('quantParameterTensorNames')) {\n        if (!Array.isArray(message.quantParameterTensorNames)) return 'quantParameterTensorNames: array expected';\n        for (var i = 0; i < message.quantParameterTensorNames.length; ++i) {\n          var error = $root.onnx.StringStringEntryProto.verify(message.quantParameterTensorNames[i]);\n          if (error) return 'quantParameterTensorNames.' + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates a TensorAnnotation message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.TensorAnnotation} TensorAnnotation\n     */\n    TensorAnnotation.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.TensorAnnotation) return object;\n      var message = new $root.onnx.TensorAnnotation();\n      if (object.tensorName != null) message.tensorName = String(object.tensorName);\n      if (object.quantParameterTensorNames) {\n        if (!Array.isArray(object.quantParameterTensorNames))\n          throw TypeError('.onnx.TensorAnnotation.quantParameterTensorNames: array expected');\n        message.quantParameterTensorNames = [];\n        for (var i = 0; i < object.quantParameterTensorNames.length; ++i) {\n          if (typeof object.quantParameterTensorNames[i] !== 'object')\n            throw TypeError('.onnx.TensorAnnotation.quantParameterTensorNames: object expected');\n          message.quantParameterTensorNames[i] = $root.onnx.StringStringEntryProto.fromObject(\n            object.quantParameterTensorNames[i],\n          );\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a TensorAnnotation message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {onnx.TensorAnnotation} message TensorAnnotation\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TensorAnnotation.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.quantParameterTensorNames = [];\n      if (options.defaults) object.tensorName = '';\n      if (message.tensorName != null && message.hasOwnProperty('tensorName')) object.tensorName = message.tensorName;\n      if (message.quantParameterTensorNames && message.quantParameterTensorNames.length) {\n        object.quantParameterTensorNames = [];\n        for (var j = 0; j < message.quantParameterTensorNames.length; ++j)\n          object.quantParameterTensorNames[j] = $root.onnx.StringStringEntryProto.toObject(\n            message.quantParameterTensorNames[j],\n            options,\n          );\n      }\n      return object;\n    };\n\n    /**\n     * Converts this TensorAnnotation to JSON.\n     * @function toJSON\n     * @memberof onnx.TensorAnnotation\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TensorAnnotation.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for TensorAnnotation\n     * @function getTypeUrl\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    TensorAnnotation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.TensorAnnotation';\n    };\n\n    return TensorAnnotation;\n  })();\n\n  onnx.GraphProto = (function () {\n    /**\n     * Properties of a GraphProto.\n     * @memberof onnx\n     * @interface IGraphProto\n     * @property {Array.<onnx.INodeProto>|null} [node] GraphProto node\n     * @property {string|null} [name] GraphProto name\n     * @property {Array.<onnx.ITensorProto>|null} [initializer] GraphProto initializer\n     * @property {Array.<onnx.ISparseTensorProto>|null} [sparseInitializer] GraphProto sparseInitializer\n     * @property {string|null} [docString] GraphProto docString\n     * @property {Array.<onnx.IValueInfoProto>|null} [input] GraphProto input\n     * @property {Array.<onnx.IValueInfoProto>|null} [output] GraphProto output\n     * @property {Array.<onnx.IValueInfoProto>|null} [valueInfo] GraphProto valueInfo\n     * @property {Array.<onnx.ITensorAnnotation>|null} [quantizationAnnotation] GraphProto quantizationAnnotation\n     */\n\n    /**\n     * Constructs a new GraphProto.\n     * @memberof onnx\n     * @classdesc Represents a GraphProto.\n     * @implements IGraphProto\n     * @constructor\n     * @param {onnx.IGraphProto=} [properties] Properties to set\n     */\n    function GraphProto(properties) {\n      this.node = [];\n      this.initializer = [];\n      this.sparseInitializer = [];\n      this.input = [];\n      this.output = [];\n      this.valueInfo = [];\n      this.quantizationAnnotation = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * GraphProto node.\n     * @member {Array.<onnx.INodeProto>} node\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.node = $util.emptyArray;\n\n    /**\n     * GraphProto name.\n     * @member {string} name\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.name = '';\n\n    /**\n     * GraphProto initializer.\n     * @member {Array.<onnx.ITensorProto>} initializer\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.initializer = $util.emptyArray;\n\n    /**\n     * GraphProto sparseInitializer.\n     * @member {Array.<onnx.ISparseTensorProto>} sparseInitializer\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.sparseInitializer = $util.emptyArray;\n\n    /**\n     * GraphProto docString.\n     * @member {string} docString\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.docString = '';\n\n    /**\n     * GraphProto input.\n     * @member {Array.<onnx.IValueInfoProto>} input\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.input = $util.emptyArray;\n\n    /**\n     * GraphProto output.\n     * @member {Array.<onnx.IValueInfoProto>} output\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.output = $util.emptyArray;\n\n    /**\n     * GraphProto valueInfo.\n     * @member {Array.<onnx.IValueInfoProto>} valueInfo\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.valueInfo = $util.emptyArray;\n\n    /**\n     * GraphProto quantizationAnnotation.\n     * @member {Array.<onnx.ITensorAnnotation>} quantizationAnnotation\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.quantizationAnnotation = $util.emptyArray;\n\n    /**\n     * Creates a new GraphProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {onnx.IGraphProto=} [properties] Properties to set\n     * @returns {onnx.GraphProto} GraphProto instance\n     */\n    GraphProto.create = function create(properties) {\n      return new GraphProto(properties);\n    };\n\n    /**\n     * Encodes the specified GraphProto message. Does not implicitly {@link onnx.GraphProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {onnx.IGraphProto} message GraphProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    GraphProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.node != null && message.node.length)\n        for (var i = 0; i < message.node.length; ++i)\n          $root.onnx.NodeProto.encode(message.node[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n      if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);\n      if (message.initializer != null && message.initializer.length)\n        for (var i = 0; i < message.initializer.length; ++i)\n          $root.onnx.TensorProto.encode(\n            message.initializer[i],\n            writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),\n          ).ldelim();\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.docString);\n      if (message.input != null && message.input.length)\n        for (var i = 0; i < message.input.length; ++i)\n          $root.onnx.ValueInfoProto.encode(\n            message.input[i],\n            writer.uint32(/* id 11, wireType 2 =*/ 90).fork(),\n          ).ldelim();\n      if (message.output != null && message.output.length)\n        for (var i = 0; i < message.output.length; ++i)\n          $root.onnx.ValueInfoProto.encode(\n            message.output[i],\n            writer.uint32(/* id 12, wireType 2 =*/ 98).fork(),\n          ).ldelim();\n      if (message.valueInfo != null && message.valueInfo.length)\n        for (var i = 0; i < message.valueInfo.length; ++i)\n          $root.onnx.ValueInfoProto.encode(\n            message.valueInfo[i],\n            writer.uint32(/* id 13, wireType 2 =*/ 106).fork(),\n          ).ldelim();\n      if (message.quantizationAnnotation != null && message.quantizationAnnotation.length)\n        for (var i = 0; i < message.quantizationAnnotation.length; ++i)\n          $root.onnx.TensorAnnotation.encode(\n            message.quantizationAnnotation[i],\n            writer.uint32(/* id 14, wireType 2 =*/ 114).fork(),\n          ).ldelim();\n      if (message.sparseInitializer != null && message.sparseInitializer.length)\n        for (var i = 0; i < message.sparseInitializer.length; ++i)\n          $root.onnx.SparseTensorProto.encode(\n            message.sparseInitializer[i],\n            writer.uint32(/* id 15, wireType 2 =*/ 122).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified GraphProto message, length delimited. Does not implicitly {@link onnx.GraphProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {onnx.IGraphProto} message GraphProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    GraphProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a GraphProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.GraphProto} GraphProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    GraphProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.GraphProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            if (!(message.node && message.node.length)) message.node = [];\n            message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 2: {\n            message.name = reader.string();\n            break;\n          }\n          case 5: {\n            if (!(message.initializer && message.initializer.length)) message.initializer = [];\n            message.initializer.push($root.onnx.TensorProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 15: {\n            if (!(message.sparseInitializer && message.sparseInitializer.length)) message.sparseInitializer = [];\n            message.sparseInitializer.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 10: {\n            message.docString = reader.string();\n            break;\n          }\n          case 11: {\n            if (!(message.input && message.input.length)) message.input = [];\n            message.input.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 12: {\n            if (!(message.output && message.output.length)) message.output = [];\n            message.output.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 13: {\n            if (!(message.valueInfo && message.valueInfo.length)) message.valueInfo = [];\n            message.valueInfo.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 14: {\n            if (!(message.quantizationAnnotation && message.quantizationAnnotation.length))\n              message.quantizationAnnotation = [];\n            message.quantizationAnnotation.push($root.onnx.TensorAnnotation.decode(reader, reader.uint32()));\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a GraphProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.GraphProto} GraphProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    GraphProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a GraphProto message.\n     * @function verify\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    GraphProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.node != null && message.hasOwnProperty('node')) {\n        if (!Array.isArray(message.node)) return 'node: array expected';\n        for (var i = 0; i < message.node.length; ++i) {\n          var error = $root.onnx.NodeProto.verify(message.node[i]);\n          if (error) return 'node.' + error;\n        }\n      }\n      if (message.name != null && message.hasOwnProperty('name'))\n        if (!$util.isString(message.name)) return 'name: string expected';\n      if (message.initializer != null && message.hasOwnProperty('initializer')) {\n        if (!Array.isArray(message.initializer)) return 'initializer: array expected';\n        for (var i = 0; i < message.initializer.length; ++i) {\n          var error = $root.onnx.TensorProto.verify(message.initializer[i]);\n          if (error) return 'initializer.' + error;\n        }\n      }\n      if (message.sparseInitializer != null && message.hasOwnProperty('sparseInitializer')) {\n        if (!Array.isArray(message.sparseInitializer)) return 'sparseInitializer: array expected';\n        for (var i = 0; i < message.sparseInitializer.length; ++i) {\n          var error = $root.onnx.SparseTensorProto.verify(message.sparseInitializer[i]);\n          if (error) return 'sparseInitializer.' + error;\n        }\n      }\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      if (message.input != null && message.hasOwnProperty('input')) {\n        if (!Array.isArray(message.input)) return 'input: array expected';\n        for (var i = 0; i < message.input.length; ++i) {\n          var error = $root.onnx.ValueInfoProto.verify(message.input[i]);\n          if (error) return 'input.' + error;\n        }\n      }\n      if (message.output != null && message.hasOwnProperty('output')) {\n        if (!Array.isArray(message.output)) return 'output: array expected';\n        for (var i = 0; i < message.output.length; ++i) {\n          var error = $root.onnx.ValueInfoProto.verify(message.output[i]);\n          if (error) return 'output.' + error;\n        }\n      }\n      if (message.valueInfo != null && message.hasOwnProperty('valueInfo')) {\n        if (!Array.isArray(message.valueInfo)) return 'valueInfo: array expected';\n        for (var i = 0; i < message.valueInfo.length; ++i) {\n          var error = $root.onnx.ValueInfoProto.verify(message.valueInfo[i]);\n          if (error) return 'valueInfo.' + error;\n        }\n      }\n      if (message.quantizationAnnotation != null && message.hasOwnProperty('quantizationAnnotation')) {\n        if (!Array.isArray(message.quantizationAnnotation)) return 'quantizationAnnotation: array expected';\n        for (var i = 0; i < message.quantizationAnnotation.length; ++i) {\n          var error = $root.onnx.TensorAnnotation.verify(message.quantizationAnnotation[i]);\n          if (error) return 'quantizationAnnotation.' + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates a GraphProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.GraphProto} GraphProto\n     */\n    GraphProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.GraphProto) return object;\n      var message = new $root.onnx.GraphProto();\n      if (object.node) {\n        if (!Array.isArray(object.node)) throw TypeError('.onnx.GraphProto.node: array expected');\n        message.node = [];\n        for (var i = 0; i < object.node.length; ++i) {\n          if (typeof object.node[i] !== 'object') throw TypeError('.onnx.GraphProto.node: object expected');\n          message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);\n        }\n      }\n      if (object.name != null) message.name = String(object.name);\n      if (object.initializer) {\n        if (!Array.isArray(object.initializer)) throw TypeError('.onnx.GraphProto.initializer: array expected');\n        message.initializer = [];\n        for (var i = 0; i < object.initializer.length; ++i) {\n          if (typeof object.initializer[i] !== 'object')\n            throw TypeError('.onnx.GraphProto.initializer: object expected');\n          message.initializer[i] = $root.onnx.TensorProto.fromObject(object.initializer[i]);\n        }\n      }\n      if (object.sparseInitializer) {\n        if (!Array.isArray(object.sparseInitializer))\n          throw TypeError('.onnx.GraphProto.sparseInitializer: array expected');\n        message.sparseInitializer = [];\n        for (var i = 0; i < object.sparseInitializer.length; ++i) {\n          if (typeof object.sparseInitializer[i] !== 'object')\n            throw TypeError('.onnx.GraphProto.sparseInitializer: object expected');\n          message.sparseInitializer[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseInitializer[i]);\n        }\n      }\n      if (object.docString != null) message.docString = String(object.docString);\n      if (object.input) {\n        if (!Array.isArray(object.input)) throw TypeError('.onnx.GraphProto.input: array expected');\n        message.input = [];\n        for (var i = 0; i < object.input.length; ++i) {\n          if (typeof object.input[i] !== 'object') throw TypeError('.onnx.GraphProto.input: object expected');\n          message.input[i] = $root.onnx.ValueInfoProto.fromObject(object.input[i]);\n        }\n      }\n      if (object.output) {\n        if (!Array.isArray(object.output)) throw TypeError('.onnx.GraphProto.output: array expected');\n        message.output = [];\n        for (var i = 0; i < object.output.length; ++i) {\n          if (typeof object.output[i] !== 'object') throw TypeError('.onnx.GraphProto.output: object expected');\n          message.output[i] = $root.onnx.ValueInfoProto.fromObject(object.output[i]);\n        }\n      }\n      if (object.valueInfo) {\n        if (!Array.isArray(object.valueInfo)) throw TypeError('.onnx.GraphProto.valueInfo: array expected');\n        message.valueInfo = [];\n        for (var i = 0; i < object.valueInfo.length; ++i) {\n          if (typeof object.valueInfo[i] !== 'object') throw TypeError('.onnx.GraphProto.valueInfo: object expected');\n          message.valueInfo[i] = $root.onnx.ValueInfoProto.fromObject(object.valueInfo[i]);\n        }\n      }\n      if (object.quantizationAnnotation) {\n        if (!Array.isArray(object.quantizationAnnotation))\n          throw TypeError('.onnx.GraphProto.quantizationAnnotation: array expected');\n        message.quantizationAnnotation = [];\n        for (var i = 0; i < object.quantizationAnnotation.length; ++i) {\n          if (typeof object.quantizationAnnotation[i] !== 'object')\n            throw TypeError('.onnx.GraphProto.quantizationAnnotation: object expected');\n          message.quantizationAnnotation[i] = $root.onnx.TensorAnnotation.fromObject(object.quantizationAnnotation[i]);\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a GraphProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {onnx.GraphProto} message GraphProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    GraphProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.node = [];\n        object.initializer = [];\n        object.input = [];\n        object.output = [];\n        object.valueInfo = [];\n        object.quantizationAnnotation = [];\n        object.sparseInitializer = [];\n      }\n      if (options.defaults) {\n        object.name = '';\n        object.docString = '';\n      }\n      if (message.node && message.node.length) {\n        object.node = [];\n        for (var j = 0; j < message.node.length; ++j)\n          object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);\n      }\n      if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;\n      if (message.initializer && message.initializer.length) {\n        object.initializer = [];\n        for (var j = 0; j < message.initializer.length; ++j)\n          object.initializer[j] = $root.onnx.TensorProto.toObject(message.initializer[j], options);\n      }\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      if (message.input && message.input.length) {\n        object.input = [];\n        for (var j = 0; j < message.input.length; ++j)\n          object.input[j] = $root.onnx.ValueInfoProto.toObject(message.input[j], options);\n      }\n      if (message.output && message.output.length) {\n        object.output = [];\n        for (var j = 0; j < message.output.length; ++j)\n          object.output[j] = $root.onnx.ValueInfoProto.toObject(message.output[j], options);\n      }\n      if (message.valueInfo && message.valueInfo.length) {\n        object.valueInfo = [];\n        for (var j = 0; j < message.valueInfo.length; ++j)\n          object.valueInfo[j] = $root.onnx.ValueInfoProto.toObject(message.valueInfo[j], options);\n      }\n      if (message.quantizationAnnotation && message.quantizationAnnotation.length) {\n        object.quantizationAnnotation = [];\n        for (var j = 0; j < message.quantizationAnnotation.length; ++j)\n          object.quantizationAnnotation[j] = $root.onnx.TensorAnnotation.toObject(\n            message.quantizationAnnotation[j],\n            options,\n          );\n      }\n      if (message.sparseInitializer && message.sparseInitializer.length) {\n        object.sparseInitializer = [];\n        for (var j = 0; j < message.sparseInitializer.length; ++j)\n          object.sparseInitializer[j] = $root.onnx.SparseTensorProto.toObject(message.sparseInitializer[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this GraphProto to JSON.\n     * @function toJSON\n     * @memberof onnx.GraphProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    GraphProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for GraphProto\n     * @function getTypeUrl\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    GraphProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.GraphProto';\n    };\n\n    return GraphProto;\n  })();\n\n  onnx.TensorProto = (function () {\n    /**\n     * Properties of a TensorProto.\n     * @memberof onnx\n     * @interface ITensorProto\n     * @property {Array.<number|Long>|null} [dims] TensorProto dims\n     * @property {number|null} [dataType] TensorProto dataType\n     * @property {onnx.TensorProto.ISegment|null} [segment] TensorProto segment\n     * @property {Array.<number>|null} [floatData] TensorProto floatData\n     * @property {Array.<number>|null} [int32Data] TensorProto int32Data\n     * @property {Array.<Uint8Array>|null} [stringData] TensorProto stringData\n     * @property {Array.<number|Long>|null} [int64Data] TensorProto int64Data\n     * @property {string|null} [name] TensorProto name\n     * @property {string|null} [docString] TensorProto docString\n     * @property {Uint8Array|null} [rawData] TensorProto rawData\n     * @property {Array.<onnx.IStringStringEntryProto>|null} [externalData] TensorProto externalData\n     * @property {onnx.TensorProto.DataLocation|null} [dataLocation] TensorProto dataLocation\n     * @property {Array.<number>|null} [doubleData] TensorProto doubleData\n     * @property {Array.<number|Long>|null} [uint64Data] TensorProto uint64Data\n     */\n\n    /**\n     * Constructs a new TensorProto.\n     * @memberof onnx\n     * @classdesc Represents a TensorProto.\n     * @implements ITensorProto\n     * @constructor\n     * @param {onnx.ITensorProto=} [properties] Properties to set\n     */\n    function TensorProto(properties) {\n      this.dims = [];\n      this.floatData = [];\n      this.int32Data = [];\n      this.stringData = [];\n      this.int64Data = [];\n      this.externalData = [];\n      this.doubleData = [];\n      this.uint64Data = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TensorProto dims.\n     * @member {Array.<number|Long>} dims\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.dims = $util.emptyArray;\n\n    /**\n     * TensorProto dataType.\n     * @member {number} dataType\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.dataType = 0;\n\n    /**\n     * TensorProto segment.\n     * @member {onnx.TensorProto.ISegment|null|undefined} segment\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.segment = null;\n\n    /**\n     * TensorProto floatData.\n     * @member {Array.<number>} floatData\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.floatData = $util.emptyArray;\n\n    /**\n     * TensorProto int32Data.\n     * @member {Array.<number>} int32Data\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.int32Data = $util.emptyArray;\n\n    /**\n     * TensorProto stringData.\n     * @member {Array.<Uint8Array>} stringData\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.stringData = $util.emptyArray;\n\n    /**\n     * TensorProto int64Data.\n     * @member {Array.<number|Long>} int64Data\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.int64Data = $util.emptyArray;\n\n    /**\n     * TensorProto name.\n     * @member {string} name\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.name = '';\n\n    /**\n     * TensorProto docString.\n     * @member {string} docString\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.docString = '';\n\n    /**\n     * TensorProto rawData.\n     * @member {Uint8Array} rawData\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.rawData = $util.newBuffer([]);\n\n    /**\n     * TensorProto externalData.\n     * @member {Array.<onnx.IStringStringEntryProto>} externalData\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.externalData = $util.emptyArray;\n\n    /**\n     * TensorProto dataLocation.\n     * @member {onnx.TensorProto.DataLocation} dataLocation\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.dataLocation = 0;\n\n    /**\n     * TensorProto doubleData.\n     * @member {Array.<number>} doubleData\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.doubleData = $util.emptyArray;\n\n    /**\n     * TensorProto uint64Data.\n     * @member {Array.<number|Long>} uint64Data\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.uint64Data = $util.emptyArray;\n\n    /**\n     * Creates a new TensorProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {onnx.ITensorProto=} [properties] Properties to set\n     * @returns {onnx.TensorProto} TensorProto instance\n     */\n    TensorProto.create = function create(properties) {\n      return new TensorProto(properties);\n    };\n\n    /**\n     * Encodes the specified TensorProto message. Does not implicitly {@link onnx.TensorProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {onnx.ITensorProto} message TensorProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TensorProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.dims != null && message.dims.length) {\n        writer.uint32(/* id 1, wireType 2 =*/ 10).fork();\n        for (var i = 0; i < message.dims.length; ++i) writer.int64(message.dims[i]);\n        writer.ldelim();\n      }\n      if (message.dataType != null && Object.hasOwnProperty.call(message, 'dataType'))\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.dataType);\n      if (message.segment != null && Object.hasOwnProperty.call(message, 'segment'))\n        $root.onnx.TensorProto.Segment.encode(\n          message.segment,\n          writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n        ).ldelim();\n      if (message.floatData != null && message.floatData.length) {\n        writer.uint32(/* id 4, wireType 2 =*/ 34).fork();\n        for (var i = 0; i < message.floatData.length; ++i) writer.float(message.floatData[i]);\n        writer.ldelim();\n      }\n      if (message.int32Data != null && message.int32Data.length) {\n        writer.uint32(/* id 5, wireType 2 =*/ 42).fork();\n        for (var i = 0; i < message.int32Data.length; ++i) writer.int32(message.int32Data[i]);\n        writer.ldelim();\n      }\n      if (message.stringData != null && message.stringData.length)\n        for (var i = 0; i < message.stringData.length; ++i)\n          writer.uint32(/* id 6, wireType 2 =*/ 50).bytes(message.stringData[i]);\n      if (message.int64Data != null && message.int64Data.length) {\n        writer.uint32(/* id 7, wireType 2 =*/ 58).fork();\n        for (var i = 0; i < message.int64Data.length; ++i) writer.int64(message.int64Data[i]);\n        writer.ldelim();\n      }\n      if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n        writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.name);\n      if (message.rawData != null && Object.hasOwnProperty.call(message, 'rawData'))\n        writer.uint32(/* id 9, wireType 2 =*/ 74).bytes(message.rawData);\n      if (message.doubleData != null && message.doubleData.length) {\n        writer.uint32(/* id 10, wireType 2 =*/ 82).fork();\n        for (var i = 0; i < message.doubleData.length; ++i) writer.double(message.doubleData[i]);\n        writer.ldelim();\n      }\n      if (message.uint64Data != null && message.uint64Data.length) {\n        writer.uint32(/* id 11, wireType 2 =*/ 90).fork();\n        for (var i = 0; i < message.uint64Data.length; ++i) writer.uint64(message.uint64Data[i]);\n        writer.ldelim();\n      }\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.docString);\n      if (message.externalData != null && message.externalData.length)\n        for (var i = 0; i < message.externalData.length; ++i)\n          $root.onnx.StringStringEntryProto.encode(\n            message.externalData[i],\n            writer.uint32(/* id 13, wireType 2 =*/ 106).fork(),\n          ).ldelim();\n      if (message.dataLocation != null && Object.hasOwnProperty.call(message, 'dataLocation'))\n        writer.uint32(/* id 14, wireType 0 =*/ 112).int32(message.dataLocation);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified TensorProto message, length delimited. Does not implicitly {@link onnx.TensorProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {onnx.ITensorProto} message TensorProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TensorProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TensorProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.TensorProto} TensorProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TensorProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.TensorProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            if (!(message.dims && message.dims.length)) message.dims = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.dims.push(reader.int64());\n            } else message.dims.push(reader.int64());\n            break;\n          }\n          case 2: {\n            message.dataType = reader.int32();\n            break;\n          }\n          case 3: {\n            message.segment = $root.onnx.TensorProto.Segment.decode(reader, reader.uint32());\n            break;\n          }\n          case 4: {\n            if (!(message.floatData && message.floatData.length)) message.floatData = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.floatData.push(reader.float());\n            } else message.floatData.push(reader.float());\n            break;\n          }\n          case 5: {\n            if (!(message.int32Data && message.int32Data.length)) message.int32Data = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.int32Data.push(reader.int32());\n            } else message.int32Data.push(reader.int32());\n            break;\n          }\n          case 6: {\n            if (!(message.stringData && message.stringData.length)) message.stringData = [];\n            message.stringData.push(reader.bytes());\n            break;\n          }\n          case 7: {\n            if (!(message.int64Data && message.int64Data.length)) message.int64Data = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.int64Data.push(reader.int64());\n            } else message.int64Data.push(reader.int64());\n            break;\n          }\n          case 8: {\n            message.name = reader.string();\n            break;\n          }\n          case 12: {\n            message.docString = reader.string();\n            break;\n          }\n          case 9: {\n            message.rawData = reader.bytes();\n            break;\n          }\n          case 13: {\n            if (!(message.externalData && message.externalData.length)) message.externalData = [];\n            message.externalData.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 14: {\n            message.dataLocation = reader.int32();\n            break;\n          }\n          case 10: {\n            if (!(message.doubleData && message.doubleData.length)) message.doubleData = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.doubleData.push(reader.double());\n            } else message.doubleData.push(reader.double());\n            break;\n          }\n          case 11: {\n            if (!(message.uint64Data && message.uint64Data.length)) message.uint64Data = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.uint64Data.push(reader.uint64());\n            } else message.uint64Data.push(reader.uint64());\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a TensorProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.TensorProto} TensorProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TensorProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TensorProto message.\n     * @function verify\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TensorProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.dims != null && message.hasOwnProperty('dims')) {\n        if (!Array.isArray(message.dims)) return 'dims: array expected';\n        for (var i = 0; i < message.dims.length; ++i)\n          if (\n            !$util.isInteger(message.dims[i]) &&\n            !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high))\n          )\n            return 'dims: integer|Long[] expected';\n      }\n      if (message.dataType != null && message.hasOwnProperty('dataType'))\n        if (!$util.isInteger(message.dataType)) return 'dataType: integer expected';\n      if (message.segment != null && message.hasOwnProperty('segment')) {\n        var error = $root.onnx.TensorProto.Segment.verify(message.segment);\n        if (error) return 'segment.' + error;\n      }\n      if (message.floatData != null && message.hasOwnProperty('floatData')) {\n        if (!Array.isArray(message.floatData)) return 'floatData: array expected';\n        for (var i = 0; i < message.floatData.length; ++i)\n          if (typeof message.floatData[i] !== 'number') return 'floatData: number[] expected';\n      }\n      if (message.int32Data != null && message.hasOwnProperty('int32Data')) {\n        if (!Array.isArray(message.int32Data)) return 'int32Data: array expected';\n        for (var i = 0; i < message.int32Data.length; ++i)\n          if (!$util.isInteger(message.int32Data[i])) return 'int32Data: integer[] expected';\n      }\n      if (message.stringData != null && message.hasOwnProperty('stringData')) {\n        if (!Array.isArray(message.stringData)) return 'stringData: array expected';\n        for (var i = 0; i < message.stringData.length; ++i)\n          if (\n            !(\n              (message.stringData[i] && typeof message.stringData[i].length === 'number') ||\n              $util.isString(message.stringData[i])\n            )\n          )\n            return 'stringData: buffer[] expected';\n      }\n      if (message.int64Data != null && message.hasOwnProperty('int64Data')) {\n        if (!Array.isArray(message.int64Data)) return 'int64Data: array expected';\n        for (var i = 0; i < message.int64Data.length; ++i)\n          if (\n            !$util.isInteger(message.int64Data[i]) &&\n            !(\n              message.int64Data[i] &&\n              $util.isInteger(message.int64Data[i].low) &&\n              $util.isInteger(message.int64Data[i].high)\n            )\n          )\n            return 'int64Data: integer|Long[] expected';\n      }\n      if (message.name != null && message.hasOwnProperty('name'))\n        if (!$util.isString(message.name)) return 'name: string expected';\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      if (message.rawData != null && message.hasOwnProperty('rawData'))\n        if (!((message.rawData && typeof message.rawData.length === 'number') || $util.isString(message.rawData)))\n          return 'rawData: buffer expected';\n      if (message.externalData != null && message.hasOwnProperty('externalData')) {\n        if (!Array.isArray(message.externalData)) return 'externalData: array expected';\n        for (var i = 0; i < message.externalData.length; ++i) {\n          var error = $root.onnx.StringStringEntryProto.verify(message.externalData[i]);\n          if (error) return 'externalData.' + error;\n        }\n      }\n      if (message.dataLocation != null && message.hasOwnProperty('dataLocation'))\n        switch (message.dataLocation) {\n          default:\n            return 'dataLocation: enum value expected';\n          case 0:\n          case 1:\n            break;\n        }\n      if (message.doubleData != null && message.hasOwnProperty('doubleData')) {\n        if (!Array.isArray(message.doubleData)) return 'doubleData: array expected';\n        for (var i = 0; i < message.doubleData.length; ++i)\n          if (typeof message.doubleData[i] !== 'number') return 'doubleData: number[] expected';\n      }\n      if (message.uint64Data != null && message.hasOwnProperty('uint64Data')) {\n        if (!Array.isArray(message.uint64Data)) return 'uint64Data: array expected';\n        for (var i = 0; i < message.uint64Data.length; ++i)\n          if (\n            !$util.isInteger(message.uint64Data[i]) &&\n            !(\n              message.uint64Data[i] &&\n              $util.isInteger(message.uint64Data[i].low) &&\n              $util.isInteger(message.uint64Data[i].high)\n            )\n          )\n            return 'uint64Data: integer|Long[] expected';\n      }\n      return null;\n    };\n\n    /**\n     * Creates a TensorProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.TensorProto} TensorProto\n     */\n    TensorProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.TensorProto) return object;\n      var message = new $root.onnx.TensorProto();\n      if (object.dims) {\n        if (!Array.isArray(object.dims)) throw TypeError('.onnx.TensorProto.dims: array expected');\n        message.dims = [];\n        for (var i = 0; i < object.dims.length; ++i)\n          if ($util.Long) (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;\n          else if (typeof object.dims[i] === 'string') message.dims[i] = parseInt(object.dims[i], 10);\n          else if (typeof object.dims[i] === 'number') message.dims[i] = object.dims[i];\n          else if (typeof object.dims[i] === 'object')\n            message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();\n      }\n      if (object.dataType != null) message.dataType = object.dataType | 0;\n      if (object.segment != null) {\n        if (typeof object.segment !== 'object') throw TypeError('.onnx.TensorProto.segment: object expected');\n        message.segment = $root.onnx.TensorProto.Segment.fromObject(object.segment);\n      }\n      if (object.floatData) {\n        if (!Array.isArray(object.floatData)) throw TypeError('.onnx.TensorProto.floatData: array expected');\n        message.floatData = [];\n        for (var i = 0; i < object.floatData.length; ++i) message.floatData[i] = Number(object.floatData[i]);\n      }\n      if (object.int32Data) {\n        if (!Array.isArray(object.int32Data)) throw TypeError('.onnx.TensorProto.int32Data: array expected');\n        message.int32Data = [];\n        for (var i = 0; i < object.int32Data.length; ++i) message.int32Data[i] = object.int32Data[i] | 0;\n      }\n      if (object.stringData) {\n        if (!Array.isArray(object.stringData)) throw TypeError('.onnx.TensorProto.stringData: array expected');\n        message.stringData = [];\n        for (var i = 0; i < object.stringData.length; ++i)\n          if (typeof object.stringData[i] === 'string')\n            $util.base64.decode(\n              object.stringData[i],\n              (message.stringData[i] = $util.newBuffer($util.base64.length(object.stringData[i]))),\n              0,\n            );\n          else if (object.stringData[i].length >= 0) message.stringData[i] = object.stringData[i];\n      }\n      if (object.int64Data) {\n        if (!Array.isArray(object.int64Data)) throw TypeError('.onnx.TensorProto.int64Data: array expected');\n        message.int64Data = [];\n        for (var i = 0; i < object.int64Data.length; ++i)\n          if ($util.Long) (message.int64Data[i] = $util.Long.fromValue(object.int64Data[i])).unsigned = false;\n          else if (typeof object.int64Data[i] === 'string') message.int64Data[i] = parseInt(object.int64Data[i], 10);\n          else if (typeof object.int64Data[i] === 'number') message.int64Data[i] = object.int64Data[i];\n          else if (typeof object.int64Data[i] === 'object')\n            message.int64Data[i] = new $util.LongBits(\n              object.int64Data[i].low >>> 0,\n              object.int64Data[i].high >>> 0,\n            ).toNumber();\n      }\n      if (object.name != null) message.name = String(object.name);\n      if (object.docString != null) message.docString = String(object.docString);\n      if (object.rawData != null)\n        if (typeof object.rawData === 'string')\n          $util.base64.decode(\n            object.rawData,\n            (message.rawData = $util.newBuffer($util.base64.length(object.rawData))),\n            0,\n          );\n        else if (object.rawData.length >= 0) message.rawData = object.rawData;\n      if (object.externalData) {\n        if (!Array.isArray(object.externalData)) throw TypeError('.onnx.TensorProto.externalData: array expected');\n        message.externalData = [];\n        for (var i = 0; i < object.externalData.length; ++i) {\n          if (typeof object.externalData[i] !== 'object')\n            throw TypeError('.onnx.TensorProto.externalData: object expected');\n          message.externalData[i] = $root.onnx.StringStringEntryProto.fromObject(object.externalData[i]);\n        }\n      }\n      switch (object.dataLocation) {\n        default:\n          if (typeof object.dataLocation === 'number') {\n            message.dataLocation = object.dataLocation;\n            break;\n          }\n          break;\n        case 'DEFAULT':\n        case 0:\n          message.dataLocation = 0;\n          break;\n        case 'EXTERNAL':\n        case 1:\n          message.dataLocation = 1;\n          break;\n      }\n      if (object.doubleData) {\n        if (!Array.isArray(object.doubleData)) throw TypeError('.onnx.TensorProto.doubleData: array expected');\n        message.doubleData = [];\n        for (var i = 0; i < object.doubleData.length; ++i) message.doubleData[i] = Number(object.doubleData[i]);\n      }\n      if (object.uint64Data) {\n        if (!Array.isArray(object.uint64Data)) throw TypeError('.onnx.TensorProto.uint64Data: array expected');\n        message.uint64Data = [];\n        for (var i = 0; i < object.uint64Data.length; ++i)\n          if ($util.Long) (message.uint64Data[i] = $util.Long.fromValue(object.uint64Data[i])).unsigned = true;\n          else if (typeof object.uint64Data[i] === 'string') message.uint64Data[i] = parseInt(object.uint64Data[i], 10);\n          else if (typeof object.uint64Data[i] === 'number') message.uint64Data[i] = object.uint64Data[i];\n          else if (typeof object.uint64Data[i] === 'object')\n            message.uint64Data[i] = new $util.LongBits(\n              object.uint64Data[i].low >>> 0,\n              object.uint64Data[i].high >>> 0,\n            ).toNumber(true);\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a TensorProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {onnx.TensorProto} message TensorProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TensorProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.dims = [];\n        object.floatData = [];\n        object.int32Data = [];\n        object.stringData = [];\n        object.int64Data = [];\n        object.doubleData = [];\n        object.uint64Data = [];\n        object.externalData = [];\n      }\n      if (options.defaults) {\n        object.dataType = 0;\n        object.segment = null;\n        object.name = '';\n        if (options.bytes === String) object.rawData = '';\n        else {\n          object.rawData = [];\n          if (options.bytes !== Array) object.rawData = $util.newBuffer(object.rawData);\n        }\n        object.docString = '';\n        object.dataLocation = options.enums === String ? 'DEFAULT' : 0;\n      }\n      if (message.dims && message.dims.length) {\n        object.dims = [];\n        for (var j = 0; j < message.dims.length; ++j)\n          if (typeof message.dims[j] === 'number')\n            object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];\n          else\n            object.dims[j] =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.dims[j])\n                : options.longs === Number\n                  ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber()\n                  : message.dims[j];\n      }\n      if (message.dataType != null && message.hasOwnProperty('dataType')) object.dataType = message.dataType;\n      if (message.segment != null && message.hasOwnProperty('segment'))\n        object.segment = $root.onnx.TensorProto.Segment.toObject(message.segment, options);\n      if (message.floatData && message.floatData.length) {\n        object.floatData = [];\n        for (var j = 0; j < message.floatData.length; ++j)\n          object.floatData[j] =\n            options.json && !isFinite(message.floatData[j]) ? String(message.floatData[j]) : message.floatData[j];\n      }\n      if (message.int32Data && message.int32Data.length) {\n        object.int32Data = [];\n        for (var j = 0; j < message.int32Data.length; ++j) object.int32Data[j] = message.int32Data[j];\n      }\n      if (message.stringData && message.stringData.length) {\n        object.stringData = [];\n        for (var j = 0; j < message.stringData.length; ++j)\n          object.stringData[j] =\n            options.bytes === String\n              ? $util.base64.encode(message.stringData[j], 0, message.stringData[j].length)\n              : options.bytes === Array\n                ? Array.prototype.slice.call(message.stringData[j])\n                : message.stringData[j];\n      }\n      if (message.int64Data && message.int64Data.length) {\n        object.int64Data = [];\n        for (var j = 0; j < message.int64Data.length; ++j)\n          if (typeof message.int64Data[j] === 'number')\n            object.int64Data[j] = options.longs === String ? String(message.int64Data[j]) : message.int64Data[j];\n          else\n            object.int64Data[j] =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.int64Data[j])\n                : options.longs === Number\n                  ? new $util.LongBits(message.int64Data[j].low >>> 0, message.int64Data[j].high >>> 0).toNumber()\n                  : message.int64Data[j];\n      }\n      if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;\n      if (message.rawData != null && message.hasOwnProperty('rawData'))\n        object.rawData =\n          options.bytes === String\n            ? $util.base64.encode(message.rawData, 0, message.rawData.length)\n            : options.bytes === Array\n              ? Array.prototype.slice.call(message.rawData)\n              : message.rawData;\n      if (message.doubleData && message.doubleData.length) {\n        object.doubleData = [];\n        for (var j = 0; j < message.doubleData.length; ++j)\n          object.doubleData[j] =\n            options.json && !isFinite(message.doubleData[j]) ? String(message.doubleData[j]) : message.doubleData[j];\n      }\n      if (message.uint64Data && message.uint64Data.length) {\n        object.uint64Data = [];\n        for (var j = 0; j < message.uint64Data.length; ++j)\n          if (typeof message.uint64Data[j] === 'number')\n            object.uint64Data[j] = options.longs === String ? String(message.uint64Data[j]) : message.uint64Data[j];\n          else\n            object.uint64Data[j] =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.uint64Data[j])\n                : options.longs === Number\n                  ? new $util.LongBits(message.uint64Data[j].low >>> 0, message.uint64Data[j].high >>> 0).toNumber(true)\n                  : message.uint64Data[j];\n      }\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      if (message.externalData && message.externalData.length) {\n        object.externalData = [];\n        for (var j = 0; j < message.externalData.length; ++j)\n          object.externalData[j] = $root.onnx.StringStringEntryProto.toObject(message.externalData[j], options);\n      }\n      if (message.dataLocation != null && message.hasOwnProperty('dataLocation'))\n        object.dataLocation =\n          options.enums === String\n            ? $root.onnx.TensorProto.DataLocation[message.dataLocation] === undefined\n              ? message.dataLocation\n              : $root.onnx.TensorProto.DataLocation[message.dataLocation]\n            : message.dataLocation;\n      return object;\n    };\n\n    /**\n     * Converts this TensorProto to JSON.\n     * @function toJSON\n     * @memberof onnx.TensorProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TensorProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for TensorProto\n     * @function getTypeUrl\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    TensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.TensorProto';\n    };\n\n    /**\n     * DataType enum.\n     * @name onnx.TensorProto.DataType\n     * @enum {number}\n     * @property {number} UNDEFINED=0 UNDEFINED value\n     * @property {number} FLOAT=1 FLOAT value\n     * @property {number} UINT8=2 UINT8 value\n     * @property {number} INT8=3 INT8 value\n     * @property {number} UINT16=4 UINT16 value\n     * @property {number} INT16=5 INT16 value\n     * @property {number} INT32=6 INT32 value\n     * @property {number} INT64=7 INT64 value\n     * @property {number} STRING=8 STRING value\n     * @property {number} BOOL=9 BOOL value\n     * @property {number} FLOAT16=10 FLOAT16 value\n     * @property {number} DOUBLE=11 DOUBLE value\n     * @property {number} UINT32=12 UINT32 value\n     * @property {number} UINT64=13 UINT64 value\n     * @property {number} COMPLEX64=14 COMPLEX64 value\n     * @property {number} COMPLEX128=15 COMPLEX128 value\n     * @property {number} BFLOAT16=16 BFLOAT16 value\n     * @property {number} FLOAT8E4M3FN=17 FLOAT8E4M3FN value\n     * @property {number} FLOAT8E4M3FNUZ=18 FLOAT8E4M3FNUZ value\n     * @property {number} FLOAT8E5M2=19 FLOAT8E5M2 value\n     * @property {number} FLOAT8E5M2FNUZ=20 FLOAT8E5M2FNUZ value\n     */\n    TensorProto.DataType = (function () {\n      var valuesById = {},\n        values = Object.create(valuesById);\n      values[(valuesById[0] = 'UNDEFINED')] = 0;\n      values[(valuesById[1] = 'FLOAT')] = 1;\n      values[(valuesById[2] = 'UINT8')] = 2;\n      values[(valuesById[3] = 'INT8')] = 3;\n      values[(valuesById[4] = 'UINT16')] = 4;\n      values[(valuesById[5] = 'INT16')] = 5;\n      values[(valuesById[6] = 'INT32')] = 6;\n      values[(valuesById[7] = 'INT64')] = 7;\n      values[(valuesById[8] = 'STRING')] = 8;\n      values[(valuesById[9] = 'BOOL')] = 9;\n      values[(valuesById[10] = 'FLOAT16')] = 10;\n      values[(valuesById[11] = 'DOUBLE')] = 11;\n      values[(valuesById[12] = 'UINT32')] = 12;\n      values[(valuesById[13] = 'UINT64')] = 13;\n      values[(valuesById[14] = 'COMPLEX64')] = 14;\n      values[(valuesById[15] = 'COMPLEX128')] = 15;\n      values[(valuesById[16] = 'BFLOAT16')] = 16;\n      values[(valuesById[17] = 'FLOAT8E4M3FN')] = 17;\n      values[(valuesById[18] = 'FLOAT8E4M3FNUZ')] = 18;\n      values[(valuesById[19] = 'FLOAT8E5M2')] = 19;\n      values[(valuesById[20] = 'FLOAT8E5M2FNUZ')] = 20;\n      return values;\n    })();\n\n    TensorProto.Segment = (function () {\n      /**\n       * Properties of a Segment.\n       * @memberof onnx.TensorProto\n       * @interface ISegment\n       * @property {number|Long|null} [begin] Segment begin\n       * @property {number|Long|null} [end] Segment end\n       */\n\n      /**\n       * Constructs a new Segment.\n       * @memberof onnx.TensorProto\n       * @classdesc Represents a Segment.\n       * @implements ISegment\n       * @constructor\n       * @param {onnx.TensorProto.ISegment=} [properties] Properties to set\n       */\n      function Segment(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Segment begin.\n       * @member {number|Long} begin\n       * @memberof onnx.TensorProto.Segment\n       * @instance\n       */\n      Segment.prototype.begin = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n      /**\n       * Segment end.\n       * @member {number|Long} end\n       * @memberof onnx.TensorProto.Segment\n       * @instance\n       */\n      Segment.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n      /**\n       * Creates a new Segment instance using the specified properties.\n       * @function create\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {onnx.TensorProto.ISegment=} [properties] Properties to set\n       * @returns {onnx.TensorProto.Segment} Segment instance\n       */\n      Segment.create = function create(properties) {\n        return new Segment(properties);\n      };\n\n      /**\n       * Encodes the specified Segment message. Does not implicitly {@link onnx.TensorProto.Segment.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {onnx.TensorProto.ISegment} message Segment message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Segment.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.begin != null && Object.hasOwnProperty.call(message, 'begin'))\n          writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.begin);\n        if (message.end != null && Object.hasOwnProperty.call(message, 'end'))\n          writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.end);\n        return writer;\n      };\n\n      /**\n       * Encodes the specified Segment message, length delimited. Does not implicitly {@link onnx.TensorProto.Segment.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {onnx.TensorProto.ISegment} message Segment message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Segment.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes a Segment message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TensorProto.Segment} Segment\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Segment.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TensorProto.Segment();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.begin = reader.int64();\n              break;\n            }\n            case 2: {\n              message.end = reader.int64();\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes a Segment message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TensorProto.Segment} Segment\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Segment.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies a Segment message.\n       * @function verify\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      Segment.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.begin != null && message.hasOwnProperty('begin'))\n          if (\n            !$util.isInteger(message.begin) &&\n            !(message.begin && $util.isInteger(message.begin.low) && $util.isInteger(message.begin.high))\n          )\n            return 'begin: integer|Long expected';\n        if (message.end != null && message.hasOwnProperty('end'))\n          if (\n            !$util.isInteger(message.end) &&\n            !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high))\n          )\n            return 'end: integer|Long expected';\n        return null;\n      };\n\n      /**\n       * Creates a Segment message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TensorProto.Segment} Segment\n       */\n      Segment.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TensorProto.Segment) return object;\n        var message = new $root.onnx.TensorProto.Segment();\n        if (object.begin != null)\n          if ($util.Long) (message.begin = $util.Long.fromValue(object.begin)).unsigned = false;\n          else if (typeof object.begin === 'string') message.begin = parseInt(object.begin, 10);\n          else if (typeof object.begin === 'number') message.begin = object.begin;\n          else if (typeof object.begin === 'object')\n            message.begin = new $util.LongBits(object.begin.low >>> 0, object.begin.high >>> 0).toNumber();\n        if (object.end != null)\n          if ($util.Long) (message.end = $util.Long.fromValue(object.end)).unsigned = false;\n          else if (typeof object.end === 'string') message.end = parseInt(object.end, 10);\n          else if (typeof object.end === 'number') message.end = object.end;\n          else if (typeof object.end === 'object')\n            message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();\n        return message;\n      };\n\n      /**\n       * Creates a plain object from a Segment message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {onnx.TensorProto.Segment} message Segment\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      Segment.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) {\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false);\n            object.begin =\n              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n          } else object.begin = options.longs === String ? '0' : 0;\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false);\n            object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n          } else object.end = options.longs === String ? '0' : 0;\n        }\n        if (message.begin != null && message.hasOwnProperty('begin'))\n          if (typeof message.begin === 'number')\n            object.begin = options.longs === String ? String(message.begin) : message.begin;\n          else\n            object.begin =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.begin)\n                : options.longs === Number\n                  ? new $util.LongBits(message.begin.low >>> 0, message.begin.high >>> 0).toNumber()\n                  : message.begin;\n        if (message.end != null && message.hasOwnProperty('end'))\n          if (typeof message.end === 'number')\n            object.end = options.longs === String ? String(message.end) : message.end;\n          else\n            object.end =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.end)\n                : options.longs === Number\n                  ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber()\n                  : message.end;\n        return object;\n      };\n\n      /**\n       * Converts this Segment to JSON.\n       * @function toJSON\n       * @memberof onnx.TensorProto.Segment\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      Segment.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for Segment\n       * @function getTypeUrl\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      Segment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TensorProto.Segment';\n      };\n\n      return Segment;\n    })();\n\n    /**\n     * DataLocation enum.\n     * @name onnx.TensorProto.DataLocation\n     * @enum {number}\n     * @property {number} DEFAULT=0 DEFAULT value\n     * @property {number} EXTERNAL=1 EXTERNAL value\n     */\n    TensorProto.DataLocation = (function () {\n      var valuesById = {},\n        values = Object.create(valuesById);\n      values[(valuesById[0] = 'DEFAULT')] = 0;\n      values[(valuesById[1] = 'EXTERNAL')] = 1;\n      return values;\n    })();\n\n    return TensorProto;\n  })();\n\n  onnx.SparseTensorProto = (function () {\n    /**\n     * Properties of a SparseTensorProto.\n     * @memberof onnx\n     * @interface ISparseTensorProto\n     * @property {onnx.ITensorProto|null} [values] SparseTensorProto values\n     * @property {onnx.ITensorProto|null} [indices] SparseTensorProto indices\n     * @property {Array.<number|Long>|null} [dims] SparseTensorProto dims\n     */\n\n    /**\n     * Constructs a new SparseTensorProto.\n     * @memberof onnx\n     * @classdesc Represents a SparseTensorProto.\n     * @implements ISparseTensorProto\n     * @constructor\n     * @param {onnx.ISparseTensorProto=} [properties] Properties to set\n     */\n    function SparseTensorProto(properties) {\n      this.dims = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SparseTensorProto values.\n     * @member {onnx.ITensorProto|null|undefined} values\n     * @memberof onnx.SparseTensorProto\n     * @instance\n     */\n    SparseTensorProto.prototype.values = null;\n\n    /**\n     * SparseTensorProto indices.\n     * @member {onnx.ITensorProto|null|undefined} indices\n     * @memberof onnx.SparseTensorProto\n     * @instance\n     */\n    SparseTensorProto.prototype.indices = null;\n\n    /**\n     * SparseTensorProto dims.\n     * @member {Array.<number|Long>} dims\n     * @memberof onnx.SparseTensorProto\n     * @instance\n     */\n    SparseTensorProto.prototype.dims = $util.emptyArray;\n\n    /**\n     * Creates a new SparseTensorProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {onnx.ISparseTensorProto=} [properties] Properties to set\n     * @returns {onnx.SparseTensorProto} SparseTensorProto instance\n     */\n    SparseTensorProto.create = function create(properties) {\n      return new SparseTensorProto(properties);\n    };\n\n    /**\n     * Encodes the specified SparseTensorProto message. Does not implicitly {@link onnx.SparseTensorProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {onnx.ISparseTensorProto} message SparseTensorProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SparseTensorProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.values != null && Object.hasOwnProperty.call(message, 'values'))\n        $root.onnx.TensorProto.encode(message.values, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n      if (message.indices != null && Object.hasOwnProperty.call(message, 'indices'))\n        $root.onnx.TensorProto.encode(message.indices, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n      if (message.dims != null && message.dims.length) {\n        writer.uint32(/* id 3, wireType 2 =*/ 26).fork();\n        for (var i = 0; i < message.dims.length; ++i) writer.int64(message.dims[i]);\n        writer.ldelim();\n      }\n      return writer;\n    };\n\n    /**\n     * Encodes the specified SparseTensorProto message, length delimited. Does not implicitly {@link onnx.SparseTensorProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {onnx.ISparseTensorProto} message SparseTensorProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SparseTensorProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SparseTensorProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.SparseTensorProto} SparseTensorProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SparseTensorProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.SparseTensorProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.values = $root.onnx.TensorProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 2: {\n            message.indices = $root.onnx.TensorProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 3: {\n            if (!(message.dims && message.dims.length)) message.dims = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.dims.push(reader.int64());\n            } else message.dims.push(reader.int64());\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a SparseTensorProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.SparseTensorProto} SparseTensorProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SparseTensorProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SparseTensorProto message.\n     * @function verify\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SparseTensorProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.values != null && message.hasOwnProperty('values')) {\n        var error = $root.onnx.TensorProto.verify(message.values);\n        if (error) return 'values.' + error;\n      }\n      if (message.indices != null && message.hasOwnProperty('indices')) {\n        var error = $root.onnx.TensorProto.verify(message.indices);\n        if (error) return 'indices.' + error;\n      }\n      if (message.dims != null && message.hasOwnProperty('dims')) {\n        if (!Array.isArray(message.dims)) return 'dims: array expected';\n        for (var i = 0; i < message.dims.length; ++i)\n          if (\n            !$util.isInteger(message.dims[i]) &&\n            !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high))\n          )\n            return 'dims: integer|Long[] expected';\n      }\n      return null;\n    };\n\n    /**\n     * Creates a SparseTensorProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.SparseTensorProto} SparseTensorProto\n     */\n    SparseTensorProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.SparseTensorProto) return object;\n      var message = new $root.onnx.SparseTensorProto();\n      if (object.values != null) {\n        if (typeof object.values !== 'object') throw TypeError('.onnx.SparseTensorProto.values: object expected');\n        message.values = $root.onnx.TensorProto.fromObject(object.values);\n      }\n      if (object.indices != null) {\n        if (typeof object.indices !== 'object') throw TypeError('.onnx.SparseTensorProto.indices: object expected');\n        message.indices = $root.onnx.TensorProto.fromObject(object.indices);\n      }\n      if (object.dims) {\n        if (!Array.isArray(object.dims)) throw TypeError('.onnx.SparseTensorProto.dims: array expected');\n        message.dims = [];\n        for (var i = 0; i < object.dims.length; ++i)\n          if ($util.Long) (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;\n          else if (typeof object.dims[i] === 'string') message.dims[i] = parseInt(object.dims[i], 10);\n          else if (typeof object.dims[i] === 'number') message.dims[i] = object.dims[i];\n          else if (typeof object.dims[i] === 'object')\n            message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a SparseTensorProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {onnx.SparseTensorProto} message SparseTensorProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SparseTensorProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.dims = [];\n      if (options.defaults) {\n        object.values = null;\n        object.indices = null;\n      }\n      if (message.values != null && message.hasOwnProperty('values'))\n        object.values = $root.onnx.TensorProto.toObject(message.values, options);\n      if (message.indices != null && message.hasOwnProperty('indices'))\n        object.indices = $root.onnx.TensorProto.toObject(message.indices, options);\n      if (message.dims && message.dims.length) {\n        object.dims = [];\n        for (var j = 0; j < message.dims.length; ++j)\n          if (typeof message.dims[j] === 'number')\n            object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];\n          else\n            object.dims[j] =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.dims[j])\n                : options.longs === Number\n                  ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber()\n                  : message.dims[j];\n      }\n      return object;\n    };\n\n    /**\n     * Converts this SparseTensorProto to JSON.\n     * @function toJSON\n     * @memberof onnx.SparseTensorProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SparseTensorProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for SparseTensorProto\n     * @function getTypeUrl\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    SparseTensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.SparseTensorProto';\n    };\n\n    return SparseTensorProto;\n  })();\n\n  onnx.TensorShapeProto = (function () {\n    /**\n     * Properties of a TensorShapeProto.\n     * @memberof onnx\n     * @interface ITensorShapeProto\n     * @property {Array.<onnx.TensorShapeProto.IDimension>|null} [dim] TensorShapeProto dim\n     */\n\n    /**\n     * Constructs a new TensorShapeProto.\n     * @memberof onnx\n     * @classdesc Represents a TensorShapeProto.\n     * @implements ITensorShapeProto\n     * @constructor\n     * @param {onnx.ITensorShapeProto=} [properties] Properties to set\n     */\n    function TensorShapeProto(properties) {\n      this.dim = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TensorShapeProto dim.\n     * @member {Array.<onnx.TensorShapeProto.IDimension>} dim\n     * @memberof onnx.TensorShapeProto\n     * @instance\n     */\n    TensorShapeProto.prototype.dim = $util.emptyArray;\n\n    /**\n     * Creates a new TensorShapeProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {onnx.ITensorShapeProto=} [properties] Properties to set\n     * @returns {onnx.TensorShapeProto} TensorShapeProto instance\n     */\n    TensorShapeProto.create = function create(properties) {\n      return new TensorShapeProto(properties);\n    };\n\n    /**\n     * Encodes the specified TensorShapeProto message. Does not implicitly {@link onnx.TensorShapeProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {onnx.ITensorShapeProto} message TensorShapeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TensorShapeProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.dim != null && message.dim.length)\n        for (var i = 0; i < message.dim.length; ++i)\n          $root.onnx.TensorShapeProto.Dimension.encode(\n            message.dim[i],\n            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified TensorShapeProto message, length delimited. Does not implicitly {@link onnx.TensorShapeProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {onnx.ITensorShapeProto} message TensorShapeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TensorShapeProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TensorShapeProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.TensorShapeProto} TensorShapeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TensorShapeProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.TensorShapeProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            if (!(message.dim && message.dim.length)) message.dim = [];\n            message.dim.push($root.onnx.TensorShapeProto.Dimension.decode(reader, reader.uint32()));\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a TensorShapeProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.TensorShapeProto} TensorShapeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TensorShapeProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TensorShapeProto message.\n     * @function verify\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TensorShapeProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.dim != null && message.hasOwnProperty('dim')) {\n        if (!Array.isArray(message.dim)) return 'dim: array expected';\n        for (var i = 0; i < message.dim.length; ++i) {\n          var error = $root.onnx.TensorShapeProto.Dimension.verify(message.dim[i]);\n          if (error) return 'dim.' + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates a TensorShapeProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.TensorShapeProto} TensorShapeProto\n     */\n    TensorShapeProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.TensorShapeProto) return object;\n      var message = new $root.onnx.TensorShapeProto();\n      if (object.dim) {\n        if (!Array.isArray(object.dim)) throw TypeError('.onnx.TensorShapeProto.dim: array expected');\n        message.dim = [];\n        for (var i = 0; i < object.dim.length; ++i) {\n          if (typeof object.dim[i] !== 'object') throw TypeError('.onnx.TensorShapeProto.dim: object expected');\n          message.dim[i] = $root.onnx.TensorShapeProto.Dimension.fromObject(object.dim[i]);\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a TensorShapeProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {onnx.TensorShapeProto} message TensorShapeProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TensorShapeProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.dim = [];\n      if (message.dim && message.dim.length) {\n        object.dim = [];\n        for (var j = 0; j < message.dim.length; ++j)\n          object.dim[j] = $root.onnx.TensorShapeProto.Dimension.toObject(message.dim[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this TensorShapeProto to JSON.\n     * @function toJSON\n     * @memberof onnx.TensorShapeProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TensorShapeProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for TensorShapeProto\n     * @function getTypeUrl\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    TensorShapeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.TensorShapeProto';\n    };\n\n    TensorShapeProto.Dimension = (function () {\n      /**\n       * Properties of a Dimension.\n       * @memberof onnx.TensorShapeProto\n       * @interface IDimension\n       * @property {number|Long|null} [dimValue] Dimension dimValue\n       * @property {string|null} [dimParam] Dimension dimParam\n       * @property {string|null} [denotation] Dimension denotation\n       */\n\n      /**\n       * Constructs a new Dimension.\n       * @memberof onnx.TensorShapeProto\n       * @classdesc Represents a Dimension.\n       * @implements IDimension\n       * @constructor\n       * @param {onnx.TensorShapeProto.IDimension=} [properties] Properties to set\n       */\n      function Dimension(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Dimension dimValue.\n       * @member {number|Long|null|undefined} dimValue\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @instance\n       */\n      Dimension.prototype.dimValue = null;\n\n      /**\n       * Dimension dimParam.\n       * @member {string|null|undefined} dimParam\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @instance\n       */\n      Dimension.prototype.dimParam = null;\n\n      /**\n       * Dimension denotation.\n       * @member {string} denotation\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @instance\n       */\n      Dimension.prototype.denotation = '';\n\n      // OneOf field names bound to virtual getters and setters\n      var $oneOfFields;\n\n      /**\n       * Dimension value.\n       * @member {\"dimValue\"|\"dimParam\"|undefined} value\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @instance\n       */\n      Object.defineProperty(Dimension.prototype, 'value', {\n        get: $util.oneOfGetter(($oneOfFields = ['dimValue', 'dimParam'])),\n        set: $util.oneOfSetter($oneOfFields),\n      });\n\n      /**\n       * Creates a new Dimension instance using the specified properties.\n       * @function create\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {onnx.TensorShapeProto.IDimension=} [properties] Properties to set\n       * @returns {onnx.TensorShapeProto.Dimension} Dimension instance\n       */\n      Dimension.create = function create(properties) {\n        return new Dimension(properties);\n      };\n\n      /**\n       * Encodes the specified Dimension message. Does not implicitly {@link onnx.TensorShapeProto.Dimension.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {onnx.TensorShapeProto.IDimension} message Dimension message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Dimension.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.dimValue != null && Object.hasOwnProperty.call(message, 'dimValue'))\n          writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.dimValue);\n        if (message.dimParam != null && Object.hasOwnProperty.call(message, 'dimParam'))\n          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.dimParam);\n        if (message.denotation != null && Object.hasOwnProperty.call(message, 'denotation'))\n          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.denotation);\n        return writer;\n      };\n\n      /**\n       * Encodes the specified Dimension message, length delimited. Does not implicitly {@link onnx.TensorShapeProto.Dimension.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {onnx.TensorShapeProto.IDimension} message Dimension message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Dimension.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes a Dimension message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TensorShapeProto.Dimension} Dimension\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Dimension.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TensorShapeProto.Dimension();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.dimValue = reader.int64();\n              break;\n            }\n            case 2: {\n              message.dimParam = reader.string();\n              break;\n            }\n            case 3: {\n              message.denotation = reader.string();\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes a Dimension message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TensorShapeProto.Dimension} Dimension\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Dimension.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies a Dimension message.\n       * @function verify\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      Dimension.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        var properties = {};\n        if (message.dimValue != null && message.hasOwnProperty('dimValue')) {\n          properties.value = 1;\n          if (\n            !$util.isInteger(message.dimValue) &&\n            !(message.dimValue && $util.isInteger(message.dimValue.low) && $util.isInteger(message.dimValue.high))\n          )\n            return 'dimValue: integer|Long expected';\n        }\n        if (message.dimParam != null && message.hasOwnProperty('dimParam')) {\n          if (properties.value === 1) return 'value: multiple values';\n          properties.value = 1;\n          if (!$util.isString(message.dimParam)) return 'dimParam: string expected';\n        }\n        if (message.denotation != null && message.hasOwnProperty('denotation'))\n          if (!$util.isString(message.denotation)) return 'denotation: string expected';\n        return null;\n      };\n\n      /**\n       * Creates a Dimension message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TensorShapeProto.Dimension} Dimension\n       */\n      Dimension.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TensorShapeProto.Dimension) return object;\n        var message = new $root.onnx.TensorShapeProto.Dimension();\n        if (object.dimValue != null)\n          if ($util.Long) (message.dimValue = $util.Long.fromValue(object.dimValue)).unsigned = false;\n          else if (typeof object.dimValue === 'string') message.dimValue = parseInt(object.dimValue, 10);\n          else if (typeof object.dimValue === 'number') message.dimValue = object.dimValue;\n          else if (typeof object.dimValue === 'object')\n            message.dimValue = new $util.LongBits(object.dimValue.low >>> 0, object.dimValue.high >>> 0).toNumber();\n        if (object.dimParam != null) message.dimParam = String(object.dimParam);\n        if (object.denotation != null) message.denotation = String(object.denotation);\n        return message;\n      };\n\n      /**\n       * Creates a plain object from a Dimension message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {onnx.TensorShapeProto.Dimension} message Dimension\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      Dimension.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) object.denotation = '';\n        if (message.dimValue != null && message.hasOwnProperty('dimValue')) {\n          if (typeof message.dimValue === 'number')\n            object.dimValue = options.longs === String ? String(message.dimValue) : message.dimValue;\n          else\n            object.dimValue =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.dimValue)\n                : options.longs === Number\n                  ? new $util.LongBits(message.dimValue.low >>> 0, message.dimValue.high >>> 0).toNumber()\n                  : message.dimValue;\n          if (options.oneofs) object.value = 'dimValue';\n        }\n        if (message.dimParam != null && message.hasOwnProperty('dimParam')) {\n          object.dimParam = message.dimParam;\n          if (options.oneofs) object.value = 'dimParam';\n        }\n        if (message.denotation != null && message.hasOwnProperty('denotation')) object.denotation = message.denotation;\n        return object;\n      };\n\n      /**\n       * Converts this Dimension to JSON.\n       * @function toJSON\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      Dimension.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for Dimension\n       * @function getTypeUrl\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      Dimension.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TensorShapeProto.Dimension';\n      };\n\n      return Dimension;\n    })();\n\n    return TensorShapeProto;\n  })();\n\n  onnx.TypeProto = (function () {\n    /**\n     * Properties of a TypeProto.\n     * @memberof onnx\n     * @interface ITypeProto\n     * @property {onnx.TypeProto.ITensor|null} [tensorType] TypeProto tensorType\n     * @property {onnx.TypeProto.ISequence|null} [sequenceType] TypeProto sequenceType\n     * @property {onnx.TypeProto.IMap|null} [mapType] TypeProto mapType\n     * @property {onnx.TypeProto.IOptional|null} [optionalType] TypeProto optionalType\n     * @property {onnx.TypeProto.ISparseTensor|null} [sparseTensorType] TypeProto sparseTensorType\n     * @property {string|null} [denotation] TypeProto denotation\n     */\n\n    /**\n     * Constructs a new TypeProto.\n     * @memberof onnx\n     * @classdesc Represents a TypeProto.\n     * @implements ITypeProto\n     * @constructor\n     * @param {onnx.ITypeProto=} [properties] Properties to set\n     */\n    function TypeProto(properties) {\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TypeProto tensorType.\n     * @member {onnx.TypeProto.ITensor|null|undefined} tensorType\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    TypeProto.prototype.tensorType = null;\n\n    /**\n     * TypeProto sequenceType.\n     * @member {onnx.TypeProto.ISequence|null|undefined} sequenceType\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    TypeProto.prototype.sequenceType = null;\n\n    /**\n     * TypeProto mapType.\n     * @member {onnx.TypeProto.IMap|null|undefined} mapType\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    TypeProto.prototype.mapType = null;\n\n    /**\n     * TypeProto optionalType.\n     * @member {onnx.TypeProto.IOptional|null|undefined} optionalType\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    TypeProto.prototype.optionalType = null;\n\n    /**\n     * TypeProto sparseTensorType.\n     * @member {onnx.TypeProto.ISparseTensor|null|undefined} sparseTensorType\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    TypeProto.prototype.sparseTensorType = null;\n\n    /**\n     * TypeProto denotation.\n     * @member {string} denotation\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    TypeProto.prototype.denotation = '';\n\n    // OneOf field names bound to virtual getters and setters\n    var $oneOfFields;\n\n    /**\n     * TypeProto value.\n     * @member {\"tensorType\"|\"sequenceType\"|\"mapType\"|\"optionalType\"|\"sparseTensorType\"|undefined} value\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    Object.defineProperty(TypeProto.prototype, 'value', {\n      get: $util.oneOfGetter(\n        ($oneOfFields = ['tensorType', 'sequenceType', 'mapType', 'optionalType', 'sparseTensorType']),\n      ),\n      set: $util.oneOfSetter($oneOfFields),\n    });\n\n    /**\n     * Creates a new TypeProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {onnx.ITypeProto=} [properties] Properties to set\n     * @returns {onnx.TypeProto} TypeProto instance\n     */\n    TypeProto.create = function create(properties) {\n      return new TypeProto(properties);\n    };\n\n    /**\n     * Encodes the specified TypeProto message. Does not implicitly {@link onnx.TypeProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {onnx.ITypeProto} message TypeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TypeProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.tensorType != null && Object.hasOwnProperty.call(message, 'tensorType'))\n        $root.onnx.TypeProto.Tensor.encode(\n          message.tensorType,\n          writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n        ).ldelim();\n      if (message.sequenceType != null && Object.hasOwnProperty.call(message, 'sequenceType'))\n        $root.onnx.TypeProto.Sequence.encode(\n          message.sequenceType,\n          writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n        ).ldelim();\n      if (message.mapType != null && Object.hasOwnProperty.call(message, 'mapType'))\n        $root.onnx.TypeProto.Map.encode(message.mapType, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();\n      if (message.denotation != null && Object.hasOwnProperty.call(message, 'denotation'))\n        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.denotation);\n      if (message.sparseTensorType != null && Object.hasOwnProperty.call(message, 'sparseTensorType'))\n        $root.onnx.TypeProto.SparseTensor.encode(\n          message.sparseTensorType,\n          writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),\n        ).ldelim();\n      if (message.optionalType != null && Object.hasOwnProperty.call(message, 'optionalType'))\n        $root.onnx.TypeProto.Optional.encode(\n          message.optionalType,\n          writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),\n        ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified TypeProto message, length delimited. Does not implicitly {@link onnx.TypeProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {onnx.ITypeProto} message TypeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TypeProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TypeProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.TypeProto} TypeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TypeProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.TypeProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.tensorType = $root.onnx.TypeProto.Tensor.decode(reader, reader.uint32());\n            break;\n          }\n          case 4: {\n            message.sequenceType = $root.onnx.TypeProto.Sequence.decode(reader, reader.uint32());\n            break;\n          }\n          case 5: {\n            message.mapType = $root.onnx.TypeProto.Map.decode(reader, reader.uint32());\n            break;\n          }\n          case 9: {\n            message.optionalType = $root.onnx.TypeProto.Optional.decode(reader, reader.uint32());\n            break;\n          }\n          case 8: {\n            message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.decode(reader, reader.uint32());\n            break;\n          }\n          case 6: {\n            message.denotation = reader.string();\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a TypeProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.TypeProto} TypeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TypeProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TypeProto message.\n     * @function verify\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TypeProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      var properties = {};\n      if (message.tensorType != null && message.hasOwnProperty('tensorType')) {\n        properties.value = 1;\n        {\n          var error = $root.onnx.TypeProto.Tensor.verify(message.tensorType);\n          if (error) return 'tensorType.' + error;\n        }\n      }\n      if (message.sequenceType != null && message.hasOwnProperty('sequenceType')) {\n        if (properties.value === 1) return 'value: multiple values';\n        properties.value = 1;\n        {\n          var error = $root.onnx.TypeProto.Sequence.verify(message.sequenceType);\n          if (error) return 'sequenceType.' + error;\n        }\n      }\n      if (message.mapType != null && message.hasOwnProperty('mapType')) {\n        if (properties.value === 1) return 'value: multiple values';\n        properties.value = 1;\n        {\n          var error = $root.onnx.TypeProto.Map.verify(message.mapType);\n          if (error) return 'mapType.' + error;\n        }\n      }\n      if (message.optionalType != null && message.hasOwnProperty('optionalType')) {\n        if (properties.value === 1) return 'value: multiple values';\n        properties.value = 1;\n        {\n          var error = $root.onnx.TypeProto.Optional.verify(message.optionalType);\n          if (error) return 'optionalType.' + error;\n        }\n      }\n      if (message.sparseTensorType != null && message.hasOwnProperty('sparseTensorType')) {\n        if (properties.value === 1) return 'value: multiple values';\n        properties.value = 1;\n        {\n          var error = $root.onnx.TypeProto.SparseTensor.verify(message.sparseTensorType);\n          if (error) return 'sparseTensorType.' + error;\n        }\n      }\n      if (message.denotation != null && message.hasOwnProperty('denotation'))\n        if (!$util.isString(message.denotation)) return 'denotation: string expected';\n      return null;\n    };\n\n    /**\n     * Creates a TypeProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.TypeProto} TypeProto\n     */\n    TypeProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.TypeProto) return object;\n      var message = new $root.onnx.TypeProto();\n      if (object.tensorType != null) {\n        if (typeof object.tensorType !== 'object') throw TypeError('.onnx.TypeProto.tensorType: object expected');\n        message.tensorType = $root.onnx.TypeProto.Tensor.fromObject(object.tensorType);\n      }\n      if (object.sequenceType != null) {\n        if (typeof object.sequenceType !== 'object') throw TypeError('.onnx.TypeProto.sequenceType: object expected');\n        message.sequenceType = $root.onnx.TypeProto.Sequence.fromObject(object.sequenceType);\n      }\n      if (object.mapType != null) {\n        if (typeof object.mapType !== 'object') throw TypeError('.onnx.TypeProto.mapType: object expected');\n        message.mapType = $root.onnx.TypeProto.Map.fromObject(object.mapType);\n      }\n      if (object.optionalType != null) {\n        if (typeof object.optionalType !== 'object') throw TypeError('.onnx.TypeProto.optionalType: object expected');\n        message.optionalType = $root.onnx.TypeProto.Optional.fromObject(object.optionalType);\n      }\n      if (object.sparseTensorType != null) {\n        if (typeof object.sparseTensorType !== 'object')\n          throw TypeError('.onnx.TypeProto.sparseTensorType: object expected');\n        message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.fromObject(object.sparseTensorType);\n      }\n      if (object.denotation != null) message.denotation = String(object.denotation);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a TypeProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {onnx.TypeProto} message TypeProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TypeProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) object.denotation = '';\n      if (message.tensorType != null && message.hasOwnProperty('tensorType')) {\n        object.tensorType = $root.onnx.TypeProto.Tensor.toObject(message.tensorType, options);\n        if (options.oneofs) object.value = 'tensorType';\n      }\n      if (message.sequenceType != null && message.hasOwnProperty('sequenceType')) {\n        object.sequenceType = $root.onnx.TypeProto.Sequence.toObject(message.sequenceType, options);\n        if (options.oneofs) object.value = 'sequenceType';\n      }\n      if (message.mapType != null && message.hasOwnProperty('mapType')) {\n        object.mapType = $root.onnx.TypeProto.Map.toObject(message.mapType, options);\n        if (options.oneofs) object.value = 'mapType';\n      }\n      if (message.denotation != null && message.hasOwnProperty('denotation')) object.denotation = message.denotation;\n      if (message.sparseTensorType != null && message.hasOwnProperty('sparseTensorType')) {\n        object.sparseTensorType = $root.onnx.TypeProto.SparseTensor.toObject(message.sparseTensorType, options);\n        if (options.oneofs) object.value = 'sparseTensorType';\n      }\n      if (message.optionalType != null && message.hasOwnProperty('optionalType')) {\n        object.optionalType = $root.onnx.TypeProto.Optional.toObject(message.optionalType, options);\n        if (options.oneofs) object.value = 'optionalType';\n      }\n      return object;\n    };\n\n    /**\n     * Converts this TypeProto to JSON.\n     * @function toJSON\n     * @memberof onnx.TypeProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TypeProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for TypeProto\n     * @function getTypeUrl\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    TypeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.TypeProto';\n    };\n\n    TypeProto.Tensor = (function () {\n      /**\n       * Properties of a Tensor.\n       * @memberof onnx.TypeProto\n       * @interface ITensor\n       * @property {number|null} [elemType] Tensor elemType\n       * @property {onnx.ITensorShapeProto|null} [shape] Tensor shape\n       */\n\n      /**\n       * Constructs a new Tensor.\n       * @memberof onnx.TypeProto\n       * @classdesc Represents a Tensor.\n       * @implements ITensor\n       * @constructor\n       * @param {onnx.TypeProto.ITensor=} [properties] Properties to set\n       */\n      function Tensor(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Tensor elemType.\n       * @member {number} elemType\n       * @memberof onnx.TypeProto.Tensor\n       * @instance\n       */\n      Tensor.prototype.elemType = 0;\n\n      /**\n       * Tensor shape.\n       * @member {onnx.ITensorShapeProto|null|undefined} shape\n       * @memberof onnx.TypeProto.Tensor\n       * @instance\n       */\n      Tensor.prototype.shape = null;\n\n      /**\n       * Creates a new Tensor instance using the specified properties.\n       * @function create\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {onnx.TypeProto.ITensor=} [properties] Properties to set\n       * @returns {onnx.TypeProto.Tensor} Tensor instance\n       */\n      Tensor.create = function create(properties) {\n        return new Tensor(properties);\n      };\n\n      /**\n       * Encodes the specified Tensor message. Does not implicitly {@link onnx.TypeProto.Tensor.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {onnx.TypeProto.ITensor} message Tensor message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Tensor.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.elemType != null && Object.hasOwnProperty.call(message, 'elemType'))\n          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.elemType);\n        if (message.shape != null && Object.hasOwnProperty.call(message, 'shape'))\n          $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n        return writer;\n      };\n\n      /**\n       * Encodes the specified Tensor message, length delimited. Does not implicitly {@link onnx.TypeProto.Tensor.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {onnx.TypeProto.ITensor} message Tensor message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Tensor.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes a Tensor message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TypeProto.Tensor} Tensor\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Tensor.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TypeProto.Tensor();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.elemType = reader.int32();\n              break;\n            }\n            case 2: {\n              message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes a Tensor message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TypeProto.Tensor} Tensor\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Tensor.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies a Tensor message.\n       * @function verify\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      Tensor.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.elemType != null && message.hasOwnProperty('elemType'))\n          if (!$util.isInteger(message.elemType)) return 'elemType: integer expected';\n        if (message.shape != null && message.hasOwnProperty('shape')) {\n          var error = $root.onnx.TensorShapeProto.verify(message.shape);\n          if (error) return 'shape.' + error;\n        }\n        return null;\n      };\n\n      /**\n       * Creates a Tensor message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TypeProto.Tensor} Tensor\n       */\n      Tensor.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TypeProto.Tensor) return object;\n        var message = new $root.onnx.TypeProto.Tensor();\n        if (object.elemType != null) message.elemType = object.elemType | 0;\n        if (object.shape != null) {\n          if (typeof object.shape !== 'object') throw TypeError('.onnx.TypeProto.Tensor.shape: object expected');\n          message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);\n        }\n        return message;\n      };\n\n      /**\n       * Creates a plain object from a Tensor message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {onnx.TypeProto.Tensor} message Tensor\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      Tensor.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) {\n          object.elemType = 0;\n          object.shape = null;\n        }\n        if (message.elemType != null && message.hasOwnProperty('elemType')) object.elemType = message.elemType;\n        if (message.shape != null && message.hasOwnProperty('shape'))\n          object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);\n        return object;\n      };\n\n      /**\n       * Converts this Tensor to JSON.\n       * @function toJSON\n       * @memberof onnx.TypeProto.Tensor\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      Tensor.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for Tensor\n       * @function getTypeUrl\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      Tensor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TypeProto.Tensor';\n      };\n\n      return Tensor;\n    })();\n\n    TypeProto.Sequence = (function () {\n      /**\n       * Properties of a Sequence.\n       * @memberof onnx.TypeProto\n       * @interface ISequence\n       * @property {onnx.ITypeProto|null} [elemType] Sequence elemType\n       */\n\n      /**\n       * Constructs a new Sequence.\n       * @memberof onnx.TypeProto\n       * @classdesc Represents a Sequence.\n       * @implements ISequence\n       * @constructor\n       * @param {onnx.TypeProto.ISequence=} [properties] Properties to set\n       */\n      function Sequence(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Sequence elemType.\n       * @member {onnx.ITypeProto|null|undefined} elemType\n       * @memberof onnx.TypeProto.Sequence\n       * @instance\n       */\n      Sequence.prototype.elemType = null;\n\n      /**\n       * Creates a new Sequence instance using the specified properties.\n       * @function create\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {onnx.TypeProto.ISequence=} [properties] Properties to set\n       * @returns {onnx.TypeProto.Sequence} Sequence instance\n       */\n      Sequence.create = function create(properties) {\n        return new Sequence(properties);\n      };\n\n      /**\n       * Encodes the specified Sequence message. Does not implicitly {@link onnx.TypeProto.Sequence.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {onnx.TypeProto.ISequence} message Sequence message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Sequence.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.elemType != null && Object.hasOwnProperty.call(message, 'elemType'))\n          $root.onnx.TypeProto.encode(message.elemType, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n        return writer;\n      };\n\n      /**\n       * Encodes the specified Sequence message, length delimited. Does not implicitly {@link onnx.TypeProto.Sequence.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {onnx.TypeProto.ISequence} message Sequence message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Sequence.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes a Sequence message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TypeProto.Sequence} Sequence\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Sequence.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TypeProto.Sequence();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes a Sequence message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TypeProto.Sequence} Sequence\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Sequence.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies a Sequence message.\n       * @function verify\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      Sequence.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.elemType != null && message.hasOwnProperty('elemType')) {\n          var error = $root.onnx.TypeProto.verify(message.elemType);\n          if (error) return 'elemType.' + error;\n        }\n        return null;\n      };\n\n      /**\n       * Creates a Sequence message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TypeProto.Sequence} Sequence\n       */\n      Sequence.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TypeProto.Sequence) return object;\n        var message = new $root.onnx.TypeProto.Sequence();\n        if (object.elemType != null) {\n          if (typeof object.elemType !== 'object')\n            throw TypeError('.onnx.TypeProto.Sequence.elemType: object expected');\n          message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);\n        }\n        return message;\n      };\n\n      /**\n       * Creates a plain object from a Sequence message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {onnx.TypeProto.Sequence} message Sequence\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      Sequence.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) object.elemType = null;\n        if (message.elemType != null && message.hasOwnProperty('elemType'))\n          object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);\n        return object;\n      };\n\n      /**\n       * Converts this Sequence to JSON.\n       * @function toJSON\n       * @memberof onnx.TypeProto.Sequence\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      Sequence.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for Sequence\n       * @function getTypeUrl\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      Sequence.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TypeProto.Sequence';\n      };\n\n      return Sequence;\n    })();\n\n    TypeProto.Map = (function () {\n      /**\n       * Properties of a Map.\n       * @memberof onnx.TypeProto\n       * @interface IMap\n       * @property {number|null} [keyType] Map keyType\n       * @property {onnx.ITypeProto|null} [valueType] Map valueType\n       */\n\n      /**\n       * Constructs a new Map.\n       * @memberof onnx.TypeProto\n       * @classdesc Represents a Map.\n       * @implements IMap\n       * @constructor\n       * @param {onnx.TypeProto.IMap=} [properties] Properties to set\n       */\n      function Map(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Map keyType.\n       * @member {number} keyType\n       * @memberof onnx.TypeProto.Map\n       * @instance\n       */\n      Map.prototype.keyType = 0;\n\n      /**\n       * Map valueType.\n       * @member {onnx.ITypeProto|null|undefined} valueType\n       * @memberof onnx.TypeProto.Map\n       * @instance\n       */\n      Map.prototype.valueType = null;\n\n      /**\n       * Creates a new Map instance using the specified properties.\n       * @function create\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {onnx.TypeProto.IMap=} [properties] Properties to set\n       * @returns {onnx.TypeProto.Map} Map instance\n       */\n      Map.create = function create(properties) {\n        return new Map(properties);\n      };\n\n      /**\n       * Encodes the specified Map message. Does not implicitly {@link onnx.TypeProto.Map.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {onnx.TypeProto.IMap} message Map message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Map.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.keyType != null && Object.hasOwnProperty.call(message, 'keyType'))\n          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.keyType);\n        if (message.valueType != null && Object.hasOwnProperty.call(message, 'valueType'))\n          $root.onnx.TypeProto.encode(message.valueType, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n        return writer;\n      };\n\n      /**\n       * Encodes the specified Map message, length delimited. Does not implicitly {@link onnx.TypeProto.Map.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {onnx.TypeProto.IMap} message Map message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Map.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes a Map message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TypeProto.Map} Map\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Map.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TypeProto.Map();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.keyType = reader.int32();\n              break;\n            }\n            case 2: {\n              message.valueType = $root.onnx.TypeProto.decode(reader, reader.uint32());\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes a Map message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TypeProto.Map} Map\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Map.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies a Map message.\n       * @function verify\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      Map.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.keyType != null && message.hasOwnProperty('keyType'))\n          if (!$util.isInteger(message.keyType)) return 'keyType: integer expected';\n        if (message.valueType != null && message.hasOwnProperty('valueType')) {\n          var error = $root.onnx.TypeProto.verify(message.valueType);\n          if (error) return 'valueType.' + error;\n        }\n        return null;\n      };\n\n      /**\n       * Creates a Map message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TypeProto.Map} Map\n       */\n      Map.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TypeProto.Map) return object;\n        var message = new $root.onnx.TypeProto.Map();\n        if (object.keyType != null) message.keyType = object.keyType | 0;\n        if (object.valueType != null) {\n          if (typeof object.valueType !== 'object') throw TypeError('.onnx.TypeProto.Map.valueType: object expected');\n          message.valueType = $root.onnx.TypeProto.fromObject(object.valueType);\n        }\n        return message;\n      };\n\n      /**\n       * Creates a plain object from a Map message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {onnx.TypeProto.Map} message Map\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      Map.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) {\n          object.keyType = 0;\n          object.valueType = null;\n        }\n        if (message.keyType != null && message.hasOwnProperty('keyType')) object.keyType = message.keyType;\n        if (message.valueType != null && message.hasOwnProperty('valueType'))\n          object.valueType = $root.onnx.TypeProto.toObject(message.valueType, options);\n        return object;\n      };\n\n      /**\n       * Converts this Map to JSON.\n       * @function toJSON\n       * @memberof onnx.TypeProto.Map\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      Map.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for Map\n       * @function getTypeUrl\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      Map.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TypeProto.Map';\n      };\n\n      return Map;\n    })();\n\n    TypeProto.Optional = (function () {\n      /**\n       * Properties of an Optional.\n       * @memberof onnx.TypeProto\n       * @interface IOptional\n       * @property {onnx.ITypeProto|null} [elemType] Optional elemType\n       */\n\n      /**\n       * Constructs a new Optional.\n       * @memberof onnx.TypeProto\n       * @classdesc Represents an Optional.\n       * @implements IOptional\n       * @constructor\n       * @param {onnx.TypeProto.IOptional=} [properties] Properties to set\n       */\n      function Optional(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Optional elemType.\n       * @member {onnx.ITypeProto|null|undefined} elemType\n       * @memberof onnx.TypeProto.Optional\n       * @instance\n       */\n      Optional.prototype.elemType = null;\n\n      /**\n       * Creates a new Optional instance using the specified properties.\n       * @function create\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {onnx.TypeProto.IOptional=} [properties] Properties to set\n       * @returns {onnx.TypeProto.Optional} Optional instance\n       */\n      Optional.create = function create(properties) {\n        return new Optional(properties);\n      };\n\n      /**\n       * Encodes the specified Optional message. Does not implicitly {@link onnx.TypeProto.Optional.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {onnx.TypeProto.IOptional} message Optional message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Optional.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.elemType != null && Object.hasOwnProperty.call(message, 'elemType'))\n          $root.onnx.TypeProto.encode(message.elemType, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n        return writer;\n      };\n\n      /**\n       * Encodes the specified Optional message, length delimited. Does not implicitly {@link onnx.TypeProto.Optional.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {onnx.TypeProto.IOptional} message Optional message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Optional.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes an Optional message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TypeProto.Optional} Optional\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Optional.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TypeProto.Optional();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes an Optional message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TypeProto.Optional} Optional\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Optional.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies an Optional message.\n       * @function verify\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      Optional.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.elemType != null && message.hasOwnProperty('elemType')) {\n          var error = $root.onnx.TypeProto.verify(message.elemType);\n          if (error) return 'elemType.' + error;\n        }\n        return null;\n      };\n\n      /**\n       * Creates an Optional message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TypeProto.Optional} Optional\n       */\n      Optional.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TypeProto.Optional) return object;\n        var message = new $root.onnx.TypeProto.Optional();\n        if (object.elemType != null) {\n          if (typeof object.elemType !== 'object')\n            throw TypeError('.onnx.TypeProto.Optional.elemType: object expected');\n          message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);\n        }\n        return message;\n      };\n\n      /**\n       * Creates a plain object from an Optional message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {onnx.TypeProto.Optional} message Optional\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      Optional.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) object.elemType = null;\n        if (message.elemType != null && message.hasOwnProperty('elemType'))\n          object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);\n        return object;\n      };\n\n      /**\n       * Converts this Optional to JSON.\n       * @function toJSON\n       * @memberof onnx.TypeProto.Optional\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      Optional.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for Optional\n       * @function getTypeUrl\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      Optional.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TypeProto.Optional';\n      };\n\n      return Optional;\n    })();\n\n    TypeProto.SparseTensor = (function () {\n      /**\n       * Properties of a SparseTensor.\n       * @memberof onnx.TypeProto\n       * @interface ISparseTensor\n       * @property {number|null} [elemType] SparseTensor elemType\n       * @property {onnx.ITensorShapeProto|null} [shape] SparseTensor shape\n       */\n\n      /**\n       * Constructs a new SparseTensor.\n       * @memberof onnx.TypeProto\n       * @classdesc Represents a SparseTensor.\n       * @implements ISparseTensor\n       * @constructor\n       * @param {onnx.TypeProto.ISparseTensor=} [properties] Properties to set\n       */\n      function SparseTensor(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * SparseTensor elemType.\n       * @member {number} elemType\n       * @memberof onnx.TypeProto.SparseTensor\n       * @instance\n       */\n      SparseTensor.prototype.elemType = 0;\n\n      /**\n       * SparseTensor shape.\n       * @member {onnx.ITensorShapeProto|null|undefined} shape\n       * @memberof onnx.TypeProto.SparseTensor\n       * @instance\n       */\n      SparseTensor.prototype.shape = null;\n\n      /**\n       * Creates a new SparseTensor instance using the specified properties.\n       * @function create\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {onnx.TypeProto.ISparseTensor=} [properties] Properties to set\n       * @returns {onnx.TypeProto.SparseTensor} SparseTensor instance\n       */\n      SparseTensor.create = function create(properties) {\n        return new SparseTensor(properties);\n      };\n\n      /**\n       * Encodes the specified SparseTensor message. Does not implicitly {@link onnx.TypeProto.SparseTensor.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {onnx.TypeProto.ISparseTensor} message SparseTensor message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      SparseTensor.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.elemType != null && Object.hasOwnProperty.call(message, 'elemType'))\n          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.elemType);\n        if (message.shape != null && Object.hasOwnProperty.call(message, 'shape'))\n          $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n        return writer;\n      };\n\n      /**\n       * Encodes the specified SparseTensor message, length delimited. Does not implicitly {@link onnx.TypeProto.SparseTensor.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {onnx.TypeProto.ISparseTensor} message SparseTensor message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      SparseTensor.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes a SparseTensor message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TypeProto.SparseTensor} SparseTensor\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      SparseTensor.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TypeProto.SparseTensor();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.elemType = reader.int32();\n              break;\n            }\n            case 2: {\n              message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes a SparseTensor message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TypeProto.SparseTensor} SparseTensor\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      SparseTensor.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies a SparseTensor message.\n       * @function verify\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      SparseTensor.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.elemType != null && message.hasOwnProperty('elemType'))\n          if (!$util.isInteger(message.elemType)) return 'elemType: integer expected';\n        if (message.shape != null && message.hasOwnProperty('shape')) {\n          var error = $root.onnx.TensorShapeProto.verify(message.shape);\n          if (error) return 'shape.' + error;\n        }\n        return null;\n      };\n\n      /**\n       * Creates a SparseTensor message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TypeProto.SparseTensor} SparseTensor\n       */\n      SparseTensor.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TypeProto.SparseTensor) return object;\n        var message = new $root.onnx.TypeProto.SparseTensor();\n        if (object.elemType != null) message.elemType = object.elemType | 0;\n        if (object.shape != null) {\n          if (typeof object.shape !== 'object') throw TypeError('.onnx.TypeProto.SparseTensor.shape: object expected');\n          message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);\n        }\n        return message;\n      };\n\n      /**\n       * Creates a plain object from a SparseTensor message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {onnx.TypeProto.SparseTensor} message SparseTensor\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      SparseTensor.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) {\n          object.elemType = 0;\n          object.shape = null;\n        }\n        if (message.elemType != null && message.hasOwnProperty('elemType')) object.elemType = message.elemType;\n        if (message.shape != null && message.hasOwnProperty('shape'))\n          object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);\n        return object;\n      };\n\n      /**\n       * Converts this SparseTensor to JSON.\n       * @function toJSON\n       * @memberof onnx.TypeProto.SparseTensor\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      SparseTensor.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for SparseTensor\n       * @function getTypeUrl\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      SparseTensor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TypeProto.SparseTensor';\n      };\n\n      return SparseTensor;\n    })();\n\n    return TypeProto;\n  })();\n\n  onnx.OperatorSetIdProto = (function () {\n    /**\n     * Properties of an OperatorSetIdProto.\n     * @memberof onnx\n     * @interface IOperatorSetIdProto\n     * @property {string|null} [domain] OperatorSetIdProto domain\n     * @property {number|Long|null} [version] OperatorSetIdProto version\n     */\n\n    /**\n     * Constructs a new OperatorSetIdProto.\n     * @memberof onnx\n     * @classdesc Represents an OperatorSetIdProto.\n     * @implements IOperatorSetIdProto\n     * @constructor\n     * @param {onnx.IOperatorSetIdProto=} [properties] Properties to set\n     */\n    function OperatorSetIdProto(properties) {\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * OperatorSetIdProto domain.\n     * @member {string} domain\n     * @memberof onnx.OperatorSetIdProto\n     * @instance\n     */\n    OperatorSetIdProto.prototype.domain = '';\n\n    /**\n     * OperatorSetIdProto version.\n     * @member {number|Long} version\n     * @memberof onnx.OperatorSetIdProto\n     * @instance\n     */\n    OperatorSetIdProto.prototype.version = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n    /**\n     * Creates a new OperatorSetIdProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {onnx.IOperatorSetIdProto=} [properties] Properties to set\n     * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto instance\n     */\n    OperatorSetIdProto.create = function create(properties) {\n      return new OperatorSetIdProto(properties);\n    };\n\n    /**\n     * Encodes the specified OperatorSetIdProto message. Does not implicitly {@link onnx.OperatorSetIdProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {onnx.IOperatorSetIdProto} message OperatorSetIdProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    OperatorSetIdProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.domain != null && Object.hasOwnProperty.call(message, 'domain'))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.domain);\n      if (message.version != null && Object.hasOwnProperty.call(message, 'version'))\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.version);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified OperatorSetIdProto message, length delimited. Does not implicitly {@link onnx.OperatorSetIdProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {onnx.IOperatorSetIdProto} message OperatorSetIdProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    OperatorSetIdProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an OperatorSetIdProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    OperatorSetIdProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.OperatorSetIdProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.domain = reader.string();\n            break;\n          }\n          case 2: {\n            message.version = reader.int64();\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes an OperatorSetIdProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    OperatorSetIdProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an OperatorSetIdProto message.\n     * @function verify\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    OperatorSetIdProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.domain != null && message.hasOwnProperty('domain'))\n        if (!$util.isString(message.domain)) return 'domain: string expected';\n      if (message.version != null && message.hasOwnProperty('version'))\n        if (\n          !$util.isInteger(message.version) &&\n          !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high))\n        )\n          return 'version: integer|Long expected';\n      return null;\n    };\n\n    /**\n     * Creates an OperatorSetIdProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto\n     */\n    OperatorSetIdProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.OperatorSetIdProto) return object;\n      var message = new $root.onnx.OperatorSetIdProto();\n      if (object.domain != null) message.domain = String(object.domain);\n      if (object.version != null)\n        if ($util.Long) (message.version = $util.Long.fromValue(object.version)).unsigned = false;\n        else if (typeof object.version === 'string') message.version = parseInt(object.version, 10);\n        else if (typeof object.version === 'number') message.version = object.version;\n        else if (typeof object.version === 'object')\n          message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();\n      return message;\n    };\n\n    /**\n     * Creates a plain object from an OperatorSetIdProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {onnx.OperatorSetIdProto} message OperatorSetIdProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    OperatorSetIdProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) {\n        object.domain = '';\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, false);\n          object.version =\n            options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.version = options.longs === String ? '0' : 0;\n      }\n      if (message.domain != null && message.hasOwnProperty('domain')) object.domain = message.domain;\n      if (message.version != null && message.hasOwnProperty('version'))\n        if (typeof message.version === 'number')\n          object.version = options.longs === String ? String(message.version) : message.version;\n        else\n          object.version =\n            options.longs === String\n              ? $util.Long.prototype.toString.call(message.version)\n              : options.longs === Number\n                ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber()\n                : message.version;\n      return object;\n    };\n\n    /**\n     * Converts this OperatorSetIdProto to JSON.\n     * @function toJSON\n     * @memberof onnx.OperatorSetIdProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    OperatorSetIdProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for OperatorSetIdProto\n     * @function getTypeUrl\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    OperatorSetIdProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.OperatorSetIdProto';\n    };\n\n    return OperatorSetIdProto;\n  })();\n\n  /**\n   * OperatorStatus enum.\n   * @name onnx.OperatorStatus\n   * @enum {number}\n   * @property {number} EXPERIMENTAL=0 EXPERIMENTAL value\n   * @property {number} STABLE=1 STABLE value\n   */\n  onnx.OperatorStatus = (function () {\n    var valuesById = {},\n      values = Object.create(valuesById);\n    values[(valuesById[0] = 'EXPERIMENTAL')] = 0;\n    values[(valuesById[1] = 'STABLE')] = 1;\n    return values;\n  })();\n\n  onnx.FunctionProto = (function () {\n    /**\n     * Properties of a FunctionProto.\n     * @memberof onnx\n     * @interface IFunctionProto\n     * @property {string|null} [name] FunctionProto name\n     * @property {Array.<string>|null} [input] FunctionProto input\n     * @property {Array.<string>|null} [output] FunctionProto output\n     * @property {Array.<string>|null} [attribute] FunctionProto attribute\n     * @property {Array.<onnx.IAttributeProto>|null} [attributeProto] FunctionProto attributeProto\n     * @property {Array.<onnx.INodeProto>|null} [node] FunctionProto node\n     * @property {string|null} [docString] FunctionProto docString\n     * @property {Array.<onnx.IOperatorSetIdProto>|null} [opsetImport] FunctionProto opsetImport\n     * @property {string|null} [domain] FunctionProto domain\n     */\n\n    /**\n     * Constructs a new FunctionProto.\n     * @memberof onnx\n     * @classdesc Represents a FunctionProto.\n     * @implements IFunctionProto\n     * @constructor\n     * @param {onnx.IFunctionProto=} [properties] Properties to set\n     */\n    function FunctionProto(properties) {\n      this.input = [];\n      this.output = [];\n      this.attribute = [];\n      this.attributeProto = [];\n      this.node = [];\n      this.opsetImport = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * FunctionProto name.\n     * @member {string} name\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.name = '';\n\n    /**\n     * FunctionProto input.\n     * @member {Array.<string>} input\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.input = $util.emptyArray;\n\n    /**\n     * FunctionProto output.\n     * @member {Array.<string>} output\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.output = $util.emptyArray;\n\n    /**\n     * FunctionProto attribute.\n     * @member {Array.<string>} attribute\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.attribute = $util.emptyArray;\n\n    /**\n     * FunctionProto attributeProto.\n     * @member {Array.<onnx.IAttributeProto>} attributeProto\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.attributeProto = $util.emptyArray;\n\n    /**\n     * FunctionProto node.\n     * @member {Array.<onnx.INodeProto>} node\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.node = $util.emptyArray;\n\n    /**\n     * FunctionProto docString.\n     * @member {string} docString\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.docString = '';\n\n    /**\n     * FunctionProto opsetImport.\n     * @member {Array.<onnx.IOperatorSetIdProto>} opsetImport\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.opsetImport = $util.emptyArray;\n\n    /**\n     * FunctionProto domain.\n     * @member {string} domain\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.domain = '';\n\n    /**\n     * Creates a new FunctionProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {onnx.IFunctionProto=} [properties] Properties to set\n     * @returns {onnx.FunctionProto} FunctionProto instance\n     */\n    FunctionProto.create = function create(properties) {\n      return new FunctionProto(properties);\n    };\n\n    /**\n     * Encodes the specified FunctionProto message. Does not implicitly {@link onnx.FunctionProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {onnx.IFunctionProto} message FunctionProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FunctionProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);\n      if (message.input != null && message.input.length)\n        for (var i = 0; i < message.input.length; ++i)\n          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.input[i]);\n      if (message.output != null && message.output.length)\n        for (var i = 0; i < message.output.length; ++i)\n          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.output[i]);\n      if (message.attribute != null && message.attribute.length)\n        for (var i = 0; i < message.attribute.length; ++i)\n          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.attribute[i]);\n      if (message.node != null && message.node.length)\n        for (var i = 0; i < message.node.length; ++i)\n          $root.onnx.NodeProto.encode(message.node[i], writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.docString);\n      if (message.opsetImport != null && message.opsetImport.length)\n        for (var i = 0; i < message.opsetImport.length; ++i)\n          $root.onnx.OperatorSetIdProto.encode(\n            message.opsetImport[i],\n            writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),\n          ).ldelim();\n      if (message.domain != null && Object.hasOwnProperty.call(message, 'domain'))\n        writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.domain);\n      if (message.attributeProto != null && message.attributeProto.length)\n        for (var i = 0; i < message.attributeProto.length; ++i)\n          $root.onnx.AttributeProto.encode(\n            message.attributeProto[i],\n            writer.uint32(/* id 11, wireType 2 =*/ 90).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified FunctionProto message, length delimited. Does not implicitly {@link onnx.FunctionProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {onnx.IFunctionProto} message FunctionProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FunctionProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a FunctionProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.FunctionProto} FunctionProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FunctionProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.FunctionProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.name = reader.string();\n            break;\n          }\n          case 4: {\n            if (!(message.input && message.input.length)) message.input = [];\n            message.input.push(reader.string());\n            break;\n          }\n          case 5: {\n            if (!(message.output && message.output.length)) message.output = [];\n            message.output.push(reader.string());\n            break;\n          }\n          case 6: {\n            if (!(message.attribute && message.attribute.length)) message.attribute = [];\n            message.attribute.push(reader.string());\n            break;\n          }\n          case 11: {\n            if (!(message.attributeProto && message.attributeProto.length)) message.attributeProto = [];\n            message.attributeProto.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 7: {\n            if (!(message.node && message.node.length)) message.node = [];\n            message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 8: {\n            message.docString = reader.string();\n            break;\n          }\n          case 9: {\n            if (!(message.opsetImport && message.opsetImport.length)) message.opsetImport = [];\n            message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 10: {\n            message.domain = reader.string();\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a FunctionProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.FunctionProto} FunctionProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FunctionProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a FunctionProto message.\n     * @function verify\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    FunctionProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.name != null && message.hasOwnProperty('name'))\n        if (!$util.isString(message.name)) return 'name: string expected';\n      if (message.input != null && message.hasOwnProperty('input')) {\n        if (!Array.isArray(message.input)) return 'input: array expected';\n        for (var i = 0; i < message.input.length; ++i)\n          if (!$util.isString(message.input[i])) return 'input: string[] expected';\n      }\n      if (message.output != null && message.hasOwnProperty('output')) {\n        if (!Array.isArray(message.output)) return 'output: array expected';\n        for (var i = 0; i < message.output.length; ++i)\n          if (!$util.isString(message.output[i])) return 'output: string[] expected';\n      }\n      if (message.attribute != null && message.hasOwnProperty('attribute')) {\n        if (!Array.isArray(message.attribute)) return 'attribute: array expected';\n        for (var i = 0; i < message.attribute.length; ++i)\n          if (!$util.isString(message.attribute[i])) return 'attribute: string[] expected';\n      }\n      if (message.attributeProto != null && message.hasOwnProperty('attributeProto')) {\n        if (!Array.isArray(message.attributeProto)) return 'attributeProto: array expected';\n        for (var i = 0; i < message.attributeProto.length; ++i) {\n          var error = $root.onnx.AttributeProto.verify(message.attributeProto[i]);\n          if (error) return 'attributeProto.' + error;\n        }\n      }\n      if (message.node != null && message.hasOwnProperty('node')) {\n        if (!Array.isArray(message.node)) return 'node: array expected';\n        for (var i = 0; i < message.node.length; ++i) {\n          var error = $root.onnx.NodeProto.verify(message.node[i]);\n          if (error) return 'node.' + error;\n        }\n      }\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      if (message.opsetImport != null && message.hasOwnProperty('opsetImport')) {\n        if (!Array.isArray(message.opsetImport)) return 'opsetImport: array expected';\n        for (var i = 0; i < message.opsetImport.length; ++i) {\n          var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);\n          if (error) return 'opsetImport.' + error;\n        }\n      }\n      if (message.domain != null && message.hasOwnProperty('domain'))\n        if (!$util.isString(message.domain)) return 'domain: string expected';\n      return null;\n    };\n\n    /**\n     * Creates a FunctionProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.FunctionProto} FunctionProto\n     */\n    FunctionProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.FunctionProto) return object;\n      var message = new $root.onnx.FunctionProto();\n      if (object.name != null) message.name = String(object.name);\n      if (object.input) {\n        if (!Array.isArray(object.input)) throw TypeError('.onnx.FunctionProto.input: array expected');\n        message.input = [];\n        for (var i = 0; i < object.input.length; ++i) message.input[i] = String(object.input[i]);\n      }\n      if (object.output) {\n        if (!Array.isArray(object.output)) throw TypeError('.onnx.FunctionProto.output: array expected');\n        message.output = [];\n        for (var i = 0; i < object.output.length; ++i) message.output[i] = String(object.output[i]);\n      }\n      if (object.attribute) {\n        if (!Array.isArray(object.attribute)) throw TypeError('.onnx.FunctionProto.attribute: array expected');\n        message.attribute = [];\n        for (var i = 0; i < object.attribute.length; ++i) message.attribute[i] = String(object.attribute[i]);\n      }\n      if (object.attributeProto) {\n        if (!Array.isArray(object.attributeProto))\n          throw TypeError('.onnx.FunctionProto.attributeProto: array expected');\n        message.attributeProto = [];\n        for (var i = 0; i < object.attributeProto.length; ++i) {\n          if (typeof object.attributeProto[i] !== 'object')\n            throw TypeError('.onnx.FunctionProto.attributeProto: object expected');\n          message.attributeProto[i] = $root.onnx.AttributeProto.fromObject(object.attributeProto[i]);\n        }\n      }\n      if (object.node) {\n        if (!Array.isArray(object.node)) throw TypeError('.onnx.FunctionProto.node: array expected');\n        message.node = [];\n        for (var i = 0; i < object.node.length; ++i) {\n          if (typeof object.node[i] !== 'object') throw TypeError('.onnx.FunctionProto.node: object expected');\n          message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);\n        }\n      }\n      if (object.docString != null) message.docString = String(object.docString);\n      if (object.opsetImport) {\n        if (!Array.isArray(object.opsetImport)) throw TypeError('.onnx.FunctionProto.opsetImport: array expected');\n        message.opsetImport = [];\n        for (var i = 0; i < object.opsetImport.length; ++i) {\n          if (typeof object.opsetImport[i] !== 'object')\n            throw TypeError('.onnx.FunctionProto.opsetImport: object expected');\n          message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);\n        }\n      }\n      if (object.domain != null) message.domain = String(object.domain);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a FunctionProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {onnx.FunctionProto} message FunctionProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    FunctionProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.input = [];\n        object.output = [];\n        object.attribute = [];\n        object.node = [];\n        object.opsetImport = [];\n        object.attributeProto = [];\n      }\n      if (options.defaults) {\n        object.name = '';\n        object.docString = '';\n        object.domain = '';\n      }\n      if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;\n      if (message.input && message.input.length) {\n        object.input = [];\n        for (var j = 0; j < message.input.length; ++j) object.input[j] = message.input[j];\n      }\n      if (message.output && message.output.length) {\n        object.output = [];\n        for (var j = 0; j < message.output.length; ++j) object.output[j] = message.output[j];\n      }\n      if (message.attribute && message.attribute.length) {\n        object.attribute = [];\n        for (var j = 0; j < message.attribute.length; ++j) object.attribute[j] = message.attribute[j];\n      }\n      if (message.node && message.node.length) {\n        object.node = [];\n        for (var j = 0; j < message.node.length; ++j)\n          object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);\n      }\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      if (message.opsetImport && message.opsetImport.length) {\n        object.opsetImport = [];\n        for (var j = 0; j < message.opsetImport.length; ++j)\n          object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);\n      }\n      if (message.domain != null && message.hasOwnProperty('domain')) object.domain = message.domain;\n      if (message.attributeProto && message.attributeProto.length) {\n        object.attributeProto = [];\n        for (var j = 0; j < message.attributeProto.length; ++j)\n          object.attributeProto[j] = $root.onnx.AttributeProto.toObject(message.attributeProto[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this FunctionProto to JSON.\n     * @function toJSON\n     * @memberof onnx.FunctionProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    FunctionProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for FunctionProto\n     * @function getTypeUrl\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    FunctionProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.FunctionProto';\n    };\n\n    return FunctionProto;\n  })();\n\n  return onnx;\n})();\n\nmodule.exports = $root;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { flatbuffers } from 'flatbuffers';\nimport Long from 'long';\n\nimport { Graph } from './graph';\nimport { onnxruntime } from './ort-schema/flatbuffers/ort-generated';\nimport { onnx } from './ort-schema/protobuf/onnx';\nimport { Tensor } from './tensor';\n\n// check the inputs shape before running an OP.\n// return true when the inputs pass the check\n// return false when the inputs do not fit the requirement\n// throw exception when fatal error or not implemented\nexport function checkInputsShape(inputs: Tensor[], ...expectedDimensions: number[]): boolean {\n  if (!inputs || inputs.length !== expectedDimensions.length) {\n    return false;\n  }\n  for (let i = 0; i < inputs.length; i++) {\n    if (!inputs[i].dims || inputs[i].dims.length !== expectedDimensions[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Evaluates the given expression and asserts error message if condition is unmet.\nexport function assert(expr: boolean, msg: () => string) {\n  if (!expr) {\n    throw new Error(typeof msg === 'string' ? msg : msg());\n  }\n}\n\nexport class ArrayUtil {\n  /**\n   * Verifies if 2 input arrays contain the same elements.\n   * @param n1 Array 1\n   * @param n2 Array 2\n   * @returns Whether these 2 are equal\n   */\n  static arraysEqual(\n    n1:\n      | readonly number[]\n      | Int8Array\n      | Uint8Array\n      | Int16Array\n      | Uint16Array\n      | Int32Array\n      | Uint32Array\n      | Uint8ClampedArray\n      | Float32Array\n      | Float64Array,\n    n2:\n      | readonly number[]\n      | Int8Array\n      | Uint8Array\n      | Int16Array\n      | Uint16Array\n      | Int32Array\n      | Uint32Array\n      | Uint8ClampedArray\n      | Float32Array\n      | Float64Array,\n  ) {\n    if (n1.length !== n2.length) {\n      return false;\n    }\n    for (let i = 0; i < n1.length; i++) {\n      if (n1[i] !== n2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nexport class MatMulUtil {\n  /**\n   * Fix the input shapes for MatMul operation if they need fixing\n   * @param dimsA The shape of tensor A. Should be an array of positive integers\n   * @param dimsB The shape of tensor B. Should be an array of positive integers\n   * @returns A tuple containing the preprocessed input shapes as required by ONNX specifications\n   */\n  static preprocessInputShapes(\n    dimsA: readonly number[],\n    dimsB: readonly number[],\n  ): [readonly number[], readonly number[]] {\n    // If the first argument is 1-D, it is promoted to a matrix by prepending\n    // a 1 to its dimensions. After matrix multiplication the prepended 1 is\n    // removed.\n    const a = dimsA.length === 1 ? [1, dimsA[0]] : dimsA;\n\n    // If the second argument is 1-D, it is promoted to a matrix by appending\n    // a 1 to its dimensions. After matrix multiplication the appended 1 is\n    // removed.\n    const b = dimsB.length === 1 ? [dimsB[0], 1] : dimsB;\n\n    return [a, b];\n  }\n\n  /**\n   * Fix the output shape computed for MatMul operation if it needs fixing\n   * @param outputShape The computed outputShape. Should be an array (atleast of length 2) of positive integers.\n   * This will be mutated.\n   * @param aRank The rank of tensor A.\n   * @param bRank The rank of tensor B.\n   */\n  static postprocessOutputShape(outputShape: number[], aRank: number, bRank: number) {\n    // Remove prepended dimension if first input is 1d\n    if (aRank === 1) {\n      // outputShape = outputShape.slice(0, outputShape.length - 2).concat(outputShape.slice(outputShape.length - 1));\n      outputShape.splice(outputShape.length - 2, 1);\n    }\n    // Remove appended dimension if second input is 1d\n    if (bRank === 1) {\n      outputShape.pop();\n    }\n  }\n\n  /**\n   * Calculate the expected shape when matrix multiplication\n   * @param a The shape of tensor A. Should be a tuple of 2 positive integers\n   * @param b The shape of tensor B. Should be a tuple of 2 positive integers\n   * @returns The expected shape of the result, or undefined if N/A\n   */\n  static calcMatMulShape(a: [number, number], b: [number, number]): [number, number] | undefined {\n    return a[1] !== b[0] ? undefined : [a[0], b[1]];\n  }\n}\n\nexport class BroadcastUtil {\n  /**\n   * Calculate the expected shape when broadcasting 2 tensors\n   * @param a The shape of tensor A. Should be an array of positive integers\n   * @param b The shape of tensor B. Should be an array of positive integers\n   * @param isMatMul Whether the operation is MatMul\n   * @returns The expected shape of the result, or undefined if N/A\n   */\n  static calcShape(\n    adims: readonly number[],\n    bdims: readonly number[],\n    isMatMul = false,\n  ): readonly number[] | undefined {\n    const arank = adims.length;\n    const brank = bdims.length;\n    if (arank === 0) {\n      return bdims;\n    }\n    if (brank === 0) {\n      return adims;\n    }\n    const crank = Math.max(adims.length, bdims.length);\n    const cdims = new Array<number>(crank);\n\n    // calculate the last 2 dimension if it is MatMul\n    if (isMatMul) {\n      if (arank < 2 || brank < 2) {\n        return undefined;\n      }\n      const cShapeMatMul = MatMulUtil.calcMatMulShape(\n        [adims[arank - 2], adims[arank - 1]],\n        [bdims[brank - 2], bdims[brank - 1]],\n      );\n      if (cShapeMatMul === undefined) {\n        return undefined;\n      }\n      [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;\n    }\n\n    for (let i = isMatMul ? 3 : 1; i <= crank; i++) {\n      const aLen = arank - i < 0 ? 1 : adims[arank - i];\n      const bLen = brank - i < 0 ? 1 : bdims[brank - i];\n\n      if (aLen !== bLen && aLen > 1 && bLen > 1) {\n        return undefined;\n      }\n      cdims[crank - i] = Math.max(aLen, bLen);\n    }\n\n    return cdims;\n  }\n\n  /**\n   * Given the indices of a broadcasted tensor, calculate the original indices\n   * @param broadcastedIndices The given indices of the broadcasted tensor.\n   * @param originalShape The original shape of the tensor before broadcas\n   * @returns The calculated indices that maps to the original tensor.\n   */\n  static index(broadcastedIndices: readonly number[], originalShape: readonly number[]): number[] {\n    // NOTE 1: we assume the parameter broadcastedIndices is valid. ie. it should have the same\n    // length as the broadcasted shape, and for each dimension the index should\n    // not be out of range.\n    const originalIndices = new Array(originalShape.length);\n    BroadcastUtil.fillIndex(broadcastedIndices, originalShape, originalIndices);\n    return originalIndices;\n  }\n\n  /**\n   * Given the indices of a broadcasted tensor, calculate the original indices\n   * @param broadcastedIndices The given indices of the broadcasted tensor.\n   * @param originalShape The original shape of the tensor before broadcast\n   * @param originalIndices The mapping of broadcastedIndices to the originalIndices (output parameter - will be\n   *     mutated).\n   */\n  static fillIndex(broadcastedIndices: readonly number[], originalShape: readonly number[], originalIndices: number[]) {\n    // NOTE 1: we assume the parameter broadcastedIndices is valid. ie. it should have the same length as the\n    // broadcasted shape, and for each dimension the index should not be out of range.\n    // NOTE 2: we assume the parameter originalIndices has the same length as the originalShape\n    const dimOffset = broadcastedIndices.length - originalShape.length;\n    for (let i = 0; i < originalShape.length; i++) {\n      originalIndices[i] = broadcastedIndices[dimOffset + i] % originalShape[i];\n    }\n  }\n\n  /**\n   * Perform the broadcasting operation on the specific operator\n   * @param a The input tensor A\n   * @param b The input tensor B\n   * @param op The operator lambda function\n   * @param inplace Whether to write the result back to A.\n   * @returns The result tensor, or undefined if input not broadcastable.\n   */\n  static calc(\n    a: Tensor,\n    b: Tensor,\n    op: (a: string | number, b: string | number) => string | number,\n    inplace: boolean,\n    resultType?: Tensor.DataType,\n  ): Tensor | undefined {\n    const outputShape = BroadcastUtil.calcShape(a.dims, b.dims);\n\n    if (outputShape) {\n      if (inplace && !ShapeUtil.areEqual(outputShape, a.dims)) {\n        // B is not broadcastable to A, failed to calculate inplace.\n        return undefined;\n      }\n\n      const size = ShapeUtil.size(outputShape);\n      const c = inplace ? a : new Tensor(outputShape, resultType || a.type);\n\n      // both inputs are scalars\n      if (outputShape.length === 0) {\n        c.set([], op(a.get([]) as number, b.get([]) as number));\n      }\n\n      // atleast one input is a non-scalar\n      else {\n        const outputIndices = new Array<number>(outputShape.length);\n        const originalIndicesA = new Array(a.dims.length);\n        const originalIndicesB = new Array(b.dims.length);\n        let valA: string | number = 0;\n        let valB: string | number = 0;\n        let isAScalar = false;\n        let isBScalar = false;\n        if (a.dims.length === 0) {\n          valA = a.get([]) as number;\n          isAScalar = true;\n        }\n        if (b.dims.length === 0) {\n          valB = b.get([]) as number;\n          isBScalar = true;\n        }\n        let rest: number;\n        for (let i = 0; i < size; i++) {\n          // traversal indices\n          rest = i;\n          for (let j = outputShape.length - 1; j >= 0; j--) {\n            outputIndices[j] = rest % outputShape[j];\n            rest = Math.floor(rest / outputShape[j]);\n          }\n\n          if (!isAScalar) {\n            // map outputIndices (which is actually broadcasted) to the originalIndices\n            BroadcastUtil.fillIndex(outputIndices, a.dims, originalIndicesA);\n            valA = a.get(originalIndicesA) as number;\n          }\n          if (!isBScalar) {\n            BroadcastUtil.fillIndex(outputIndices, b.dims, originalIndicesB);\n            valB = b.get(originalIndicesB) as number;\n          }\n\n          c.set(outputIndices, op(valA, valB));\n        }\n      }\n\n      return c;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Determine if a shape is unidirectional broadcastable to another shape\n   * @param shape The input shape\n   * @param finalShape The desired shape after broadcasting\n   */\n  static isValidBroadcast(shape: readonly number[], finalShape: readonly number[]): boolean {\n    // align shape to the right\n    const inputRank = shape.length;\n    const finalRank = finalShape.length;\n    if (inputRank > finalRank) {\n      return false;\n    }\n    for (let i = 1; i <= inputRank; i++) {\n      if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determine the broadcasted dims in input shape based on the given output shape.\n   * Note that this function only returns the broadcasted dims.\n   * @param inputShape The input shape\n   * @param outputShape The output shape\n   * @returns The broadcasted dims in input shape.\n   */\n  static getBroadcastDims(inputShape: readonly number[], outputShape: readonly number[]): number[] {\n    const inRank = inputShape.length;\n    const dims: number[] = [];\n    for (let i = 0; i < inRank; i++) {\n      const dim = inRank - 1 - i;\n      const a = inputShape[dim] || 1;\n      const b = outputShape[outputShape.length - 1 - i] || 1;\n      if (b > 1 && a === 1) {\n        dims.unshift(dim);\n      }\n    }\n    return dims;\n  }\n}\n\n// copy array helper\n// mimics memcpy as much as possible\nexport function arrayCopyHelper(\n  target: number[] | Tensor.NumberType,\n  source: number[] | Tensor.NumberType,\n  targetIndex: number,\n  sourceIndex: number,\n  blockSize: number,\n) {\n  if (sourceIndex < 0 || sourceIndex >= source.length) {\n    throw new Error('sourceIndex out of bounds');\n  }\n  if (targetIndex < 0 || targetIndex >= target.length) {\n    throw new Error('targetIndex out of bounds');\n  }\n  if (sourceIndex + blockSize > source.length) {\n    throw new Error('source indices to be copied are outside bounds');\n  }\n  if (targetIndex + blockSize > target.length) {\n    throw new Error('target array is too small to hold result');\n  }\n\n  for (let offset = 0; offset < blockSize; offset++) {\n    target[targetIndex + offset] = source[sourceIndex + offset];\n  }\n}\n\nexport class GemmUtil {\n  // will make sure input shapes are compatible for this op\n  // and return back the shape of the output in the form of a tuple\n  // will throw exception if the input shapes are not compatible\n  static getShapeOfGemmResult(\n    leftShape: readonly number[],\n    transLeft: boolean,\n    rightShape: readonly number[],\n    transRight: boolean,\n    biasShape?: readonly number[],\n  ): readonly number[] {\n    if (leftShape.length !== 2 || rightShape.length !== 2) {\n      throw new Error('shape need to be of size 2');\n    }\n\n    let M: number;\n    let K: number;\n    let N: number;\n\n    if (transLeft) {\n      M = leftShape[1];\n      K = leftShape[0];\n    } else {\n      M = leftShape[0];\n      K = leftShape[1];\n    }\n\n    let kDim = -1;\n\n    if (transRight) {\n      N = rightShape[0];\n      kDim = 1;\n    } else {\n      N = rightShape[1];\n      kDim = 0;\n    }\n\n    if (rightShape[kDim] !== K) {\n      throw new Error('dimension mismatch');\n    }\n\n    if (M <= 0 || N <= 0 || K <= 0) {\n      throw new Error('invalid shape specified');\n    }\n\n    if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {\n      throw new Error('gemm: invalid bias shape for broadcast');\n    }\n\n    return [M, N, K];\n  }\n}\n\nexport class ProtoUtil {\n  static tensorDataTypeFromProto(\n    typeProto: onnx.TensorProto.DataType | onnxruntime.experimental.fbs.TensorDataType,\n  ): Tensor.DataType {\n    switch (typeProto) {\n      case onnx.TensorProto.DataType.INT8:\n        return 'int8';\n      case onnx.TensorProto.DataType.UINT8:\n        return 'uint8';\n      case onnx.TensorProto.DataType.BOOL:\n        return 'bool';\n      case onnx.TensorProto.DataType.INT16:\n        return 'int16';\n      case onnx.TensorProto.DataType.UINT16:\n        return 'uint16';\n      case onnx.TensorProto.DataType.INT32:\n        return 'int32';\n      case onnx.TensorProto.DataType.UINT32:\n        return 'uint32';\n      case onnx.TensorProto.DataType.FLOAT:\n        return 'float32';\n      case onnx.TensorProto.DataType.DOUBLE:\n        return 'float64';\n      case onnx.TensorProto.DataType.STRING:\n        return 'string';\n\n      // For INT64/UINT64, reduce their value to 32-bits.\n      // Should throw exception when overflow\n      case onnx.TensorProto.DataType.INT64:\n        return 'int32';\n      case onnx.TensorProto.DataType.UINT64:\n        return 'uint32';\n\n      default:\n        throw new Error(`unsupported data type: ${onnx.TensorProto.DataType[typeProto]}`);\n    }\n  }\n\n  static tensorDataTypeStringToEnum(type: string): onnx.TensorProto.DataType {\n    switch (type) {\n      case 'int8':\n        return onnx.TensorProto.DataType.INT8;\n      case 'uint8':\n        return onnx.TensorProto.DataType.UINT8;\n      case 'bool':\n        return onnx.TensorProto.DataType.BOOL;\n      case 'int16':\n        return onnx.TensorProto.DataType.INT16;\n      case 'uint16':\n        return onnx.TensorProto.DataType.UINT16;\n      case 'int32':\n        return onnx.TensorProto.DataType.INT32;\n      case 'uint32':\n        return onnx.TensorProto.DataType.UINT32;\n      case 'float32':\n        return onnx.TensorProto.DataType.FLOAT;\n      case 'float64':\n        return onnx.TensorProto.DataType.DOUBLE;\n      case 'string':\n        return onnx.TensorProto.DataType.STRING;\n      case 'int64':\n        return onnx.TensorProto.DataType.INT64;\n      case 'uint64':\n        return onnx.TensorProto.DataType.UINT64;\n\n      default:\n        throw new Error(`unsupported data type: ${type}`);\n    }\n  }\n\n  static tensorDimsFromProto(dims: Array<number | Long>): number[] {\n    // get rid of Long type for dims\n    return dims.map((d) => (Long.isLong(d) ? d.toNumber() : d));\n  }\n\n  static tensorValueTypeFromProto(valueType: onnx.TypeProto.ITensor): Graph.ValueType {\n    return {\n      tensorType: ProtoUtil.tensorDataTypeFromProto(valueType.elemType!),\n      shape: { dims: ProtoUtil.tensorDimsFromProto(valueType.shape!.dim!.map((d) => d.dimValue!)) },\n    };\n  }\n\n  static tensorDimsFromORTFormat(tensor: onnxruntime.experimental.fbs.Tensor) {\n    const dims = [];\n    for (let i = 0; i < tensor.dimsLength(); i++) {\n      dims.push(LongUtil.longToNumber(tensor.dims(i)!));\n    }\n    return dims;\n  }\n\n  static tensorAttributesFromORTFormat(node: onnxruntime.experimental.fbs.Node) {\n    const attributes = [];\n    for (let i = 0; i < node.attributesLength(); i++) {\n      attributes.push(node.attributes(i)!);\n    }\n    return attributes;\n  }\n}\n\nexport class LongUtil {\n  // This function is called to get a number from long type of data for attribute, dim, and ir version,\n  // which values are signed integers.\n  // To make it more generic, add an optional parameter to convert to a unsigned number.\n  static longToNumber(n: Long | flatbuffers.Long | number, unsigned?: boolean) {\n    if (Long.isLong(n)) {\n      return n.toNumber();\n    } else if (n instanceof flatbuffers.Long) {\n      return Long.fromValue({ low: n.low, high: n.high, unsigned: unsigned ?? false }).toNumber();\n    }\n    return n;\n  }\n  static isLong(n: unknown) {\n    return Long.isLong(n) || n instanceof flatbuffers.Long;\n  }\n}\n\nexport class ShapeUtil {\n  static size(dims: readonly number[]): number {\n    return ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);\n  }\n\n  // `axis` inclusive\n  static sizeFromDimension(dims: readonly number[], axis: number): number {\n    if (axis < 0 || axis > dims.length) {\n      throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);\n    }\n    return ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);\n  }\n\n  // `axis` exclusive\n  static sizeToDimension(dims: readonly number[], axis: number): number {\n    if (axis < 0 || axis > dims.length) {\n      throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);\n    }\n    return ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);\n  }\n\n  static getSizeFromDimensionRange(dims: readonly number[], start: number, end: number): number {\n    let size = 1;\n    for (let i = start; i < end; i++) {\n      // safety check as this method is called by multiple other methods requiring size.\n      // size cannot be 0 or negative.\n      if (dims[i] <= 0) {\n        throw new Error(\n          // eslint-disable-next-line max-len\n          'cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.',\n        );\n      }\n      size *= dims[i];\n    }\n    return size;\n  }\n\n  static computeStrides(dims: readonly number[]): readonly number[] {\n    const rank = dims.length;\n    if (rank === 0) {\n      return [];\n    } else if (rank === 1) {\n      return [1];\n    }\n    const strides = new Array(rank);\n    strides[rank - 1] = 1;\n    strides[rank - 2] = dims[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * dims[i + 1];\n    }\n    return strides;\n  }\n\n  static transpose(dims: readonly number[]): readonly number[] {\n    const copy = dims.slice();\n    return copy.reverse();\n  }\n\n  static indicesToOffset(indices: readonly number[], strides: readonly number[], axis?: number): number {\n    if (axis === undefined) {\n      axis = indices.length;\n    }\n    let offset = 0;\n    for (let i = 0; i < axis; ++i) {\n      offset += strides[i] * indices[i];\n    }\n    return offset;\n  }\n\n  static offsetToIndices(offset: number, strides: readonly number[]): readonly number[] {\n    const rank = strides.length;\n    if (rank === 0) {\n      return [];\n    } else if (rank === 1) {\n      return [offset * strides[0]];\n    }\n    const indices: number[] = new Array(strides.length);\n    for (let i = 0; i < indices.length - 1; ++i) {\n      indices[i] = Math.floor(offset / strides[i]);\n      offset -= indices[i] * strides[i];\n    }\n    indices[indices.length - 1] = offset;\n    return indices;\n  }\n\n  /**\n   * normailze axis of range [-r, r) into [0, r).\n   */\n  static normalizeAxis(axis: number, tensorRank: number): number {\n    if (axis < -tensorRank && axis >= tensorRank) {\n      throw new Error('unsupported axis for this operation.');\n    }\n    return axis < 0 ? axis + tensorRank : axis;\n  }\n\n  static normalizeAxes(axes: readonly number[], tensorRank: number): number[] {\n    return axes.map((x) => this.normalizeAxis(x, tensorRank));\n  }\n\n  // Increment an index into a tensor (in lexicographic\n  // ordering), wrapping around the specified upper_bound.\n  /**\n   * Increment an index into a tensor (in lexicographic ordering), wrapping around the specified upper_bound.\n   * @param index Given index to increment (Will be mutated)\n   * @param dims The dimensions of the tensor for which the given index corresponds to\n   * @param axisToIncrementOn The 1-indexed axis to increment on. If undefined, axisToIncrementOn == rank\n   */\n  static incrementIndex(index: number[], dims: readonly number[], axisToIncrementOn?: number) {\n    if (dims.length === 0 || index.length === 0) {\n      throw new Error('Index incrementing unsupported for scalar Tensor');\n    }\n    if (axisToIncrementOn === undefined) {\n      axisToIncrementOn = dims.length;\n    } else {\n      if (axisToIncrementOn <= 0 || axisToIncrementOn > dims.length) {\n        throw new Error('Incorrect axis to increment on');\n      }\n    }\n\n    for (let k = axisToIncrementOn - 1; k >= 0; --k) {\n      index[k]++;\n      if (index[k] < dims[k]) {\n        break;\n      }\n      index[k] = 0;\n    }\n  }\n\n  /**\n   * Produces a new dimensions array based on the values in the 'originalDimensions' and 'shape' array\n   * Used in Reshape\n   * @param originalDims Original Shape array\n   * @param shapeHints array containing values to compute the new dimensions\n   * For example:\n   * originalDims = [2,2] and shapeHints = [0,-1] will return [2,2]\n   * originalDims = [2,2] and shapeHints = [4] will return [4]\n   * originalDims = [2,2] and shapeHints = [5] will throw an exception\n   * https://github.com/onnx/onnx/blob/main/docs/Operators.md#Reshape\n   */\n\n  static calculateReshapedDims(originalDims: readonly number[], shapeHints: ArrayLike<number>): number[] {\n    // reshape to a Scalar Tensor\n    if (shapeHints.length === 0) {\n      if (originalDims.length === 0 || ShapeUtil.size(originalDims) === 1) {\n        return [];\n      } else {\n        throw new Error('cannot reshape to a scalar Tensor');\n      }\n    }\n\n    const nDims = shapeHints.length;\n    const reshapedDims = new Array<number>(nDims);\n    let unknownDimension = -1;\n    let newTensorSize = 1;\n    for (let i = 0; i < nDims; i++) {\n      if (shapeHints[i] < -1) {\n        throw new Error('a dimension in shape hints cannot be less than -1');\n      }\n      if (shapeHints[i] === -1) {\n        if (unknownDimension !== -1) {\n          throw new Error('at most one dimension in shape hints can be -1');\n        }\n        unknownDimension = i;\n      } else {\n        if (shapeHints[i] === 0) {\n          if (i >= originalDims.length) {\n            throw new Error('the dimension with value zero exceeds the dimension size of the input tensor');\n          }\n          reshapedDims[i] = originalDims[i];\n        } else {\n          reshapedDims[i] = shapeHints[i];\n        }\n        newTensorSize *= reshapedDims[i];\n      }\n    }\n\n    const oldTensorSize = ShapeUtil.size(originalDims);\n    if (unknownDimension !== -1) {\n      if (oldTensorSize % newTensorSize !== 0) {\n        throw new Error(\n          `the input tensor cannot be reshaped to the requested shape. Input shape: [${\n            originalDims\n          }] Output shape: [${shapeHints}]`,\n        );\n      }\n      reshapedDims[unknownDimension] = oldTensorSize / newTensorSize;\n    }\n    // validate sizes from originalDims and reshapedDims match\n    else {\n      if (newTensorSize !== oldTensorSize) {\n        throw new Error(\"reshapedDims and originalDims don't have matching sizes\");\n      }\n    }\n    return reshapedDims;\n  }\n\n  /**\n   * Sorts a given array based on the indices in the Perm array\n   * Used in Transpose\n   * @param a Array to be sorted such as dims or strides\n   * @param perm Perm given; if null a will be reversed\n   */\n  static sortBasedOnPerm(a: readonly number[], perm?: readonly number[]): readonly number[] {\n    if (perm) {\n      return perm.map((v) => a[v]);\n    } else {\n      return a.slice().reverse();\n    }\n  }\n\n  /**\n   * Pads a given shape according to the padding values\n   * @param dims shape of the Tensor to be padded\n   * @param pad pad values\n   */\n  static padShape(dims: readonly number[], pad: readonly number[]): readonly number[] {\n    const rank = dims.length;\n    return dims.map((v, i) => v + pad[i] + pad[i + rank]);\n  }\n\n  /**\n   * Determines if the two shapes are identical\n   * @param shape1\n   * @param shape2\n   */\n  static areEqual(shape1: readonly number[], shape2: readonly number[]): boolean {\n    if (shape1.length !== shape2.length) {\n      return false;\n    }\n    return shape1.every((v, i) => v === shape2[i]);\n  }\n\n  /**\n   * Validates if the given `dims` or `shape` is valid in ONNX.js context and returns data size\n   * @param dims - input `dims` that needs to be checked\n   */\n  static validateDimsAndCalcSize(dims: readonly number[]): number {\n    if (dims.length > 6) {\n      throw new TypeError('Only rank 0 to 6 is supported for tensor shape.');\n    }\n    let size = 1;\n    for (const n of dims) {\n      if (!Number.isInteger(n)) {\n        throw new TypeError(`Invalid shape: ${n} is not an integer`);\n      }\n      if (n < 0 || n > 2147483647) {\n        throw new TypeError(`Invalid shape: length ${n} is not allowed`);\n      }\n      size *= n;\n    }\n    return size;\n  }\n\n  /**\n   * Determines the shape of output tensor y = flatten(x, axis)\n   * @param dims - shape of input tensor\n   * @param axis - flatten axis, in the range [-r, r]\n   */\n  static flattenShape(dims: readonly number[], axis: number): readonly number[] {\n    if (axis < 0) {\n      axis += dims.length;\n    }\n    const total = dims.reduce((x, y) => x * y, 1);\n    const right = dims.slice(axis).reduce((x, y) => x * y, 1);\n    const outputDims = [total / right, right];\n\n    return outputDims;\n  }\n\n  /**\n   * Determines the shape of output tensor y = squeeze(x, axes)\n   * @param dims - shape of input tensor\n   * @param axes - squeeze axes\n   */\n  static squeezeShape(dims: readonly number[], axes: readonly number[]): readonly number[] {\n    const outputDims = new Array<number>();\n\n    // sanity check\n    axes = ShapeUtil.normalizeAxes(axes, dims.length);\n\n    for (let i = 0; i < dims.length; i++) {\n      const inSqueezeList = axes.indexOf(i) >= 0;\n      if (inSqueezeList && dims[i] !== 1) {\n        throw new Error('squeeze an axis of size different than 1');\n      }\n\n      if ((axes.length === 0 && dims[i] > 1) || (axes.length > 0 && !inSqueezeList)) {\n        outputDims.push(dims[i]);\n      }\n    }\n\n    return outputDims;\n  }\n\n  /**\n   * Determines the shape of output tensor y = unsqueeze(x, axes)\n   * @param dims - shape of input tensor\n   * @param axes - unsqueeze axes\n   */\n  static unsqueezeShape(dims: readonly number[], axes: readonly number[]): readonly number[] {\n    const outputDims = new Array<number>(dims.length + axes.length);\n\n    // initialize the array elements to 0\n    outputDims.fill(0);\n\n    // set all axes indices to 1 in outputDims and check for duplicates\n    for (let i = 0; i < axes.length; i++) {\n      const axis = ShapeUtil.normalizeAxis(axes[i], outputDims.length);\n      if (axis >= outputDims.length) {\n        throw new Error(\"'axes' has an out of range axis\");\n      }\n      if (outputDims[axis] !== 0) {\n        throw new Error(\"'axes' has a duplicate axis\");\n      }\n\n      outputDims[axis] = 1;\n    }\n\n    // fill in the zero entries of outputDims with the input tensor's shape\n    let inputDimsIterator = 0;\n    for (let i = 0; i < outputDims.length; i++) {\n      if (outputDims[i] === 0) {\n        outputDims[i] = dims[inputDimsIterator++];\n      }\n    }\n\n    // sanity check assertion. 'inputDimsIterator'\n    // should be equal to the length of 'dims'\n    if (inputDimsIterator !== dims.length) {\n      throw new Error('the unsqueezed dimension could not be established');\n    }\n\n    return outputDims;\n  }\n}\n\n// bunch of helper methods that do a variety of math operations\nexport class MathUtil {\n  // y = (x*x) + y\n  static sqr(\n    target: number[] | Tensor.NumberType,\n    source: number[] | Tensor.NumberType,\n    targetIndex: number,\n    sourceIndex: number,\n    blockSize: number,\n  ) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] += Math.pow(source[sourceIndex + offset], 2);\n    }\n  }\n\n  // y = ax + y\n  static axpy(\n    target: number[] | Tensor.NumberType,\n    source: number[] | Tensor.NumberType,\n    targetIndex: number,\n    sourceIndex: number,\n    blockSize: number,\n    alpha: number,\n  ) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] += alpha * source[sourceIndex + offset];\n    }\n  }\n\n  // y = pow(x, b)\n  static powx(\n    target: number[] | Tensor.NumberType,\n    source: number[] | Tensor.NumberType,\n    targetIndex: number,\n    sourceIndex: number,\n    blockSize: number,\n    b: number,\n  ) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] = Math.pow(source[sourceIndex + offset], b);\n    }\n  }\n\n  // y = x * y\n  static mul(\n    target: number[] | Tensor.NumberType,\n    source: number[] | Tensor.NumberType,\n    targetIndex: number,\n    sourceIndex: number,\n    blockSize: number,\n  ) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] = source[sourceIndex + offset] * target[targetIndex + offset];\n    }\n  }\n}\n\nexport class SplitUtil {\n  /**\n   * Calculates new Shapes from existing one and the splits given along the axis provides\n   * @param dims Shape of the Tensor to be splitted into two or more Shapes\n   * @param axis The dimension along which the Tensor will be split\n   * @param splits Offsets for the start of each split\n   */\n  static splitShape(\n    dims: readonly number[],\n    axis: number,\n    split: number[],\n    numOutputs?: number,\n  ): [number[][], number[]] {\n    if (split.length === 0) {\n      if (!numOutputs) {\n        throw new Error(\"need to know number of outputs when the 'split' attribute is not specified\");\n      }\n      SplitUtil.determineSplit(dims[axis], numOutputs, split);\n    }\n\n    const shapes: number[][] = [];\n    const offsets = [0];\n    for (let i = 0; i < split.length; ++i) {\n      if (i !== 0) {\n        offsets.push(offsets[i - 1] + split[i - 1]);\n      }\n      const shape = dims.slice();\n      shape[axis] = split[i];\n      shapes.push(shape);\n    }\n    return [shapes, offsets];\n  }\n\n  static determineSplit(numElementsAlongAxis: number, numOutputs: number, split: number[]) {\n    // If 'split' is not specified by the user, we need to partition the number of elements equally among the outputs\n    if (numElementsAlongAxis % numOutputs !== 0) {\n      throw new Error('cannot split tensor to equal sized parts');\n    }\n    for (let i = 0; i < numOutputs; ++i) {\n      split.push(numElementsAlongAxis / numOutputs);\n    }\n  }\n}\n\nexport class ReduceUtil {\n  /**\n   * Perform reduce operations on the specific operator\n   * @param a Input tensor data\n   * @param axes The dimensions along which the Tensor will be reduced\n   * @param keepdims If set to true, the axes which are reduced are left in the\n   *    result as dimensions with size one.\n   * @param op1 The operation to be performed on each element in the tensor\n   * @param op2 The operation to be performed between elements in the tensor\n   */\n  static calcReduce(\n    a: Tensor,\n    axes: number[],\n    keepdims: boolean,\n    op1: (b: number) => number,\n    op2: (a: number, b: number) => number,\n  ): Tensor {\n    const dims = a.dims.slice(0);\n    // if axes is not set, perform reduce on all axes\n    if (axes.length === 0) {\n      dims.forEach((_d, ind) => axes.push(ind));\n    }\n    // get a temporary broadcastable output shape\n    const outputDims = ReduceUtil.calcReduceShape(dims, axes, true);\n\n    // loop through the output and calculate result one by one\n    const size = ShapeUtil.size(outputDims);\n    const y = new Tensor(outputDims, a.type);\n    const strides = ShapeUtil.computeStrides(outputDims);\n    const inputStrides = ShapeUtil.computeStrides(dims);\n    const indicesY = new Array(dims.length);\n    for (let i = 0; i < size; i++) {\n      const indices = ShapeUtil.offsetToIndices(i, strides);\n      // map index\n      BroadcastUtil.fillIndex(indices, dims, indicesY);\n      y.set(\n        indices,\n        ReduceUtil.calcReduceByAxis(\n          a.numberData,\n          axes,\n          dims,\n          0,\n          ShapeUtil.indicesToOffset(indicesY, inputStrides),\n          op1,\n          op2,\n        ),\n      );\n    }\n\n    if (keepdims) {\n      return y;\n    } else {\n      // keepdims == 0, calculate the expected shape\n      return new Tensor(\n        ReduceUtil.calcReduceShape(dims, axes, keepdims),\n        y.type,\n        undefined,\n        undefined,\n        y.data,\n        y.dataId,\n      );\n    }\n  }\n\n  /**\n   * Perform reduce operations on the specific operator on specific axes\n   * @param a Input tensor data\n   * @param axes The dimensions along which the Tensor will be reduced\n   * @param dims The input dimension.\n   * @param curAxisInd Index in axes specifying the current dimension along\n   *      which the tensor will be reduced\n   * @param pos The current index of element to perform operation\n   * @param op1 The operation to be performed on each element in the tensor\n   * @param op2 The operation to be performed between elements in the tensor\n   */\n  static calcReduceByAxis(\n    input: Tensor.NumberType,\n    axes: number[],\n    dims: number[],\n    curAxisInd: number,\n    pos: number,\n    op1: (b: number) => number,\n    op2: (a: number, b: number) => number,\n  ): number {\n    let res = 0;\n    if (curAxisInd >= axes.length) {\n      return op1(input[pos]);\n    }\n    const axis = axes[curAxisInd];\n    const step = axis >= dims.length ? 1 : ShapeUtil.size(dims.slice(axis + 1));\n    for (let i = 0; i < dims[axis]; i++) {\n      res =\n        i === 0\n          ? ReduceUtil.calcReduceByAxis(input, axes, dims, curAxisInd + 1, pos, op1, op2)\n          : op2(res, ReduceUtil.calcReduceByAxis(input, axes, dims, curAxisInd + 1, pos, op1, op2));\n      pos += step;\n    }\n    return res;\n  }\n\n  /**\n   * Calculate the expected shape of a reduce operation\n   * @param dims The input tensor dimension\n   * @param axes The dimensions along which the Tensor will be reduced\n   * @param keepdims If set to true, the axes which are reduced are left in the\n   *    result as dimensions with size one.\n   */\n  static calcReduceShape(dims: readonly number[], axes: readonly number[], keepDims: boolean): number[] {\n    const outputDims = dims.slice();\n    for (let i = 0; i < axes.length; i++) {\n      if (keepDims) {\n        outputDims[axes[i]] = 1;\n      } else {\n        outputDims[axes[i]] = 0;\n      }\n    }\n    return outputDims.filter((dim) => dim !== 0);\n  }\n}\n\nexport class PoolConvUtil {\n  /**\n   * Adjust the kernel, strides, pads to correct rank. Set to default value if not present\n   * @param isGlobalOperator If true, perform global pooling.\n   * @param inputDims The input tensor dimension.\n   * @param kernelShape The size of the kernel along each axis.\n   * @param strides Stride along each axis.\n   * @param dilations Dilation along each axis.\n   * @param pads Padding for the beginning and ending along each axis.\n   */\n  static adjustPoolAttributes(\n    isGlobalOperator: boolean,\n    inputDims: readonly number[],\n    kernelShape: number[],\n    strides: number[],\n    dilations: number[],\n    pads: number[],\n  ) {\n    if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {\n      throw new Error('length of specified kernel shapes should be 2 less than length of input dimensions');\n    }\n\n    if (isGlobalOperator) {\n      // adjust kernel shape to cover the input dims\n      for (let dim = 0; dim < inputDims.length - 2; dim++) {\n        if (dim >= kernelShape.length) {\n          kernelShape.push(inputDims[dim + 2]);\n        } else {\n          kernelShape[dim] = inputDims[dim + 2];\n        }\n      }\n    }\n\n    // adjust strides length to match kernel shape length\n    for (let dim = 0; dim < kernelShape.length; dim++) {\n      if (dim < strides.length) {\n        if (strides[dim] < 0) {\n          throw new Error('strides should be greater than or equal to 1');\n        }\n      } else {\n        strides.push(1);\n      }\n    }\n\n    // adjust dilation value\n    for (let dim = 0; dim < kernelShape.length; dim++) {\n      if (dim < dilations.length) {\n        if (dilations[dim] < 0) {\n          throw new Error('dilations should be greater than or equal to 1');\n        }\n      } else {\n        dilations.push(1);\n      }\n    }\n\n    // adjust pads length to match 2 * kernel shape length\n    for (let dim = 0; dim < kernelShape.length * 2; dim++) {\n      if (dim < pads.length) {\n        if (pads[dim] < 0) {\n          throw new Error('pad should be greater than or equal to 1');\n        }\n      } else {\n        pads.push(0);\n      }\n    }\n\n    // sanity checks for values in kernel shapes and pads\n    for (let dim = 0; dim < kernelShape.length; dim++) {\n      if (kernelShape[dim] <= 0) {\n        throw new Error('kernel shapes need to be greater than 0');\n      }\n\n      if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {\n        throw new Error('pads should be smaller than kernel');\n      }\n    }\n  }\n\n  // adjust pad values based on 'autoPad' attribute\n  static adjustPadsBasedOnAutoPad(\n    inputDims: readonly number[],\n    strides: readonly number[],\n    dilations: readonly number[],\n    kernelShape: readonly number[],\n    pads: number[],\n    autoPad?: string,\n  ) {\n    if (!autoPad) {\n      return;\n    }\n\n    if (pads.length !== 2 * (inputDims.length - 2)) {\n      throw new Error('length of pads should be twice the length of data dimensions');\n    }\n\n    if (strides.length !== inputDims.length - 2) {\n      throw new Error('length of strides should be the length of data dimensions');\n    }\n\n    if (kernelShape.length !== inputDims.length - 2) {\n      throw new Error('length of kernel shapes should be the length of data dimensions');\n    }\n\n    for (let dim = 0; dim < inputDims.length - 2; dim++) {\n      PoolConvUtil.adjustPadAndReturnShape(\n        inputDims[dim + 2],\n        strides[dim],\n        dilations[dim],\n        kernelShape[dim],\n        pads,\n        dim,\n        dim + inputDims.length - 2,\n        autoPad,\n      );\n    }\n  }\n\n  /**\n   * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)\n   * @param isGlobalOperator If true, perform global pooling.\n   * @param inputDims The input tensor dimension. (inputs[0].dims)\n   * @param strides Stride along each axis.\n   * @param dilations Dilation along each axis.\n   * @param kernelShape The size of the kernel along each axis.\n   * @param pads Padding for the beginning and ending along each axis.\n   * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each\n   *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.\n   */\n  static computePoolOutputShape(\n    isGlobalOperator: boolean,\n    inputDims: readonly number[],\n    strides: number[],\n    dilations: number[],\n    kernelShape: number[],\n    pads: number[],\n    autoPad?: string,\n  ): number[] {\n    if (inputDims.length <= 0) {\n      throw new Error('input shape must be of size greater than 0');\n    }\n\n    // Add batch size and number of channels of output\n    const outputDims = [inputDims[0], inputDims[1]];\n\n    PoolConvUtil.computeShapeHelper(\n      isGlobalOperator,\n      inputDims,\n      outputDims,\n      strides,\n      dilations,\n      kernelShape,\n      pads,\n      autoPad,\n    );\n    return outputDims;\n  }\n\n  /**\n   * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)\n   * @param inputDims The input tensor dimension. (inputs[0].dims)\n   * @param filterDims The filter tensor dimension. (inputs[1].dims)\n   * @param strides Stride along each axis.\n   * @param kernelShape The size of the kernel along each axis.\n   * @param pads Padding for the beginning and ending along each axis.\n   * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each\n   *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.\n   */\n  static computeConvOutputShape(\n    inputDims: readonly number[],\n    filterDims: readonly number[],\n    strides: number[],\n    dilations: number[],\n    kernelShape: number[],\n    pads: number[],\n    autoPad?: string,\n  ): number[] {\n    if (inputDims.length <= 0 || filterDims.length <= 0) {\n      throw new Error('invalid input tensor dims or invalid filter tensor dims');\n    }\n\n    // Add batch size and number of channels of output\n    const outputDims = [inputDims[0], filterDims[0]];\n\n    PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);\n    return outputDims;\n  }\n\n  // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels\n  // called by computePoolOutputShape() and computeConvOutputShape()\n  // adjust pads based on 'autoPad' attribute prior to shape computation\n  private static computeShapeHelper(\n    isGlobalOperator: boolean,\n    inputDims: readonly number[],\n    outputDims: number[],\n    strides: readonly number[],\n    dilations: readonly number[],\n    kernelShape: readonly number[],\n    pads: number[],\n    autoPad?: string,\n  ) {\n    if (isGlobalOperator) {\n      for (let dim = 0; dim < inputDims.length - 2; dim++) {\n        outputDims.push(1);\n      }\n    } else {\n      for (let dim = 0; dim < inputDims.length - 2; dim++) {\n        outputDims.push(\n          PoolConvUtil.adjustPadAndReturnShape(\n            inputDims[dim + 2],\n            strides[dim],\n            dilations[dim],\n            kernelShape[dim],\n            pads,\n            dim,\n            dim + inputDims.length - 2,\n            autoPad,\n          ),\n        );\n      }\n    }\n  }\n\n  // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()\n  // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension\n  private static adjustPadAndReturnShape(\n    inSize: number,\n    stride: number,\n    dilation: number,\n    kernel: number,\n    pads: number[],\n    padHeadIndex: number,\n    padTailIndex: number,\n    autoPad?: string,\n  ): number {\n    const dkernel = dilation * (kernel - 1) + 1;\n    if (autoPad && autoPad !== 'NOTSET') {\n      switch (autoPad) {\n        case 'VALID':\n          pads[padHeadIndex] = 0;\n          pads[padTailIndex] = 0;\n          return Math.floor((inSize - dkernel) / stride + 1);\n        case 'SAME_LOWER':\n        case 'SAME_UPPER':\n          if (dilation !== 1) {\n            throw new Error('Dilation not supported for SAME_UPPER or SAME_LOWER');\n          } else {\n            const legacyTargetSize = (inSize + stride - 1) / stride;\n            const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;\n            pads[padHeadIndex] = autoPad === 'SAME_LOWER' ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);\n            pads[padTailIndex] = padNeeded - pads[padHeadIndex];\n            return Math.floor((inSize + padNeeded - kernel) / stride + 1);\n          }\n        default:\n          throw new Error('Unsupported AutoPad type');\n      }\n    } else {\n      return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);\n    }\n  }\n}\n\nexport const MIN_CLIP = -3.4028234663852886e38;\nexport const MAX_CLIP = 3.4028234663852886e38;\n\nexport function decodeUtf8String(buffer: Uint8Array): string {\n  return new TextDecoder().decode(buffer);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Guid } from 'guid-typescript';\nimport Long from 'long';\n\nimport { onnxruntime } from './ort-schema/flatbuffers/ort-generated';\nimport { onnx } from './ort-schema/protobuf/onnx';\nimport { decodeUtf8String, ProtoUtil, ShapeUtil } from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport declare namespace Tensor {\n  export interface DataTypeMap {\n    bool: Uint8Array;\n    float32: Float32Array;\n    float64: Float64Array;\n    string: string[];\n    int8: Int8Array;\n    uint8: Uint8Array;\n    int16: Int16Array;\n    uint16: Uint16Array;\n    int32: Int32Array;\n    uint32: Uint32Array;\n    int64: BigInt64Array;\n  }\n\n  export type DataType = keyof DataTypeMap;\n\n  export type StringType = Tensor.DataTypeMap['string'];\n  export type BooleanType = Tensor.DataTypeMap['bool'];\n  export type IntegerType =\n    | Tensor.DataTypeMap['int8']\n    | Tensor.DataTypeMap['uint8']\n    | Tensor.DataTypeMap['int16']\n    | Tensor.DataTypeMap['uint16']\n    | Tensor.DataTypeMap['int32']\n    | Tensor.DataTypeMap['uint32'];\n  export type FloatType = Tensor.DataTypeMap['float32'] | Tensor.DataTypeMap['float64'];\n  export type NumberType = BooleanType | IntegerType | FloatType;\n\n  export type Id = Guid;\n}\n\ntype TensorData = Tensor.DataTypeMap[Tensor.DataType];\n\ntype DataProvider = (id: Tensor.Id) => TensorData;\ntype AsyncDataProvider = (id: Tensor.Id) => Promise<TensorData>;\n\nexport class Tensor {\n  /**\n   * get the underlying tensor data\n   */\n  get data(): TensorData {\n    if (this.cache === undefined) {\n      const data = this.dataProvider!(this.dataId);\n      if (data.length !== this.size) {\n        throw new Error('Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.');\n      }\n      this.cache = data;\n    }\n    return this.cache;\n  }\n\n  /**\n   * get the underlying string tensor data. Should only use when type is STRING\n   */\n  get stringData() {\n    if (this.type !== 'string') {\n      throw new TypeError('data type is not string');\n    }\n\n    return this.data as Tensor.StringType;\n  }\n\n  /**\n   * get the underlying integer tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,\n   * INT16, INT32, UINT32, BOOL)\n   */\n  get integerData() {\n    switch (this.type) {\n      case 'uint8':\n      case 'int8':\n      case 'uint16':\n      case 'int16':\n      case 'int32':\n      case 'uint32':\n      case 'bool':\n        return this.data as Tensor.IntegerType;\n\n      default:\n        throw new TypeError('data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)');\n    }\n  }\n\n  /**\n   * get the underlying float tensor data. Should only use when type is one of the following: (FLOAT, DOUBLE)\n   */\n  get floatData() {\n    switch (this.type) {\n      case 'float32':\n      case 'float64':\n        return this.data as Tensor.FloatType;\n\n      default:\n        throw new TypeError('data type is not float (float32, float64)');\n    }\n  }\n\n  /**\n   * get the underlying number tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,\n   * INT16, INT32, UINT32, BOOL, FLOAT, DOUBLE)\n   */\n  get numberData() {\n    if (this.type !== 'string') {\n      return this.data as Tensor.NumberType;\n    }\n    throw new TypeError('type cannot be non-number (string)');\n  }\n\n  /**\n   * get value of an element at the given indices\n   */\n  get(indices: readonly number[]): Tensor.DataTypeMap[Tensor.DataType][number] {\n    return this.data[ShapeUtil.indicesToOffset(indices, this.strides)];\n  }\n\n  /**\n   * set value of an element at the given indices\n   */\n  set(indices: readonly number[], value: Tensor.DataTypeMap[Tensor.DataType][number]) {\n    this.data[ShapeUtil.indicesToOffset(indices, this.strides)] = value;\n  }\n\n  /**\n   * get the underlying tensor data asynchronously\n   */\n  async getData(): Promise<TensorData> {\n    if (this.cache === undefined) {\n      this.cache = await this.asyncDataProvider!(this.dataId);\n    }\n    return this.cache;\n  }\n\n  /**\n   * get the number of elements in the tensor\n   */\n  public readonly size: number;\n\n  private _strides: readonly number[];\n  /**\n   * get the strides for each dimension\n   */\n  get strides(): readonly number[] {\n    if (!this._strides) {\n      this._strides = ShapeUtil.computeStrides(this.dims);\n    }\n    return this._strides;\n  }\n\n  constructor(\n    /**\n     * get the dimensions of the tensor\n     */\n    public readonly dims: readonly number[],\n    /**\n     * get the type of the tensor\n     */\n    public readonly type: Tensor.DataType,\n    private dataProvider?: DataProvider,\n    private asyncDataProvider?: AsyncDataProvider,\n    private cache?: TensorData,\n    /**\n     * get the data ID that used to map to a tensor data\n     */\n    public readonly dataId: Guid = Guid.create(),\n  ) {\n    this.size = ShapeUtil.validateDimsAndCalcSize(dims);\n    const size = this.size;\n    const empty = dataProvider === undefined && asyncDataProvider === undefined && cache === undefined;\n\n    if (cache !== undefined) {\n      if (cache.length !== size) {\n        throw new RangeError(\"Input dims doesn't match data length.\");\n      }\n    }\n\n    if (type === 'string') {\n      if (cache !== undefined && (!Array.isArray(cache) || !cache.every((i) => typeof i === 'string'))) {\n        throw new TypeError('cache should be a string array');\n      }\n\n      if (empty) {\n        this.cache = new Array<string>(size);\n      }\n    } else {\n      if (cache !== undefined) {\n        const constructor = dataviewConstructor(type);\n        if (!(cache instanceof constructor)) {\n          throw new TypeError(`cache should be type ${constructor.name}`);\n        }\n      }\n\n      if (empty) {\n        const buf = new ArrayBuffer(size * sizeof(type));\n        this.cache = createView(buf, type);\n      }\n    }\n  }\n\n  /**\n   * Construct new Tensor from a ONNX Tensor object\n   * @param tensorProto the ONNX Tensor\n   */\n  static fromProto(tensorProto: onnx.ITensorProto): Tensor {\n    if (!tensorProto) {\n      throw new Error('cannot construct Value from an empty tensor');\n    }\n    const type = ProtoUtil.tensorDataTypeFromProto(tensorProto.dataType!);\n    const dims = ProtoUtil.tensorDimsFromProto(tensorProto.dims!);\n\n    const value = new Tensor(dims, type);\n\n    if (type === 'string') {\n      // When it's STRING type, the value should always be stored in field\n      // 'stringData'\n      tensorProto.stringData!.forEach((str, i) => {\n        value.data[i] = decodeUtf8String(str);\n      });\n    } else if (\n      tensorProto.rawData &&\n      typeof tensorProto.rawData.byteLength === 'number' &&\n      tensorProto.rawData.byteLength > 0\n    ) {\n      // NOT considering segment for now (IMPORTANT)\n\n      // populate value from rawData\n      const dataDest = value.data;\n      const dataSource = new DataView(\n        tensorProto.rawData.buffer,\n        tensorProto.rawData.byteOffset,\n        tensorProto.rawData.byteLength,\n      );\n      const elementSize = sizeofProto(tensorProto.dataType!);\n      const length = tensorProto.rawData.byteLength / elementSize;\n\n      if (tensorProto.rawData.byteLength % elementSize !== 0) {\n        throw new Error('invalid buffer length');\n      }\n      if (dataDest.length !== length) {\n        throw new Error('buffer length mismatch');\n      }\n\n      for (let i = 0; i < length; i++) {\n        const n = readProto(dataSource, tensorProto.dataType!, i * elementSize);\n        dataDest[i] = n;\n      }\n    } else {\n      // populate value from array\n      let array: Array<number | Long>;\n      switch (tensorProto.dataType) {\n        case onnx.TensorProto.DataType.FLOAT:\n          array = tensorProto.floatData!;\n          break;\n        case onnx.TensorProto.DataType.INT32:\n        case onnx.TensorProto.DataType.INT16:\n        case onnx.TensorProto.DataType.UINT16:\n        case onnx.TensorProto.DataType.INT8:\n        case onnx.TensorProto.DataType.UINT8:\n        case onnx.TensorProto.DataType.BOOL:\n          array = tensorProto.int32Data!;\n          break;\n        case onnx.TensorProto.DataType.INT64:\n          array = tensorProto.int64Data!;\n          break;\n        case onnx.TensorProto.DataType.DOUBLE:\n          array = tensorProto.doubleData!;\n          break;\n        case onnx.TensorProto.DataType.UINT32:\n        case onnx.TensorProto.DataType.UINT64:\n          array = tensorProto.uint64Data!;\n          break;\n        default:\n          // should never run here\n          throw new Error('unspecific error');\n      }\n\n      if (array === null || array === undefined) {\n        throw new Error('failed to populate data from a tensorproto value');\n      }\n\n      const data = value.data;\n      if (data.length !== array.length) {\n        throw new Error('array length mismatch');\n      }\n\n      for (let i = 0; i < array.length; i++) {\n        const element = array[i];\n        if (Long.isLong(element)) {\n          data[i] = longToNumber(element, tensorProto.dataType);\n        } else {\n          data[i] = element;\n        }\n      }\n    }\n\n    return value;\n  }\n\n  /**\n   * Construct new Tensor from raw data\n   * @param data the raw data object. Should be a string array for 'string' tensor, and the corresponding typed array\n   * for other types of tensor.\n   * @param dims the dimensions of the tensor\n   * @param type the type of the tensor\n   */\n  static fromData(data: Tensor.DataTypeMap[Tensor.DataType], dims: readonly number[], type: Tensor.DataType) {\n    return new Tensor(dims, type, undefined, undefined, data);\n  }\n\n  static fromOrtTensor(ortTensor: ortFbs.Tensor) {\n    if (!ortTensor) {\n      throw new Error('cannot construct Value from an empty tensor');\n    }\n    const dims = ProtoUtil.tensorDimsFromORTFormat(ortTensor);\n    const type = ProtoUtil.tensorDataTypeFromProto(ortTensor.dataType());\n\n    const value = new Tensor(dims, type);\n\n    if (type === 'string') {\n      // When it's STRING type, the value should always be stored in field\n      // 'stringData'\n      for (let i = 0; i < ortTensor.stringDataLength(); i++) {\n        value.data[i] = ortTensor.stringData(i);\n      }\n    } else if (\n      ortTensor.rawDataArray() &&\n      typeof ortTensor.rawDataLength() === 'number' &&\n      ortTensor.rawDataLength() > 0\n    ) {\n      // NOT considering segment for now (IMPORTANT)\n\n      // populate value from rawData\n      const dataDest = value.data;\n      const dataSource = new DataView(\n        ortTensor.rawDataArray()!.buffer,\n        ortTensor.rawDataArray()!.byteOffset,\n        ortTensor.rawDataLength(),\n      );\n      const elementSize = sizeofProto(ortTensor.dataType());\n      const length = ortTensor.rawDataLength() / elementSize;\n\n      if (ortTensor.rawDataLength() % elementSize !== 0) {\n        throw new Error('invalid buffer length');\n      }\n      if (dataDest.length !== length) {\n        throw new Error('buffer length mismatch');\n      }\n\n      for (let i = 0; i < length; i++) {\n        const n = readProto(dataSource, ortTensor.dataType(), i * elementSize);\n        dataDest[i] = n;\n      }\n    }\n    return value;\n  }\n}\n\nfunction sizeof(type: Tensor.DataType): number {\n  switch (type) {\n    case 'bool':\n    case 'int8':\n    case 'uint8':\n      return 1;\n    case 'int16':\n    case 'uint16':\n      return 2;\n    case 'int32':\n    case 'uint32':\n    case 'float32':\n      return 4;\n    case 'float64':\n      return 8;\n    default:\n      throw new Error(`cannot calculate sizeof() on type ${type}`);\n  }\n}\n\nfunction sizeofProto(type: onnx.TensorProto.DataType | ortFbs.TensorDataType): number {\n  switch (type) {\n    case onnx.TensorProto.DataType.UINT8:\n    case onnx.TensorProto.DataType.INT8:\n    case onnx.TensorProto.DataType.BOOL:\n      return 1;\n    case onnx.TensorProto.DataType.UINT16:\n    case onnx.TensorProto.DataType.INT16:\n      return 2;\n    case onnx.TensorProto.DataType.FLOAT:\n    case onnx.TensorProto.DataType.INT32:\n    case onnx.TensorProto.DataType.UINT32:\n      return 4;\n    case onnx.TensorProto.DataType.INT64:\n    case onnx.TensorProto.DataType.DOUBLE:\n    case onnx.TensorProto.DataType.UINT64:\n      return 8;\n    default:\n      throw new Error(`cannot calculate sizeof() on type ${onnx.TensorProto.DataType[type]}`);\n  }\n}\n\nfunction createView(dataBuffer: ArrayBuffer, type: Tensor.DataType) {\n  return new (dataviewConstructor(type))(dataBuffer);\n}\n\nfunction dataviewConstructor(type: Tensor.DataType) {\n  switch (type) {\n    case 'bool':\n    case 'uint8':\n      return Uint8Array;\n    case 'int8':\n      return Int8Array;\n    case 'int16':\n      return Int16Array;\n    case 'uint16':\n      return Uint16Array;\n    case 'int32':\n      return Int32Array;\n    case 'uint32':\n      return Uint32Array;\n    case 'int64':\n      return BigInt64Array;\n    case 'float32':\n      return Float32Array;\n    case 'float64':\n      return Float64Array;\n    default:\n      // should never run to here\n      throw new Error('unspecified error');\n  }\n}\n\n// convert a long number to a 32-bit integer (cast-down)\nfunction longToNumber(i: Long, type: onnx.TensorProto.DataType | ortFbs.TensorDataType): number {\n  // INT64, UINT32, UINT64\n  if (type === onnx.TensorProto.DataType.INT64 || type === ortFbs.TensorDataType.INT64) {\n    if (i.greaterThanOrEqual(2147483648) || i.lessThan(-2147483648)) {\n      throw new TypeError('int64 is not supported');\n    }\n  } else if (\n    type === onnx.TensorProto.DataType.UINT32 ||\n    type === ortFbs.TensorDataType.UINT32 ||\n    type === onnx.TensorProto.DataType.UINT64 ||\n    type === ortFbs.TensorDataType.UINT64\n  ) {\n    if (i.greaterThanOrEqual(4294967296) || i.lessThan(0)) {\n      throw new TypeError('uint64 is not supported');\n    }\n  } else {\n    throw new TypeError(`not a LONG type: ${onnx.TensorProto.DataType[type]}`);\n  }\n\n  return i.toNumber();\n}\n\n// read one value from TensorProto\nfunction readProto(\n  view: DataView,\n  type: onnx.TensorProto.DataType | ortFbs.TensorDataType,\n  byteOffset: number,\n): number {\n  switch (type) {\n    case onnx.TensorProto.DataType.BOOL:\n    case onnx.TensorProto.DataType.UINT8:\n      return view.getUint8(byteOffset);\n    case onnx.TensorProto.DataType.INT8:\n      return view.getInt8(byteOffset);\n    case onnx.TensorProto.DataType.UINT16:\n      return view.getUint16(byteOffset, true);\n    case onnx.TensorProto.DataType.INT16:\n      return view.getInt16(byteOffset, true);\n    case onnx.TensorProto.DataType.FLOAT:\n      return view.getFloat32(byteOffset, true);\n    case onnx.TensorProto.DataType.INT32:\n      return view.getInt32(byteOffset, true);\n    case onnx.TensorProto.DataType.UINT32:\n      return view.getUint32(byteOffset, true);\n    case onnx.TensorProto.DataType.INT64:\n      return longToNumber(\n        Long.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), false),\n        type,\n      );\n    case onnx.TensorProto.DataType.DOUBLE:\n      return view.getFloat64(byteOffset, true);\n    case onnx.TensorProto.DataType.UINT64:\n      return longToNumber(\n        Long.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), true),\n        type,\n      );\n    default:\n      throw new Error(`cannot read from DataView for type ${onnx.TensorProto.DataType[type]}`);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * represent a version irrelevant abstraction of for GLSL source code\n */\nexport interface Glsl {\n  readonly version: string;\n  readonly attribute: string;\n  readonly varyingVertex: string;\n  readonly varyingFrag: string;\n  readonly texture2D: string;\n  readonly output: string;\n  readonly outputDeclaration: string;\n}\n\nconst GLSL_ES_2_0: Glsl = {\n  version: '',\n  attribute: 'attribute',\n  varyingVertex: 'varying',\n  varyingFrag: 'varying',\n  texture2D: 'texture2D',\n  output: 'gl_FragColor',\n  outputDeclaration: '',\n};\nconst GLSL_ES_3_0: Glsl = {\n  version: '#version 300 es',\n  attribute: 'in',\n  varyingVertex: 'out',\n  varyingFrag: 'in',\n  texture2D: 'texture',\n  output: 'outputColor',\n  outputDeclaration: 'out vec4 outputColor;',\n};\n\nexport function getGlsl(version: 1 | 2) {\n  return version === 1 ? GLSL_ES_2_0 : GLSL_ES_3_0;\n}\n\nexport function getVertexShaderSource(version: 1 | 2): string {\n  const glsl = getGlsl(version);\n  return `${glsl.version}\n      precision highp float;\n      ${glsl.attribute} vec3 position;\n      ${glsl.attribute} vec2 textureCoord;\n\n      ${glsl.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`;\n}\n\nexport function getFragShaderPreamble(version: 1 | 2): string {\n  const glsl = getGlsl(version);\n  return `${glsl.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${glsl.varyingFrag} vec2 TexCoords;\n    ${glsl.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `;\n}\n\nexport function getDefaultFragShaderMain(version: 1 | 2, outputShapeLength: number): string {\n  const glsl = getGlsl(version);\n  return `\n  void main() {\n    int indices[${outputShapeLength}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${glsl.output} = result;\n  }\n  `;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../tensor';\n\n/**\n * Layout info is used for mapping n-dimensional array to 2D textures\n * The layout is created by the TextureLayoutStrategy based on\n * the Tensor's dimensions and strides\n */\nexport interface TextureLayout {\n  width: number;\n  height: number;\n  /**\n   * specify the number of value that encoded in a single pixel\n   */\n  channels: 1 | 2 | 3 | 4;\n  /**\n   * whether in packed mode or not\n   */\n  isPacked?: boolean;\n  /**\n   * the normalized shape\n   */\n  shape: readonly number[];\n  /**\n   * the stride of each dimensions, calculated according to shape\n   */\n  strides: readonly number[];\n  /**\n   * the original shape(dims) of the corresponding tensor\n   */\n  unpackedShape: readonly number[];\n\n  reversedWH?: boolean;\n}\nexport interface TextureData extends TextureLayout {\n  tensor: Tensor;\n  texture: WebGLTexture;\n}\n\nexport enum TextureType {\n  unpacked, // <-- normal unpacked texture\n  unpackedReversed, // <-- unpacked texture used in old ONNX.js implementation (deprecated)\n  packed, // <-- normal packed texture\n  downloadUint8AsFloat, // <-- ONLY used in texture downloading for iOS devices\n  packedLastDimension, // <-- ONLY used in old ONNX.js Conv implementation for input W (deprecated)\n}\n\nexport interface TensorInfo {\n  id?: Tensor.Id;\n  dims: readonly number[];\n  type: Tensor.DataType;\n  textureType: TextureType;\n}\n\nexport interface ProgramVariable {\n  type: 'float' | 'int';\n  name: string;\n  arrayLength?: number;\n  data: number | number[];\n}\n\n/**\n * A set of metadata of a shader program.\n */\nexport interface ProgramMetadata {\n  /**\n   * the name of the program. used for debugging and profiling\n   */\n  name: string;\n  /**\n   * texture types for each input\n   */\n  inputTypes: TextureType[];\n  /**\n   * names of each input\n   */\n  inputNames: string[];\n  /**\n   * an optional string as a cache hint in the artifact cache\n   */\n  cacheHint?: string;\n}\n\n/**\n * A ProgramInfoLoader allows\n */\nexport interface ProgramInfoLoader extends ProgramMetadata {\n  /**\n   * a function to get the program info\n   */\n  get(): ProgramInfo;\n}\n\n/**\n * A set of data that represent a shader program\n */\nexport interface ProgramInfo extends ProgramMetadata {\n  /**\n   * information of uniform variables\n   */\n  variables?: ProgramVariable[];\n  /**\n   * tensor info for output\n   */\n  output: TensorInfo;\n  /**\n   * the shader's processing source code\n   */\n  shaderSource: string;\n  /**\n   * whether the shader source contains a customized main function implementation\n   */\n  hasMain?: boolean;\n}\n\nexport interface VariableInfo {\n  type: 'float' | 'int';\n  name: string;\n  arrayLength?: number;\n}\n\nexport interface ProgramVariable {\n  type: 'float' | 'int';\n  name: string;\n  arrayLength?: number;\n  data: number | number[];\n}\n\n/**\n * Information of uniforms that shader uses\n */\nexport interface UniformInfo {\n  type: 'sampler2D' | VariableInfo['type'];\n  name: string;\n  arrayLength?: number;\n}\n\nexport interface UniformLocation extends UniformInfo {\n  location: WebGLUniformLocation;\n}\n\n/**\n * Artifact is the result of compilation\n * It does not contain input of output data\n * However anything that could be run as a \"program\"\n */\nexport interface Artifact {\n  programInfo: ProgramInfo;\n  program: WebGLProgram;\n  uniformLocations: UniformLocation[];\n  attribLocations: { position: number; textureCoord: number };\n}\nexport declare namespace Artifact {\n  type UniformLocations = Artifact['uniformLocations'];\n  type AttribLocations = Artifact['attribLocations'];\n}\n\nexport interface UniformData {\n  [name: string]: number | number[];\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { assert } from '../../util';\n/**\n * Given a non RGBA shape calculate the R version\n * It is assumed that the dimensions are multiples of given channels\n * NOTE: it is always the last dim that gets packed.\n * @param unpackedShape original shape to create a packed version from\n */\nexport function getPackedShape(unpackedShape: readonly number[]): readonly number[] {\n  const len = unpackedShape.length;\n  return unpackedShape.slice(0, len - 1).concat(unpackedShape[len - 1] / 4);\n}\n\nexport async function repeatedTry(\n  checkFn: () => boolean,\n  delayFn = (_counter: number) => 0,\n  maxCounter?: number,\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    let tryCount = 0;\n\n    const tryFn = () => {\n      if (checkFn()) {\n        resolve();\n        return;\n      }\n\n      tryCount++;\n\n      const nextBackoff = delayFn(tryCount);\n\n      if (maxCounter != null && tryCount >= maxCounter) {\n        reject();\n        return;\n      }\n      setTimeout(tryFn, nextBackoff);\n    };\n\n    tryFn();\n  });\n}\n\n/**\n * Generates the function name from an input sampler name.\n * @param samplerName Name of the sampler.\n */\nexport function generateShaderFuncNameFromInputSamplerName(samplerName: string): string {\n  assert(typeof samplerName !== 'undefined' && samplerName.length !== 0, () => 'empty string found for sampler name');\n  return 'get' + samplerName.charAt(0).toUpperCase() + samplerName.slice(1);\n}\n\n/**\n * Generates the function name from an input sampler name at output coordinates.\n * @param samplerName Name of the sampler.\n */\nexport function generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName: string): string {\n  assert(typeof samplerName !== 'undefined' && samplerName.length !== 0, () => 'empty string found for sampler name');\n  return 'get' + samplerName.charAt(0).toUpperCase() + samplerName.slice(1) + 'AtOutCoords';\n}\n\n/** Returns a new input shape (a copy) that has a squeezed logical shape. */\nexport function squeezeInputShape(inputShape: readonly number[], squeezedShape: number[]): number[] {\n  // Deep copy.\n  let newInputShape: number[] = JSON.parse(JSON.stringify(inputShape));\n  newInputShape = squeezedShape;\n  return newInputShape;\n}\n\n/** Returns a list of squeezed parameters for shader functions */\nexport function getSqueezedParams(params: string[], keptDims: number[]): string {\n  return keptDims.map((d) => params[d]).join(', ');\n}\n\n/** Returns the data type for different ranks. */\nexport function getCoordsDataType(rank: number): string {\n  if (rank <= 1) {\n    return 'int';\n  } else if (rank === 2) {\n    return 'ivec2';\n  } else if (rank === 3) {\n    return 'ivec3';\n  } else if (rank === 4) {\n    return 'ivec4';\n  } else if (rank === 5) {\n    return 'ivec5';\n  } else if (rank === 6) {\n    return 'ivec6';\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\n\nexport function getGlChannels(rank = 6): string[] {\n  return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { getGlChannels } from '../utils';\n\nexport function getVecChannels(name: string, rank: number): string[] {\n  return getGlChannels(rank).map((d) => `${name}.${d}`);\n}\n\nexport function getChannels(name: string, rank: number): string[] {\n  if (rank === 1) {\n    return [name];\n  }\n  return getVecChannels(name, rank);\n}\n\nexport function unpackFromChannel(): string {\n  return `\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  `;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, TextureType } from '../types';\nimport { getCoordsDataType } from '../utils';\n\nimport { getChannels } from './packing-utils';\n\nconst packProgramMetadata = {\n  name: 'pack',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpackedReversed],\n};\n\nconst createPackProgramInfo = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfo => {\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n  const inputShape = input.dims;\n\n  const inputRank = inputShape.length;\n  // createTextureLayoutFromShape won't change output rank. Need to verify by running tests\n  const outputRank = input.dims.length;\n\n  const coordsDataType = getCoordsDataType(outputRank);\n  const channels = getChannels('rc', outputRank);\n  const setup = getSetup(outputRank, channels, inputShape[inputShape.length - 2], inputShape[inputShape.length - 1]);\n\n  let reversedInputWH;\n  if (inputRank === 0) {\n    reversedInputWH = [1, 1];\n  } else if (inputRank === 1) {\n    reversedInputWH = [inputShape[0], 1];\n  } else {\n    reversedInputWH = [inputShape[outputRank - 1], inputShape[outputRank - 2]];\n  }\n  const outOfBoundsCondition = getOutOfBoundsCondition(outputRank, reversedInputWH, channels);\n  const output = getOutput(inputShape, channels);\n\n  const shaderSource = `\n        void main() {\n          ${coordsDataType} rc = getOutputCoords();\n\n          if(${outOfBoundsCondition}) {\n            ${glsl.output} = vec4(0);\n          } else {\n            ${setup}\n\n            ${glsl.output} = vec4(${output});\n          }\n        }\n      `;\n  return {\n    ...packProgramMetadata,\n    hasMain: true,\n    output: { dims: input.dims, type: input.type, textureType: TextureType.packed },\n    shaderSource,\n  };\n};\n\nexport const createPackProgramInfoLoader = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfoLoader => ({\n  ...packProgramMetadata,\n  get: () => createPackProgramInfo(handler, input),\n});\n\n/**\n * check output coordinate location and return false if it is outside input's width/height boundary\n */\nfunction getOutOfBoundsCondition(rank: number, shape: readonly number[], dims: string[]): string {\n  if (rank === 0) {\n    return 'false';\n  }\n  if (rank === 1) {\n    return `rc > ${shape[0]}`;\n  }\n\n  let cond = '';\n  for (let i = rank - 2; i < rank; i++) {\n    cond += `${dims[i]} >= ${shape[i - rank + 2]}`;\n    if (i < rank - 1) {\n      cond += '||';\n    }\n  }\n\n  return cond;\n}\n\n/**\n * code snippet to sample input texture with output coordinates\n */\nfunction getOutput(shape: readonly number[], dims: string[]): string {\n  const rank = shape.length;\n\n  if (rank === 0) {\n    return 'getA(), 0, 0, 0';\n  }\n\n  if (rank === 1) {\n    return `getA(rc),\n            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),\n            0, 0`;\n  }\n\n  const coord00 = 'r, c';\n  const coord01 = 'r, cp1';\n  const coord10 = 'rp1, c';\n  const coord11 = 'rp1, cp1';\n  let D = '';\n  if (rank > 2) {\n    for (let i = 0; i < rank - 2; ++i) {\n      D = D + `${dims[i]},`;\n    }\n  }\n  return `getA(${D}${coord00}),\n          rEdge ? 0. : getA(${D}${coord10}),\n          cEdge ? 0. : getA(${D}${coord01}),\n          rEdge || cEdge ? 0. : getA(${D}${coord11})`;\n}\n\n/**\n * code snippet to setup 4 coordinates and edge conditions\n */\nfunction getSetup(rank: number, dims: string[], rows: number, cols: number): string {\n  if (rank === 0 || rank === 1) {\n    return '';\n  }\n  // rank >= 2 for width+height pack.\n  else {\n    const setup = `\n    int r = ${dims[rank - 2]};\n    int c = ${dims[rank - 1]};\n    int rp1 = ${dims[rank - 2]} + 1;\n    int cp1 = ${dims[rank - 1]} + 1;\n    bool rEdge = rp1 >= ${cols};\n    bool cEdge = cp1 >= ${rows};\n    `;\n    return setup;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { unpackFromChannel } from './packing-utils';\n\nconst createPackedReshape3DProgramMetadata = (outputShape3D: readonly number[]) => ({\n  name: 'Reshape (packed)',\n  inputTypes: [TextureType.packed],\n  inputNames: ['A'],\n  cacheHint: `${outputShape3D}`,\n});\n\nconst createPackedReshape3DProgramInfo = (\n  handler: WebGLInferenceHandler,\n  input3D: Tensor,\n  metadata: ProgramMetadata,\n  outputShape3D: readonly number[],\n): ProgramInfo => {\n  const inputShape3D = input3D.dims as [number, number, number];\n  const squeezedOutputShape = outputShape3D as [number, number, number];\n\n  let mainLoop = '';\n  for (let i = 0; i < 4; i++) {\n    let outputCoords = '';\n    switch (i) {\n      case 0:\n        outputCoords = 'outputCoords = rc;';\n        break;\n      case 1:\n        outputCoords = 'outputCoords = ivec3(rc.x, rc.y+1, rc.z);';\n        break;\n      case 2:\n        outputCoords = 'outputCoords = ivec3(rc.x, rc.y, rc.z+1);';\n        break;\n      case 3:\n        outputCoords = 'outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);';\n        break;\n      default:\n        throw new Error();\n    }\n\n    mainLoop += `\n        ${outputCoords}\n        ${i > 0 ? 'if(outputCoords.y < rows && outputCoords.z < cols){' : ''}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${i > 0 ? '}' : ''}\n      `;\n  }\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n\n  const shaderSource = `\n      ${getReshapedInputCoords(inputShape3D)}\n      ${getFlattenedIndexFrom3D(squeezedOutputShape)}\n      ${unpackFromChannel()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${squeezedOutputShape[2]};\n        int cols = ${squeezedOutputShape[1]};\n\n        ${mainLoop}\n        ${glsl.output} = result;\n      }\n    `;\n\n  return {\n    ...metadata,\n    output: { dims: squeezedOutputShape, type: input3D.type, textureType: TextureType.packed },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nexport const createPackedReshape3DProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  input3D: Tensor,\n  outputShape3D: readonly number[],\n): ProgramInfoLoader => {\n  const metadata = createPackedReshape3DProgramMetadata(outputShape3D);\n  return { ...metadata, get: () => createPackedReshape3DProgramInfo(handler, input3D, metadata, outputShape3D) };\n};\n\nexport function processDims3D(shape: ArrayLike<number>): [number, number, number] {\n  if (shape.length === 0) {\n    return [1, 1, 1];\n  }\n  // TODO: squeeze other shapes to 2D case\n  let batch = 1;\n  for (let i = 0; i < shape.length - 2; ++i) {\n    batch *= shape[i];\n  }\n  return [batch, shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\n\n// For packed reshape, we need to re-arrange texel data for output shape.\n// Our pack is designed to pack a 2x2 tile in last h and w dimension, so\n// for the reshaped new tensor, we just need to re-arrange the last h and\n// w dimension. For any shape that is not in 3D, i.e. [batch, W, H], we\n// first convert it to 3D by collapsing other dimension to batch dim, then\n// process with the last two dimensions.\n// Note: we only need the shape tensor to calculate output shape, so the\n// content in shape tensor is never uploaded to GPU. It is always kept in CPU.\n// TODO: optimize the algorithm -- in some cases, if the last two dims are\n// the same between input shape and output shape, the packed reshape can be\n// treated as no-op.\nexport function isReshapeCheap(dims: readonly number[], reshapedDims: readonly number[]) {\n  let isCheapReshape = false;\n  if (dims.length === 0 || reshapedDims.length === 0) {\n    // scalar\n    isCheapReshape = true;\n  } else if (dims.length < 2 || reshapedDims.length < 2) {\n    // 1D\n    isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1];\n  } else {\n    // 2D +\n    isCheapReshape =\n      dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1] &&\n      dims[dims.length - 2] === reshapedDims[reshapedDims.length - 2];\n  }\n\n  return isCheapReshape;\n}\n\nfunction getReshapedInputCoords(shape: [number, number, number]): string {\n  const strides = ShapeUtil.computeStrides(shape);\n  const coords = ['b', 'r', 'c'];\n  const index = 'index';\n  const coordsFromIndexSnippet = strides\n    .map((stride, i) => {\n      const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n      const line2 =\n        i === strides.length - 1\n          ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}`\n          : `index -= ${coords[i]} * ${stride}`;\n      return `${line1}; ${line2};`;\n    })\n    .join('');\n\n  return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${coordsFromIndexSnippet}\n      return ivec3(b, r, c);\n    }\n  `;\n}\n\nfunction getFlattenedIndexFrom3D(shape: [number, number, number]): string {\n  const strides = ShapeUtil.computeStrides(shape);\n\n  return `\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${strides[0]} + coords.z * ${strides[1]} + coords.y;\n  }\n`;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { TextureData, TextureType } from '../types';\n\nexport const encodeAsUint8 = (inferenceHandler: WebGLInferenceHandler, input: TextureData): TextureData => {\n  const outputShape = input.shape;\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  /**\n   * https://github.com/tensorflow/tfjs-core/blob/master/src/kernels/webgl/encode_float_gpu.ts\n   */\n  const shaderSource = `\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${glsl.texture2D}(X,TexCoords).r;\n      ${glsl.output} = encodeAsUint8(value);\n    }`;\n  const programInfo = {\n    name: 'Uint8Encode',\n    inputTypes: [TextureType.unpacked],\n    inputNames: ['X'],\n    output: { dims: outputShape, type: input.tensor.type, textureType: TextureType.downloadUint8AsFloat },\n    shaderSource,\n    hasMain: true,\n  };\n  return inferenceHandler.executeProgram(programInfo, [input.tensor]);\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, TextureType } from '../types';\nimport { getCoordsDataType } from '../utils';\n\nimport { getChannels, unpackFromChannel } from './packing-utils';\n\nconst unpackProgramMetadata = {\n  name: 'unpack',\n  inputNames: ['A'],\n  inputTypes: [TextureType.packed],\n};\n\nexport const createUnpackProgramInfo = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfo => {\n  const rank = input.dims.length;\n\n  const channels = getChannels('rc', rank);\n  const innerDims = channels.slice(-2);\n  const coordsDataType = getCoordsDataType(rank);\n  const unpackChannel = unpackFromChannel();\n  const isScalar = input.dims.length === 0;\n  const sourceCoords = isScalar ? '' : getSourceCoords(rank, channels);\n  const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n  const shaderSource = `\n    ${unpackChannel}\n    void main() {\n      ${coordsDataType} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${sourceCoords});\n\n       ${glsl.output} = vec4(getChannel(packedInput, ${coords}), 0, 0, 0);\n     }\n   `;\n\n  return {\n    ...unpackProgramMetadata,\n    hasMain: true,\n    output: { dims: input.dims, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nexport const createUnpackProgramInfoLoader = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfoLoader => ({\n  ...unpackProgramMetadata,\n  get: () => createUnpackProgramInfo(handler, input),\n});\n\nfunction getSourceCoords(rank: number, dims: string[]): string {\n  if (rank === 1) {\n    return 'rc';\n  }\n\n  let coords = '';\n  for (let i = 0; i < rank; i++) {\n    coords += dims[i];\n    if (i < rank - 1) {\n      coords += ',';\n    }\n  }\n  return coords;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Logger } from '../../instrument';\n\nexport declare namespace Encoder {\n  export interface DataTypeMap {\n    float: Float32Array;\n    byte: Uint8Array;\n    int: Uint32Array;\n  }\n  export type DataType = keyof DataTypeMap;\n  type DataArrayType = DataTypeMap[DataType];\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport const enum EncoderUsage {\n  Default = 0,\n  UploadOnly,\n  Download4BytesAsFloat32,\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n/**\n * Abstraction for mapping data types to texture texlets\n * Encoding means how a Float32 is mapped to 1 or 4 channels for each texlet\n * Decoding means how a texlet's channels are mapped to a resulting Float32\n */\nexport interface DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize: number;\n  encode(src: Encoder.DataArrayType, textureSize: number): Encoder.DataArrayType;\n  allocate(size: number): Encoder.DataArrayType;\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Encoder.DataArrayType;\n}\n/**\n * WebGL2 data encoder\n * Uses R32F as the format for texlet\n */\nexport class RedFloat32DataEncoder implements DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize: number;\n  constructor(gl: WebGL2RenderingContext, channels = 1) {\n    if (channels === 1) {\n      this.internalFormat = gl.R32F;\n      this.format = gl.RED;\n      this.textureType = gl.FLOAT;\n      this.channelSize = channels;\n    } else if (channels === 4) {\n      this.internalFormat = gl.RGBA32F;\n      this.format = gl.RGBA;\n      this.textureType = gl.FLOAT;\n      this.channelSize = channels;\n    } else {\n      throw new Error(`Invalid number of channels: ${channels}`);\n    }\n  }\n  encode(src: Encoder.DataArrayType, textureSize: number): Encoder.DataArrayType {\n    let result: Float32Array;\n    let source: Float32Array;\n    if (src.constructor !== Float32Array) {\n      Logger.warning('Encoder', 'data was not of type Float32; creating new Float32Array');\n      source = new Float32Array(src);\n    }\n    if (textureSize * this.channelSize > src.length) {\n      Logger.warning('Encoder', 'Source data too small. Allocating larger array');\n      source = src as Float32Array;\n      result = this.allocate(textureSize * this.channelSize) as Float32Array;\n      source.forEach((v, i) => (result[i] = v));\n    } else {\n      source = src as Float32Array;\n      result = source;\n    }\n    return result;\n  }\n  allocate(size: number): Encoder.DataArrayType {\n    return new Float32Array(size * 4);\n  }\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Float32Array {\n    if (this.channelSize === 1) {\n      const filteredData = (buffer as Float32Array).filter((_value, index) => index % 4 === 0).subarray(0, dataSize);\n      return filteredData;\n    }\n    return buffer.subarray(0, dataSize) as Float32Array;\n  }\n}\n/**\n * Data encoder for WebGL 1 with support for floating point texture\n */\nexport class RGBAFloatDataEncoder implements DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize: number;\n  constructor(gl: WebGLRenderingContext, channels = 1, textureType?: number) {\n    if (channels !== 1 && channels !== 4) {\n      throw new Error(`Invalid number of channels: ${channels}`);\n    }\n    this.internalFormat = gl.RGBA;\n    this.format = gl.RGBA;\n    this.channelSize = channels;\n    this.textureType = textureType || gl.FLOAT;\n  }\n  encode(src: Float32Array, textureSize: number): Encoder.DataArrayType {\n    let dest = src;\n    if (this.channelSize === 1) {\n      Logger.verbose('Encoder', 'Exploding into a larger array');\n      dest = this.allocate(textureSize) as Float32Array;\n      src.forEach((v, i) => (dest[i * 4] = v));\n    }\n    return dest;\n  }\n  allocate(size: number): Encoder.DataArrayType {\n    return new Float32Array(size * 4);\n  }\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Float32Array {\n    if (this.channelSize === 1) {\n      const filteredData = (buffer as Float32Array).filter((_value, index) => index % 4 === 0).subarray(0, dataSize);\n      return filteredData;\n    }\n    return buffer.subarray(0, dataSize) as Float32Array;\n  }\n}\n\nexport class Uint8DataEncoder implements DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize = 4;\n  constructor(gl: WebGLRenderingContext, channels = 1) {\n    if (channels === 1) {\n      this.internalFormat = gl.ALPHA;\n      this.format = gl.ALPHA; // not tested\n      this.textureType = gl.UNSIGNED_BYTE;\n      this.channelSize = channels;\n    } else if (channels === 4) {\n      this.internalFormat = gl.RGBA;\n      this.format = gl.RGBA;\n      this.textureType = gl.UNSIGNED_BYTE;\n      this.channelSize = channels;\n    } else {\n      throw new Error(`Invalid number of channels: ${channels}`);\n    }\n  }\n  encode(src: Uint8Array, _textureSize: number): Encoder.DataArrayType {\n    return new Uint8Array(src.buffer, src.byteOffset, src.byteLength);\n  }\n  allocate(size: number): Encoder.DataArrayType {\n    return new Uint8Array(size * this.channelSize);\n  }\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Uint8Array {\n    if (buffer instanceof Uint8Array) {\n      return buffer.subarray(0, dataSize);\n    }\n    throw new Error(`Invalid array type: ${buffer.constructor}`);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { ShapeUtil } from '../../util';\n\nimport { TextureLayoutStrategy, WidthHeightPrefs } from './texture-layout-strategy';\nimport { TextureLayout, TextureType } from './types';\n\nexport const createTextureLayoutFromTextureType = (\n  textureLayoutStrategy: TextureLayoutStrategy,\n  shape: readonly number[],\n  textureType: TextureType,\n): TextureLayout => {\n  const channel = textureType === TextureType.unpacked || textureType === TextureType.unpackedReversed ? 1 : 4;\n  const isPacked = textureType === TextureType.packed;\n  const reverseWH = textureType === TextureType.unpackedReversed || textureType === TextureType.packed;\n  const breakAxis = textureType === TextureType.packedLastDimension ? shape.length - 1 : undefined;\n  const unpackedShape =\n    textureType === TextureType.packedLastDimension\n      ? shape.map((d, i) => (i === shape.length - 1 ? d * 4 : d))\n      : undefined;\n  return createTextureLayoutFromShape(textureLayoutStrategy, shape, channel, unpackedShape, {\n    isPacked,\n    reverseWH,\n    breakAxis,\n  });\n};\n\nexport const calculateTextureWidthAndHeight = (\n  textureLayoutStrategy: TextureLayoutStrategy,\n  shape: readonly number[],\n  textureType: TextureType,\n): [number, number] => {\n  const layout = createTextureLayoutFromTextureType(textureLayoutStrategy, shape, textureType);\n  return [layout.width, layout.height];\n};\n\n/**\n * Create a TextureLayout object from shape.\n */\nexport const createTextureLayoutFromShape = (\n  textureLayoutStrategy: TextureLayoutStrategy,\n  shape: readonly number[],\n  channels: 1 | 4 = 1,\n  unpackedShape?: readonly number[],\n  prefs?: WidthHeightPrefs,\n): TextureLayout => {\n  const isPacked = !!(prefs && prefs.isPacked);\n  const [width, height] = textureLayoutStrategy.computeTextureWH(isPacked ? unpackedShape || shape : shape, prefs);\n  const rank = shape.length;\n  let inferredDims = shape.slice(0);\n  if (rank === 0) {\n    inferredDims = [1];\n  }\n  if (channels === 1) {\n    // unpackedShape will take `shape` and not `inferredDims` so as to create a scalar Tensor if need be\n    unpackedShape = shape;\n  } else if (isPacked) {\n    if (channels !== 4) {\n      throw new Error('a packed texture must be 4-channel');\n    }\n    unpackedShape = shape;\n    if (rank > 0) {\n      inferredDims[rank - 1] = Math.ceil(inferredDims[rank - 1] / 2);\n    }\n    if (rank > 1) {\n      inferredDims[rank - 2] = Math.ceil(inferredDims[rank - 2] / 2);\n    }\n  } else if (!unpackedShape) {\n    throw new Error('Unpacked shape is needed when using channels > 1');\n  }\n  return {\n    width,\n    height,\n    channels,\n    isPacked,\n    shape: inferredDims,\n    strides: ShapeUtil.computeStrides(inferredDims),\n    unpackedShape,\n    reversedWH: prefs && prefs.reverseWH,\n  };\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceHandler } from '../../backend';\nimport { Logger } from '../../instrument';\nimport { Tensor } from '../../tensor';\nimport { ShapeUtil } from '../../util';\n\nimport { createPackProgramInfoLoader } from './ops/pack';\nimport { createPackedReshape3DProgramInfoLoader, isReshapeCheap, processDims3D } from './ops/reshape-packed';\nimport { encodeAsUint8 } from './ops/uint8-encode';\nimport { createUnpackProgramInfoLoader } from './ops/unpack';\nimport { WebGLSessionHandler } from './session-handler';\nimport { EncoderUsage } from './texture-data-encoder';\nimport {\n  calculateTextureWidthAndHeight,\n  createTextureLayoutFromShape,\n  createTextureLayoutFromTextureType,\n} from './texture-layout';\nimport { Artifact, ProgramInfo, ProgramInfoLoader, TextureData, TextureLayout, TextureType } from './types';\n\nconst getProgramInfoUniqueKey = (\n  programInfo: ProgramInfo | ProgramInfoLoader,\n  inputTextureDatas: TextureData[],\n): string => {\n  const inputs = inputTextureDatas\n    .map((texture) => `${texture.unpackedShape.join(',')};${texture.width}x${texture.height}`)\n    .join('_');\n  let key = programInfo.name;\n  if (programInfo.cacheHint) {\n    key += '[' + programInfo.cacheHint + ']';\n  }\n  key += ':' + inputs;\n  return key;\n};\n\nexport class WebGLInferenceHandler implements InferenceHandler {\n  private packedTextureDataCache: Map<Tensor.Id, TextureData>;\n  private unpackedTextureDataCache: Map<Tensor.Id, TextureData>;\n  constructor(public session: WebGLSessionHandler) {\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache = new Map();\n  }\n\n  /**\n   * @returns [width, height]\n   */\n  calculateTextureWidthAndHeight(shape: readonly number[], textureType: TextureType): [number, number] {\n    return calculateTextureWidthAndHeight(this.session.layoutStrategy, shape, textureType);\n  }\n\n  executeProgram(program: ProgramInfo | ProgramInfoLoader, inputs: readonly Tensor[]): TextureData {\n    if (inputs.length < program.inputNames.length) {\n      throw new Error(`Input size mustn't be less than ${program.inputNames.length}.`);\n    }\n    if (program.inputNames.length !== program.inputTypes.length) {\n      throw new Error('input names size does not match input types');\n    }\n\n    // create texture info for input\n    const inputTextureDatas: TextureData[] = [];\n    for (let i = 0; i < program.inputNames.length; ++i) {\n      inputTextureDatas[i] = this.getOrCreateTextureData(inputs[i], program.inputTypes[i]);\n    }\n\n    const key = getProgramInfoUniqueKey(program, inputTextureDatas);\n    let artifact = this.session.programManager.getArtifact(key);\n    const programInfo = artifact\n      ? artifact.programInfo\n      : typeof (program as ProgramInfoLoader).get === 'function'\n        ? (program as ProgramInfoLoader).get()\n        : (program as ProgramInfo);\n\n    // create texture info for output\n    const outputTextureLayout = createTextureLayoutFromTextureType(\n      this.session.layoutStrategy,\n      programInfo.output.dims,\n      programInfo.output.textureType,\n    );\n    const outputTextureData = this.createTextureData(outputTextureLayout, programInfo.output.type);\n\n    if (!artifact) {\n      artifact = this.session.programManager.build(programInfo, inputTextureDatas, outputTextureData);\n      this.session.programManager.setArtifact(key, artifact);\n    }\n\n    this.runProgram(artifact, inputTextureDatas, outputTextureData);\n    return outputTextureData;\n  }\n\n  run(program: ProgramInfoLoader, inputs: readonly Tensor[]): Tensor {\n    const outputTextureData = this.executeProgram(program, inputs);\n    return outputTextureData.tensor;\n  }\n\n  private runProgram(artifact: Artifact, inputs: TextureData[], output: TextureData): void {\n    // input should match\n    for (let i = 0; i < inputs.length; ++i) {\n      if (!!inputs[i].isPacked !== (artifact.programInfo.inputTypes[i] === TextureType.packed)) {\n        throw new Error(`input[${i}] property packed inconsistent`);\n      }\n    }\n\n    // output should match\n    if (!!output.isPacked !== (artifact.programInfo.output.textureType === TextureType.packed)) {\n      throw new Error('output property packed inconsistent');\n    }\n\n    this.session.programManager.run(artifact, inputs, output);\n  }\n\n  /**\n   * Create a TextureData object from a tensor.\n   * Usage = EncoderUsage.UploadOnly.\n   * If a related texture data is found in cache, returns it;\n   * Otherwise:\n   *   Creates a new texture layout if not provided;\n   *   Creates WebGLTexture with the layout;\n   *   Upload tensor data to the texture;\n   *   Creates a texture data object associated with the given tensor.\n   * @param tensor the tensor with data to upload\n   */\n  private getOrCreateTextureData(tensor: Tensor, textureType: TextureType) {\n    let td = this.getTextureData(tensor.dataId, textureType === TextureType.packed);\n\n    if (!td) {\n      // check if we have texture data in different type\n      td = this.getTextureData(tensor.dataId, textureType !== TextureType.packed);\n      if (td) {\n        if (textureType === TextureType.packed) {\n          return this.pack(td);\n        } else {\n          return this.unpack(td);\n        }\n      }\n    }\n\n    if (!td) {\n      const layout = createTextureLayoutFromTextureType(this.session.layoutStrategy, tensor.dims, textureType);\n\n      if (textureType === TextureType.packedLastDimension) {\n        const group = 1;\n        const channels = 4;\n        const shape = tensor.dims;\n        if (shape.length === 4) {\n          // pre-processing for kernel data of Conv.\n          //\n          // TODO: currently this is a hacking to overwrite Conv's weight. The correct way to do this should be:\n          // 1. implement texture based const-folding\n          // 2. create a WebGL program \"preprocessConvWeight\" to do the same work as below\n          // 3. run the program before dotProduct.\n          //\n          const adjustedKernelShape = [shape[0], Math.ceil((shape[1] * shape[2] * shape[3]) / channels)];\n          const adjustedLayout = createTextureLayoutFromTextureType(\n            this.session.layoutStrategy,\n            adjustedKernelShape,\n            textureType,\n          );\n          let buffer = tensor.numberData;\n          if ((shape[1] * shape[2] * shape[3]) % channels !== 0) {\n            const numFeatureMaps = shape[0];\n            const oldRowSize = shape[1] * shape[2] * shape[3];\n            const newRowSize = Math.ceil((oldRowSize * group) / channels) * channels;\n            const newSize = numFeatureMaps * newRowSize;\n            buffer = new Float32Array(newSize);\n            for (let f = 0; f < numFeatureMaps; ++f) {\n              const oldOffset = f * oldRowSize;\n              const newOffset = f * newRowSize + (f % group) * oldRowSize;\n              buffer.set(tensor.numberData.subarray(oldOffset, oldOffset + oldRowSize), newOffset);\n            }\n          }\n          return this.createTextureData(adjustedLayout, tensor.type, buffer, tensor, EncoderUsage.UploadOnly);\n        }\n      }\n\n      if (textureType === TextureType.packed) {\n        const unpackedTextureLayout = createTextureLayoutFromShape(this.session.layoutStrategy, tensor.dims, 1, [], {\n          reverseWH: true,\n        });\n        const unpackedTextureData = this.createTextureData(\n          unpackedTextureLayout,\n          tensor.type,\n          tensor.numberData,\n          tensor,\n          EncoderUsage.UploadOnly,\n        );\n        td = this.pack(unpackedTextureData);\n      } else {\n        td = this.createTextureData(layout, tensor.type, tensor.numberData, tensor, EncoderUsage.UploadOnly);\n      }\n    }\n    return td;\n  }\n\n  /**\n   * Create a TextureData object using the given data and bind to the given tensor.\n   * Usage = EncoderUsage.UploadOnly.\n   * NOTE: this function is a hack for Conv implementation. should remove this function, after rewriting Conv\n   * implementation by Graph.Transformer\n   * @param dataType the tensor data type\n   * @param data the actual data to upload\n   * @param tensor the tensor to bind. tensor's data is ignored.\n   */\n  createTextureDataFromLayoutBindTensor(\n    layout: TextureLayout,\n    dataType: Tensor.DataType,\n    data: Tensor.NumberType,\n    tensor: Tensor,\n  ): TextureData {\n    return this.createTextureData(layout, dataType, data, tensor, EncoderUsage.UploadOnly);\n  }\n\n  private createTextureData(\n    layout: TextureLayout,\n    dataType: Tensor.DataType,\n    data?: Tensor.NumberType,\n    tensor?: Tensor,\n    usage?: EncoderUsage,\n  ): TextureData {\n    Logger.verbose('InferenceHandler', `Creating TextureData: layout:[${JSON.stringify(layout)}]`);\n    const texture = this.session.textureManager.createTextureFromLayout(dataType, layout, data, usage);\n    return this.createTextureDataFromTexture(layout, dataType, texture, tensor);\n  }\n\n  reshapeUnpacked(input: Tensor, reshapedDims: readonly number[]): Tensor {\n    const inputTD = this.getOrCreateTextureData(input, TextureType.unpacked);\n    const newTextureLayout: TextureLayout = {\n      channels: inputTD.channels,\n      height: inputTD.height,\n      width: inputTD.width,\n      // handle reshaping into scalar Tensors\n      shape: reshapedDims.length !== 0 ? reshapedDims : [1],\n      strides: ShapeUtil.computeStrides(reshapedDims),\n      unpackedShape: reshapedDims,\n    };\n    const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);\n    return newTextureData.tensor;\n  }\n\n  reshapePacked(input: Tensor, reshapedDims: readonly number[]): Tensor {\n    const inputTD = this.getOrCreateTextureData(input, TextureType.packed);\n\n    // check if the reshape is 'cheap'\n    if (isReshapeCheap(input.dims, reshapedDims)) {\n      const newTextureLayout: TextureLayout = {\n        channels: inputTD.channels,\n        height: inputTD.height,\n        width: inputTD.width,\n        // handle reshaping into scalar Tensors\n        shape: reshapedDims.length !== 0 ? reshapedDims : [1],\n        strides: ShapeUtil.computeStrides(reshapedDims),\n        unpackedShape: reshapedDims,\n        isPacked: true,\n      };\n      const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);\n      return newTextureData.tensor;\n    }\n\n    const squeezedInputShape = processDims3D(input.dims);\n    const squeezedOutputShape = processDims3D(reshapedDims);\n\n    const squeezedInputTensor = this.reshapePacked(input, squeezedInputShape);\n    const squeezedOutputTensor = this.run(\n      createPackedReshape3DProgramInfoLoader(this, squeezedInputTensor, squeezedOutputShape),\n      [squeezedInputTensor],\n    );\n    const outputTensor = this.reshapePacked(squeezedOutputTensor, reshapedDims);\n    return outputTensor;\n  }\n\n  cast(input: Tensor, type: Tensor.DataType): Tensor {\n    const inputTD = this.getOrCreateTextureData(input, TextureType.unpacked);\n    const newTextureData = this.createTextureDataFromTexture(inputTD as TextureLayout, type, inputTD.texture);\n    return newTextureData.tensor;\n  }\n\n  private createTextureDataFromTexture(\n    layout: TextureLayout,\n    dataType: Tensor.DataType,\n    texture: WebGLTexture,\n    tensor?: Tensor,\n    tensorId?: Tensor.Id,\n  ) {\n    const textureData: TextureData = {\n      ...layout,\n      tensor:\n        tensor ||\n        new Tensor(\n          layout.unpackedShape,\n          dataType,\n          (_id: Tensor.Id) => this.readTexture(textureData),\n          async (_id: Tensor.Id) => this.readTextureAsync(textureData),\n          undefined,\n          tensorId,\n        ),\n      texture,\n    };\n    this.setTextureData(textureData.tensor.dataId, textureData, layout.isPacked);\n    return textureData;\n  }\n\n  private getTextureData(tensorId: Tensor.Id, isPacked = false): TextureData | undefined {\n    return this.session.isInitializer(tensorId)\n      ? this.session.getTextureData(tensorId, isPacked)\n      : isPacked\n        ? this.packedTextureDataCache.get(tensorId)\n        : this.unpackedTextureDataCache.get(tensorId);\n  }\n  setTextureData(tensorId: Tensor.Id, td: TextureData, isPacked = false): void {\n    if (this.session.isInitializer(tensorId)) {\n      this.session.setTextureData(tensorId, td, isPacked);\n    } else {\n      (isPacked ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(tensorId, td);\n    }\n  }\n  isTextureLayoutCached(tensor: Tensor, isPacked = false): boolean {\n    return !!this.getTextureData(tensor.dataId, isPacked);\n  }\n\n  dispose(): void {\n    this.session.textureManager.clearActiveTextures();\n    this.packedTextureDataCache.forEach((td) => this.session.textureManager.releaseTexture(td));\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache.forEach((td) => this.session.textureManager.releaseTexture(td));\n    this.unpackedTextureDataCache = new Map();\n  }\n\n  readTexture(textureData: TextureData): Tensor.NumberType {\n    if (textureData.isPacked) {\n      return this.readTexture(this.unpack(textureData));\n    }\n    if (!this.session.backend.glContext.isFloat32DownloadSupported) {\n      return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));\n    }\n    return this.session.textureManager.readTexture(textureData, textureData.tensor.type, textureData.channels);\n  }\n\n  async readTextureAsync(textureData: TextureData): Promise<Tensor.NumberType> {\n    if (textureData.isPacked) {\n      return this.readTextureAsync(this.unpack(textureData));\n    }\n    if (!this.session.backend.glContext.isFloat32DownloadSupported) {\n      return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));\n    }\n    return this.session.textureManager.readTextureAsync(textureData, textureData.tensor.type, textureData.channels);\n  }\n\n  pack(input: TextureData): TextureData {\n    const outputTextureData = this.executeProgram(createPackProgramInfoLoader(this, input.tensor), [input.tensor]);\n    return outputTextureData;\n  }\n\n  unpack(input: TextureData): TextureData {\n    const outputTextureData = this.executeProgram(createUnpackProgramInfoLoader(this, input.tensor), [input.tensor]);\n    return outputTextureData;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nclass AttributeWithCacheKeyImpl {\n  constructor(attribute: Record<string, unknown>) {\n    Object.assign(this, attribute);\n  }\n\n  private key: string;\n  public get cacheKey(): string {\n    if (!this.key) {\n      this.key = Object.getOwnPropertyNames(this)\n        .sort()\n        .map((name) => `${(this as Record<string, unknown>)[name]}`)\n        .join(';');\n    }\n    return this.key;\n  }\n}\n\nexport interface AttributeWithCacheKey {\n  readonly cacheKey: string;\n}\n\nexport const createAttributeWithCacheKey = <T extends Record<string, unknown>>(\n  attribute: T,\n): T & AttributeWithCacheKey => new AttributeWithCacheKeyImpl(attribute) as unknown as T & AttributeWithCacheKey;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nexport interface BatchNormalizationAttributes extends AttributeWithCacheKey {\n  epsilon: number;\n  momentum: number;\n  spatial: number;\n}\n\nconst batchNormalizationProgramMetadata = {\n  name: 'BatchNormalization',\n  inputNames: ['A', 'Scale', 'B', 'Mean', 'Variance'],\n  inputTypes: [\n    TextureType.unpacked,\n    TextureType.unpacked,\n    TextureType.unpacked,\n    TextureType.unpacked,\n    TextureType.unpacked,\n  ],\n};\n\nexport const batchNormalization: OperatorImplementation<BatchNormalizationAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: BatchNormalizationAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const output = inferenceHandler.run(\n    {\n      ...batchNormalizationProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createBatchNormalizationProgramInfo(inferenceHandler, inputs, attributes),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseBatchNormalizationAttributes: OperatorInitialization<BatchNormalizationAttributes> = (\n  node: Graph.Node,\n): BatchNormalizationAttributes => {\n  const epsilon = node.attributes.getFloat('epsilon', 1e-5);\n  const momentum = node.attributes.getFloat('momentum', 0.9);\n  const spatial = node.attributes.getInt('spatial', 1);\n  return createAttributeWithCacheKey({ epsilon, momentum, spatial });\n};\n\nconst createBatchNormalizationProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: BatchNormalizationAttributes,\n): ProgramInfo => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const rank = inputs[0].dims.length;\n  const [scaleWidth, scaleHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    inputs[1].dims,\n    TextureType.unpacked,\n  );\n  const shaderSource = `\n  float process(int[${rank}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${scaleWidth}, ${scaleHeight});\n    float scale = getColorAsFloat(${glsl.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${glsl.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${glsl.texture2D}(Variance, position));\n    float b = getColorAsFloat(${glsl.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${attributes.epsilon})) ) + b;\n  }`;\n  return {\n    ...batchNormalizationProgramMetadata,\n    output: { dims: inputs[0].dims, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 5) {\n    throw new Error('BatchNormalization requires 5 inputs.');\n  }\n\n  const X = inputs[0];\n  const scale = inputs[1];\n  const B = inputs[2];\n  const mean = inputs[3];\n  const var_ = inputs[4];\n\n  // input should atleast have three dimensions - N,C,dim1,...,dimn\n  // other inputs can have only one dimensions\n  if (\n    X.dims.length < 3 ||\n    scale.dims.length !== 1 ||\n    B.dims.length !== 1 ||\n    mean.dims.length !== 1 ||\n    var_.dims.length !== 1\n  ) {\n    throw new Error('invalid input shape.');\n  }\n  if (\n    scale.dims[0] !== X.dims[1] ||\n    B.dims[0] !== X.dims[1] ||\n    mean.dims[0] !== X.dims[1] ||\n    var_.dims[0] !== X.dims[1]\n  ) {\n    throw new Error('invalid input shape.');\n  }\n  if (\n    (X.type !== 'float32' && X.type !== 'float64') ||\n    (scale.type !== 'float32' && scale.type !== 'float64') ||\n    (B.type !== 'float32' && B.type !== 'float64') ||\n    (mean.type !== 'float32' && mean.type !== 'float64') ||\n    (var_.type !== 'float32' && var_.type !== 'float64')\n  ) {\n    throw new Error('invalid input tensor types.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { ProgramInfo, TextureLayout } from './types';\nimport { WebGLContext } from './webgl-context';\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum FunctionType {\n  ValueBased,\n  Positional,\n}\nexport interface GlslFunction<T extends FunctionType> {\n  body: string;\n  name: string;\n  type: T;\n}\nexport type GlslValueFunction = GlslFunction<FunctionType.ValueBased>;\nexport interface GlslPositionalFunction extends GlslFunction<FunctionType.Positional> {\n  inputShape: readonly number[];\n  outputShape: readonly number[];\n}\n\nexport class GlslContext {\n  constructor(\n    public glContext: WebGLContext,\n    public programInfo: ProgramInfo,\n    public inputTextureLayouts: TextureLayout[],\n    public outputTextureLayout: TextureLayout,\n  ) {}\n}\nexport abstract class GlslLib {\n  constructor(public context: GlslContext) {}\n  abstract getFunctions(): { [name: string]: GlslLibRoutine };\n  abstract getCustomTypes(): { [name: string]: string };\n}\n\n// abstraction to represent a GLSL library routine and it's dependencies\nexport class GlslLibRoutine {\n  constructor(\n    public routineBody: string,\n    public dependencies?: string[],\n  ) {}\n}\n\n// abstraction to represent a GLSL library routine and it's dependencies AS GRAPH Nodes\n// this level of abstraction is used to topologically sort routines before fragment shade inclusion\nexport class GlslLibRoutineNode {\n  dependencies: GlslLibRoutineNode[];\n  routineBody: string;\n  constructor(\n    public name: string,\n    routineBody?: string,\n    dependencies?: GlslLibRoutineNode[],\n  ) {\n    if (dependencies) {\n      this.dependencies = dependencies;\n    } else {\n      this.dependencies = [];\n    }\n\n    if (routineBody) {\n      this.routineBody = routineBody;\n    }\n  }\n  addDependency(node: GlslLibRoutineNode) {\n    if (node) {\n      this.dependencies.push(node);\n    }\n  }\n}\n\n// topologically sort GLSL library routines (graph nodes abstraction) before shader script inclusion\nexport class TopologicalSortGlslRoutines {\n  static returnOrderedNodes(nodes: GlslLibRoutineNode[]): GlslLibRoutineNode[] {\n    if (!nodes || nodes.length === 0) {\n      return [];\n    }\n\n    if (nodes.length === 1) {\n      return nodes;\n    }\n\n    const cycleCheck = new Set<string>();\n    const alreadyTraversed = new Set<string>();\n    const result = new Array<GlslLibRoutineNode>();\n\n    this.createOrderedNodes(nodes, cycleCheck, alreadyTraversed, result);\n    return result;\n  }\n\n  private static createOrderedNodes(\n    graphNodes: GlslLibRoutineNode[],\n    cycleCheck: Set<string>,\n    alreadyTraversed: Set<string>,\n    result: GlslLibRoutineNode[],\n  ) {\n    for (let i = 0; i < graphNodes.length; ++i) {\n      this.dfsTraverse(graphNodes[i], cycleCheck, alreadyTraversed, result);\n    }\n  }\n\n  private static dfsTraverse(\n    root: GlslLibRoutineNode,\n    cycleCheck: Set<string>,\n    alreadyTraversed: Set<string>,\n    result: GlslLibRoutineNode[],\n  ) {\n    // if this root has already been traversed return\n    if (!root || alreadyTraversed.has(root.name)) {\n      return;\n    }\n\n    // cyclic dependency has been detected\n    if (cycleCheck.has(root.name)) {\n      throw new Error(\"Cyclic dependency detected. Can't topologically sort routines needed for shader.\");\n    }\n\n    // hold this node to detect cycles if any\n    cycleCheck.add(root.name);\n\n    // traverse children in a dfs fashion\n    const dependencies = root.dependencies;\n    if (dependencies && dependencies.length > 0) {\n      for (let i = 0; i < dependencies.length; ++i) {\n        this.dfsTraverse(dependencies[i], cycleCheck, alreadyTraversed, result);\n      }\n    }\n\n    // add to result holder\n    result.push(root);\n\n    // mark this node as traversed so that we don't traverse from this again\n    alreadyTraversed.add(root.name);\n\n    // release the hold\n    cycleCheck.delete(root.name);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { BroadcastUtil, ShapeUtil } from '../../../util';\nimport { FunctionType, GlslValueFunction } from '../glsl-definitions';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, TextureType } from '../types';\n\nexport function glslAdd(): GlslValueFunction {\n  const name = 'add_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslDiv(): GlslValueFunction {\n  const name = 'div_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslMul(): GlslValueFunction {\n  const name = 'mul_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslSub(): GlslValueFunction {\n  const name = 'sub_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslEqual(): GlslValueFunction {\n  const name = 'equal_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslGreater(): GlslValueFunction {\n  const name = 'greater_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslLess(): GlslValueFunction {\n  const name = 'less_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslAnd(): GlslValueFunction {\n  const name = 'and_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslOr(): GlslValueFunction {\n  const name = 'or_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslXor(): GlslValueFunction {\n  const name = 'xor_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslPow(): GlslValueFunction {\n  return glslBuiltinBinary('pow');\n}\nexport function glslPRelu(): GlslValueFunction {\n  const name = 'prelu_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\n\nfunction glslBuiltinBinary(fname: string): GlslValueFunction {\n  const name = `${fname}_`;\n  const body = `\n  float ${name}(float a, float b) {\n    return ${fname}(a, b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return ${fname}(v1, v2);\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\n\nconst createBinaryProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  glslFunc: GlslValueFunction,\n  outputTensorType: Tensor.DataType = inputs[0].type,\n  cacheKey?: string,\n): ProgramInfoLoader => {\n  const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n  return {\n    name: glslFunc.name,\n    inputNames: ['A', 'B'],\n    inputTypes: [textureType, textureType],\n    cacheHint: cacheKey,\n    get: () => createBinaryProgramInfo(handler, inputs, glslFunc, outputTensorType),\n  };\n};\n\nconst createBinaryProgramInfo = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  glslFunc: GlslValueFunction,\n  outputTensorType: Tensor.DataType = inputs[0].type,\n): ProgramInfo => {\n  const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n  const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);\n  let outputShape = inputs[0].dims;\n\n  const usePackedTexture = handler.session.pack;\n\n  if (isBroadcast) {\n    const calculatedShape = BroadcastUtil.calcShape(inputs[0].dims, inputs[1].dims, false);\n    if (!calculatedShape) {\n      throw new Error(\"Can't perform binary op on the given tensors\");\n    }\n    outputShape = calculatedShape;\n    const outputRank = outputShape.length;\n    const aRank = inputs[0].dims.length !== 0 ? inputs[0].dims.length : 1;\n    const bRank = inputs[1].dims.length !== 0 ? inputs[1].dims.length : 1;\n    const aBcast = inputs[0].dims.length !== 0 ? 'bcastIndices_A(indices, aindices);' : 'aindices[0] = 0;';\n    const bBcast = inputs[1].dims.length !== 0 ? 'bcastIndices_B(indices, bindices);' : 'bindices[0] = 0;';\n\n    const glsl = getGlsl(handler.session.backend.glContext.version);\n    const shaderSource = usePackedTexture\n      ? `\n      ${glslFunc.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${glslFunc.name}(a, b);\n        ${glsl.output} = result;\n      }`\n      : `\n      ${glslFunc.body}\n      float process(int indices[${outputRank}]) {\n        int aindices[${aRank}];\n        int bindices[${bRank}];\n        ${aBcast}\n        ${bBcast}\n        return ${glslFunc.name}(_A(aindices), _B(bindices));\n      }`;\n\n    return {\n      name: glslFunc.name,\n      inputNames: ['A', 'B'],\n      inputTypes: [textureType, textureType],\n      output: { dims: outputShape, type: outputTensorType, textureType },\n      shaderSource,\n      hasMain: usePackedTexture,\n    };\n  }\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n  const shaderSource = `\n    ${glslFunc.body}\n    void main() {\n      vec4 v1 = ${glsl.texture2D}(A, TexCoords);\n      vec4 v2 = ${glsl.texture2D}(B, TexCoords);\n      vec4 result = ${glslFunc.name}(v1, v2);\n      ${glsl.output} = result;\n    }\n    `;\n\n  return {\n    name: glslFunc.name,\n    inputNames: ['A', 'B'],\n    inputTypes: [textureType, textureType],\n    output: { dims: inputs[0].dims, type: outputTensorType, textureType },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nexport const add = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAdd()), inputs),\n];\n\nexport const and = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAnd(), 'bool'), inputs),\n];\n\nexport const div = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslDiv()), inputs),\n];\n\nexport const equal = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslEqual(), 'bool'), inputs),\n];\n\nexport const greater = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslGreater(), 'bool'), inputs),\n];\n\nexport const less = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslLess(), 'bool'), inputs),\n];\n\nexport const mul = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslMul()), inputs),\n];\n\nexport const or = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslOr(), 'bool'), inputs),\n];\n\nexport const pow = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPow()), inputs),\n];\n\nexport const pRelu = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPRelu()), inputs),\n];\n\nexport const sub = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslSub()), inputs),\n];\n\nexport const xor = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslXor(), 'bool'), inputs),\n];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ProtoUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nexport const cast: OperatorImplementation<Tensor.DataType> = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  to: Tensor.DataType,\n): Tensor[] => {\n  validateInputs(inputs);\n  return [handler.cast(inputs[0], to)];\n};\n\nexport const parseCastAttributes: OperatorInitialization<Tensor.DataType> = (node: Graph.Node): Tensor.DataType =>\n  ProtoUtil.tensorDataTypeFromProto(node.attributes.getInt('to'));\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Cast requires 1 input.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\nimport { getCoordsDataType, getGlChannels } from '../utils';\n\nimport { ConcatAttributes } from './concat';\nimport { getChannels, unpackFromChannel } from './packing-utils';\n\nconst createPackedConcatProgramMetadata = (inputCount: number, cacheHint: string) => ({\n  name: 'Concat (packed)',\n  inputNames: Array.from({ length: inputCount }, (_v, i) => `X${i}`),\n  inputTypes: Array(inputCount).fill(TextureType.packed),\n  cacheHint,\n});\n\nconst createPackedConcatProgramInfo = (\n  handler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  axis: number,\n): ProgramInfo => {\n  const inputShape = inputs[0].dims.slice();\n  if (axis >= inputShape.length || axis < -1 * inputShape.length) {\n    throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n  }\n  if (axis < 0) {\n    axis = inputShape.length + axis;\n  }\n  // ensure all of the non-concatenated axes match each other\n  // calculate the shape of the output tensor while we do that\n  const outputShape = inputShape.slice(0);\n  for (let i = 1; i < inputs.length; i++) {\n    const dataNShape = inputs[i].dims.slice();\n    for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {\n      // add to the placeholder for computing output shape\n      if (axisIndex === axis) {\n        outputShape[axis] += dataNShape[axisIndex];\n      }\n      // ensure all non-cancatenated axes match each other\n      else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {\n        throw new Error('non concat dimensions must match');\n      }\n    }\n  }\n\n  const rank = outputShape.length;\n  const coords = getChannels('coords', rank);\n  const dtype = getCoordsDataType(rank);\n  const unpackChannel = unpackFromChannel();\n\n  const shapes = inputs.map((i) => i.dims);\n  const channels = getGlChannels(rank);\n  const offsets: number[] = new Array(shapes.length - 1);\n\n  offsets[0] = shapes[0][axis];\n  for (let i = 1; i < offsets.length; i++) {\n    offsets[i] = offsets[i - 1] + shapes[i][axis];\n  }\n\n  const channel = channels[axis];\n  const lastChannels = channels.slice(-2);\n  const allChannels = channels.join();\n\n  let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getX0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n  for (let i = 1; i < offsets.length; i++) {\n    const shift = offsets[i - 1];\n    getValueSnippet += `\n            if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n              return getChannel(\n                getX${i}(${getShiftedChannelsSnippet(channels, channel, shift)}),\n                vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift)}));\n            }`;\n  }\n  const lastIndex = offsets.length;\n  const shift = offsets[offsets.length - 1];\n  getValueSnippet += `\n            return getChannel(\n              getX${lastIndex}(${getShiftedChannelsSnippet(channels, channel, shift)}),\n              vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift)}));`;\n\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n\n  const shaderSource = `\n          ${unpackChannel}\n          float getValue(${channels.map((x) => 'int ' + x)}) {\n            ${getValueSnippet}\n          }\n\n          void main() {\n            ${dtype} coords = getOutputCoords();\n            int lastDim = coords.${channels[rank - 1]};\n            coords.${channels[rank - 1]} = coords.${channels[rank - 2]};\n            coords.${channels[rank - 2]} = lastDim;\n\n            vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n            ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n            if (${coords[rank - 1]} < ${outputShape[rank - 1]}) {\n              result.g = getValue(${coords});\n            }\n\n            ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n            if (${coords[rank - 2]} < ${outputShape[rank - 2]}) {\n              result.a = getValue(${coords});\n            }\n\n            ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n            if (${coords[rank - 2]} < ${outputShape[rank - 2]} &&\n                ${coords[rank - 1]} < ${outputShape[rank - 1]}) {\n              result.b = getValue(${coords});\n            }\n            ${glsl.output} = result;\n          }\n        `;\n\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.packed },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nexport const createPackedConcatProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ConcatAttributes,\n): ProgramInfoLoader => {\n  const metadata = createPackedConcatProgramMetadata(inputs.length, attributes.cacheKey);\n  return { ...metadata, get: () => createPackedConcatProgramInfo(handler, metadata, inputs, attributes.axis) };\n};\n\nconst getShiftedChannelsSnippet = (channels: string[], channel: string, shift: number): string => {\n  const channelIdx = channels.indexOf(channel);\n  const res = channels.map((c, idx) => {\n    if (idx === channelIdx) {\n      return `${c} - ${shift}`;\n    } else {\n      return c;\n    }\n  });\n  return res.join();\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { createPackedConcatProgramInfoLoader } from './concat-packed';\n\nexport interface ConcatAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n}\n\nexport const concat: OperatorImplementation<ConcatAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ConcatAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  if (inferenceHandler.session.pack && inputs[0].dims.length > 1) {\n    const output = inferenceHandler.run(\n      createPackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes),\n      inputs,\n    );\n    return [output];\n  } else {\n    const output = inferenceHandler.run(\n      createUnpackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes),\n      inputs,\n    );\n    return [output];\n  }\n};\n\nconst createUnpackedConcatProgramMetadata = (inputCount: number, cacheHint: string) => ({\n  name: 'Concat',\n  inputNames: Array.from({ length: inputCount }, (_v, i) => `X${i}`),\n  inputTypes: Array(inputCount).fill(TextureType.unpacked),\n  cacheHint,\n});\n\nconst createUnpackedConcatProgramInfo = (\n  _handler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  axis: number,\n): ProgramInfo => {\n  const inputShape = inputs[0].dims.slice();\n  if (axis >= inputShape.length || axis < -1 * inputShape.length) {\n    throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n  }\n  if (axis < 0) {\n    axis = inputShape.length + axis;\n  }\n  // ensure all of the non-concatenated axes match each other\n  // calculate the shape of the output tensor while we do that\n  const outputShape = inputShape.slice(0);\n  for (let i = 1; i < inputs.length; i++) {\n    const dataNShape = inputs[i].dims.slice();\n    for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {\n      // add to the placeholder for computing output shape\n      if (axisIndex === axis) {\n        outputShape[axis] += dataNShape[axisIndex];\n      }\n      // ensure all non-cancatenated axes match each other\n      else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {\n        throw new Error('non concat dimensions must match');\n      }\n    }\n  }\n\n  const rank = outputShape.length;\n\n  const sizeInConcatAxis = new Array<number>(inputs.length);\n  let previousSum = 0;\n  for (let i = 0; i < sizeInConcatAxis.length; ++i) {\n    previousSum += inputs[i].dims[axis];\n    sizeInConcatAxis[i] = previousSum;\n  }\n\n  let getTextureIndexWhereDataResidesMethod = '';\n  // in most cases linear search is sufficient, as in most scenarios, only 2 tensors are concatenated\n  if (inputs.length < 5) {\n    getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);\n  } else {\n    getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesBinarySearch(sizeInConcatAxis);\n  }\n\n  const fetchDataFromCorrectTextureMethod = getFetchDataFromCorrectTextureMethod(inputs.length, rank);\n  const getSizeInConcatAxisValueFromIndexMethod = getGetSizeInConcatAxisValueFromIndexMethod(sizeInConcatAxis);\n  const shaderSource = `\n        ${fetchDataFromCorrectTextureMethod}\n        ${getSizeInConcatAxisValueFromIndexMethod}\n        ${getTextureIndexWhereDataResidesMethod}\n        float process(int indices[${rank}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${axis}]);\n\n          if(textureIndex != 0) {\n            indices[${axis}] = indices[${axis}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst createUnpackedConcatProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ConcatAttributes,\n): ProgramInfoLoader => {\n  const metadata = createUnpackedConcatProgramMetadata(inputs.length, attributes.cacheKey);\n  return { ...metadata, get: () => createUnpackedConcatProgramInfo(handler, metadata, inputs, attributes.axis) };\n};\n\nconst getTextureIndexWhereDataResidesLinearSearch = (sizeInConcatAxis: number[]): string => {\n  const searchAxis = sizeInConcatAxis.map(\n    (size, i) => `if(index<${size}) {return ${i};}\n`,\n  );\n  return `int getTextureWhereDataResides(int index) {\n      ${searchAxis.join('')}\n    }`;\n};\n\n// TODO: Implement BinarySearch in GLSL\nconst getTextureIndexWhereDataResidesBinarySearch = (sizeInConcatAxis: number[]): string =>\n  getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);\n\nconst getFetchDataFromCorrectTextureMethod = (numberOfTensors: number, tensorRank: number) => {\n  const codeLines: string[] = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${tensorRank}]) {`];\n  for (let i = 0; i < numberOfTensors; ++i) {\n    if (i === 0) {\n      codeLines.push('\\t' + `if (textureIndex == ${i}) { return _X${i}(indices); }`);\n    } else if (i === numberOfTensors - 1) {\n      codeLines.push('\\t' + `else { return _X${i}(indices); }`);\n    } else {\n      codeLines.push('\\t' + `else if (textureIndex == ${i}) { return _X${i}(indices); }`);\n    }\n  }\n  codeLines.push('\\t' + '}');\n  return codeLines.join('\\n');\n};\n\nconst getGetSizeInConcatAxisValueFromIndexMethod = (sizeInConcatAxis: number[]): string => {\n  const codeLines: string[] = ['int getSizeInConcatAxisValueFromIndex(int index) {'];\n  for (let i = 0; i < sizeInConcatAxis.length; ++i) {\n    if (i === 0) {\n      codeLines.push('\\t' + `if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`);\n    } else if (i === sizeInConcatAxis.length - 1) {\n      codeLines.push('\\t' + `else { return ${sizeInConcatAxis[i]}; }`);\n    } else {\n      codeLines.push('\\t' + `else if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`);\n    }\n  }\n  codeLines.push('\\t' + '}');\n\n  return codeLines.join('\\n');\n};\n\nexport const parseConcatAttributes: OperatorInitialization<ConcatAttributes> = (node: Graph.Node): ConcatAttributes =>\n  createAttributeWithCacheKey({ axis: node.attributes.getInt('axis') });\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length < 1) {\n    throw new Error('too few inputs');\n  }\n\n  const inputType = inputs[0].type;\n  const inputDimensionality = inputs[0].dims.length;\n\n  // TODO: Support string concat\n  if (inputType === 'string') {\n    throw new Error('string tensor is not supported yet');\n  }\n\n  for (const input of inputs) {\n    // make sure types of all inputs match\n    if (input.type !== inputType) {\n      throw new Error('input tensors should be one type');\n    }\n\n    // make sure the dimensionality of all inputs are the same\n    if (input.dims.length !== inputDimensionality) {\n      throw new Error('input tensors should have the same shape');\n    }\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { Tensor } from '../../../tensor';\nimport { MAX_CLIP, MIN_CLIP } from '../../../util';\nimport { FunctionType, GlslValueFunction } from '../glsl-definitions';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nexport function glslAbs(): GlslValueFunction {\n  return glslBuiltinUnary('abs');\n}\nexport function glslAcos(): GlslValueFunction {\n  return glslBuiltinUnary('acos');\n}\nexport function glslAsin(): GlslValueFunction {\n  return glslBuiltinUnary('asin');\n}\nexport function glslAtan(): GlslValueFunction {\n  return glslBuiltinUnary('atan');\n}\nexport function glslCeil(): GlslValueFunction {\n  return glslBuiltinUnary('ceil');\n}\nexport function glslCos(): GlslValueFunction {\n  return glslBuiltinUnary('cos');\n}\nexport function glslElu(alpha: number): GlslValueFunction {\n  const name = 'elu';\n  const body = `\n  const float alpha = float(${alpha});\n\n  float ${name}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${name}_(vec4 v) {\n    return vec4(${name}_(v.x), ${name}_(v.y), ${name}_(v.z), ${name}_(v.w));\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslExp(): GlslValueFunction {\n  return glslBuiltinUnary('exp');\n}\nexport function glslFloor(): GlslValueFunction {\n  return glslBuiltinUnary('floor');\n}\nexport function glslClip(min: number, max: number): GlslValueFunction {\n  const name = 'clip';\n  const body = `\n  const float min = float(${min});\n  const float max = float(${max});\n\n  float ${name}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${name}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslIdentity(): GlslValueFunction {\n  const name = 'indentity';\n  const body = `\n  float ${name}_(float a) {\n    return a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return v;\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslLeakyRelu(alpha: number): GlslValueFunction {\n  const name = 'leakyRelu';\n  const body = `\n  const float alpha = float(${alpha});\n\n  float ${name}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return vec4(${name}_(v.x), ${name}_(v.y), ${name}_(v.z), ${name}_(v.w));\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslLog(): GlslValueFunction {\n  return glslBuiltinUnary('log');\n}\nexport function glslNeg(): GlslValueFunction {\n  const name = 'neg';\n  const body = `\n  float ${name}_(float a) {\n    return -a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return -v;\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslNot(): GlslValueFunction {\n  const name = 'not';\n  const body = `\n  float ${name}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${name}_(bool a) {\n    return !a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${name}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslSin(): GlslValueFunction {\n  return glslBuiltinUnary('sin');\n}\nexport function glslRelu(): GlslValueFunction {\n  const name = 'relu';\n  const body = `\n  float ${name}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${name}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslSigmoid(): GlslValueFunction {\n  const name = 'sigmoid';\n  const body = `\n  float ${name}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${name}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslSqrt(): GlslValueFunction {\n  return glslBuiltinUnary('sqrt');\n}\nexport function glslTan(): GlslValueFunction {\n  return glslBuiltinUnary('tan');\n}\nexport function glslTanh(): GlslValueFunction {\n  const name = 'tanh';\n  const body = `\n  float ${name}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${name}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nfunction glslBuiltinUnary(name: string): GlslValueFunction {\n  const body = `\n  float ${name}_(float a) {\n    return ${name}(a);\n  }\n  vec4 ${name}_(vec4 v) {\n    return ${name}(v);\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\n\n/////\n/////\n/////\n\nconst createElementwiseProgramInfo = (\n  handler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  input: Tensor,\n  glslFunc: GlslValueFunction,\n): ProgramInfo => {\n  const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n  return {\n    ...metadata,\n    output: { dims: input.dims, type: input.type, textureType },\n    shaderSource: `\n     ${glslFunc.body}\n     void main() {\n       vec4 v = ${glsl.texture2D}(A, TexCoords);\n       v = ${glslFunc.name}_(v);\n       ${glsl.output} = v;\n     }\n     `,\n    hasMain: true,\n  };\n};\n\nconst createElementwiseProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  input: Tensor,\n  glslFunc: GlslValueFunction,\n  cacheKey?: string,\n): ProgramInfoLoader => {\n  const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n  const metadata = { name: glslFunc.name, inputTypes: [textureType], inputNames: ['A'], cacheHint: cacheKey };\n  return { ...metadata, get: () => createElementwiseProgramInfo(handler, metadata, input, glslFunc) };\n};\n\nexport const abs = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAbs()), inputs),\n];\n\nexport const acos = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAcos()), inputs),\n];\n\nexport const asin = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAsin()), inputs),\n];\n\nexport const atan = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAtan()), inputs),\n];\n\nexport interface ClipAttributes extends AttributeWithCacheKey {\n  readonly min: number;\n  readonly max: number;\n}\n\nexport const clip = (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: ClipAttributes): Tensor[] => [\n  handler.run(\n    createElementwiseProgramInfoLoader(\n      handler,\n      inputs[0],\n      glslClip(attributes.min, attributes.max),\n      attributes.cacheKey,\n    ),\n    inputs,\n  ),\n];\n\nexport const parseClipAttributes = (node: Graph.Node): ClipAttributes =>\n  createAttributeWithCacheKey({\n    min: node.attributes.getFloat('min', MIN_CLIP),\n    max: node.attributes.getFloat('max', MAX_CLIP),\n  });\n\nexport const clipV11 = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  const attributes = generateClipAttributesFromInputs(handler, inputs);\n  return clip(handler, [inputs[0]], attributes);\n};\n\nconst generateClipAttributesFromInputs = (handler: WebGLInferenceHandler, inputs: Tensor[]): ClipAttributes => {\n  if (\n    inputs.length >= 3 &&\n    (!handler.session.isInitializer(inputs[1].dataId) || !handler.session.isInitializer(inputs[2].dataId))\n  ) {\n    throw new Error('dynamic clip attributes are not allowed');\n  }\n\n  const min = inputs.length >= 3 ? inputs[1].numberData[0] : MIN_CLIP;\n  const max = inputs.length >= 3 ? inputs[2].numberData[0] : MAX_CLIP;\n  return createAttributeWithCacheKey({ min, max });\n};\n\nexport const ceil = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCeil()), inputs),\n];\n\nexport const cos = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCos()), inputs),\n];\n\nexport interface EluAttributes extends AttributeWithCacheKey {\n  readonly alpha: number;\n}\n\nexport const elu = (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: EluAttributes): Tensor[] => [\n  handler.run(\n    createElementwiseProgramInfoLoader(handler, inputs[0], glslElu(attributes.alpha), attributes.cacheKey),\n    inputs,\n  ),\n];\n\nexport const parseEluAttributes = (node: Graph.Node): EluAttributes =>\n  createAttributeWithCacheKey({ alpha: node.attributes.getFloat('alpha', 1.0) });\n\nexport const exp = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslExp()), inputs),\n];\n\nexport const floor = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslFloor()), inputs),\n];\n\nexport const identity = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslIdentity()), inputs),\n];\n\nexport interface LeakyReluAttributes extends AttributeWithCacheKey {\n  readonly alpha: number;\n}\n\nexport const leakyRelu = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: LeakyReluAttributes,\n): Tensor[] => [\n  handler.run(\n    createElementwiseProgramInfoLoader(handler, inputs[0], glslLeakyRelu(attributes.alpha), attributes.cacheKey),\n    inputs,\n  ),\n];\n\nexport const parseLeakyReluAttributes = (node: Graph.Node): LeakyReluAttributes =>\n  createAttributeWithCacheKey({ alpha: node.attributes.getFloat('alpha', 0.01) });\n\nexport const log = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslLog()), inputs),\n];\n\nexport const neg = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNeg()), inputs),\n];\n\nexport const not = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNot()), inputs),\n];\n\nexport const relu = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslRelu()), inputs),\n];\n\nexport const sigmoid = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSigmoid()), inputs),\n];\n\nexport const sin = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSin()), inputs),\n];\n\nexport const sqrt = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSqrt()), inputs),\n];\n\nexport const tan = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTan()), inputs),\n];\n\nexport const tanh = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTanh()), inputs),\n];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Attribute } from '../../../attribute';\nimport { MAX_CLIP, MIN_CLIP } from '../../../util';\nimport { GlslValueFunction } from '../glsl-definitions';\n\nimport { glslClip, glslRelu, glslSigmoid } from './unary-op';\n\nexport interface InternalActivationAttributes {\n  readonly activation: string;\n  readonly clipMin?: number;\n  readonly clipMax?: number;\n  readonly activationCacheKey: string;\n}\n\nexport function getActivationSnippet(attributes: InternalActivationAttributes) {\n  let func: GlslValueFunction;\n  switch (attributes.activation) {\n    case 'Relu':\n      func = glslRelu();\n      break;\n    case 'Sigmoid':\n      func = glslSigmoid();\n      break;\n    case 'Clip':\n      func = glslClip(attributes.clipMin!, attributes.clipMax!);\n      break;\n    // TODO: adding other activations that can be fused.\n    default:\n      return { activationFunction: '', applyActivation: '' };\n  }\n\n  const activationName = func.name;\n  const activationFunction = func.body;\n  const applyActivation = `value = ${activationName}_(value);`;\n  return { activationFunction, applyActivation };\n}\n\nexport const parseInternalActivationAttributes = (attributes: Attribute): InternalActivationAttributes => {\n  const activation = attributes.getString('activation', '');\n\n  if (activation === 'Clip') {\n    const [clipMin, clipMax] = attributes.getFloats('activation_params', [MIN_CLIP, MAX_CLIP]);\n    return { activation, clipMax, clipMin, activationCacheKey: `${activation}:${clipMin},${clipMax}` };\n  }\n  return { activation, activationCacheKey: activation };\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Logger } from '../../../instrument';\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { calculateOutputShape, ConvAttributes } from './conv';\nimport { getActivationSnippet } from './fuse-utils';\n\nconst createUnpackedGroupedConvProgramMetadata = (hasBias: boolean, cacheHint: string): ProgramMetadata => ({\n  name: 'GroupedConv',\n  inputNames: hasBias ? ['X', 'W', 'Bias'] : ['X', 'W'],\n  inputTypes: hasBias\n    ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked]\n    : [TextureType.unpacked, TextureType.unpacked],\n  cacheHint,\n});\n\nconst createUnpackedGroupedConvProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  metadata: ProgramMetadata,\n  attributes: ConvAttributes,\n): ProgramInfo => {\n  const hasBias = inputs.length > 2;\n  const processBias = hasBias ? 'value += getBias(output_channel);' : '';\n  const xShape = inputs[0].dims.slice();\n  const wShape = inputs[1].dims.slice();\n  const outputChannelsPerGroup = wShape[0] / attributes.group;\n  Logger.verbose(\n    'GroupedConv',\n    `autpPad:${attributes.autoPad}, dilations:${attributes.dilations}, group:${attributes.group}, kernelShape:${\n      attributes.kernelShape\n    }, pads:${attributes.pads}, strides:${attributes.strides}`,\n  );\n  const outputShape = calculateOutputShape(xShape, wShape, attributes.dilations, attributes.pads, attributes.strides);\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const { activationFunction, applyActivation } = getActivationSnippet(attributes);\n\n  const shaderSource = `\n  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});\n  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});\n  ${activationFunction}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${outputChannelsPerGroup};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${wShape[1]}; wInChannel++) {\n      int input_channel = group_id * ${wShape[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${wShape[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${attributes.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${xShape[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${wShape[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${attributes.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${xShape[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${processBias}\n    ${applyActivation}\n    ${glsl.output} = vec4(value, .0, .0, .0);\n  }\n`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nexport const createUnpackedGroupedConvProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvAttributes,\n): ProgramInfoLoader => {\n  const metadata = createUnpackedGroupedConvProgramMetadata(inputs.length > 2, attributes.cacheKey);\n  return {\n    ...metadata,\n    get: () => createUnpackedGroupedConvProgramInfo(inferenceHandler, inputs, metadata, attributes),\n  };\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { ConvAttributes } from './conv';\nimport { unpackFromChannel } from './packing-utils';\n\nconst createPackedIm2ColProgramMetadata = (cacheHint: string) => ({\n  name: 'Im2Col (packed)',\n  inputNames: ['A'],\n  inputTypes: [TextureType.packed],\n  cacheHint,\n});\n\nconst createPackedIm2ColProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  x: Tensor,\n  w: Tensor,\n  outputShape: readonly number[],\n  attributes: ConvAttributes,\n): ProgramInfo => {\n  const xshape = x.dims;\n  const wshape = w.dims;\n  const rowDim = 2;\n  const colDim = 3;\n  const rank = outputShape.length;\n  const im2colShape = [wshape[1] * wshape[2] * wshape[3], outputShape[2] * outputShape[3]];\n  const kernelSize = wshape[2] * wshape[3];\n  const unpackChannel = unpackFromChannel();\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  let unrolled = '';\n\n  for (let row = 0; row <= 1; row++) {\n    for (let col = 0; col <= 1; col++) {\n      unrolled += `\n            blockIndex = rc.x + ${col};\n            pos = rc.y + ${row};\n\n            if(blockIndex < ${im2colShape[1]} && pos < ${im2colShape[0]}) {\n              offsetY = int(blockIndex / (${outputShape[rank - 1]})) * ${attributes.strides[0]} -\n                ${attributes.pads[0]};\n              d0 = offsetY + ${attributes.dilations[0]} * (imod(pos, ${kernelSize}) / ${wshape[2]});\n\n              if(d0 < ${xshape[rowDim]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${outputShape[rank - 1]}) * ${attributes.strides[1]} -\n                  ${attributes.pads[1]};\n                d1 = offsetX + ${attributes.dilations[1]} * imod(imod(pos, ${kernelSize}), ${wshape[2]});\n\n                if(d1 < ${xshape[colDim]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${kernelSize}.);\n                    innerDims = vec2(d0, d1);\n                    result[${row * 2 + col}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;\n    }\n  }\n\n  const shaderSource = `\n      ${unpackChannel}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${unrolled}\n          ${glsl.output} = result;\n      }\n            `;\n  return {\n    ...metadata,\n    output: { dims: im2colShape, type: x.type, textureType: TextureType.packed },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nexport const createPackedIm2ColProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  x: Tensor,\n  w: Tensor,\n  outputShape: readonly number[],\n  attributes: ConvAttributes,\n): ProgramInfoLoader => {\n  const metadata = createPackedIm2ColProgramMetadata(attributes.cacheKey);\n  return {\n    ...metadata,\n    get: () => createPackedIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes),\n  };\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { BroadcastUtil, ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\nimport { getCoordsDataType, getGlChannels } from '../utils';\n\nimport { getActivationSnippet, InternalActivationAttributes, parseInternalActivationAttributes } from './fuse-utils';\nimport { createPackedMatmulProgramInfoLoader } from './matmul-pack';\n\nexport const matMul: OperatorImplementation<InternalActivationAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: InternalActivationAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  if (inferenceHandler.session.pack) {\n    return [inferenceHandler.run(createPackedMatmulProgramInfoLoader(inferenceHandler, inputs, attributes), inputs)];\n  } else {\n    return [inferenceHandler.run(createMatmulProgramInfoLoader(inputs, attributes), inputs)];\n  }\n};\n\nexport const parseMatMulAttributes: OperatorInitialization<InternalActivationAttributes> = (\n  node: Graph.Node,\n): InternalActivationAttributes => parseInternalActivationAttributes(node.attributes);\n\nconst createMatmulProgramMetadata = (hasBias: boolean, cacheHint: string) => ({\n  name: 'MatMul',\n  inputNames: hasBias ? ['A', 'B', 'Bias'] : ['A', 'B'],\n  inputTypes: hasBias\n    ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked]\n    : [TextureType.unpacked, TextureType.unpacked],\n  cacheHint,\n});\n\nfunction createMatmulProgramInfo(\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  activationAttributes: InternalActivationAttributes,\n): ProgramInfo {\n  const aShape = inputs[0].dims;\n  const bShape = inputs[1].dims;\n  const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);\n  if (!outputShape) {\n    throw new Error(\"Can't use matmul on the given tensors\");\n  }\n  const coordsDataType = getCoordsDataType(outputShape.length);\n  const allGlChannels = getGlChannels();\n  const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes);\n\n  const hasBias = inputs.length > 2;\n  const processBias = hasBias ? 'value += getBiasForMatmul();' : '';\n  const getBiasForMatmulSnippet = hasBias\n    ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, false)}`\n    : '';\n\n  const rank = outputShape.length;\n  const arank = aShape.length;\n  const brank = bShape.length;\n  const sharedDim = aShape[aShape.length - 1];\n  const shaderSource = `\n    ${activationFunction}\n    ${getBiasForMatmulSnippet}\n    float process(int indices[${rank}]) {\n        int a[${arank}];\n        int b[${brank}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${sharedDim}; ++k) {\n            a[${arank - 1}] = k;\n            b[${brank - 2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${processBias}\n        ${applyActivation}\n        return value;\n    }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n}\n\nexport function createMatmulProgramInfoLoader(\n  inputs: Tensor[],\n  activationAttributes: InternalActivationAttributes,\n): ProgramInfoLoader {\n  const metadata = createMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);\n  return { ...metadata, get: () => createMatmulProgramInfo(metadata, inputs, activationAttributes) };\n}\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('MatMul requires 2 inputs.');\n  }\n\n  if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {\n    throw new Error('shared dimension does not match.');\n  }\n\n  if (\n    (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') ||\n    (inputs[1].type !== 'float32' && inputs[1].type !== 'float64')\n  ) {\n    throw new Error('inputs should be float type');\n  }\n\n  if (inputs[0].type !== inputs[1].type) {\n    throw new Error('inputs types should match');\n  }\n};\n\nexport function getBiasForMatmul(\n  coordsDataType: string,\n  allGlChannels: readonly string[],\n  inShape: readonly number[],\n  outShape: readonly number[],\n  isPacked: boolean,\n): string {\n  let unpackedCoordsSnippet = '';\n  const inRank = inShape.length;\n  const outRank = outShape.length;\n  const rankDiff = outRank - inRank;\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    unpackedCoordsSnippet = inShape.map((_s, i) => `coords.${allGlChannels[i + rankDiff]}`).join(', ');\n  }\n  const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);\n  const coordsSnippet = broadcastDims.map((d) => `coords.${allGlChannels[d + rankDiff]} = 0;`).join('\\n');\n  const inSize = ShapeUtil.size(inShape);\n  const isInputScalar = inSize === 1;\n  let output = 'vec4(outputValue.xx, outputValue.yy)';\n  if (isInputScalar) {\n    output = 'vec4(outputValue.x)';\n  }\n  const getBiasForMatmulSource = isPacked\n    ? `\nvec4 getBiasForMatmul() {\n  ${coordsDataType} coords = getOutputCoords();\n  ${coordsSnippet}\n  vec4 outputValue = getBias(${unpackedCoordsSnippet});\n  return ${output};\n}`\n    : `\nfloat getBiasForMatmul() {\n  ${coordsDataType} coords = getOutputCoords();\n  ${coordsSnippet}\n  return getBias(coords.x);\n}`;\n\n  return getBiasForMatmulSource;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { BroadcastUtil, ShapeUtil } from '../../../util';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\nimport { getCoordsDataType, getGlChannels } from '../utils';\n\nimport { getActivationSnippet, InternalActivationAttributes } from './fuse-utils';\nimport { getBiasForMatmul } from './matmul';\n\nconst createPackedMatmulProgramMetadata = (hasBias: boolean, cacheHint: string) => ({\n  name: 'MatMul (packed)',\n  inputNames: hasBias ? ['A', 'B', 'Bias'] : ['A', 'B'],\n  inputTypes: hasBias\n    ? [TextureType.packed, TextureType.packed, TextureType.packed]\n    : [TextureType.packed, TextureType.packed],\n  cacheHint,\n});\n\nconst createPackedMatmulProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  activationAttributes: InternalActivationAttributes,\n): ProgramInfo => {\n  const hasBias = inputs.length > 2;\n  const processBias = hasBias ? 'value += getBiasForMatmul();' : '';\n  const aShape = inputs[0].dims;\n  const bShape = inputs[1].dims;\n  const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);\n  const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);\n\n  if (!outputShape) {\n    throw new Error(\"Can't use matmul on the given tensors\");\n  }\n  const sharedDim = aShape[aShape.length - 1];\n  const sharedDimIndex = Math.ceil(sharedDim / 2);\n  const aRank = aShape.length;\n  const bRank = bShape.length;\n\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const coordsDataType = getCoordsDataType(outputShape.length);\n  const outRank = outputShape.length;\n  const allGlChannels = getGlChannels();\n  const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes);\n\n  const getBiasForMatmulSnippet = hasBias\n    ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, true)}`\n    : '';\n\n  const getBcastedSamplerForMatmulSnippet = isBroadcast\n    ? `${getBcastSamplerForMatmul(coordsDataType, allGlChannels, inputs, outputShape)}`\n    : '';\n\n  const getSamplerAInLoopSnippet = isBroadcast ? 'getAAtOutCoordsMatmul(i)' : `getA(${getA(allGlChannels, aRank)})`;\n  const getSamplerBInLoopSnippet = isBroadcast ? 'getBAtOutCoordsMatmul(i)' : `getB(${getB(allGlChannels, bRank)})`;\n  const getOutputCoordsSnippet = isBroadcast\n    ? ''\n    : `${coordsDataType} rc =\n          getOutputCoords(); int lastDim = rc.${allGlChannels[outRank - 1]}; rc.${allGlChannels[outRank - 1]} =\n          rc.${allGlChannels[outRank - 2]}; rc.${allGlChannels[outRank - 2]} = lastDim;\n      `;\n  const shaderSource = `\n            ${getBcastedSamplerForMatmulSnippet}\n            ${getBiasForMatmulSnippet}\n            ${activationFunction}\n            void main() {\n              ${getOutputCoordsSnippet}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${sharedDimIndex}; i++) {\n                vec4 a = ${getSamplerAInLoopSnippet};\n                vec4 b = ${getSamplerBInLoopSnippet};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${processBias}\n              ${applyActivation}\n              ${glsl.output} = value;\n            }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.packed },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nexport const createPackedMatmulProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  activationAttributes: InternalActivationAttributes,\n): ProgramInfoLoader => {\n  const metadata = createPackedMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);\n  return {\n    ...metadata,\n    get: () => createPackedMatmulProgramInfo(inferenceHandler, metadata, inputs, activationAttributes),\n  };\n};\n\nfunction getBcastSamplerForMatmul(\n  coordsDataType: string,\n  allGlChannels: readonly string[],\n  inputs: Tensor[],\n  outShape: readonly number[],\n): string {\n  let unpackedACoordsSnippet = [];\n  let unpackedBCoordsSnippet = [];\n\n  const inAShape = inputs[0].dims;\n  const inBShape = inputs[1].dims;\n\n  const inARank = inAShape.length;\n  const inBRank = inBShape.length;\n\n  const outRank = outShape.length;\n  const rankADiff = outRank - inARank;\n  const rankBDiff = outRank - inBRank;\n\n  unpackedACoordsSnippet = inAShape.map((_s, i) => `coords.${allGlChannels[i + rankADiff]}`);\n  unpackedACoordsSnippet[inARank - 1] = 'i*2';\n  unpackedACoordsSnippet.join(', ');\n  unpackedBCoordsSnippet = inBShape.map((_s, i) => `coords.${allGlChannels[i + rankBDiff]}`);\n  unpackedBCoordsSnippet[inBRank - 2] = 'i*2';\n  unpackedBCoordsSnippet.join(', ');\n\n  const broadcastADims = BroadcastUtil.getBroadcastDims(inAShape, outShape);\n  const broadcastBDims = BroadcastUtil.getBroadcastDims(inBShape, outShape);\n\n  const coordsASnippet = broadcastADims.map((d) => `coords.${allGlChannels[d + rankADiff]} = 0;`).join('\\n');\n  const coordsBSnippet = broadcastBDims.map((d) => `coords.${allGlChannels[d + rankBDiff]} = 0;`).join('\\n');\n  const swapDimSnippet = `int lastDim = coords.${allGlChannels[outRank - 1]};\n  coords.${allGlChannels[outRank - 1]} = coords.${allGlChannels[outRank - 2]};\n  coords.${allGlChannels[outRank - 2]} = lastDim;`;\n\n  const getBcastSamplerMatmulSource = `\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${coordsDataType} coords = getOutputCoords();\n  ${swapDimSnippet}\n  ${coordsASnippet}\n  vec4 outputValue = getA(${unpackedACoordsSnippet});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${coordsDataType} coords = getOutputCoords();\n  ${swapDimSnippet}\n  ${coordsBSnippet}\n  vec4 outputValue = getB(${unpackedBCoordsSnippet});\n  return outputValue;\n}`;\n\n  return getBcastSamplerMatmulSource;\n}\n\nfunction getA(allGlChannels: string[], rank: number): string {\n  let res = '';\n  for (let i = 0; i < rank - 2; i++) {\n    res += `rc.${allGlChannels[i]}, `;\n  }\n  res += `rc.${allGlChannels[rank - 2]}, ` + 'i*2';\n  return res;\n}\n\nfunction getB(allGlChannels: string[], rank: number): string {\n  let res = '';\n  for (let i = 0; i < rank - 2; i++) {\n    res += `rc.${allGlChannels[i]}, `;\n  }\n  res += 'i*2, ' + `rc.${allGlChannels[rank - 1]}`;\n  return res;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nimport { calculateOutputShape, ConvAttributes } from './conv';\nimport { createPackedIm2ColProgramInfoLoader } from './im2col-pack';\nimport { createPackedMatmulProgramInfoLoader } from './matmul-pack';\n\nexport const conv2DPackedPointwise = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvAttributes,\n): Tensor => {\n  const xshape = inputs[0].dims;\n  const kshape = inputs[1].dims;\n  const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n  const reshapedX = inferenceHandler.reshapePacked(inputs[0], [xshape[1], xshape[2] * xshape[3]]);\n  const reshapedK = inferenceHandler.reshapePacked(inputs[1], [kshape[0], kshape[1]]);\n\n  const matmulInputs = inputs.length > 2 ? [reshapedK, reshapedX, inputs[2]] : [reshapedK, reshapedX];\n  const matmulOutput = inferenceHandler.run(\n    createPackedMatmulProgramInfoLoader(inferenceHandler, matmulInputs, attributes),\n    matmulInputs,\n  );\n  return inferenceHandler.reshapePacked(matmulOutput, outputShape);\n};\n\nexport const conv2DPacked = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvAttributes,\n): Tensor => {\n  const xshape = inputs[0].dims;\n  const kshape = inputs[1].dims;\n  const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n\n  // run im2col\n  const im2colOutput = inferenceHandler.run(\n    createPackedIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),\n    [inputs[0]],\n  );\n\n  // reshape kernel\n  const kernelReshaped = inferenceHandler.reshapePacked(inputs[1], [kshape[0], kshape[1] * kshape[2] * kshape[3]]);\n\n  // run matmul\n  const matmulInputs = inputs.length === 3 ? [kernelReshaped, im2colOutput, inputs[2]] : [kernelReshaped, im2colOutput];\n  const matmulOutput = inferenceHandler.run(\n    createPackedMatmulProgramInfoLoader(inferenceHandler, matmulInputs, attributes),\n    matmulInputs,\n  );\n\n  // reshape output\n  const outputReshaped = inferenceHandler.reshapePacked(matmulOutput, outputShape);\n  return outputReshaped;\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { ConvAttributes } from './conv';\n\nconst createIm2ColProgramMetadata = (cacheHint: string) => ({\n  name: 'Im2Col',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n  cacheHint,\n});\n\nconst createIm2ColProgramInfo = (\n  _inferenceHandler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  x: Tensor,\n  w: Tensor,\n  outputShape: readonly number[],\n  attributes: ConvAttributes,\n): ProgramInfo => {\n  const xshape = x.dims;\n  const wshape = w.dims;\n\n  const rank = outputShape.length;\n  const im2colDims = calculateIm2ColDims(xshape, wshape, outputShape, 4);\n\n  const shaderSource = `\n        const int XC = ${xshape[1]};\n        const int XH = ${xshape[2]};\n        const int XW = ${xshape[3]};\n        const int KH = ${attributes.kernelShape[0]};\n        const int KW = ${attributes.kernelShape[1]};\n        const int dilationH = ${attributes.dilations[0]};\n        const int dilationW = ${attributes.dilations[1]};\n        const int strideH = ${attributes.strides[0]};\n        const int strideW = ${attributes.strides[1]};\n        const int padH = ${attributes.pads[0]};\n        const int padW = ${attributes.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${rank}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${xshape.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;\n  return {\n    ...metadata,\n    output: { dims: im2colDims, type: x.type, textureType: TextureType.packedLastDimension },\n    shaderSource,\n  };\n};\n\nexport const createIm2ColProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  x: Tensor,\n  w: Tensor,\n  outputShape: readonly number[],\n  attributes: ConvAttributes,\n): ProgramInfoLoader => {\n  const metadata = createIm2ColProgramMetadata(attributes.cacheKey);\n  return {\n    ...metadata,\n    get: () => createIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes),\n  };\n};\n\nexport const calculateIm2ColDims = (\n  inputShape: readonly number[],\n  kernelShape: readonly number[],\n  outputShape: readonly number[],\n  channels = 4,\n): number[] => [\n  outputShape[0],\n  outputShape[2],\n  outputShape[3],\n  Math.ceil((inputShape[1] * kernelShape[2] * kernelShape[3]) / channels),\n];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { getActivationSnippet, InternalActivationAttributes } from './fuse-utils';\nimport { calculateIm2ColDims } from './im2col';\n\nconst createDotProductProgramMetadata = (hasBias: boolean, attributes: InternalActivationAttributes) => ({\n  name: 'ConvDotProduct',\n  inputNames: hasBias ? ['Im2Col', 'K', 'B'] : ['Im2Col', 'K'],\n  inputTypes: hasBias\n    ? [TextureType.unpacked, TextureType.packedLastDimension, TextureType.unpacked]\n    : [TextureType.unpacked, TextureType.packedLastDimension],\n  cacheKey: attributes.activationCacheKey,\n});\n\nconst createDotProductProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  inputs: readonly Tensor[],\n  outputShape: number[],\n  attributes: InternalActivationAttributes,\n): ProgramInfo => {\n  const xshape = inputs[0].dims;\n  const kshape = inputs[1].dims;\n  const adjustedKernelShape = [kshape[0], Math.ceil((xshape[1] * kshape[2] * kshape[3]) / 4)];\n  const im2colShape = calculateIm2ColDims(xshape, kshape, outputShape);\n  const [kWidth, kHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    adjustedKernelShape,\n    TextureType.packedLastDimension,\n  );\n\n  const im2colStrides = ShapeUtil.computeStrides(im2colShape);\n  const [im2colWidth, im2colHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    im2colShape,\n    TextureType.packedLastDimension,\n  );\n  const rank = outputShape.length;\n\n  const initValue = inputs.length < 3 ? '0.0' : '_B(b)';\n  const sharedDim = Math.ceil((xshape[1] * kshape[2] * kshape[3]) / 4);\n  const { activationFunction, applyActivation } = getActivationSnippet(attributes);\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const shaderSource = `\n${activationFunction}\nfloat process(int indices[${rank}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${im2colStrides[0]} + im2col[1] * ${im2colStrides[1]} + im2col[2] * ${\n    im2colStrides[2]\n  };\n  int kernelOffset = indices[1] * ${adjustedKernelShape[1]};\n  float value = ${initValue};\n  for (int i = 0; i < ${sharedDim}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${im2colWidth}, ${im2colHeight});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${kWidth}, ${kHeight});\n    value += dot(${glsl.texture2D}(Im2Col, im2colCoords), ${glsl.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${applyActivation}\n  return value;\n}`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nexport const createDotProductProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  outputShape: number[],\n  attributes: InternalActivationAttributes,\n): ProgramInfoLoader => {\n  const metadata = createDotProductProgramMetadata(inputs.length > 2, attributes);\n  return {\n    ...metadata,\n    get: () => createDotProductProgramInfo(inferenceHandler, metadata, inputs, outputShape, attributes),\n  };\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { InferenceHandler } from '../../../backend';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { PoolConvUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nimport { createUnpackedGroupedConvProgramInfoLoader } from './conv-grouped';\nimport { conv2DPacked } from './conv-pack';\nimport { createDotProductProgramInfoLoader } from './dot-product';\nimport { InternalActivationAttributes, parseInternalActivationAttributes } from './fuse-utils';\nimport { createIm2ColProgramInfoLoader } from './im2col';\nimport { createMatmulProgramInfoLoader } from './matmul';\n\nexport const calculateOutputShape = (\n  inputShape: readonly number[],\n  kernelShape: readonly number[],\n  dilations: readonly number[],\n  adjustPads: readonly number[],\n  strides: readonly number[],\n): number[] => {\n  const batchSize = inputShape[0];\n  const inputSpatialShape = inputShape.slice(2);\n  const spatialRank = inputSpatialShape.length;\n  const outChannels = kernelShape[0];\n  const kernelSpatialShape = kernelShape.slice(2);\n  const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));\n  const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);\n  const outputSpatialShape = inputSpatialShapeWithPad.map((v, i) =>\n    Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i]),\n  );\n  const outputShape = [batchSize, outChannels].concat(...outputSpatialShape);\n  return outputShape;\n};\n\nexport interface ConvAttributes extends InternalActivationAttributes, AttributeWithCacheKey {\n  readonly autoPad: string;\n  readonly dilations: readonly number[];\n  readonly group: number;\n  readonly kernelShape: readonly number[];\n  readonly pads: readonly number[];\n  readonly strides: readonly number[];\n}\n\nexport const conv: OperatorImplementation<ConvAttributes> = (\n  inferenceHandler: InferenceHandler,\n  inputs: Tensor[],\n  attributes: ConvAttributes,\n): Tensor[] => {\n  validateInputs(inputs, attributes); // currently will fail if not conv2D\n  return conv2d(inferenceHandler, inputs, attributes);\n};\n\nconst conv2d: OperatorImplementation<ConvAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ConvAttributes,\n): Tensor[] => {\n  const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);\n  const packMode = inferenceHandler.session.pack;\n  const isPointwise = adjustedAttributes.kernelShape[0] === 1 && adjustedAttributes.kernelShape[1] === 1;\n  if (adjustedAttributes.group > 1) {\n    const result = inferenceHandler.run(\n      createUnpackedGroupedConvProgramInfoLoader(inferenceHandler, inputs, adjustedAttributes),\n      inputs,\n    );\n    return [result];\n  } else if (isPointwise && packMode) {\n    return [conv2DUnpackedPointwise(inferenceHandler, inputs, adjustedAttributes)];\n  } else if (packMode && inputs[0].dims.length === 4 && inputs[0].dims[0] === 1 && !isPointwise) {\n    return [conv2DPacked(inferenceHandler, inputs, adjustedAttributes)];\n  } else {\n    return [conv2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];\n  }\n};\n\nconst conv2DUnpackedPointwise = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvAttributes,\n): Tensor => {\n  const xshape = inputs[0].dims;\n  const kshape = inputs[1].dims;\n  const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n  const reshapedX = inferenceHandler.reshapeUnpacked(inputs[0], [xshape[1], xshape[2] * xshape[3]]);\n  const reshapedK = inferenceHandler.reshapeUnpacked(inputs[1], [kshape[0], kshape[1]]);\n\n  const matmulInputs = inputs.length > 2 ? [reshapedK, reshapedX, inputs[2]] : [reshapedK, reshapedX];\n  const matmulOutput = inferenceHandler.run(createMatmulProgramInfoLoader(matmulInputs, attributes), matmulInputs);\n  return inferenceHandler.reshapeUnpacked(matmulOutput, outputShape);\n};\n\nconst conv2DUnpacked = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvAttributes,\n): Tensor => {\n  const xshape = inputs[0].dims;\n  const kshape = inputs[1].dims;\n  const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n  const xIm2Col = inferenceHandler.run(\n    createIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),\n    [inputs[0]],\n  );\n\n  const dotProductInputs = inputs.length === 3 ? [xIm2Col, inputs[1], inputs[2]] : [xIm2Col, inputs[1]];\n  const output = inferenceHandler.run(\n    createDotProductProgramInfoLoader(inferenceHandler, inputs, outputShape, attributes),\n    dotProductInputs,\n  );\n  return output;\n};\n\nconst getAdjustedConvAttributes = <T extends ConvAttributes>(attributes: T, inputs: Tensor[]): T => {\n  const kernelShape = attributes.kernelShape.slice();\n  // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims\n  if (attributes.kernelShape.length === 0) {\n    for (let i = 2; i < inputs[1].dims.length; ++i) {\n      kernelShape.push(inputs[1].dims[i]);\n    }\n  }\n  const pads = attributes.pads.slice();\n  PoolConvUtil.adjustPadsBasedOnAutoPad(\n    inputs[0].dims,\n    attributes.strides,\n    attributes.dilations,\n    kernelShape,\n    pads,\n    attributes.autoPad,\n  );\n\n  // always return a new object so does not modify the original attributes\n  const newAttributes: T = Object.assign({}, attributes);\n  Object.assign(newAttributes, { kernelShape, pads, cacheKey: attributes.cacheKey });\n  return newAttributes;\n};\n\nexport const parseConvAttributes: OperatorInitialization<ConvAttributes> = (node: Graph.Node): ConvAttributes => {\n  const attributes = node.attributes;\n  const activationAttributes = parseInternalActivationAttributes(attributes);\n  // TODO : Make this generic enough to compute default attributes for multi-dimensional conv\n  const autoPad = attributes.getString('auto_pad', 'NOTSET');\n  const dilations = attributes.getInts('dilations', [1, 1]);\n  const group = attributes.getInt('group', 1);\n  const kernelShape = attributes.getInts('kernel_shape', []);\n  const pads = attributes.getInts('pads', [0, 0, 0, 0]);\n  const strides = attributes.getInts('strides', [1, 1]);\n\n  return createAttributeWithCacheKey({\n    autoPad,\n    dilations,\n    group,\n    kernelShape,\n    pads,\n    strides,\n    ...activationAttributes,\n  });\n};\n\nconst validateInputs = (inputs: Tensor[], attributes: ConvAttributes): void => {\n  // Refer to the below link for all input checks\n  // https://github.com/onnx/onnx/blob/main/docs/Operators.md#Conv\n  if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {\n    throw new Error('Conv requires 2 or 3 inputs');\n  }\n\n  // TODO : Need to add support for multi-dimensional conv\n  if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {\n    throw new Error('currently only support 2-dimensional conv');\n  }\n\n  // FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\n  const dataChannel = inputs[0].dims[1];\n  const filterInChannel = inputs[1].dims[1] * attributes.group;\n  if (dataChannel !== filterInChannel) {\n    throw new Error('FILTER_IN_CHANNEL should be equal to DATA_CHANNEL');\n  }\n\n  // if bias is provided it should be 1D and the number of elements should be equal to the number of feature maps\n  if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {\n    throw new Error('invalid bias');\n  }\n\n  const spatialRank = inputs[0].dims.length - 2;\n  // wrong dilations dimension\n  if (attributes.dilations.length !== spatialRank) {\n    throw new Error(`dilations should be ${spatialRank}D`);\n  }\n\n  // Wrong strides dimension\n  if (attributes.strides.length !== spatialRank) {\n    throw new Error(`strides should be ${spatialRank}D`);\n  }\n\n  // Wrong pads dimension\n  if (attributes.pads.length !== spatialRank * 2) {\n    throw new Error(`pads should be ${spatialRank * 2}D`);\n  }\n\n  // if kernelShape is specified, it's data length must be 2 less than dims length of the weights tensor\n  // (the first 2 dims are batch_size and channels)\n  if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {\n    throw new Error('invalid kernel shape');\n  }\n\n  // TODO : Need to add support for float64\n  if (inputs[0].type !== 'float32' || inputs[1].type !== 'float32') {\n    throw new Error('Conv input(X,W) should be float tensor');\n  }\n\n  if (inputs.length === 3 && inputs[2].type !== 'float32') {\n    throw new Error('Conv input(bias) should be float tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { InferenceHandler } from '../../../backend';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { ConvAttributes } from './conv';\nimport { getActivationSnippet, parseInternalActivationAttributes } from './fuse-utils';\n\nconst computeTotalPad = (\n  inDim: number,\n  stride: number,\n  adj: number,\n  kernel: number,\n  dilation: number,\n  outSize: number,\n) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;\n\nconst distributePadding = (totalPad: number, autoPad: string, pads: number[], head: number, tail: number) => {\n  const smallPad = Math.floor(totalPad / 2);\n  if (autoPad === 'SAME_UPPER') {\n    pads[head] = smallPad;\n    pads[tail] = totalPad - smallPad;\n  } else if (autoPad === 'SAME_LOWER') {\n    pads[head] = totalPad - smallPad;\n    pads[tail] = smallPad;\n  }\n};\n\nconst calculateOutputShapeAndPads = (\n  inputShape: readonly number[],\n  kernelShape: readonly number[],\n  dilations: readonly number[],\n  autoPad: string,\n  pads: number[],\n  strides: readonly number[],\n  outputPadding: readonly number[],\n  outputShape: number[],\n) => {\n  const spatialRank = inputShape.length - 2;\n  const updateShape = outputShape.length === 0;\n  for (let i = 0; i < spatialRank; ++i) {\n    const outSize = updateShape ? inputShape[i + 2] * strides[i] : outputShape[i];\n    const totalPad = computeTotalPad(inputShape[i + 2], strides[i], pads[i], kernelShape[i], dilations[i], outSize);\n    distributePadding(totalPad, autoPad, pads, i, i + spatialRank);\n    if (updateShape) {\n      outputShape.push(\n        strides[i] * (inputShape[i + 2] - 1) +\n          outputPadding[i] +\n          (kernelShape[i] - 1) * dilations[i] +\n          1 -\n          pads[i] -\n          pads[i + spatialRank],\n      );\n    }\n  }\n};\n\nexport interface ConvTransposeAttributes extends ConvAttributes {\n  readonly outputPadding: readonly number[];\n  readonly outputShape: readonly number[];\n}\n\nexport const convTranspose: OperatorImplementation<ConvTransposeAttributes> = (\n  inferenceHandler: InferenceHandler,\n  inputs: Tensor[],\n  attributes: ConvTransposeAttributes,\n): Tensor[] => {\n  validateInputs(inputs, attributes); // currently will fail if not convTranspose2D\n  return convTranspose2d(inferenceHandler, inputs, attributes);\n};\n\nconst convTranspose2d: OperatorImplementation<ConvTransposeAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ConvTransposeAttributes,\n): Tensor[] => {\n  const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, inputs);\n  return [convTranspose2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];\n};\n\nconst createConvTransposeProgramMetadata = (hasBias: boolean, cacheHint: string) => ({\n  name: 'ConvTranspose',\n  inputNames: hasBias ? ['X', 'W', 'B'] : ['X', 'W'],\n  inputTypes: hasBias\n    ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked]\n    : [TextureType.unpacked, TextureType.unpacked],\n  cacheHint,\n});\n\nconst createUnpackedConvTransposeProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  metadata: ProgramMetadata,\n  attributes: ConvTransposeAttributes,\n): ProgramInfo => {\n  const hasBias = inputs.length > 2;\n  const valueInit = hasBias ? 'getB(output_channel)' : '0.0';\n  const xShape = inputs[0].dims;\n  const wShape = inputs[1].dims;\n  const outputChannelsPerGroup = wShape[1];\n  const inputChannelsPerGroup = wShape[0] / attributes.group;\n  const outputShape = [inputs[0].dims[0], inputs[1].dims[1] * attributes.group, ...attributes.outputShape];\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const { activationFunction, applyActivation } = getActivationSnippet(attributes);\n\n  const shaderSource = `\n  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});\n  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});\n  ${activationFunction}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${outputChannelsPerGroup};\n    int wOutChannel = output_channel - group_id * ${outputChannelsPerGroup};\n\n    float value = ${valueInit};\n    for (int inChannelOffset = 0; inChannelOffset < ${inputChannelsPerGroup}; inChannelOffset++) {\n      int input_channel = group_id * ${inputChannelsPerGroup} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${wShape[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${wShape[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${attributes.dilations[0]}, wHOff * ${attributes.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${xShape[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${xShape[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${applyActivation}\n    ${glsl.output} = vec4(value, .0, .0, .0);\n  }\n`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nconst createUnpackedConvTransposeProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvTransposeAttributes,\n): ProgramInfoLoader => {\n  const metadata = createConvTransposeProgramMetadata(inputs.length > 2, attributes.cacheKey);\n  return {\n    ...metadata,\n    get: () => createUnpackedConvTransposeProgramInfo(inferenceHandler, inputs, metadata, attributes),\n  };\n};\n\nconst convTranspose2DUnpacked = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvTransposeAttributes,\n): Tensor => {\n  const result = inferenceHandler.run(\n    createUnpackedConvTransposeProgramInfoLoader(inferenceHandler, inputs, attributes),\n    inputs,\n  );\n  return result;\n};\n\nconst getAdjustedConvTransposeAttributes = <T extends ConvTransposeAttributes>(attributes: T, inputs: Tensor[]): T => {\n  const kernelShape = attributes.kernelShape.slice();\n  // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims\n  if (attributes.kernelShape.length === 0) {\n    for (let i = 2; i < inputs[1].dims.length; ++i) {\n      kernelShape.push(inputs[1].dims[i]);\n    }\n  }\n\n  const pads = attributes.pads.slice();\n  const outputShape = attributes.outputShape.slice();\n  const inputShape = inputs[0].dims;\n  // If outputShape is not specified in the attributes of this op, infer it from the parameters\n  // Similarly, automatically infer pads if not specified\n  calculateOutputShapeAndPads(\n    inputShape,\n    kernelShape,\n    attributes.dilations,\n    attributes.autoPad,\n    pads,\n    attributes.strides,\n    attributes.outputPadding,\n    outputShape,\n  );\n\n  // always return a new object so does not modify the original attributes\n  const newAttributes: T = Object.assign({}, attributes);\n  Object.assign(newAttributes, { kernelShape, pads, outputShape, cacheKey: attributes.cacheKey });\n  return newAttributes;\n};\n\nexport const parseConvTransposeAttributes: OperatorInitialization<ConvTransposeAttributes> = (\n  node: Graph.Node,\n): ConvTransposeAttributes => {\n  const attributes = node.attributes;\n  const activationAttributes = parseInternalActivationAttributes(attributes);\n  // TODO : Make this generic enough to compute default attributes for multi-dimensional conv\n  const autoPad = attributes.getString('auto_pad', 'NOTSET');\n  const dilations = attributes.getInts('dilations', [1, 1]);\n  const group = attributes.getInt('group', 1);\n  const kernelShape = attributes.getInts('kernel_shape', []);\n  const outputPadding = attributes.getInts('output_padding', [0, 0]);\n  const outputShape = attributes.getInts('output_shape', []);\n  const pads = attributes.getInts('pads', [0, 0, 0, 0]);\n  const strides = attributes.getInts('strides', [1, 1]);\n\n  return createAttributeWithCacheKey({\n    autoPad,\n    dilations,\n    group,\n    kernelShape,\n    outputPadding,\n    outputShape,\n    pads,\n    strides,\n    ...activationAttributes,\n  });\n};\n\nconst validateInputs = (inputs: Tensor[], attributes: ConvTransposeAttributes): void => {\n  // Refer to the below link for all input checks\n  // https://github.com/onnx/onnx/blob/main/docs/Operators.md#Conv\n  if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {\n    throw new Error('Conv requires 2 or 3 inputs');\n  }\n\n  // TODO : Need to add support for multi-dimensional conv\n  if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {\n    throw new Error('currently only support 2-dimensional conv');\n  }\n\n  // FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\n  const dataChannel = inputs[0].dims[1];\n  const filterInChannel = inputs[1].dims[0];\n  if (dataChannel !== filterInChannel) {\n    throw new Error('FILTER_IN_CHANNEL should be equal to DATA_CHANNEL');\n  }\n\n  const featureMaps = inputs[1].dims[1] * attributes.group;\n\n  // if bias is provided it should be 1D and the number of elements should be equal to the number of feature maps\n  if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {\n    throw new Error('invalid bias');\n  }\n\n  const spatialRank = inputs[0].dims.length - 2;\n  // wrong dilations dimension\n  if (attributes.dilations.length !== spatialRank) {\n    throw new Error(`dilations should be ${spatialRank}D`);\n  }\n\n  // Wrong strides dimension\n  if (attributes.strides.length !== spatialRank) {\n    throw new Error(`strides should be ${spatialRank}D`);\n  }\n\n  // Wrong pads dimension\n  if (attributes.pads.length !== spatialRank * 2) {\n    throw new Error(`pads should be ${spatialRank * 2}D`);\n  }\n\n  // Wrong output padding dimension\n  if (attributes.outputPadding.length !== spatialRank) {\n    throw new Error(`output_padding should be ${spatialRank}D`);\n  }\n\n  // if kernelShape is specified, it's data length must be 2 less than dims length of the weights tensor\n  // (the first 2 dims are batch_size and channels)\n  if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {\n    throw new Error('invalid kernel shape');\n  }\n\n  // as with kernelShape, must have same number of spatial dims as input\n  if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {\n    throw new Error('invalid output shape');\n  }\n\n  // TODO : Need to add support for float64\n  if (inputs[0].type !== 'float32' || inputs[1].type !== 'float32') {\n    throw new Error('ConvTranspose input(X,W) should be float tensor');\n  }\n\n  if (inputs.length === 3 && inputs[2].type !== 'float32') {\n    throw new Error('ConvTranspose input(bias) should be float tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nexport interface TransposeAttributes extends AttributeWithCacheKey {\n  readonly perm: number[];\n}\n\nconst transposeProgramMetadata = {\n  name: 'Transpose',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const transpose: OperatorImplementation<TransposeAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: TransposeAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const output = inferenceHandler.run(\n    {\n      ...transposeProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createTransposeProgramInfo(inferenceHandler, inputs[0], attributes.perm),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseTransposeAttributes: OperatorInitialization<TransposeAttributes> = (\n  node: Graph.Node,\n): TransposeAttributes => createAttributeWithCacheKey({ perm: node.attributes.getInts('perm', []) });\n\nconst createTransposeProgramInfo = (\n  _inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  perm: number[],\n): ProgramInfo => {\n  const inputShape = input.dims;\n  perm = getAdjustedPerm(inputShape, perm);\n  const unpackedOutputShape = getOutputShape(inputShape, perm);\n  const rank = inputShape.length;\n  // A dims=[${inputs[0].dims.toString()}]\n  // out Dims=[${unpackedOutputShape.toString()}]\n  // based on perm=[${perm.toString()}]\n  const shaderSource = `\n      ${getPermFunctionBody('perm', perm, rank)}\n      float process(int indices[${rank}]) {\n        int a[${rank}];\n        perm(a, indices);\n        return _A(a);\n      }`;\n  return {\n    ...transposeProgramMetadata,\n    output: { dims: unpackedOutputShape, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst getAdjustedPerm = (inputShape: readonly number[], perm: number[]): number[] => {\n  if (perm && perm.length !== inputShape.length) {\n    perm = [...inputShape.keys()].reverse();\n  }\n  return perm;\n};\n\nconst getOutputShape = (inputShape: readonly number[], perm: number[]): readonly number[] => {\n  perm = getAdjustedPerm(inputShape, perm);\n  return ShapeUtil.sortBasedOnPerm(inputShape, perm);\n};\n\nconst getPermFunctionBody = (name: string, perm: number[], rank: number): string => {\n  const reverseFunc = [];\n  reverseFunc.push(`void ${name}(out int a[${rank}], int src[${rank}]) {`);\n  for (let i = 0; i < rank; ++i) {\n    reverseFunc.push(`\\ta[${perm[i]}]=src[${i}];`);\n  }\n  reverseFunc.push('\\t}');\n  return reverseFunc.join('\\n');\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Transpose requires 1 input.');\n  }\n\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('input should be float tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nimport { transpose, TransposeAttributes } from './transpose';\n\nexport interface DepthToSpaceAttributes {\n  mode: 'DCR' | 'CRD';\n  blocksize: number;\n}\n\nexport const depthToSpace: OperatorImplementation<DepthToSpaceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: DepthToSpaceAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const blocksize = attributes.blocksize;\n  const blocksizeSqr = blocksize * blocksize;\n  const transposePerm = attributes.mode === 'DCR' ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];\n  const firstReshapeShape =\n    attributes.mode === 'DCR'\n      ? [\n          inputs[0].dims[0],\n          blocksize,\n          blocksize,\n          inputs[0].dims[1] / blocksizeSqr,\n          inputs[0].dims[2],\n          inputs[0].dims[3],\n        ]\n      : [\n          inputs[0].dims[0],\n          inputs[0].dims[1] / blocksizeSqr,\n          blocksize,\n          blocksize,\n          inputs[0].dims[2],\n          inputs[0].dims[3],\n        ];\n\n  // const transpose = new WebGLTranspose();\n  // const attributes = new Attribute(undefined);\n  // attributes.set('perm', 'ints', transposePerm);\n  // transpose.initialize(attributes);\n\n  // First reshape\n  const firstReshapedTensor = inferenceHandler.reshapeUnpacked(inputs[0], firstReshapeShape);\n\n  // transpose\n  const transposeAttributes: TransposeAttributes = { perm: transposePerm, cacheKey: `${transposePerm}` };\n  const [transposeOutput] = transpose(inferenceHandler, [firstReshapedTensor], transposeAttributes);\n\n  // Second reshape\n  const secondReshapeShape = [\n    inputs[0].dims[0],\n    inputs[0].dims[1] / blocksizeSqr,\n    inputs[0].dims[2] * blocksize,\n    inputs[0].dims[3] * blocksize,\n  ];\n  const result = inferenceHandler.reshapeUnpacked(transposeOutput, secondReshapeShape);\n  return [result];\n};\n\nexport const parseDepthToSpaceAttributes: OperatorInitialization<DepthToSpaceAttributes> = (\n  node: Graph.Node,\n): DepthToSpaceAttributes => {\n  // processing node attributes\n  const blocksize = node.attributes.getInt('blocksize');\n  if (blocksize < 1) {\n    throw new Error(`blocksize must be >= 1, but got : ${blocksize} for DepthToSpace`);\n  }\n  const mode = node.attributes.getString('mode', 'DCR');\n  if (mode !== 'DCR' && mode !== 'CRD') {\n    throw new Error(`unrecognized mode: ${mode} for DepthToSpace`);\n  }\n  return { mode, blocksize };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (inputs.length !== 1) {\n    throw new Error(`DepthToSpace expect 1 inputs, but got ${inputs.length}`);\n  }\n\n  // Input has to be a 4-D tensor\n  // TODO: Support string depth-to-space.\n  if (inputs[0].type === 'string' || inputs[0].dims.length !== 4) {\n    throw new TypeError('DepthToSpace input should be a 4-D numeric tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nexport const flatten: OperatorImplementation<number> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  axis: number,\n): Tensor[] => {\n  validateInputs(inputs, axis);\n\n  const outputDims = ShapeUtil.flattenShape(inputs[0].dims, axis);\n  return [inferenceHandler.reshapeUnpacked(inputs[0], outputDims)];\n};\n\nexport const parseFlattenAttributes: OperatorInitialization<number> = (node: Graph.Node): number =>\n  node.attributes.getInt('axis', 1); // default axis is 1\n\nconst validateInputs = (inputs: Tensor[], axis: number): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Flatten requires 1 input.');\n  }\n\n  const r = inputs[0].dims.length;\n  if (r === 0) {\n    throw new Error('scalar tensor is not supported.');\n  }\n\n  if (axis < -r || axis > r) {\n    throw new Error('Invalid axis');\n  }\n\n  // TODO: Support string type\n  if (inputs[0].type === 'string') {\n    throw new Error('string tensor is not supported.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceHandler } from './backend';\nimport { Graph } from './graph';\nimport { Tensor } from './tensor';\n\nexport type OperatorImplementation<T> = (inferenceHandler: InferenceHandler, inputs: Tensor[], context: T) => Tensor[];\nexport type OperatorInitialization<T> = (node: Graph.Node, graph: Graph) => T;\n\nexport interface Operator {\n  readonly impl: OperatorImplementation<unknown>;\n  readonly context: Graph.Node | unknown;\n}\n\nexport const NUMBER_TYPES: readonly Tensor.DataType[] = [\n  'float32',\n  'float64',\n  'int32',\n  'int16',\n  'int8',\n  'uint16',\n  'uint32',\n  'uint8',\n];\nexport const INT_TYPES: readonly Tensor.DataType[] = ['int32', 'int16', 'int8', 'uint16', 'uint32', 'uint8'];\nexport const FLOAT_TYPES: readonly Tensor.DataType[] = ['float32', 'float64'];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { NUMBER_TYPES, OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\ninterface GatherAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n}\n\nexport const gather: OperatorImplementation<GatherAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: GatherAttributes,\n): Tensor[] => {\n  validateInputs(inputs, attributes.axis);\n  const output = inferenceHandler.run(createGatherProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n  return [output];\n};\n\nexport const parseGatherAttributes: OperatorInitialization<GatherAttributes> = (node: Graph.Node): GatherAttributes =>\n  createAttributeWithCacheKey({ axis: node.attributes.getInt('axis', 0) });\n\nconst gatherProgramMetadata = {\n  name: 'Gather',\n  inputNames: ['A', 'B'],\n  inputTypes: [TextureType.unpacked, TextureType.unpacked],\n};\n\nconst createGatherProgramInfo = (\n  _handler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  axis: number,\n): ProgramInfo => {\n  const inputShape = inputs[0].dims.slice();\n  const indexDataShape = inputs[1].dims.slice();\n  const outputShape = new Array(inputShape.length + indexDataShape.length - 1);\n\n  axis = ShapeUtil.normalizeAxis(axis, inputShape.length);\n  const indexCopyOps: string[] = [];\n  for (let i = 0; i < outputShape.length; i++) {\n    // outputShape is divided into three parts: A, B, C\n    // |0        axis|  axis + indexDataShape.length |          end|\n    // |     A       |             B                 |      C      |\n    //\n    // inputIdx: [A, inputs[1][B], C]\n    if (i < axis) {\n      // A\n      outputShape[i] = inputShape[i];\n      indexCopyOps.push(`inputIdx[${i}] = outputIdx[${i}];`);\n    } else {\n      if (i < axis + indexDataShape.length) {\n        // B\n        outputShape[i] = indexDataShape[i - axis];\n        indexCopyOps.push(`indexDataIdx[${i - axis}] = outputIdx[${i}];`);\n      } else {\n        // C\n        outputShape[i] = inputShape[i - indexDataShape.length + 1]; // skip 1 for axis\n        indexCopyOps.push(`inputIdx[${i - indexDataShape.length + 1}] = outputIdx[${i}];`);\n      }\n    }\n  }\n\n  const orank = outputShape.length || 1;\n  const irank = inputShape.length;\n  const iDrank = indexDataShape.length || 1;\n  const shaderSource = `\n      float process(int outputIdx[${orank}]) {\n        int inputIdx[${irank}];\n        int indexDataIdx[${iDrank}];\n        indexDataIdx[0] = 0;\n        ${indexCopyOps.join('\\n        ')}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${axis}] = idx < 0 ? idx + ${inputShape[axis]} : idx;\n        return _A(inputIdx);\n      }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst createGatherProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: GatherAttributes,\n): ProgramInfoLoader => {\n  const metadata = { ...gatherProgramMetadata, cacheHint: attributes.cacheKey };\n  return { ...metadata, get: () => createGatherProgramInfo(handler, metadata, inputs, attributes.axis) };\n};\n\nconst validateInputs = (inputs: Tensor[], axis: number): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Gather requires 2 inputs.');\n  }\n  const tensorRank = inputs[0].dims.length;\n  if (tensorRank < 1) {\n    throw new Error('Invalid input shape.');\n  }\n  if (axis < -tensorRank || axis > tensorRank - 1) {\n    throw new Error('Invalid axis.');\n  }\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invaid input type.');\n  }\n  if (inputs[1].type !== 'int32' && inputs[1].type !== 'int16') {\n    throw new Error('Invaid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { GemmUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nexport interface GemmAttributes extends AttributeWithCacheKey {\n  transA: boolean;\n  transB: boolean;\n  alpha: number;\n  beta: number;\n  isOptionalC: boolean; // in opset 11, C becomes optional\n}\n\nexport const gemm: OperatorImplementation<GemmAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: GemmAttributes,\n): Tensor[] => {\n  validateInputs(inputs, attributes);\n  const output = inferenceHandler.run(createGemmProgramInfoLoader(inputs, attributes), inputs);\n  return [output];\n};\n\nconst parseGemmAttributes = (node: Graph.Node, isOptionalC: boolean): GemmAttributes => {\n  const transA = node.attributes.getInt('transA', 0) !== 0;\n  const transB = node.attributes.getInt('transB', 0) !== 0;\n  const alpha = node.attributes.getFloat('alpha', 1.0);\n  const beta = node.attributes.getFloat('beta', 1.0);\n  return createAttributeWithCacheKey({ transA, transB, alpha, beta, isOptionalC });\n};\n\nexport const parseGemmAttributesV7: OperatorInitialization<GemmAttributes> = (node: Graph.Node): GemmAttributes =>\n  parseGemmAttributes(node, false);\n\nexport const parseGemmAttributesV11: OperatorInitialization<GemmAttributes> = (node: Graph.Node): GemmAttributes =>\n  parseGemmAttributes(node, true);\n\nconst createGemmProgramInfoLoader = (inputs: Tensor[], attributes: GemmAttributes): ProgramInfoLoader => {\n  const metadata = {\n    name: 'Gemm',\n    inputNames: inputs.length === 3 ? ['A', 'B', 'C'] : ['A', 'B'],\n    inputTypes:\n      inputs.length === 3\n        ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked]\n        : [TextureType.unpacked, TextureType.unpacked],\n    key: attributes.cacheKey,\n  };\n\n  return { ...metadata, get: () => createGemmProgramInfo(metadata, inputs, attributes) };\n};\n\nconst createGemmProgramInfo = (\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  attributes: GemmAttributes,\n): ProgramInfo => {\n  const aShape = inputs[0].dims.slice();\n  const bShape = inputs[1].dims.slice();\n  const [M, N] = GemmUtil.getShapeOfGemmResult(\n    aShape,\n    attributes.transA,\n    bShape,\n    attributes.transB,\n    inputs.length === 3 ? inputs[2].dims : undefined,\n  );\n  const outputShape = [M, N];\n  if (!outputShape) {\n    throw new Error(\"Can't use gemm on the given tensors\");\n  }\n  let sharedDim = aShape[aShape.length - 1];\n  let line = '';\n  if (attributes.transA) {\n    sharedDim = aShape[0];\n  }\n  if (attributes.transA && attributes.transB) {\n    line = 'value += _A_T(a) * _B_T(b);';\n  } else if (attributes.transA && !attributes.transB) {\n    line = 'value += _A_T(a) * _B(b);';\n  } else if (!attributes.transA && attributes.transB) {\n    line = 'value += _A(a) * _B_T(b);';\n  } else if (!attributes.transA && !attributes.transB) {\n    line = 'value += _A(a) * _B(b);';\n  }\n  const rank = outputShape.length;\n  const declareC = inputs.length === 3 ? `int c[${inputs[2].dims.length}];` : '';\n  const broadcastC = inputs.length === 3 ? 'bcastIndices_C(indices, c);' : '';\n  const calculateC = inputs.length === 3 ? 'value += beta * _C(c);' : '';\n  const shaderSource = `\n      float process(int indices[${rank}]) {\n          int a[${rank}];\n          int b[${rank}];\n          ${declareC}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${broadcastC}\n\n          float value = 0.0;\n          for (int k=0; k<${sharedDim}; ++k) {\n              a[${rank - 1}] = k;\n              b[${rank - 2}] = k;\n              ${line}\n          }\n\n          value = value * alpha;\n          ${calculateC}\n          return value;\n      }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    variables: [\n      { name: 'alpha', type: 'float', data: attributes.alpha },\n      { name: 'beta', type: 'float', data: attributes.beta },\n    ],\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[], attributes: GemmAttributes): void => {\n  if (!inputs) {\n    throw new Error('Input is missing');\n  }\n  if (attributes.isOptionalC && (inputs.length < 2 || inputs.length > 3)) {\n    throw new Error('Invaid input shape.');\n  }\n  if (!attributes.isOptionalC && inputs.length !== 3) {\n    throw new Error('Gemm requires 3 inputs');\n  }\n\n  // 'C' can be of dimensionality 1 or 2 only\n  if (inputs.length === 3 && inputs[2].dims.length !== 1 && inputs[2].dims.length !== 2) {\n    throw new Error('Invalid input shape of C');\n  }\n\n  if (\n    (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') ||\n    (inputs[1].type !== 'float32' && inputs[1].type !== 'float64') ||\n    (inputs.length === 3 && inputs[2].type !== 'float32' && inputs[2].type !== 'float64')\n  ) {\n    throw new Error('Invalid input type.');\n  }\n\n  if (inputs[0].type !== inputs[1].type || (inputs.length === 3 && inputs[0].type !== inputs[2].type)) {\n    throw new Error('Input types are mismatched');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nexport interface ImageScalerAttributes extends AttributeWithCacheKey {\n  scale: number;\n  bias: number[];\n}\n\nexport const imageScaler: OperatorImplementation<ImageScalerAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ImageScalerAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const output = inferenceHandler.run(createImageScalerProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n  return [output];\n};\n\nexport const parseImageScalerAttributes: OperatorInitialization<ImageScalerAttributes> = (\n  node: Graph.Node,\n): ImageScalerAttributes => {\n  const scale = node.attributes.getFloat('scale');\n  const bias = node.attributes.getFloats('bias');\n  return createAttributeWithCacheKey({ scale, bias });\n};\n\nconst imageScalerProgramMetadata = {\n  name: 'ImageScaler',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nconst createImageScalerProgramInfo = (\n  _handler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  attributes: ImageScalerAttributes,\n): ProgramInfo => {\n  const outputShape = inputs[0].dims.slice();\n  const rank = outputShape.length;\n  const getBiasMethod = createGetBiasMethod(attributes.bias.length);\n  const shaderSource = `\n      ${getBiasMethod}\n      float process(int indices[${rank}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    variables: [\n      { name: 'bias', type: 'float', arrayLength: attributes.bias.length, data: attributes.bias },\n      { name: 'scale', type: 'float', data: attributes.scale },\n    ],\n    shaderSource,\n  };\n};\n\nconst createImageScalerProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ImageScalerAttributes,\n): ProgramInfoLoader => {\n  const metadata = { ...imageScalerProgramMetadata, cacheHint: attributes.cacheKey };\n  return { ...metadata, get: () => createImageScalerProgramInfo(handler, metadata, inputs, attributes) };\n};\n\nconst createGetBiasMethod = (numChannels: number): string => {\n  const codeLines: string[] = [`float getBias(float bias[${numChannels}], int channel) {`];\n  for (let i = 0; i < numChannels; ++i) {\n    if (i === 0) {\n      codeLines.push('\\t' + `if (channel == ${i}) { return bias[${i}]; }`);\n    } else if (i === numChannels - 1) {\n      codeLines.push('\\t' + `else { return bias[${i}]; }`);\n    } else {\n      codeLines.push('\\t' + `else if (channel == ${i}) { return bias[${i}]; }`);\n    }\n  }\n  codeLines.push('\\t' + '}');\n  return codeLines.join('\\n');\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('ImageScaler requires 1 input.');\n  }\n  if (inputs[0].dims.length !== 4) {\n    throw new Error('Invalid input shape.');\n  }\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nexport const instanceNormalization: OperatorImplementation<number> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  epsilon: number,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  const meanAndVariance = inferenceHandler.run(createMeanAndVarianceProgramInfoLoader(inputs[0]), inputs);\n  const output = inferenceHandler.run(\n    createComputeOutputProgramInfoLoader(inferenceHandler, inputs[0], epsilon, meanAndVariance.dims),\n    [inputs[0], meanAndVariance, inputs[1], inputs[2]],\n  );\n  return [output];\n};\n\nexport const parseInstanceNormalizationAttributes: OperatorInitialization<number> = (node: Graph.Node): number =>\n  node.attributes.getFloat('epsilon', 1e-5);\n\nconst meanAndVarianceProgramMetadata = {\n  name: 'InstanceNormalization_MeanAndVariance',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nconst createMeanAndVarianceProgramInfo = (metadata: ProgramMetadata, input: Tensor): ProgramInfo => {\n  const xDims = input.dims.slice();\n  const channel = xDims[1];\n  const channelSize = xDims[2] * xDims[3];\n  const outputShape = [xDims[0], channel];\n\n  const shaderSource = `\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${xDims[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${xDims[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${channelSize});\n        temp = 0.0;\n        for(int a2=0; a2<${xDims[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${xDims[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${channelSize});\n\n        return v;\n      }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: input.type, textureType: TextureType.packedLastDimension },\n    shaderSource,\n  };\n};\n\nconst createMeanAndVarianceProgramInfoLoader = (input: Tensor): ProgramInfoLoader => ({\n  ...meanAndVarianceProgramMetadata,\n  get: () => createMeanAndVarianceProgramInfo(meanAndVarianceProgramMetadata, input),\n});\n\nconst computeOutputProgramMetadata = {\n  name: 'InstanceNormalization_ComputeOutput',\n  inputNames: ['X', 'MeanAndVariance', 'Scale', 'B'],\n  inputTypes: [TextureType.unpacked, TextureType.packedLastDimension, TextureType.unpacked, TextureType.unpacked],\n};\n\nconst createComputeOutputProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  input: Tensor,\n  epsilon: number,\n  meanAndVarianceShape: readonly number[],\n): ProgramInfo => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    meanAndVarianceShape,\n    TextureType.packedLastDimension,\n  );\n  const [meanAndVarianceWidth, meanAndVarianceHeight] = [textureWidth / 4, textureHeight];\n  const shaderSource = `\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${meanAndVarianceWidth}, ${meanAndVarianceHeight});\n        return ${glsl.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;\n  return {\n    ...metadata,\n    output: { dims: input.dims, type: input.type, textureType: TextureType.unpacked },\n    variables: [{ name: 'epsilon', type: 'float', data: epsilon }],\n    shaderSource,\n  };\n};\n\nconst createComputeOutputProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  epsilon: number,\n  meanAndVarianceShape: readonly number[],\n): ProgramInfoLoader => {\n  const metadata = { ...computeOutputProgramMetadata, cacheHint: `${epsilon}` };\n  return {\n    ...metadata,\n    get: () => createComputeOutputProgramInfo(inferenceHandler, metadata, input, epsilon, meanAndVarianceShape),\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 3) {\n    throw new Error('InstanceNormalization requires 3 inputs.');\n  }\n\n  const X = inputs[0];\n  const scale = inputs[1];\n  const B = inputs[2];\n\n  // input should at least have three dimensions - N,C,dim1,...,dimn\n  // other inputs can have only one dimensions\n  if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1) {\n    throw new Error('Invalid input shape.');\n  }\n  if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1]) {\n    throw new Error('Input shapes are mismatched.');\n  }\n  if (\n    (X.type !== 'float32' && X.type !== 'float64') ||\n    (scale.type !== 'float32' && scale.type !== 'float64') ||\n    (B.type !== 'float32' && B.type !== 'float64')\n  ) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs[0].dims.length !== 4) {\n    throw new Error('Only support 4-D input shape.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, TextureType } from '../types';\n\nexport interface LrnAttributes extends AttributeWithCacheKey {\n  alpha: number;\n  beta: number;\n  bias: number;\n  size: number;\n}\n\nexport const lrn: OperatorImplementation<LrnAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: LrnAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  // if (inferenceHandler.session.pack) {\n  //   return [inferenceHandler.run(createPackedLrnProgramInfoLoader(inferenceHandler, inputs, attributes),\n  //   inputs)];\n  // } else {\n  return [inferenceHandler.run(createLrnProgramInfoLoader(inputs, attributes), inputs)];\n  //}\n};\n\nexport const parseLrnAttributes: OperatorInitialization<LrnAttributes> = (node: Graph.Node): LrnAttributes => {\n  const alpha = node.attributes.getFloat('alpha', 0.0001);\n  const beta = node.attributes.getFloat('beta', 0.75);\n  const bias = node.attributes.getFloat('bias', 1.0);\n  const size = node.attributes.getInt('size');\n\n  return createAttributeWithCacheKey({ alpha, beta, bias, size });\n};\n\nconst lrnProgramMetadata = {\n  name: 'LRN',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nfunction createLrnProgramInfo(inputs: Tensor[], attributes: LrnAttributes): ProgramInfo {\n  const C = inputs[0].dims[1];\n  const rank = inputs[0].dims.length;\n  const from = -Math.floor((attributes.size - 1) / 2);\n  const to = Math.ceil((attributes.size - 1) / 2);\n  const alpha = `float(${attributes.alpha}) / float(${attributes.size})`;\n  const bias = `float(${attributes.bias})`;\n  const beta = `float(${attributes.beta})`;\n\n  const shaderSource = `\n    float process(int indices[${rank}]) {\n        int c = indices[1];\n        float x = _X(indices);\n        float square_sum = 0.0;\n\n        for (int i = ${from}; i <= ${to}; i++) {\n          int idx = c + i;\n          if (c >= 0 && c < ${C}) {\n            indices[1] = idx;\n            float j = _X(indices);\n            square_sum += j * j;\n          }\n        }\n        return x / pow(${bias} + ${alpha} * square_sum, ${beta});\n    }`;\n  return {\n    ...lrnProgramMetadata,\n    cacheHint: attributes.cacheKey,\n    output: { dims: inputs[0].dims, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n}\n\nexport function createLrnProgramInfoLoader(inputs: Tensor[], attributes: LrnAttributes): ProgramInfoLoader {\n  return { ...lrnProgramMetadata, cacheHint: attributes.cacheKey, get: () => createLrnProgramInfo(inputs, attributes) };\n}\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('LRN requires 1 input.');\n  }\n  if (inputs[0].dims.length !== 4) {\n    throw new Error('currently only support LRN for input with \"NCHW\" format');\n  }\n  if (inputs[0].type !== 'float32') {\n    throw new Error('input should be float type');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { getGlsl, Glsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nexport interface PadAttributes extends AttributeWithCacheKey {\n  readonly mode: string;\n  readonly pads: number[];\n  readonly value: number;\n}\n\nconst padProgramMetadata = {\n  name: 'Pad',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const padV2: OperatorImplementation<PadAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: PadAttributes,\n): Tensor[] => {\n  validateInputsV2(inputs);\n  const output = inferenceHandler.run(\n    {\n      ...padProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createPadProgramInfo(inferenceHandler, inputs[0], attributes),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parsePadAttributesV2: OperatorInitialization<PadAttributes> = (node: Graph.Node): PadAttributes => {\n  const mode = node.attributes.getString('mode', 'constant');\n  const value = node.attributes.getFloat('value', 0.0);\n  const pads = node.attributes.getInts('pads');\n  return createAttributeWithCacheKey({ mode, value, pads });\n};\n\nexport const padV11: OperatorImplementation<string> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  mode: string,\n): Tensor[] => {\n  validateInputsV11(inputs);\n  const attrubutes = generatePadAttributesFromInputs(inferenceHandler, inputs, mode);\n  return padV2(inferenceHandler, [inputs[0]], attrubutes);\n};\n\nexport const parsePadAttributesV11: OperatorInitialization<string> = (node: Graph.Node): string =>\n  node.attributes.getString('mode', 'constant');\n\nconst generatePadAttributesFromInputs = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  mode: string,\n): PadAttributes => {\n  if (\n    !inferenceHandler.session.isInitializer(inputs[1].dataId) ||\n    (inputs.length >= 3 && !inferenceHandler.session.isInitializer(inputs[2].dataId))\n  ) {\n    throw new Error('dynamic pad attributes are not allowed');\n  }\n\n  const pads = Array.from(inputs[1].integerData);\n  const value = inputs.length >= 3 ? inputs[2].floatData[0] : 0.0;\n\n  return createAttributeWithCacheKey({ mode, pads, value });\n};\n\nconst createPadProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  attributes: PadAttributes,\n): ProgramInfo => {\n  const outputShape = ShapeUtil.padShape(input.dims.slice(), attributes.pads);\n  const rank = outputShape.length;\n  const padFunction = getPadFunction(inferenceHandler, input, attributes);\n  const shaderSource = `\n      ${padFunction}\n      float process(int[${rank}] indices) {\n          return padA(indices);\n      }`;\n  return {\n    name: 'Pad',\n    inputNames: ['A'],\n    inputTypes: [TextureType.unpacked],\n    output: { dims: outputShape, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputsV2 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Pad requires 1 input');\n  }\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n};\n\nconst validateInputsV11 = (inputs: Tensor[]): void => {\n  if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {\n    throw new Error('Pad requires 2 or 3 inputs');\n  }\n  if (inputs[1].type !== 'int32') {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs.length >= 3 && inputs[2].type === 'string') {\n    throw new Error('Invalid input type.');\n  }\n};\n\nconst getPadFunction = (inferenceHandler: WebGLInferenceHandler, input: Tensor, attributes: PadAttributes): string => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const [width, height] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, TextureType.unpacked);\n  const strides = ShapeUtil.computeStrides(input.dims);\n\n  switch (attributes.mode) {\n    case 'constant':\n      return getPadConstant(glsl, input.dims, strides, width, height, attributes.pads, attributes.value);\n    case 'reflect':\n      return getPadReflect(glsl, input.dims, strides, width, height, attributes.pads);\n    case 'edge':\n      return getPadEdge(glsl, input.dims, strides, width, height, attributes.pads);\n    default:\n      throw new Error('Invalid mode');\n  }\n};\n\nconst getPadConstant = (\n  glsl: Glsl,\n  shape: readonly number[],\n  strides: readonly number[],\n  width: number,\n  height: number,\n  pads: number[],\n  value: number,\n): string => {\n  const rank = shape.length;\n  let block = '';\n  for (let i = rank - 1; i >= 0; --i) {\n    block += `\n        k = m[${i}] - ${pads[i]};\n        if (k < 0)  return constant;\n        if (k >= ${shape[i]}) return constant;\n        offset += k * ${strides[i]};\n        `;\n  }\n  return `\n      float padA(int m[${rank}]) {\n        const float constant = float(${value});\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `;\n};\n\nconst getPadReflect = (\n  glsl: Glsl,\n  shape: readonly number[],\n  strides: readonly number[],\n  width: number,\n  height: number,\n  pads: number[],\n): string => {\n  const rank = shape.length;\n\n  let block = '';\n  for (let i = rank - 1; i >= 0; --i) {\n    block += `\n        k = m[${i}] - ${pads[i]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2 * (shape[i] - 1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${shape[i]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${strides[i]};\n        `;\n  }\n  return `\n      float padA(int m[${rank}]) {\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `;\n};\n\nconst getPadEdge = (\n  glsl: Glsl,\n  shape: readonly number[],\n  strides: readonly number[],\n  width: number,\n  height: number,\n  pads: number[],\n): string => {\n  const rank = shape.length;\n\n  let block = '';\n  for (let i = rank - 1; i >= 0; --i) {\n    block += `\n        k = m[${i}] - ${pads[i]};\n        if (k < 0)  k = 0;\n        if (k >= ${shape[i]}) k = ${shape[i] - 1};\n        offset += k * ${strides[i]};\n      `;\n  }\n  return `\n      float padA(int m[${rank}]) {\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `;\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { PoolConvUtil, ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramMetadata, TextureType } from '../types';\n\nexport interface AveragePoolAttributes extends AttributeWithCacheKey {\n  readonly autoPad: string;\n  readonly ceilMode: number;\n  readonly countIncludePad: boolean;\n  readonly kernelShape: readonly number[];\n  readonly strides: readonly number[];\n  readonly pads: readonly number[];\n}\n\nexport const averagePool: OperatorImplementation<AveragePoolAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: AveragePoolAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const metadata = {\n    name: 'AveragePool',\n    inputNames: ['X'],\n    inputTypes: [TextureType.unpacked],\n    cacheHint: attributes.cacheKey,\n  };\n  const output = inferenceHandler.run(\n    { ...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, false, attributes) },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseAveragePoolAttributes: OperatorInitialization<AveragePoolAttributes> = (\n  node: Graph.Node,\n): AveragePoolAttributes => {\n  const autoPad = node.attributes.getString('auto_pad', 'NOTSET');\n  const ceilMode = node.attributes.getInt('ceil_mode', 0);\n  const countIncludePad = node.attributes.getInt('count_include_pad', 0) === 0 ? false : true;\n  const kernelShape = node.attributes.getInts('kernel_shape');\n  const strides = node.attributes.getInts('strides', []);\n  const pads = node.attributes.getInts('pads', []);\n\n  // TODO: support attribute 'ceil_mode'\n  if (ceilMode !== 0) {\n    throw new Error('using ceil() in shape computation is not yet supported for AveragePool');\n  }\n\n  return createAttributeWithCacheKey({ autoPad, ceilMode, countIncludePad, kernelShape, strides, pads });\n};\n\nconst createAveragePoolProgramInfo = (\n  inputs: Tensor[],\n  metadata: ProgramMetadata,\n  isGlobalOperator: boolean,\n  attributes: AveragePoolAttributes,\n): ProgramInfo => {\n  const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(\n    inputs,\n    attributes,\n    isGlobalOperator,\n  );\n  const kernelSize = ShapeUtil.size(adjustedAttributes.kernelShape);\n  const op1 = 'value += _X(x);';\n  let op2 = '';\n  if (adjustedAttributes.countIncludePad) {\n    op2 += `value /= float(${kernelSize});`;\n  } else {\n    op2 += `value /= float(${kernelSize} - pad);`;\n  }\n  const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, '0.0');\n  const shaderSource = `\n        ${poolingCode}\n      `;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nexport const globalAveragePool: OperatorImplementation<AveragePoolAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: AveragePoolAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const metadata = {\n    name: 'GlobalAveragePool',\n    inputNames: ['X'],\n    inputTypes: [TextureType.unpacked],\n    cacheHint: `${attributes.countIncludePad}`,\n  };\n  const output = inferenceHandler.run(\n    { ...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, true, attributes) },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseGlobalAveragePoolAttributes: OperatorInitialization<AveragePoolAttributes> = (\n  node: Graph.Node,\n): AveragePoolAttributes => {\n  const countIncludePad = node.attributes.getInt('count_include_pad', 0) === 0 ? false : true;\n  return createAttributeWithCacheKey({\n    autoPad: '',\n    ceilMode: 0,\n    countIncludePad,\n    kernelShape: [],\n    strides: [],\n    pads: [],\n  });\n};\n\nexport interface MaxPoolAttributes extends AveragePoolAttributes {\n  readonly storageOrder: number;\n  readonly dilations: number[];\n}\n\nexport const maxPool: OperatorImplementation<MaxPoolAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: MaxPoolAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const metadata = {\n    name: 'MaxPool',\n    inputNames: ['X'],\n    inputTypes: [TextureType.unpacked],\n    cacheHint: attributes.cacheKey,\n  };\n  const output = inferenceHandler.run(\n    { ...metadata, get: () => createMaxPoolProgramInfo(inputs, metadata, false, attributes) },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseMaxPoolAttributes: OperatorInitialization<MaxPoolAttributes> = (\n  node: Graph.Node,\n): MaxPoolAttributes => {\n  const autoPad = node.attributes.getString('auto_pad', 'NOTSET');\n  const ceilMode = node.attributes.getInt('ceil_mode', 0);\n  const kernelShape = node.attributes.getInts('kernel_shape');\n  const strides = node.attributes.getInts('strides', []);\n  const pads = node.attributes.getInts('pads', []);\n  const storageOrder = node.attributes.getInt('storage_order', 0);\n  const dilations = node.attributes.getInts('dilations', []);\n\n  // TODO: support attribute 'ceil_mode' and 'storage_order'\n  if (storageOrder !== 0) {\n    throw new Error('column major storage order is not yet supported for MaxPool');\n  }\n  if (ceilMode !== 0) {\n    throw new Error('using ceil() in shape computation is not yet supported for MaxPool');\n  }\n\n  return createAttributeWithCacheKey({\n    autoPad,\n    ceilMode,\n    countIncludePad: false,\n    kernelShape,\n    strides,\n    pads,\n    storageOrder,\n    dilations,\n  });\n};\n\nconst createMaxPoolProgramInfo = (\n  inputs: Tensor[],\n  metadata: ProgramMetadata,\n  isGlobalOperator: boolean,\n  attributes: MaxPoolAttributes,\n): ProgramInfo => {\n  const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(\n    inputs,\n    attributes,\n    isGlobalOperator,\n  );\n  const op1 = `\n      value = max(_X(x), value);\n    `;\n  const op2 = '';\n  const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, '-1e5');\n  const shaderSource = `\n      ${poolingCode}\n    `;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst getAdjustedPoolAttributesAndOutputShape = (\n  inputs: Tensor[],\n  attributes: AveragePoolAttributes | MaxPoolAttributes,\n  isGlobalOperator: boolean,\n): [AveragePoolAttributes | MaxPoolAttributes, number[]] => {\n  const inputShape = inputs[0].dims.slice();\n  const hasDilations = Object.hasOwnProperty.call(attributes, 'dilations');\n  const kernelShape = attributes.kernelShape.slice();\n  const strides = attributes.strides.slice();\n  const dilations: number[] = hasDilations ? (attributes as MaxPoolAttributes).dilations.slice() : [];\n  const pads = attributes.pads.slice();\n  PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShape, kernelShape, strides, dilations, pads);\n\n  const outputShape = PoolConvUtil.computePoolOutputShape(\n    isGlobalOperator,\n    inputShape,\n    strides,\n    dilations,\n    kernelShape,\n    pads,\n    attributes.autoPad,\n  );\n\n  const newAttributes = Object.assign({}, attributes);\n  if (hasDilations) {\n    Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });\n  } else {\n    Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });\n  }\n  return [newAttributes, outputShape];\n};\n\nconst globalMaxPoolAttributes = {\n  autoPad: '',\n  ceilMode: 0,\n  countIncludePad: false,\n  kernelShape: [],\n  strides: [],\n  pads: [],\n  storageOrder: 0,\n  dilations: [],\n  cacheKey: '',\n};\n\nconst globalMaxPoolMetadata = {\n  name: 'GlobalMaxPool',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const globalMaxPool = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n  const output = inferenceHandler.run(\n    {\n      ...globalMaxPoolMetadata,\n      get: () => createMaxPoolProgramInfo(inputs, globalMaxPoolMetadata, true, globalMaxPoolAttributes),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Pool ops requires 1 input.');\n  }\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n};\n\nconst generatePoolingCode = (\n  inputDims: readonly number[],\n  attributes: AveragePoolAttributes,\n  op1: string,\n  op2: string,\n  start: string,\n): string => {\n  const rank = inputDims.length;\n  if (attributes.kernelShape.length <= 2) {\n    const kw = attributes.kernelShape[attributes.kernelShape.length - 1];\n    const sw = attributes.strides[attributes.strides.length - 1];\n    const pwStart = attributes.pads[attributes.pads.length / 2 - 1];\n    const pwEnd = attributes.pads[attributes.pads.length - 1];\n    const dimW = inputDims[rank - 1];\n    let codeW = '';\n    let codeH = '';\n    let codeHEnd = '';\n    if (pwStart + pwEnd !== 0) {\n      codeW = `\n          for (int i = 0; i < ${kw}; i++) {\n            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;\n            if (x[${rank} - 1] < 0 || x[${rank} - 1] >= ${dimW}) {\n              pad++;\n              continue;\n            }\n            ${op1}\n          }`;\n    } else {\n      codeW = `\n          for (int i = 0; i < ${kw}; i++) {\n            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;\n            ${op1}\n          }`;\n    }\n\n    if (attributes.kernelShape.length === 2) {\n      const kh = attributes.kernelShape[attributes.kernelShape.length - 2];\n      const sh = attributes.strides[attributes.strides.length - 2];\n      const phStart = attributes.pads[attributes.pads.length / 2 - 2];\n      const phEnd = attributes.pads[attributes.pads.length - 2];\n      const dimH = inputDims[rank - 2];\n      if (phStart + phEnd !== 0) {\n        codeH = `\n            for (int j = 0; j < ${kh}; j++) {\n              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;\n              if (x[${rank} - 2] < 0 || x[${rank} - 2] >= ${dimH}) {\n                pad+= ${kw};\n                continue;\n              }\n          `;\n      } else {\n        codeH = `\n            for (int j = 0; j < ${kh}; j++) {\n              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;\n            `;\n      }\n      codeHEnd = `\n          }\n        `;\n    }\n\n    const poolingCode = `\n        float process(int indices[${rank}]) {\n          int x[${rank}];\n          copyVec(indices, x);\n\n          float value = ${start};\n          int pad = 0;\n          ${codeH}\n          ${codeW}\n          ${codeHEnd}\n          ${op2}\n          return value;\n        }\n      `;\n    return poolingCode;\n  } else {\n    const kernelSize = ShapeUtil.size(attributes.kernelShape);\n    const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);\n    const stridesRank = kernelStrides.length;\n    const padsRank = attributes.pads.length;\n    const offsetToIndicesFunction = offsetToIndices(stridesRank);\n    const copyInputDims = copyArray(inputDims, 'inputDims');\n    const copyPads = copyArray(attributes.pads, 'pads');\n    const copyKernelStrides = copyArray(kernelStrides, 'kernelStrides');\n    const copyStrides = copyArray(attributes.strides, 'strides');\n    const hasPads = attributes.pads.reduce((sum, cur) => sum + cur);\n    let padCode = '';\n    if (hasPads) {\n      padCode = `\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${op1}\n          }`;\n    } else {\n      padCode = `\n          }\n          ${op1}\n        `;\n    }\n    const poolingCode = `\n        ${offsetToIndicesFunction}\n        float process(int indices[${rank}]) {\n          int x[${rank}];\n          copyVec(indices, x);\n          int offset[${stridesRank}];\n          int pads[${padsRank}];\n          int inputDims[${rank}];\n          int kernelStrides[${stridesRank}];\n          int strides[${stridesRank}];\n          ${copyPads}\n          ${copyInputDims}\n          ${copyStrides}\n          ${copyKernelStrides}\n\n          float value = ${start};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${kernelSize}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${rank} - ${stridesRank}; j < ${rank}; j++) {\n              x[j] = indices[j] * strides[j - ${rank} + ${stridesRank}]\n                + offset[j - ${rank} + ${stridesRank}] - pads[j - 2];\n              ${padCode}\n          }\n          ${op2}\n\n          return value;\n        }\n      `;\n    return poolingCode;\n  }\n};\n\nconst copyArray = (array: readonly number[], arrayName: string): string => {\n  let block = '';\n  for (let i = 0; i < array.length; i++) {\n    block += `\n      ${arrayName}[${i}] = ${array[i]};\n    `;\n  }\n  return block;\n};\n\nconst offsetToIndices = (rank: number): string => `\n  void offsetToIndices(int offset, int[${rank}] strides, out int[${rank}] indices) {\n    if (${rank} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${rank} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${rank} - 1] = offset;\n  }`;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { NUMBER_TYPES, OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramMetadata, TextureType } from '../types';\n\nexport interface ReduceAttributes extends AttributeWithCacheKey {\n  readonly axes: number[];\n  readonly keepDims: boolean;\n}\n\n// return [init ops, reduce ops, final ops]\ntype ReduceOp = (inputs: Tensor[], axes: number[]) => string[];\n\nconst reduce = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n  name: string,\n  reduceOp: ReduceOp,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  const reduceProgramMetadata = {\n    name,\n    inputNames: ['A'],\n    inputTypes: [TextureType.unpacked],\n  };\n\n  const output = inferenceHandler.run(\n    {\n      ...reduceProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createReduceProgramInfo(inferenceHandler, inputs, attributes, name, reduceOp, reduceProgramMetadata),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseReduceAttributes: OperatorInitialization<ReduceAttributes> = (node: Graph.Node): ReduceAttributes => {\n  const axes = node.attributes.getInts('axes', []);\n  const keepDims = node.attributes.getInt('keepdims', 1) === 1;\n  return createAttributeWithCacheKey({ axes, keepDims });\n};\n\nconst createReduceProgramInfo = (\n  _handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n  _name: string,\n  reduceOp: ReduceOp,\n  reduceProgramMetadata: ProgramMetadata,\n): ProgramInfo => {\n  const outputShape: number[] = [];\n  const iRank = inputs[0].dims.length || 1;\n\n  const idxCopy = []; // copy output indexes to input indexes\n\n  const axes = ShapeUtil.normalizeAxes(attributes.axes, inputs[0].dims.length);\n  const ops = reduceOp(inputs, axes);\n  let reduceOps = ops[1];\n\n  for (let k = 0; k < inputs[0].dims.length; k++) {\n    // if this axis is reduced\n    if (axes.indexOf(k) >= 0 || axes.length === 0) {\n      if (attributes.keepDims) {\n        outputShape.push(1);\n      } // else { remove the axis from outputShape; }\n\n      // loop over the d-th axis\n      reduceOps = `\n          for(int j${k} = 0; j${k} < ${inputs[0].dims[k]}; j${k}++) {\n            inputIdx[${k}] = j${k};\n            ${reduceOps}\n          }`;\n    } else {\n      idxCopy.push(`inputIdx[${k}] = outputIdx[${outputShape.length}];`);\n\n      outputShape.push(inputs[0].dims[k]);\n    }\n  }\n\n  const oRank = outputShape.length || 1;\n\n  const shaderSource = `\n      float process(int outputIdx[${oRank}]) {\n        float value;                 // final result\n        int inputIdx[${iRank}];      // addressing input data\n        ${idxCopy.join('\\n')}\n        ${ops[0]}       // init ops for reduce max/min\n        ${reduceOps}\n        ${ops[2]}       // final computation for reduce mean\n        return value;\n      }`;\n\n  return {\n    ...reduceProgramMetadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  // TODO: support Reduce* operators with 2 inputs.\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Reduce op requires 1 input.');\n  }\n\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invalid input type.');\n  }\n};\n\nexport const reduceSum: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (): string[] => ['value = 0.0;', 'value += _A(inputIdx);', ''];\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceSum', reduceOp);\n};\n\nexport const reduceMean: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (inputs: Tensor[], axes: number[]): string[] => {\n    let size = 1.0;\n    for (let k = 0; k < inputs[0].dims.length; k++) {\n      if (axes.indexOf(k) >= 0 || axes.length === 0) {\n        size *= inputs[0].dims[k];\n      }\n    }\n\n    return ['value = 0.0;', 'value += _A(inputIdx);', `value /= ${size}.;`]; // ensure real number with `.`\n  };\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceMean', reduceOp);\n};\n\nexport const reduceMax: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (inputs: Tensor[], axes: number[]): string[] => {\n    const idxZero = [];\n    for (let k = 0; k < inputs[0].dims.length; k++) {\n      if (axes.indexOf(k) >= 0 || axes.length === 0) {\n        idxZero.push(`inputIdx[${k}] = 0;`); // first element\n      }\n    }\n\n    return [`${idxZero.join('\\n')}\\nvalue = _A(inputIdx);`, 'value = max(value, _A(inputIdx));', ''];\n  };\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceMax', reduceOp);\n};\n\nexport const reduceMin: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (inputs: Tensor[], axes: number[]): string[] => {\n    const idxZero = [];\n    for (let k = 0; k < inputs[0].dims.length; k++) {\n      if (axes.indexOf(k) >= 0 || axes.length === 0) {\n        idxZero.push(`inputIdx[${k}] = 0;`); // first element\n      }\n    }\n\n    return [`${idxZero.join('\\n')}\\nvalue = _A(inputIdx);`, 'value = min(value, _A(inputIdx));', ''];\n  };\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceMin', reduceOp);\n};\n\nexport const reduceProd: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (): string[] => ['value = 1.0;', 'value *= _A(inputIdx);', ''];\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceProd', reduceOp);\n};\n\nexport const reduceLogSum: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (): string[] => ['value = 0.0;', 'value += _A(inputIdx);', 'value = log(value);'];\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceLogSum', reduceOp);\n};\n\nexport const reduceLogSumSquare: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (): string[] => ['float t; value = 0.0;', 't = _A(inputIdx); value += t * t;', ''];\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceLogSumSquare', reduceOp);\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nexport const reshape = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  const reshapedDims = ShapeUtil.calculateReshapedDims(inputs[0].dims, inputs[1].integerData);\n  if (handler.session.pack) {\n    return [handler.reshapePacked(inputs[0], reshapedDims)];\n  } else {\n    return [handler.reshapeUnpacked(inputs[0], reshapedDims)];\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nexport interface UpsampleAttributes extends AttributeWithCacheKey {\n  readonly opset: number;\n  readonly isResize: boolean;\n  readonly mode: string;\n  readonly scales: number[];\n  readonly extrapolationValue: number;\n  readonly coordinateTransformMode: string;\n  readonly useExtrapolation: boolean;\n  readonly needRoiInput: boolean;\n  readonly nearestMode: string;\n  readonly cubicCoefficientA: number;\n  readonly excludeOutside: boolean;\n  readonly useNearest2xOptimization: boolean;\n  readonly roiInputIdx: number;\n  readonly scalesInputIdx: number;\n  readonly sizesInputIdx: number;\n}\n\nconst upsampleProgramMetadata = {\n  name: 'Upsample',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const upsample: OperatorImplementation<UpsampleAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: UpsampleAttributes,\n): Tensor[] => {\n  validateInputs(inputs, attributes);\n  const output = inferenceHandler.run(\n    {\n      ...upsampleProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createUpsampleProgramInfo(inferenceHandler, inputs, attributes),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseUpsampleAttributesV7: OperatorInitialization<UpsampleAttributes> = (\n  node: Graph.Node,\n): UpsampleAttributes => parseUpsampleAttributes(node, 7);\n\nexport const parseUpsampleAttributesV9: OperatorInitialization<UpsampleAttributes> = (\n  node: Graph.Node,\n): UpsampleAttributes => parseUpsampleAttributes(node, 9);\n\nexport const parseUpsampleAttributes = (node: Graph.Node, opset: number): UpsampleAttributes => {\n  const isResize = opset >= 10;\n\n  // processing node attributes\n  const mode = node.attributes.getString('mode', 'nearest');\n  if (mode !== 'nearest' && mode !== 'linear' && (opset < 11 || mode !== 'cubic')) {\n    throw new Error(`unrecognized mode: ${mode}`);\n  }\n\n  let scales: number[] = [];\n  if (opset < 9) {\n    scales = node.attributes.getFloats('scales');\n    scalesValidation(scales, mode, isResize);\n  }\n\n  const extrapolationValue = node.attributes.getFloat('extrapolation_value', 0.0);\n\n  const coordinateTransformMode =\n    opset > 10 ? node.attributes.getString('coordinate_transformation_mode', 'half_pixel') : 'asymmetric';\n  if (\n    [\n      'asymmetric',\n      'pytorch_half_pixel',\n      'tf_half_pixel_for_nn',\n      'align_corners',\n      'tf_crop_and_resize',\n      'half_pixel',\n    ].indexOf(coordinateTransformMode) === -1\n  ) {\n    throw new Error(`coordinate_transform_mode '${coordinateTransformMode}' is not supported`);\n  }\n  const needRoiInput = coordinateTransformMode === 'tf_crop_and_resize';\n  const useExtrapolation = needRoiInput;\n\n  const nearestMode =\n    mode === 'nearest' && opset >= 11 ? node.attributes.getString('nearest_mode', 'round_prefer_floor') : '';\n  if (['round_prefer_floor', 'round_prefer_ceil', 'floor', 'ceil', ''].indexOf(nearestMode) === -1) {\n    throw new Error(`nearest_mode '${nearestMode}' is not supported`);\n  }\n\n  const cubicCoefficientA = node.attributes.getFloat('cubic_coeff_a', -0.75);\n  const excludeOutside = node.attributes.getInt('exclude_outside', 0) !== 0;\n  if (excludeOutside && mode !== 'cubic') {\n    throw new Error('exclude_outside can be set to 1 only when mode is CUBIC.');\n  }\n\n  const useNearest2xOptimization =\n    opset < 11 ? true : mode === 'nearest' && coordinateTransformMode === 'asymmetric' && nearestMode === 'floor';\n\n  let roiInputIdx = 0;\n  let scalesInputIdx = 0;\n  let sizesInputIdx = 0;\n\n  if (opset > 10) {\n    // handle when roiInput is not given\n    if (node.inputs.length > 2) {\n      roiInputIdx = 1;\n      scalesInputIdx = 2;\n      sizesInputIdx = 3;\n    } else {\n      scalesInputIdx = 1;\n      sizesInputIdx = 2;\n    }\n  } else if (opset === 9) {\n    scalesInputIdx = 1;\n  }\n\n  return createAttributeWithCacheKey({\n    opset,\n    isResize,\n    mode,\n    scales,\n    extrapolationValue,\n    coordinateTransformMode,\n    useExtrapolation,\n    needRoiInput,\n    nearestMode,\n    cubicCoefficientA,\n    excludeOutside,\n    useNearest2xOptimization,\n    roiInputIdx,\n    scalesInputIdx,\n    sizesInputIdx,\n  });\n};\n\nconst createUpsampleProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: UpsampleAttributes,\n): ProgramInfo => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const [inputWidth, inputHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    inputs[0].dims,\n    TextureType.unpacked,\n  );\n\n  const outputShape = inputs[0].dims.map((dim, i) => Math.floor(dim * attributes.scales[i]));\n  const [outputWidth, outputHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    outputShape,\n    TextureType.unpacked,\n  );\n  const dim = outputShape.length;\n\n  const outputPitches = new Array<number>(dim);\n  const inputPitches = new Array<number>(dim);\n  let precalculatedPitches = `\n      int output_pitches[${dim}];\n      int input_pitches[${dim}];\n      `;\n  for (let d = dim - 1; d >= 0; d--) {\n    outputPitches[d] = d === dim - 1 ? 1 : outputPitches[d + 1] * outputShape[d + 1];\n    inputPitches[d] = d === dim - 1 ? 1 : inputPitches[d + 1] * inputs[0].dims[d + 1];\n\n    precalculatedPitches += `\n        output_pitches[${d}] = ${outputPitches[d]};\n        input_pitches[${d}] = ${inputPitches[d]};\n        `;\n  }\n  const getInputFloatFunction = `\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${inputWidth}, ${inputHeight});\n        float value = getColorAsFloat(${glsl.texture2D}(X, coords));\n        return value;\n      }\n      `;\n\n  const shaderSource =\n    attributes.mode === 'nearest'\n      ? // nearest\n        `\n    ${getInputFloatFunction}\n    float process(int indices[${dim}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int d, m;\n      for (int dim = 0; dim < ${dim}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`\n      : dim === 4\n        ? // bilinear 4D\n          `\n    ${getInputFloatFunction}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${inputs[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`\n        : // bilinear 2D\n          `\n    ${getInputFloatFunction}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${inputs[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;\n  return {\n    ...upsampleProgramMetadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n    variables: [\n      {\n        name: 'scales',\n        type: 'int',\n        arrayLength: attributes.scales.length,\n        data: attributes.scales.map((x) => Math.ceil(x)),\n      },\n    ],\n  };\n};\n\nexport const validateInputs = (inputs: Tensor[], attribute: UpsampleAttributes): void => {\n  if (\n    !inputs ||\n    (attribute.opset < 9 && inputs.length !== 1) ||\n    (attribute.opset >= 9 && attribute.opset < 11 && inputs.length !== 2) ||\n    (attribute.opset >= 11 && inputs.length < 2)\n  ) {\n    throw new Error('invalid inputs.');\n  }\n\n  if (attribute.scales.length > 0 && inputs[0].dims.length !== attribute.scales.length) {\n    throw new Error('Invalid input shape.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('Invalid input tensor types.');\n  }\n};\n\nexport const scalesValidation = (scales: number[], mode: string, isResize: boolean): void => {\n  if (!isResize) {\n    for (const scale of scales) {\n      if (scale < 1) {\n        throw new Error('Scale value should be greater than or equal to 1.');\n      }\n    }\n  } else {\n    for (const scale of scales) {\n      if (scale <= 0) {\n        throw new Error('Scale value should be greater than 0.');\n      }\n    }\n  }\n  if (mode === 'linear' || mode === 'cubic') {\n    if (scales.length !== 2 && (scales.length !== 4 || scales[0] !== 1 || scales[1] !== 1)) {\n      throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic') \\\n        or 4-D inputs with the corresponding outermost 2 scale values being 1 \\\n        in the ${isResize ? 'Resize' : 'Upsample'} opeartor.`);\n    }\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\nimport { getCoordsDataType } from '../utils';\n\nimport { unpackFromChannel } from './packing-utils';\nimport { parseUpsampleAttributes, scalesValidation, UpsampleAttributes, validateInputs } from './upsample';\n\nconst resizeProgramMetadata = {\n  name: 'Resize',\n  inputNames: ['A'],\n  inputTypes: [TextureType.packed],\n};\n\nexport const resize: OperatorImplementation<UpsampleAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: UpsampleAttributes,\n): Tensor[] => {\n  validateInputs(inputs, attributes);\n  const output = inferenceHandler.run(\n    {\n      ...resizeProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createPackedResizeProgramInfo(inferenceHandler, inputs, attributes),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseResizeAttributesV10: OperatorInitialization<UpsampleAttributes> = (\n  node: Graph.Node,\n): UpsampleAttributes => parseUpsampleAttributes(node, 10);\n\nexport const parseResizeAttributesV11: OperatorInitialization<UpsampleAttributes> = (\n  node: Graph.Node,\n): UpsampleAttributes => parseUpsampleAttributes(node, 11);\n\nconst createPackedResizeProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: UpsampleAttributes,\n): ProgramInfo => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const [scales, outputShape] = prepareInputs(inputs, attributes);\n\n  const isSame = scales.every((s: number) => s === 1) && attributes.coordinateTransformMode !== 'tf_crop_and_resize';\n  if (isSame) {\n    return {\n      ...resizeProgramMetadata,\n      output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.packed },\n      hasMain: true,\n      shaderSource: `void main() {\n                    vec4 v = ${glsl.texture2D}(X, TexCoords);\n                    ${glsl.output} = v;\n                }`,\n    };\n  }\n\n  const dim = outputShape.length;\n  if (dim < 2) {\n    throw new Error(`output dimension should be at least 2, but got ${dim}`);\n  }\n\n  const outputHeight = outputShape[dim - 2];\n  const outputWidth = outputShape[dim - 1];\n\n  const inputShape = inputs[0].dims;\n  if (dim !== inputShape.length) {\n    throw new Error(`output dimension should match input ${inputShape.length}, but got ${dim}`);\n  }\n  const inputHeight = inputShape[dim - 2];\n  const inputWidth = inputShape[dim - 1];\n\n  const scalesHeight = scales[dim - 2];\n  const scalesWidth = scales[dim - 1];\n\n  let getSourceFracIndex = '';\n\n  if (attributes.mode !== 'linear') {\n    // TODO: support other modes\n    throw new Error(`resize (packed) does not support mode: '${attributes.mode}'`);\n  }\n  switch (attributes.coordinateTransformMode) {\n    case 'asymmetric':\n      getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                `;\n      break;\n    case 'half_pixel':\n      getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                `;\n      break;\n    case 'pytorch_half_pixel':\n      getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${outputWidth}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${outputHeight}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${outputWidth}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${outputHeight}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;\n      break;\n    case 'align_corners':\n      getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${outputWidth}.0 - 1.0, ${outputHeight}.0 - 1.0, ${outputWidth}.0 - 1.0,\n                            ${outputHeight}.0 - 1.0);\n                        vec4 original = vec4(${inputWidth}.0 - 1.0, ${inputHeight}.0 - 1.0, ${inputWidth}.0 - 1.0,\n                            ${inputHeight}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;\n      break;\n    default:\n      // TODO:supporting other coordinateTransformModes\n      throw new Error(`resize (packed) does not support coordinateTransformMode: \\\n                                '${attributes.coordinateTransformMode}'`);\n  }\n\n  const coordsDataType = getCoordsDataType(dim);\n  const unpackChannel = unpackFromChannel();\n  const shaderSource = `\n            const vec2 inputWH = vec2(${inputHeight}.0, ${inputWidth}.0);\n            const vec4 scaleWHWH = vec4(float(${scalesHeight}), float(${scalesWidth}), float(${scalesHeight}), float(${\n              scalesWidth\n            }));\n            ${unpackChannel}\n            ${getSourceFracIndex}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${coordsDataType} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${outputHeight - 1};\n                bool hasNextCol = rc.z < ${outputWidth - 1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${glsl.output} = vec4(newValue);\n            }\n        `;\n  return {\n    ...resizeProgramMetadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.packed },\n    hasMain: true,\n    shaderSource,\n  };\n};\n\nconst prepareInputs = (inputs: Tensor[], attributes: UpsampleAttributes): [readonly number[], readonly number[]] => {\n  const x = inputs[0];\n  const xDims = x.dims;\n\n  let scales = attributes.scales;\n  let outputSizes: number[] | undefined;\n  if (scales.length === 0) {\n    const scalesTensor = inputs[attributes.scalesInputIdx];\n    if (scalesTensor && scalesTensor.size !== 0) {\n      if (inputs[attributes.sizesInputIdx]) {\n        throw new Error('Only one of scales or sizes must be provided as input.');\n      }\n      scales = parseScalesData(scalesTensor, attributes.mode, attributes.isResize);\n    } else {\n      const sizesTensor = inputs[attributes.sizesInputIdx];\n      if (!sizesTensor || sizesTensor.size === 0) {\n        throw new Error('Either scales or sizes MUST be provided as input.');\n      }\n\n      outputSizes = Array.from(sizesTensor.integerData);\n      scales = parseScalesDataFromOutputSize(outputSizes, xDims, attributes.mode, attributes.isResize);\n    }\n  } else {\n    if (inputs[attributes.sizesInputIdx]) {\n      throw new Error('Only one of scales or sizes must be provided as input.');\n    }\n  }\n\n  const yDims = outputSizes || xDims.map((dim, i) => Math.floor(dim * scales[i]));\n\n  return [scales, yDims];\n};\n\nconst parseScalesData = (scale: Tensor, mode: string, isResize: boolean): number[] => {\n  const scales = Array.from(scale.floatData);\n  scalesValidation(scales, mode, isResize);\n  return scales;\n};\n\nconst parseScalesDataFromOutputSize = (\n  yDims: readonly number[],\n  xDims: readonly number[],\n  mode: string,\n  isResize: boolean,\n): number[] => {\n  const length = xDims.length;\n  const scales = new Array<number>(length);\n\n  for (let i = 0, end = length; i < end; i++) {\n    if (xDims[i] === 0) {\n      if (yDims[i] !== 0) {\n        throw new Error('Input dim is zero but required output dim is non-zero.');\n      }\n      scales[i] = 1;\n    } else {\n      scales[i] = yDims[i] / xDims[i];\n    }\n  }\n  scalesValidation(scales, mode, isResize);\n  return scales;\n};\n\n// roi data is not used yet. but leave here for future usage.\n// const getRoi = (inputs: Tensor[], attributes: UpsampleAttributes) : number[] => {\n//     let roi: number[] = [];\n//     if (attributes.needRoiInput) {\n//         if (attributes.roiInputIdx <= 0) {\n//             throw new Error('Invalid roi input index.');\n//         }\n//         const roiTensor = inputs[attributes.roiInputIdx];\n//         roi = roiTensor.size > 0 ? Array.from(roiTensor.floatData) : [];\n//     } else {\n//         roi = new Array(inputs[0].dims.length * 2).fill(0);\n//     }\n//     return roi;\n// };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nexport const shape = (_inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n  return [new Tensor([inputs[0].dims.length], 'int32', undefined, undefined, new Int32Array(inputs[0].dims))];\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Shape requires 1 input.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { NUMBER_TYPES, OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nexport interface SliceAttributes extends AttributeWithCacheKey {\n  readonly axes: number[];\n  readonly ends: number[];\n  readonly starts: number[];\n}\n\nconst sliceProgramMetadata = {\n  name: 'Slice',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const slice: OperatorImplementation<SliceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: SliceAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const output = inferenceHandler.run(\n    {\n      ...sliceProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseSliceAttributes: OperatorInitialization<SliceAttributes> = (node: Graph.Node): SliceAttributes => {\n  const starts = node.attributes.getInts('starts');\n  const ends = node.attributes.getInts('ends');\n  const axes = node.attributes.getInts('axes', []);\n  return createAttributeWithCacheKey({ starts, ends, axes });\n};\n\nconst createSliceProgramInfo = (\n  _inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  attributes: SliceAttributes,\n): ProgramInfo => {\n  const axes = attributes.axes.length === 0 ? input.dims.slice(0).map((_val, i) => i) : attributes.axes;\n  const normalizedAxes = ShapeUtil.normalizeAxes(axes, input.dims.length);\n  const starts = attributes.starts.map((start, i) => {\n    if (start > input.dims[normalizedAxes[i]] - 1) {\n      return input.dims[normalizedAxes[i]];\n    }\n    return ShapeUtil.normalizeAxis(start, input.dims[normalizedAxes[i]]);\n  });\n  const ends = attributes.ends.map((end, i) => {\n    if (end > input.dims[normalizedAxes[i]] - 1) {\n      return input.dims[normalizedAxes[i]];\n    }\n    return ShapeUtil.normalizeAxis(end, input.dims[normalizedAxes[i]]);\n  });\n\n  const outputShape = input.dims.slice();\n\n  const sliceOps: string[] = [];\n  for (let i = 0; i < normalizedAxes.length; i++) {\n    outputShape[normalizedAxes[i]] = ends[i] - starts[i];\n    if (starts[i] > 0) {\n      sliceOps.push(`outputIdx[${normalizedAxes[i]}] += ${starts[i]};`);\n    } // else { sliceOps.push(`outputIdx[${normalizedAxes[i]}] += 0;`); }\n  }\n\n  const rank = outputShape.length;\n  const shaderSource = `\n      float process(int outputIdx[${rank}]) {\n        ${sliceOps.join('\\n      ')}\n        return _A(outputIdx);\n      }`;\n  return {\n    ...sliceProgramMetadata,\n    output: { dims: outputShape, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Slice requires 1 input.');\n  }\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invalid input type.');\n  }\n};\n\nexport const sliceV10 = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputsV10(inputs);\n  const attributes = generateSliceAttributesFromInputs(inferenceHandler, inputs);\n  const output = inferenceHandler.run(\n    {\n      ...sliceProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes),\n    },\n    [inputs[0]],\n  );\n  return [output];\n};\n\nconst generateSliceAttributesFromInputs = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n): SliceAttributes => {\n  if (\n    !inferenceHandler.session.isInitializer(inputs[1].dataId) ||\n    !inferenceHandler.session.isInitializer(inputs[2].dataId) ||\n    (inputs.length >= 4 && !inferenceHandler.session.isInitializer(inputs[3].dataId)) ||\n    (inputs.length >= 5 && !inferenceHandler.session.isInitializer(inputs[4].dataId))\n  ) {\n    throw new Error('dynamic slice attributes are not allowed');\n  }\n\n  if (inputs.length >= 5 && inputs[4].integerData.some((i: number) => i !== 1)) {\n    throw new Error('currently non-1 steps is not supported for Slice');\n  }\n\n  const starts = Array.from(inputs[1].integerData);\n  const ends = Array.from(inputs[2].integerData);\n  const axes = inputs.length >= 4 ? Array.from(inputs[3].integerData) : [];\n  const cacheKey = `${axes};${starts};${ends}`;\n  return { starts, ends, axes, cacheKey };\n};\n\nconst validateInputsV10 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length < 3 || inputs.length > 5) {\n    throw new Error('Invalid input number.');\n  }\n  if (inputs[1].type !== 'int32' || inputs[1].dims.length !== 1) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs[2].type !== 'int32' || inputs[2].dims.length !== 1) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs.length >= 4 && (inputs[3].type !== 'int32' || inputs[3].dims.length !== 1)) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs.length >= 5 && (inputs[4].type !== 'int32' || inputs[4].dims.length !== 1)) {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nimport { transpose, TransposeAttributes } from './transpose';\n\nexport interface SoftmaxAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n}\n\nconst softmaxComputeMaxProgramMetadata = {\n  name: 'SoftmaxComputeMax',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nconst softmaxComputeScaleProgramMetadata = {\n  name: 'SoftmaxComputeScale',\n  inputNames: ['A', 'Max'],\n  inputTypes: [TextureType.unpacked, TextureType.unpacked],\n};\n\nconst softmaxProgramMetadata = {\n  name: 'SoftMax',\n  inputNames: ['A', 'Max', 'Norm'],\n  inputTypes: [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked],\n};\n\nexport const softmax: OperatorImplementation<SoftmaxAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: SoftmaxAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  const inputShape = inputs[0].dims.slice();\n  const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);\n  const logicalRowCount = ShapeUtil.sizeToDimension(inputShape, axis);\n  const featureCount = ShapeUtil.sizeFromDimension(inputShape, axis);\n\n  const output = computeSoftmax(inferenceHandler, inputs, attributes, logicalRowCount, featureCount);\n  return output;\n};\n\nexport const parseSoftmaxAttributes: OperatorInitialization<SoftmaxAttributes> = (\n  node: Graph.Node,\n): SoftmaxAttributes => createAttributeWithCacheKey({ axis: node.attributes.getInt('axis', 1) });\n\nexport const parseSoftmaxAttributesV13: OperatorInitialization<SoftmaxAttributes> = (\n  node: Graph.Node,\n): SoftmaxAttributes => createAttributeWithCacheKey({ axis: node.attributes.getInt('axis', -1) });\n\n// The \"semantic\" meaning of axis has changed in opset-13.\n// Please compare: https://github.com/onnx/onnx/blob/main/docs/Operators.md#Softmax\n// with https://github.com/onnx/onnx/blob/main/docs/Changelog.md#Softmax-11 for detailed explanations\n// To account for the opset-13 behavior, our plan will be to transpose the \"axis\" dim to the innermost dim\n// and perform softmax and then reverse the transpose. We can skip the transposing aspect if the axis is already\n// the innermost dim\nexport const softmaxV13: OperatorImplementation<SoftmaxAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: SoftmaxAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  const inputShape = inputs[0].dims.slice();\n  const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);\n  const rank = inputShape.length;\n\n  const isTransposeRequired = axis !== rank - 1 ? true : false;\n  const transposedInputShape: number[] = [];\n  let perm: number[] = [];\n  let transposedInputs: Tensor[] = [];\n  let transposeAttribute: TransposeAttributes;\n\n  if (isTransposeRequired) {\n    perm = Array.from({ length: rank }).map((_, i) => i);\n\n    // swap the innermost dim with the dim corresponding to axis\n    perm[axis] = rank - 1;\n    perm[rank - 1] = axis;\n\n    perm.map((p) => transposedInputShape.push(inputShape[p]));\n\n    transposeAttribute = createAttributeWithCacheKey({ perm });\n    transposedInputs = transpose(inferenceHandler, inputs, transposeAttribute);\n  }\n\n  const logicalRowCount = isTransposeRequired\n    ? ShapeUtil.sizeToDimension(transposedInputShape, rank - 1)\n    : ShapeUtil.sizeToDimension(inputShape, rank - 1);\n  const featureCount = isTransposeRequired\n    ? ShapeUtil.sizeFromDimension(transposedInputShape, rank - 1)\n    : ShapeUtil.sizeFromDimension(inputShape, rank - 1);\n\n  const output = computeSoftmax(\n    inferenceHandler,\n    isTransposeRequired ? transposedInputs : inputs,\n    attributes,\n    logicalRowCount,\n    featureCount,\n  );\n\n  if (isTransposeRequired) {\n    const reversedOutput = transpose(inferenceHandler, output, transposeAttribute!);\n    return reversedOutput;\n  } else {\n    return output;\n  }\n};\n\nconst computeSoftmax = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: SoftmaxAttributes,\n  logicalRowCount: number,\n  featureCount: number,\n): Tensor[] => {\n  const computeMaxProgramInfo = createComputeMaxProgramInfo(\n    inferenceHandler,\n    inputs[0],\n    logicalRowCount,\n    featureCount,\n    [logicalRowCount],\n  );\n  const max = inferenceHandler.run(\n    { ...softmaxComputeMaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeMaxProgramInfo },\n    inputs,\n  );\n\n  const computeScaleProgramInfo = createComputScaleProgramInfo(\n    inferenceHandler,\n    inputs[0],\n    logicalRowCount,\n    featureCount,\n    computeMaxProgramInfo.output.dims,\n    [logicalRowCount],\n  );\n  const scale = inferenceHandler.run(\n    { ...softmaxComputeScaleProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeScaleProgramInfo },\n    [inputs[0], max],\n  );\n\n  const softMaxProgramInfo = createSoftMaxProgramInfo(\n    inferenceHandler,\n    inputs[0],\n    logicalRowCount,\n    featureCount,\n    computeMaxProgramInfo.output.dims,\n    computeScaleProgramInfo.output.dims,\n  );\n  const output = inferenceHandler.run(\n    { ...softmaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => softMaxProgramInfo },\n    [inputs[0], max, scale],\n  );\n  return [output];\n};\n\n/**\n * Create a texture that contains the maximum value of each of the 'N' rows\n */\nconst createComputeMaxProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  logicalRowCount: number,\n  featureCount: number,\n  outputShape: number[],\n): ProgramInfo => {\n  const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    input.dims,\n    TextureType.unpacked,\n  );\n  const rank = outputShape.length;\n\n  if (logicalRowCount < 1 || featureCount < 1) {\n    throw new Error('Logical row count N and feature count D must be greater than or equal to 1');\n  }\n\n  if (outputShape.length !== 1) {\n    throw new Error('Dimensionality of the output should be 1');\n  }\n\n  if (outputShape[0] !== logicalRowCount) {\n    throw new Error('Shape of the output should be equal to logical row count');\n  }\n\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const shaderSource = `\n      float process(int[${rank}] indices) {\n        int logical_row_start_offset = indices[0] * ${featureCount};\n\n        float max = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset, ${textureWidth},\n        ${textureHeight} )));\n        for(int i=1; i<${featureCount}; ++i)\n        {\n          float current = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${textureWidth}, ${textureHeight})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;\n  return {\n    ...softmaxComputeMaxProgramMetadata,\n    output: { dims: outputShape, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\n/**\n * Create a texture that contains the normalization factor for each of the 'N' rows\n */\nconst createComputScaleProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  logicalRowCount: number,\n  featureCount: number,\n  maxElementPerLogicalRow: readonly number[],\n  outputShape: number[],\n): ProgramInfo => {\n  const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    input.dims,\n    TextureType.unpacked,\n  );\n  const rank = outputShape.length;\n\n  if (logicalRowCount < 1 || featureCount < 1) {\n    throw new Error('Logical row count N and feature count D must be greater than or equal to 1');\n  }\n\n  if (outputShape.length !== 1) {\n    throw new Error('Dimensionality of the output should be 1');\n  }\n\n  if (outputShape[0] !== logicalRowCount) {\n    throw new Error('Shape of the output should be equal to logical row count');\n  }\n\n  if (maxElementPerLogicalRow.length !== 1) {\n    throw new Error('Dimensionality of the intermediate results should be 1');\n  }\n\n  if (maxElementPerLogicalRow[0] !== logicalRowCount) {\n    throw new Error('Shape of the intermediate results should be equal to logical row count');\n  }\n\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const shaderSource = `\n      float process(int[${rank}] indices) {\n        int logical_row_start_offset = indices[0] * ${featureCount};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${featureCount}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${textureWidth}, ${textureHeight}))) - max);\n        }\n\n        return norm_factor;\n      }`;\n  return {\n    ...softmaxComputeScaleProgramMetadata,\n    output: { dims: outputShape, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst createSoftMaxProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  logicalRowCount: number,\n  featureCount: number,\n  maxElementPerLogicalRow: readonly number[],\n  normalizationPerLogicalRow: readonly number[],\n): ProgramInfo => {\n  const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    input.dims,\n    TextureType.unpacked,\n  );\n  const rank = input.dims.length;\n\n  if (logicalRowCount < 1 || featureCount < 1) {\n    throw new Error('Logical row count N and feature count D must be greater than or equal to 1');\n  }\n\n  if (maxElementPerLogicalRow.length !== 1 || normalizationPerLogicalRow.length !== 1) {\n    throw new Error('Dimensionality of the intermediate results should be 1');\n  }\n\n  if (maxElementPerLogicalRow[0] !== logicalRowCount || normalizationPerLogicalRow[0] !== logicalRowCount) {\n    throw new Error('Shape of the intermediate results should be equal to logical row count');\n  }\n\n  const shaderSource = `\n      float process(int[${rank}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${textureWidth}, ${textureHeight});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${featureCount};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;\n  return {\n    ...softmaxProgramMetadata,\n    output: { dims: input.dims, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Softmax requires 1 input.');\n  }\n\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil, SplitUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nexport interface SplitAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n  readonly split: number[];\n  readonly numOutputs: number;\n}\n\nconst splitProgramMetadata = {\n  name: 'Split',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const split: OperatorImplementation<SplitAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: SplitAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);\n  const count = getProgramCount(inferenceHandler, inputs, axis, attributes);\n  const output: Tensor[] = [];\n  for (let i = 0; i < count; ++i) {\n    output.push(\n      inferenceHandler.run(\n        {\n          ...splitProgramMetadata,\n          cacheHint: `${attributes.cacheKey};${i}`,\n          get: () => createSplitProgramInfo(inferenceHandler, inputs[0], attributes, axis, i),\n        },\n        inputs,\n      ),\n    );\n  }\n\n  return output;\n};\n\nexport const parseSplitAttributes: OperatorInitialization<SplitAttributes> = (node: Graph.Node): SplitAttributes => {\n  const axis = node.attributes.getInt('axis', 0);\n  const split = node.attributes.getInts('split', []);\n  const numOutputs = node.outputs.length;\n  return createAttributeWithCacheKey({ axis, split, numOutputs });\n};\n\nconst getProgramCount = (\n  _inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  axis: number,\n  attributes: SplitAttributes,\n): number => {\n  const [, offsets] = SplitUtil.splitShape(inputs[0].dims, axis, attributes.split, attributes.numOutputs);\n  return offsets.length;\n};\n\nconst createSplitProgramInfo = (\n  _inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  attributes: SplitAttributes,\n  axis: number,\n  index: number,\n): ProgramInfo => {\n  const [shapes, offsets] = SplitUtil.splitShape(input.dims, axis, attributes.split, attributes.numOutputs);\n  const offset = offsets[index];\n  const outputShape = shapes[index];\n  const rank = outputShape.length;\n  const shaderSource = `\n      float process(int indices[${rank}]) {\n        indices[${axis}] += ${offset};\n        return _A(indices);\n      }\n    `;\n  return {\n    ...splitProgramMetadata,\n    cacheHint: `${attributes.cacheKey}:${index}`,\n    output: { dims: outputShape, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Split requires one input.');\n  }\n\n  if (\n    inputs[0].type !== 'int8' &&\n    inputs[0].type !== 'uint8' &&\n    inputs[0].type !== 'int16' &&\n    inputs[0].type !== 'uint16' &&\n    inputs[0].type !== 'int32' &&\n    inputs[0].type !== 'uint32' &&\n    inputs[0].type !== 'float32' &&\n    inputs[0].type !== 'float64' &&\n    inputs[0].type !== 'bool'\n  ) {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nexport const squeeze: OperatorImplementation<number[]> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  axes: number[],\n): Tensor[] => {\n  validateInputs(inputs);\n  const outputShape = ShapeUtil.squeezeShape(inputs[0].dims, axes);\n  const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);\n  return [output];\n};\n\nexport const squeezeV13 = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputsV13(inputs);\n  return squeeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));\n};\n\nexport const parseSqueezeAttributes: OperatorInitialization<number[]> = (node: Graph.Node): number[] =>\n  node.attributes.getInts('axes');\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Squeeze requires 1 input.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('invalid input tensor types.');\n  }\n};\n\nconst validateInputsV13 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Squeeze requires 2 inputs.');\n  }\n\n  if (inputs[1].type !== 'int32') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramMetadata, TextureType } from '../types';\n\nexport const sum = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n\n  const sumProgramMetadata = {\n    name: 'Sum',\n    inputNames: inputs.map((_v, i) => `X${i}`),\n    inputTypes: new Array(inputs.length).fill(TextureType.unpacked),\n  };\n\n  const output = inferenceHandler.run(\n    { ...sumProgramMetadata, get: () => createSumProgramInfo(inferenceHandler, inputs, sumProgramMetadata) },\n    inputs,\n  );\n  return [output];\n};\n\nconst createSumProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  sumProgramMetadata: ProgramMetadata,\n): ProgramInfo => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const outputShape = inputs[0].dims.slice();\n  const sumLine = inputs.map((_v, i) => `${glsl.texture2D}(X${i},TexCoords)`).join(' + ');\n  const shaderSource = `\n      void main() {\n        vec4 result = ${sumLine};\n        ${glsl.output} = result;\n      }\n    `;\n  return {\n    ...sumProgramMetadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    hasMain: true,\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length === 0) {\n    throw new Error('Sum requires inputs.');\n  }\n\n  const length = inputs[0].dims.length;\n  for (let i = 1; i < inputs.length; i++) {\n    if (length !== inputs[i].dims.length) {\n      throw new Error('Input shapes are mismatched.');\n    }\n\n    for (let j = 0; j < length; j++) {\n      if (inputs[0].dims[j] !== inputs[i].dims[j]) {\n        throw new Error('Input shapes are not matched.');\n      }\n    }\n  }\n\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n  for (let i = 1; i < inputs.length; i++) {\n    if (inputs[0].type !== inputs[i].type) {\n      throw new Error('Input types are not matched.');\n    }\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { NUMBER_TYPES } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramMetadata, TextureType } from '../types';\n\nexport const tile = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n\n  const tileProgramMetadata = {\n    name: 'Tile',\n    inputNames: ['A'],\n    inputTypes: [TextureType.unpacked],\n  };\n\n  const output = inferenceHandler.run(\n    { ...tileProgramMetadata, get: () => createTileProgramInfo(inferenceHandler, inputs, tileProgramMetadata) },\n    inputs,\n  );\n  return [output];\n};\n\nconst createTileProgramInfo = (\n  _handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  tileProgramMetadata: ProgramMetadata,\n): ProgramInfo => {\n  const inputShape = inputs[0].dims.slice();\n  const outputShape = new Array(inputShape.length);\n\n  const tileOps: string[] = [];\n  for (let i = 0; i < inputShape.length; i++) {\n    outputShape[i] = inputShape[i] * inputs[1].numberData[i];\n    tileOps.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${inputShape[i]}.));`);\n  }\n\n  const rank = outputShape.length;\n  const shaderSource = `\n      float process(int outputIdx[${rank}]) {\n        int inputIdx[${rank}];\n        ${tileOps.join('\\n')}\n        return _A(inputIdx);\n      }\n    `;\n  return {\n    ...tileProgramMetadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Tile requires 2 input.');\n  }\n  if (inputs[1].dims.length !== 1) {\n    throw new Error('The second input shape must 1 dimension.');\n  }\n  if (inputs[1].dims[0] !== inputs[0].dims.length) {\n    throw new Error('Invalid input shape.');\n  }\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs[1].type !== 'int32' && inputs[1].type !== 'int16') {\n    throw new Error('Invalid repeat type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nexport const unsqueeze: OperatorImplementation<number[]> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  axes: number[],\n): Tensor[] => {\n  validateInputs(inputs);\n  const outputShape = ShapeUtil.unsqueezeShape(inputs[0].dims, axes);\n  const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);\n  return [output];\n};\n\nexport const unsqueezeV13 = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputsV13(inputs);\n  return unsqueeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));\n};\n\nexport const parseUnsqueezeAttributes: OperatorInitialization<number[]> = (node: Graph.Node): number[] =>\n  node.attributes.getInts('axes');\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Unsqueeze requires 1 input.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('invalid input tensor types.');\n  }\n};\n\nconst validateInputsV13 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Unsqueeze requires 2 inputs.');\n  }\n\n  if (inputs[1].type !== 'int32') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { OpSet } from '../../opset';\n\nimport { batchNormalization, parseBatchNormalizationAttributes } from './ops/batch-normalization';\nimport * as binaryOps from './ops/binary-op';\nimport { cast, parseCastAttributes } from './ops/cast';\nimport { concat, parseConcatAttributes } from './ops/concat';\nimport { conv, parseConvAttributes } from './ops/conv';\nimport { convTranspose, parseConvTransposeAttributes } from './ops/conv-transpose';\nimport { depthToSpace, parseDepthToSpaceAttributes } from './ops/depth-to-space';\nimport { flatten, parseFlattenAttributes } from './ops/flatten';\nimport { gather, parseGatherAttributes } from './ops/gather';\nimport { gemm, parseGemmAttributesV11, parseGemmAttributesV7 } from './ops/gemm';\nimport { imageScaler, parseImageScalerAttributes } from './ops/image-scaler';\nimport { instanceNormalization, parseInstanceNormalizationAttributes } from './ops/instance-normalization';\nimport { lrn, parseLrnAttributes } from './ops/lrn';\nimport { matMul, parseMatMulAttributes } from './ops/matmul';\nimport { padV11, padV2, parsePadAttributesV11, parsePadAttributesV2 } from './ops/pad';\nimport {\n  averagePool,\n  globalAveragePool,\n  globalMaxPool,\n  maxPool,\n  parseAveragePoolAttributes,\n  parseGlobalAveragePoolAttributes,\n  parseMaxPoolAttributes,\n} from './ops/pool';\nimport {\n  parseReduceAttributes,\n  reduceLogSum,\n  reduceLogSumSquare,\n  reduceMax,\n  reduceMean,\n  reduceMin,\n  reduceProd,\n  reduceSum,\n} from './ops/reduce';\nimport { reshape } from './ops/reshape';\nimport { parseResizeAttributesV10, parseResizeAttributesV11, resize } from './ops/resize-packed';\nimport { shape } from './ops/shape';\nimport { parseSliceAttributes, slice, sliceV10 } from './ops/slice';\nimport { parseSoftmaxAttributes, parseSoftmaxAttributesV13, softmax, softmaxV13 } from './ops/softmax';\nimport { parseSplitAttributes, split } from './ops/split';\nimport { parseSqueezeAttributes, squeeze, squeezeV13 } from './ops/squeeze';\nimport { sum } from './ops/sum';\nimport { tile } from './ops/tile';\nimport { parseTransposeAttributes, transpose } from './ops/transpose';\nimport * as unaryOps from './ops/unary-op';\nimport { parseUnsqueezeAttributes, unsqueeze, unsqueezeV13 } from './ops/unsqueeze';\nimport { parseUpsampleAttributesV7, parseUpsampleAttributesV9, upsample } from './ops/upsample';\n\nexport const WEBGL_OP_RESOLVE_RULES: readonly OpSet.ResolveRule[] = [\n  ['Abs', '', '6+', unaryOps.abs],\n  ['Acos', '', '7+', unaryOps.acos],\n  ['Add', '', '7+', binaryOps.add],\n  ['And', '', '7+', binaryOps.and],\n  ['Asin', '', '7+', unaryOps.asin],\n  ['Atan', '', '7+', unaryOps.atan],\n  // TODO: support new attributes for AveragePool-10\n  ['AveragePool', '', '7+', averagePool, parseAveragePoolAttributes],\n  ['BatchNormalization', '', '7+', batchNormalization, parseBatchNormalizationAttributes],\n  ['Cast', '', '6+', cast, parseCastAttributes],\n  ['Ceil', '', '6+', unaryOps.ceil],\n  ['Clip', '', '6-10', unaryOps.clip, unaryOps.parseClipAttributes],\n  ['Clip', '', '11+', unaryOps.clipV11],\n  ['Concat', '', '4+', concat, parseConcatAttributes],\n  ['Conv', '', '1+', conv, parseConvAttributes],\n  ['ConvTranspose', '', '1+', convTranspose, parseConvTransposeAttributes],\n  ['Cos', '', '7+', unaryOps.cos],\n  ['Div', '', '7+', binaryOps.div],\n  ['Dropout', '', '7+', unaryOps.identity],\n  ['DepthToSpace', '', '1+', depthToSpace, parseDepthToSpaceAttributes],\n  ['Equal', '', '7+', binaryOps.equal],\n  ['Elu', '', '6+', unaryOps.elu, unaryOps.parseEluAttributes],\n  ['Exp', '', '6+', unaryOps.exp],\n  ['Flatten', '', '1+', flatten, parseFlattenAttributes],\n  ['Floor', '', '6+', unaryOps.floor],\n  ['FusedConv', 'com.microsoft', '1+', conv, parseConvAttributes],\n  ['Gather', '', '1+', gather, parseGatherAttributes],\n  ['Gemm', '', '7-10', gemm, parseGemmAttributesV7],\n  ['Gemm', '', '11+', gemm, parseGemmAttributesV11],\n  ['GlobalAveragePool', '', '1+', globalAveragePool, parseGlobalAveragePoolAttributes],\n  ['GlobalMaxPool', '', '1+', globalMaxPool],\n  ['Greater', '', '7+', binaryOps.greater],\n  ['Identity', '', '1+', unaryOps.identity],\n  ['ImageScaler', '', '1+', imageScaler, parseImageScalerAttributes],\n  ['InstanceNormalization', '', '6+', instanceNormalization, parseInstanceNormalizationAttributes],\n  ['LeakyRelu', '', '6+', unaryOps.leakyRelu, unaryOps.parseLeakyReluAttributes],\n  ['Less', '', '7+', binaryOps.less],\n  ['LRN', '', '1+', lrn, parseLrnAttributes],\n  ['Log', '', '6+', unaryOps.log],\n  ['MatMul', '', '1+', matMul, parseMatMulAttributes],\n  // TODO: support new attributes for MaxPool-8 and MaxPool-10\n  ['MaxPool', '', '1+', maxPool, parseMaxPoolAttributes],\n  ['Mul', '', '7+', binaryOps.mul],\n  ['Neg', '', '6+', unaryOps.neg],\n  ['Not', '', '1+', unaryOps.not],\n  ['Or', '', '7+', binaryOps.or],\n  ['Pad', '', '2-10', padV2, parsePadAttributesV2],\n  ['Pad', '', '11+', padV11, parsePadAttributesV11],\n  ['Pow', '', '7+', binaryOps.pow],\n  ['PRelu', '', '7+', binaryOps.pRelu],\n  ['ReduceLogSum', '', '1+', reduceLogSum, parseReduceAttributes],\n  ['ReduceMax', '', '1+', reduceMax, parseReduceAttributes],\n  ['ReduceMean', '', '1+', reduceMean, parseReduceAttributes],\n  ['ReduceMin', '', '1+', reduceMin, parseReduceAttributes],\n  ['ReduceProd', '', '1+', reduceProd, parseReduceAttributes],\n  ['ReduceSum', '', '1-12', reduceSum, parseReduceAttributes],\n  ['ReduceSumSquare', '', '1+', reduceLogSumSquare, parseReduceAttributes],\n  ['Relu', '', '6+', unaryOps.relu],\n  ['Reshape', '', '5+', reshape],\n  ['Resize', '', '10', resize, parseResizeAttributesV10],\n  ['Resize', '', '11+', resize, parseResizeAttributesV11],\n  ['Shape', '', '1+', shape],\n  ['Sigmoid', '', '6+', unaryOps.sigmoid],\n  ['Sin', '', '7+', unaryOps.sin],\n  ['Slice', '', '10+', sliceV10], // TODO: support 'steps' for Slice-10\n  ['Slice', '', '1-9', slice, parseSliceAttributes],\n  // The \"semantic\" meaning of axis has changed in opset-13.\n  ['Softmax', '', '1-12', softmax, parseSoftmaxAttributes],\n  ['Softmax', '', '13+', softmaxV13, parseSoftmaxAttributesV13],\n  // 'Split' operator has an optional attribute 'split'\n  // this attribute determines how the specified axis of input data is split.\n  // When the attribute is missing, we need the count of number of outputs\n  // so that we can determine the 'split' attribute from the runtime input to the Operator\n  ['Split', '', '2-12', split, parseSplitAttributes],\n  ['Sqrt', '', '6+', unaryOps.sqrt],\n  ['Squeeze', '', '1-12', squeeze, parseSqueezeAttributes],\n  ['Squeeze', '', '13+', squeezeV13],\n  ['Sub', '', '7+', binaryOps.sub],\n  ['Sum', '', '6+', sum],\n  ['Tan', '', '7+', unaryOps.tan],\n  ['Tanh', '', '6+', unaryOps.tanh],\n  ['Tile', '', '6+', tile],\n  ['Transpose', '', '1+', transpose, parseTransposeAttributes],\n  ['Upsample', '', '7-8', upsample, parseUpsampleAttributesV7],\n  ['Upsample', '', '9', upsample, parseUpsampleAttributesV9],\n  ['Unsqueeze', '', '1-12', unsqueeze, parseUnsqueezeAttributes],\n  ['Unsqueeze', '', '13+', unsqueezeV13],\n  ['Xor', '', '7+', binaryOps.xor],\n];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nconst INLINE_FUNC_DEF_REGEX = /@inline[\\s\\n\\r]+(\\w+)[\\s\\n\\r]+([0-9a-zA-Z_]+)\\s*\\(([^)]*)\\)\\s*{(([^}]|[\\n\\r])*)}/gm;\nconst FUNC_CALL_REGEX = '(\\\\w+)?\\\\s+([_0-9a-zA-Z]+)\\\\s+=\\\\s+__FUNC__\\\\((.*)\\\\)\\\\s*;';\n/**\n * GLSL preprocessor responsible for resolving @inline directives\n */\nexport function replaceInlines(script: string): string {\n  const inlineDefs: { [name: string]: { params: Array<{ type: string; name: string } | null>; body: string } } = {};\n  let match;\n  while ((match = INLINE_FUNC_DEF_REGEX.exec(script)) !== null) {\n    const params = match[3]\n      .split(',')\n      .map((s) => {\n        const tokens = s.trim().split(' ');\n        if (tokens && tokens.length === 2) {\n          return { type: tokens[0], name: tokens[1] };\n        }\n        return null;\n      })\n      .filter((v) => v !== null);\n    inlineDefs[match[2]] = { params, body: match[4] };\n  }\n  for (const name in inlineDefs) {\n    const regexString = FUNC_CALL_REGEX.replace('__FUNC__', name);\n    const regex = new RegExp(regexString, 'gm');\n    while ((match = regex.exec(script)) !== null) {\n      const type = match[1];\n      const variable = match[2];\n      const params = match[3].split(',');\n      const declLine = type ? `${type} ${variable};` : '';\n      let newBody: string = inlineDefs[name].body;\n      let paramRedecLine = '';\n      inlineDefs[name].params.forEach((v, i) => {\n        if (v) {\n          paramRedecLine += `${v.type} ${v.name} = ${params[i]};\\n`;\n        }\n      });\n      newBody = `${paramRedecLine}\\n ${newBody}`;\n      newBody = newBody.replace('return', `${variable} = `);\n      const replacement = `\n      ${declLine}\n      {\n        ${newBody}\n      }\n      `;\n      script = script.replace(match[0], replacement);\n    }\n  }\n  script = script.replace(INLINE_FUNC_DEF_REGEX, '');\n  return script;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Logger } from '../../instrument';\nimport { assert } from '../../util';\n\n/** Layout preferences */\nexport interface WidthHeightPrefs {\n  breakAxis?: number;\n  isPacked?: boolean;\n  reverseWH?: boolean;\n}\n/**\n * TextureLayoutStrategy is an abstraction for different plans\n * for mapping n-dimensional arrays to 2D textures (and back)\n */\nexport interface TextureLayoutStrategy {\n  computeTextureWH(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number];\n}\n\n/**\n * This strategy try to find the minimal max(W,H) that fulfills (W * H == totalSize)\n */\nexport class AlwaysKeepOriginalSizeStrategy implements TextureLayoutStrategy {\n  constructor(public maxTextureSize: number) {}\n  computeTextureWH(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number] {\n    // scalar tensor\n    if (shape.length === 0) {\n      return [1, 1];\n    }\n    const maxTextureSize = this.maxTextureSize;\n    if (prefs && prefs.breakAxis !== undefined) {\n      // check to see if dims fit\n      const wsize = prefs.breakAxis >= shape.length ? 1 : shape.slice(prefs.breakAxis).reduce((a, b) => a * b);\n      const hsize = prefs.breakAxis <= 0 ? 1 : shape.slice(0, prefs.breakAxis).reduce((a, b) => a * b);\n      if (wsize > maxTextureSize || hsize > maxTextureSize) {\n        // ignore preferences\n        // continue with default layout\n        Logger.verbose(\n          'TextureLayout',\n          `Given width/height preferences were unattainable: shape:${shape}, breakAxis:${prefs.breakAxis}`,\n        );\n      } else {\n        return [wsize, hsize];\n      }\n    }\n    const totalSize = shape.reduce((a, b) => a * b);\n\n    let width = Math.floor(Math.sqrt(totalSize));\n\n    for (; width < maxTextureSize && width < totalSize; width++) {\n      if (totalSize % width === 0) {\n        break;\n      }\n    }\n\n    if (width >= maxTextureSize || totalSize % width !== 0) {\n      throw new Error(`The given dimensions are outside this GPU's boundaries: ${shape}`);\n    }\n    return [width, totalSize / width];\n  }\n}\n\nexport class PreferLogicalStrategy implements TextureLayoutStrategy {\n  constructor(public maxTextureSize: number) {}\n  computeTextureWH(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number] {\n    const wh = this.computeTexture(shape, prefs);\n    if (prefs && prefs.isPacked) {\n      wh[0] /= 2;\n      wh[1] /= 2;\n    }\n    if (prefs && prefs.reverseWH) {\n      return [wh[1], wh[0]];\n    }\n    return wh;\n  }\n\n  computeTexture(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number] {\n    const isPacked = prefs && prefs.isPacked;\n    // scalar tensor\n    if (shape.length === 0) {\n      return isPacked ? [2, 2] : [1, 1];\n    }\n    let maxTextureSize = this.maxTextureSize;\n    if (prefs && prefs.breakAxis !== undefined) {\n      // check to see if dims fit\n      const wsize = prefs.breakAxis >= shape.length ? 1 : shape.slice(prefs.breakAxis).reduce((a, b) => a * b);\n      const hsize = prefs.breakAxis <= 0 ? 1 : shape.slice(0, prefs.breakAxis).reduce((a, b) => a * b);\n      if (wsize > maxTextureSize || hsize > maxTextureSize) {\n        // ignore preferences\n        // continue with default layout\n        Logger.verbose(\n          'TextureLayout',\n          `Given width/height preferences were unattainable: shape:${shape}, breakAxis:${prefs.breakAxis}`,\n        );\n      } else {\n        return [wsize, hsize];\n      }\n    }\n    let logShape = shape.slice(0);\n    if (isPacked) {\n      maxTextureSize = maxTextureSize * 2;\n\n      // This logic ensures we accurately count the number of packed texels needed\n      // to accommodate the tensor. We can only pack values in the same texel if\n      // they are from adjacent pairs of rows/cols within the same batch. So if a\n      // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n      // fact that the texels containing the third row are half empty.\n      logShape = logShape.map((_d, i) =>\n        i >= logShape.length - 2 ? (logShape[i] % 2 === 0 ? logShape[i] : logShape[i] + 1) : logShape[i],\n      );\n\n      // Packed texture height is at least 2 (the channel height of a single\n      // texel).\n      if (logShape.length === 1) {\n        logShape = [2, logShape[0]];\n      }\n    }\n\n    // If logical shape is 2, we don't squeeze, since we want to match physical.\n    if (logShape.length !== 2) {\n      const squeezeResult = squeezeShape(logShape);\n      logShape = squeezeResult.newShape;\n    }\n\n    const size = sizeFromShape(logShape);\n    if (logShape.length <= 1 && size <= maxTextureSize) {\n      return [1, size];\n    } else if (logShape.length === 2 && logShape[0] <= maxTextureSize && logShape[1] <= maxTextureSize) {\n      return logShape as [number, number];\n    } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTextureSize && logShape[2] <= maxTextureSize) {\n      return [logShape[0] * logShape[1], logShape[2]];\n    } else if (logShape.length === 3 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] <= maxTextureSize) {\n      return [logShape[0], logShape[1] * logShape[2]];\n    } else if (\n      logShape.length === 4 &&\n      logShape[0] * logShape[1] * logShape[2] <= maxTextureSize &&\n      logShape[3] <= maxTextureSize\n    ) {\n      return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n    } else if (\n      logShape.length === 4 &&\n      logShape[0] <= maxTextureSize &&\n      logShape[1] * logShape[2] * logShape[3] <= maxTextureSize\n    ) {\n      return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n    } else {\n      if (isPacked) {\n        // For packed textures size equals the number of channels required to\n        // accommodate the texture data. However in order to squarify such that\n        // inner dimensions stay even, we rewrite size to equal the number of\n        // texels. Then in the return statement we rehydrate the squarified\n        // dimensions to channel units.\n        return sizeToSquarishShape(size / 4).map((d) => d * 2) as [number, number];\n      }\n      return sizeToSquarishShape(size);\n    }\n  }\n}\n\nexport function squeezeShape(shape: number[], axis?: number[]): { newShape: number[]; keptDims: number[] } {\n  const newShape: number[] = [];\n  const keptDims: number[] = [];\n  const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;\n  const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape).sort();\n  let j = 0;\n  for (let i = 0; i < shape.length; ++i) {\n    if (axes != null) {\n      if (axes[j] === i && shape[i] !== 1) {\n        throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);\n      }\n      if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {\n        newShape.push(shape[i]);\n        keptDims.push(i);\n      }\n      if (axes[j] <= i) {\n        j++;\n      }\n    }\n    if (shape[i] !== 1) {\n      newShape.push(shape[i]);\n      keptDims.push(i);\n    }\n  }\n  return { newShape, keptDims };\n}\n\nexport function parseAxisParam(axis: number | number[], shape: number[]): number[] {\n  const rank = shape.length;\n\n  // Normalize input\n  axis = axis == null ? shape.map((_s, i) => i) : ([] as number[]).concat(axis);\n\n  // Check for valid range\n  assert(\n    axis.every((ax) => ax >= -rank && ax < rank),\n    () => `All values in axis param must be in range [-${rank}, ${rank}) but ` + `got axis ${axis}`,\n  );\n\n  // Check for only integers\n  assert(axis.every(isInt), () => 'All values in axis param must be integers but ' + `got axis ${axis}`);\n\n  // Handle negative axis.\n  return axis.map((a) => (a < 0 ? rank + a : a));\n}\nexport function isInt(a: number): boolean {\n  return a % 1 === 0;\n}\nexport function sizeFromShape(shape: number[]): number {\n  if (shape.length === 0) {\n    // Scalar.\n    return 1;\n  }\n  let size = shape[0];\n  for (let i = 1; i < shape.length; i++) {\n    size *= shape[i];\n  }\n  return size;\n}\nexport function getRowsCols(shape: number[]): [number, number] {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\nexport function sizeToSquarishShape(size: number): [number, number] {\n  const width = Math.ceil(Math.sqrt(size));\n  return [width, Math.ceil(size / width)];\n}\nexport function getBatchDim(shape: number[], dimsToSkip = 2): number {\n  return sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { ArrayUtil, BroadcastUtil, ShapeUtil } from '../../util';\n\nimport { GlslContext, GlslLib, GlslLibRoutine } from './glsl-definitions';\nimport { getGlsl } from './glsl-source';\nimport { squeezeShape } from './texture-layout-strategy';\nimport { TextureLayout } from './types';\nimport {\n  generateShaderFuncNameFromInputSamplerName,\n  generateShaderFuncNameFromInputSamplerNameAtOutCoords,\n  getCoordsDataType,\n  getGlChannels,\n  getSqueezedParams,\n  squeezeInputShape,\n} from './utils';\n\n/**\n * GLSL Library responsible for data types and routines for manipulating\n * coordinates and mapping to/from tensor indices\n */\nexport class CoordsGlslLib extends GlslLib {\n  returnType: string;\n\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): { [name: string]: GlslLibRoutine } {\n    return {\n      ...this.offsetToCoords(),\n      ...this.coordsToOffset(),\n      ...this.toVec(),\n      ...this.valueFrom(),\n      // TODO return these only when packing is enabled.\n      ...this.getCommonUtilFuncs(),\n      ...this.getInputsSamplingSnippets(),\n      ...this.getOutputSamplingSnippet(),\n    };\n  }\n  getCustomTypes() {\n    return {};\n  }\n  /**\n   * Produces a function that can map from\n   * 2D normalzied coordinates (s,t) to a flat offset\n   */\n  protected offsetToCoords(): { [name: string]: GlslLibRoutine } {\n    const funcName = 'offsetToCoords';\n    return {\n      offsetToCoords: new GlslLibRoutine(`\n      vec2 ${funcName}(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      `),\n    };\n  }\n\n  /**\n   * Produces a function that can map from\n   * 2D normalzied coordinates (s,t) to a flat offset\n   */\n  protected coordsToOffset(): { [name: string]: GlslLibRoutine } {\n    const funcName = 'coordsToOffset';\n    return {\n      coordsToOffset: new GlslLibRoutine(`\n      int ${funcName}(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      `),\n    };\n  }\n\n  /**\n   * Generates code for output sampler.\n   */\n\n  protected getOutputSamplingSnippet(): { [name: string]: GlslLibRoutine } {\n    const outputLayout = this.context.outputTextureLayout;\n    if (outputLayout.isPacked) {\n      return this.getPackedOutputSamplingSnippet(outputLayout);\n    } else {\n      return this.getUnpackedOutputSamplingSnippet(outputLayout);\n    }\n  }\n\n  /**\n   * Generates code for packed output sampler.\n   */\n  protected getPackedOutputSamplingSnippet(outputLayout: TextureLayout): { [name: string]: GlslLibRoutine } {\n    const outShape = outputLayout.unpackedShape;\n    const outTexShape = [outputLayout.width, outputLayout.height];\n    const result: { [name: string]: GlslLibRoutine } = {};\n    const funcName = 'getOutputCoords';\n    switch (outShape.length) {\n      case 0:\n        result[funcName] = this.getOutputScalarCoords();\n        break;\n      case 1:\n        result[funcName] = this.getOutputPacked1DCoords(outShape as [number], outTexShape as [number, number]);\n        break;\n      case 2:\n        result[funcName] = this.getOutputPacked2DCoords(outShape as [number, number], outTexShape as [number, number]);\n        break;\n      case 3:\n        result[funcName] = this.getOutputPacked3DCoords(\n          outShape as [number, number, number],\n          outTexShape as [number, number],\n        );\n        break;\n      default:\n        result[funcName] = this.getOutputPackedNDCoords(outShape, outTexShape as [number, number]);\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    // TODO we need this to properly return a packed vec4 from kernels.\n    // Replace all '{glsl.output} = result' with 'setOutput(result)' in all kernels.\n    const floatTextureSetRGBASource = `\n      void setOutput(vec4 val) {\n        ${glsl.output} = val;\n      }\n    `;\n    const floatTextureSetRGBAFuncName = 'floatTextureSetRGBA';\n    result[floatTextureSetRGBAFuncName] = new GlslLibRoutine(floatTextureSetRGBASource);\n    return result;\n  }\n\n  /**\n   * Generates code for unpacked output sampler.\n   */\n  protected getUnpackedOutputSamplingSnippet(outputLayout: TextureLayout): { [name: string]: GlslLibRoutine } {\n    const outShape = outputLayout.unpackedShape;\n    const outTexShape = [outputLayout.width, outputLayout.height];\n    const result: { [name: string]: GlslLibRoutine } = {};\n    const funcName = 'getOutputCoords';\n    switch (outShape.length) {\n      case 0:\n        result[funcName] = this.getOutputScalarCoords();\n        break;\n      case 1:\n        result[funcName] = this.getOutputUnpacked1DCoords(outShape as [number], outTexShape as [number, number]);\n        break;\n      case 2:\n        result[funcName] = this.getOutputUnpacked2DCoords(\n          outShape as [number, number],\n          outTexShape as [number, number],\n        );\n        break;\n      case 3:\n        result[funcName] = this.getOutputUnpacked3DCoords(\n          outShape as [number, number, number],\n          outTexShape as [number, number],\n        );\n        break;\n      case 4:\n        result[funcName] = this.getOutputUnpacked4DCoords(\n          outShape as [number, number, number, number],\n          outTexShape as [number, number],\n        );\n        break;\n      case 5:\n        result[funcName] = this.getOutputUnpacked5DCoords(\n          outShape as [number, number, number, number, number],\n          outTexShape as [number, number],\n        );\n        break;\n      case 6:\n        result[funcName] = this.getOutputUnpacked6DCoords(\n          outShape as [number, number, number, number, number, number],\n          outTexShape as [number, number],\n        );\n        break;\n      default:\n        throw new Error(`Unsupported output dimensionality: ${outShape.length}`);\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    // TODO we need this to properly return a packed vec4 from kernels.\n    // Replace all '{glsl.output} = result' with 'setOutput(result)' in all kernels.\n    const floatTextureSetRSource = `\n        void setOutput(float val) {\n          ${glsl.output} = vec4(val, 0, 0, 0);\n        }\n    `;\n    const floatTextureSetRFuncName = 'floatTextureSetR';\n    result[floatTextureSetRFuncName] = new GlslLibRoutine(floatTextureSetRSource);\n    return result;\n  }\n\n  /**\n   * Scalar output coordinates.\n   */\n  protected getOutputScalarCoords(): GlslLibRoutine {\n    return new GlslLibRoutine(`\n      int getOutputCoords() {\n        return 0;\n      }\n    `);\n  }\n\n  /**\n   * 1D packed output coordinates.\n   */\n  protected getOutputPacked1DCoords(_shape: [number], texShape: [number, number]): GlslLibRoutine {\n    const packedTexShape = texShape;\n    let source = '';\n    if (packedTexShape[0] === 1) {\n      source = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${packedTexShape[1]}.0);\n          }\n        `;\n      return new GlslLibRoutine(source);\n    }\n\n    if (packedTexShape[1] === 1) {\n      source = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${packedTexShape[0]}.0);\n          }\n        `;\n      return new GlslLibRoutine(source);\n    }\n\n    source = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n          return 2 * (resTexRC.y * ${packedTexShape[0]} + resTexRC.x);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * 2D packed output coordinates.\n   */\n  protected getOutputPacked2DCoords(shape: [number, number], texShape: [number, number]): GlslLibRoutine {\n    let source = '';\n    if (ArrayUtil.arraysEqual(shape, texShape)) {\n      source = `\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${texShape[0]}, ${texShape[1]}));\n        }\n      `;\n      return new GlslLibRoutine(source);\n    }\n\n    const packedTexShape = texShape;\n    // texels needed to accommodate a logical row\n    const texelsInLogicalRow = Math.ceil(shape[1] / 2);\n\n    /**\n     * getOutputCoords\n     *\n     * resTexRC: The rows and columns of the texels. If you move over one\n     * texel to the right in the packed texture, you are moving over one column\n     * (not two).\n     *\n     * index: The texel index\n     */\n    source = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n\n          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${texelsInLogicalRow}) * 2;\n          int c = 2 * (index / ${texelsInLogicalRow});\n\n          return ivec2(r, c);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * 3D packed output coordinates.\n   */\n  protected getOutputPacked3DCoords(shape: [number, number, number], texShape: [number, number]): GlslLibRoutine {\n    const packedTexShape = [texShape[0], texShape[1]];\n    const texelsInLogicalRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);\n    const source = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n          int b = index / ${texelsInBatch};\n          index -= b * ${texelsInBatch};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${texelsInLogicalRow}) * 2;\n          int c = 2 * (index / ${texelsInLogicalRow});\n\n          return ivec3(b, r, c);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * ND packed output coordinates.\n   */\n  protected getOutputPackedNDCoords(shape: readonly number[], texShape: [number, number]): GlslLibRoutine {\n    const packedTexShape = [texShape[0], texShape[1]];\n\n    const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);\n    let texelsInBatchN = texelsInBatch;\n    let batches = '';\n    let coords = 'b, r, c';\n\n    for (let b = 2; b < shape.length - 1; b++) {\n      texelsInBatchN *= shape[shape.length - b - 1];\n      batches =\n        `\n      int b${b} = index / ${texelsInBatchN};\n      index -= b${b} * ${texelsInBatchN};\n    ` + batches;\n      coords = `b${b}, ` + coords;\n    }\n    const source = `\n      ivec${shape.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n        int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n        ${batches}\n\n        int b = index / ${texelsInBatch};\n        index -= b * ${texelsInBatch};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${texelsInLogicalRow}) * 2;\n        int c = 2 * (index / ${texelsInLogicalRow});\n\n        return ivec${shape.length}(${coords});\n      }\n    `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 1D output coordinates.\n   */\n  protected getOutputUnpacked1DCoords(_shape: [number], texShape: [number, number]): GlslLibRoutine {\n    const source = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          return resTexRC.y * ${texShape[0]} + resTexRC.x;\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 2D output coordinates.\n   */\n  protected getOutputUnpacked2DCoords(shape: [number, number], texShape: [number, number]): GlslLibRoutine {\n    const source = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          int r = index / ${shape[1]};\n          int c = index - r * ${shape[1]};\n          return ivec2(r, c);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 3D output coordinates.\n   */\n  protected getOutputUnpacked3DCoords(shape: [number, number, number], texShape: [number, number]): GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd'];\n    const coordsFromIndexSnippet = strides\n      .map((stride, i) => {\n        const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n        const line2 =\n          i === strides.length - 1\n            ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}`\n            : `index -= ${coordsToCompute[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n\n    source = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec3(r, c, d);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 4D output coordinates.\n   */\n  protected getOutputUnpacked4DCoords(\n    shape: [number, number, number, number],\n    texShape: [number, number],\n  ): GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd', 'd2'];\n    const coordsFromIndexSnippet = strides\n      .map((stride, i) => {\n        const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n        const line2 =\n          i === strides.length - 1\n            ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}`\n            : `index -= ${coordsToCompute[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n\n    source = `\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec4(r, c, d, d2);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 5D output coordinates.\n   */\n  protected getOutputUnpacked5DCoords(\n    shape: [number, number, number, number, number],\n    texShape: [number, number],\n  ): GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd', 'd2', 'd3'];\n    const coordsFromIndexSnippet = strides\n      .map((stride, i) => {\n        const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n        const line2 =\n          i === strides.length - 1\n            ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}`\n            : `index -= ${coordsToCompute[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n\n    source = `\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 6D output coordinates.\n   */\n  protected getOutputUnpacked6DCoords(\n    shape: [number, number, number, number, number, number],\n    texShape: [number, number],\n  ): GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd', 'd2', 'd3', 'd4'];\n    const coordsFromIndexSnippet = strides\n      .map((stride, i) => {\n        const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n        const line2 =\n          i === strides.length - 1\n            ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}`\n            : `index -= ${coordsToCompute[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n\n    source = `\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n         int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n         ${coordsFromIndexSnippet}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Generates code for common UV coords computation utility functions.\n   */\n  protected getCommonUtilFuncs(): { [name: string]: GlslLibRoutine } {\n    const result: { [name: string]: GlslLibRoutine } = {};\n    let funcName = 'uvFromFlat';\n    result[funcName] = new GlslLibRoutine(`\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    `);\n    funcName = 'packedUVfrom1D';\n    result[funcName] = new GlslLibRoutine(`\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `);\n    funcName = 'packedUVfrom2D';\n    result[funcName] = new GlslLibRoutine(`\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `);\n    funcName = 'packedUVfrom3D';\n    result[funcName] = new GlslLibRoutine(`\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `);\n    funcName = 'sampleTexture';\n    const glsl = getGlsl(this.context.glContext.version);\n    result[funcName] = new GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${glsl.texture2D}(textureSampler, uv).r;\n        }`);\n    return result;\n  }\n\n  /**\n   * Constructing snippets for inputs\n   */\n  protected getInputsSamplingSnippets(): { [name: string]: GlslLibRoutine } {\n    const result: { [name: string]: GlslLibRoutine } = {};\n    const outputLayout = this.context.outputTextureLayout;\n    this.context.programInfo.inputNames.forEach((samplerName, i) => {\n      const inputLayout = this.context.inputTextureLayouts[i];\n      const funcName = generateShaderFuncNameFromInputSamplerName(samplerName);\n      if (inputLayout.isPacked) {\n        result[funcName] = this.getPackedSamplerFromInput(funcName, samplerName, inputLayout);\n      } else {\n        result[funcName] = this.getUnpackedSamplerFromInput(funcName, samplerName, inputLayout);\n      }\n\n      const outCoordFuncName = generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName);\n      if (inputLayout.unpackedShape.length <= outputLayout.unpackedShape.length) {\n        if (inputLayout.isPacked) {\n          result[outCoordFuncName] = this.getPackedSamplerAtOutputCoords(\n            outCoordFuncName,\n            inputLayout,\n            outputLayout,\n            samplerName,\n          );\n        } else {\n          result[outCoordFuncName] = this.getUnpackedSamplerAtOutputCoords(\n            outCoordFuncName,\n            inputLayout,\n            outputLayout,\n            samplerName,\n          );\n        }\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * Constructing snippets for output coordinates of samplers\n   */\n  protected getPackedSamplerAtOutputCoords(\n    funcName: string,\n    inputLayout: TextureLayout,\n    outputLayout: TextureLayout,\n    name: string,\n  ): GlslLibRoutine {\n    const inShape = inputLayout.unpackedShape;\n    const outShape = outputLayout.unpackedShape;\n    const texName = name;\n    const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(texName);\n\n    const inRank = inShape.length;\n    const outRank = outShape.length;\n\n    const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);\n\n    const type = getCoordsDataType(outRank);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet: string;\n    const fields = getGlChannels();\n\n    if (inRank === 0) {\n      coordsSnippet = '';\n    } else if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0;';\n    } else {\n      coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n      unpackedCoordsSnippet = 'coords';\n    } else {\n      unpackedCoordsSnippet = inShape.map((_s, i) => `coords.${fields[i + rankDiff]}`).join(', ');\n    }\n\n    let output = 'return outputValue;';\n    const inSize = ShapeUtil.size(inShape);\n    const isInputScalar = inSize === 1;\n    const outSize = ShapeUtil.size(outShape);\n    const isOutputScalar = outSize === 1;\n\n    if (inRank === 1 && !isInputScalar && !isOutputScalar) {\n      output = `\n        return vec4(outputValue.xy, outputValue.xy);\n      `;\n    } else if (isInputScalar && !isOutputScalar) {\n      if (outRank === 1) {\n        output = `\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        `;\n      } else {\n        output = `\n          return vec4(outputValue.x);\n        `;\n      }\n    } else if (broadcastDims.length) {\n      const rows = inRank - 2;\n      const cols = inRank - 1;\n\n      if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {\n        output = 'return vec4(outputValue.x);';\n      } else if (broadcastDims.indexOf(rows) > -1) {\n        output = 'return vec4(outputValue.x, outputValue.y, ' + 'outputValue.x, outputValue.y);';\n      } else if (broadcastDims.indexOf(cols) > -1) {\n        output = 'return vec4(outputValue.xx, outputValue.zz);';\n      }\n    }\n\n    const swapLastDimsSnippet = `\n        int lastDim = coords.${fields[outRank - 1]};\n        coords.${fields[outRank - 1]} = coords.${fields[outRank - 2]};\n        coords.${fields[outRank - 2]} = lastDim;\n      `;\n    const source = `\n      vec4 ${funcName}() {\n        ${type} coords = getOutputCoords();\n        ${swapLastDimsSnippet}\n        ${coordsSnippet}\n        vec4 outputValue = ${texFuncSnippet}(${unpackedCoordsSnippet});\n        ${output}\n      }\n    `;\n    return new GlslLibRoutine(source, ['coordinates.getOutputCoords']);\n  }\n\n  /**\n   * Constructing snippets for unpacked output coordinates of samplers\n   */\n  protected getUnpackedSamplerAtOutputCoords(\n    funcName: string,\n    inputLayout: TextureLayout,\n    outputLayout: TextureLayout,\n    name: string,\n  ): GlslLibRoutine {\n    const outTexShape = [outputLayout.width, outputLayout.height];\n    const inTexShape = [inputLayout.width, inputLayout.height];\n    const inRank = inputLayout.unpackedShape.length;\n    const outRank = outputLayout.unpackedShape.length;\n    const inShape = inputLayout.unpackedShape;\n    const outShape = outputLayout.unpackedShape;\n    const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(name);\n\n    if (inRank === outRank && ArrayUtil.arraysEqual(inTexShape, outTexShape)) {\n      const source = `\n          float ${funcName}() {\n            return sampleTexture(${name}, TexCoords);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const type = getCoordsDataType(outRank);\n    const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet: string;\n    const fields = getGlChannels();\n\n    if (inRank === 0) {\n      coordsSnippet = '';\n    } else if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0;';\n    } else {\n      coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n      unpackedCoordsSnippet = 'coords';\n    } else {\n      unpackedCoordsSnippet = inputLayout.unpackedShape.map((_s, i) => `coords.${fields[i + rankDiff]}`).join(', ');\n    }\n    const source = `\n        float ${funcName}() {\n          ${type} coords = getOutputCoords();\n          ${coordsSnippet}\n          return ${texFuncSnippet}(${unpackedCoordsSnippet});\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.getOutputCoords']);\n  }\n\n  /**\n   * Constructing snippets for packed operations.\n   */\n  protected getPackedSamplerFromInput(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    switch (inputLayout.unpackedShape.length) {\n      case 0:\n        return this.getPackedSamplerScalar(funcName, name);\n      case 1:\n        return this.getPackedSampler1D(funcName, name, inputLayout);\n      case 2:\n        return this.getPackedSampler2D(funcName, name, inputLayout);\n      case 3:\n        return this.getPackedSampler3D(funcName, name, inputLayout);\n      default:\n        return this.getPackedSamplerND(funcName, name, inputLayout);\n    }\n  }\n\n  /**\n   * Constructing snippets for unpacked operations.\n   */\n  protected getUnpackedSamplerFromInput(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    switch (shape.length) {\n      case 0:\n        return this.getUnpackedSamplerScalar(funcName, name, inputLayout);\n      case 1:\n        return this.getUnpackedSampler1D(funcName, name, inputLayout);\n      case 2:\n        return this.getUnpackedSampler2D(funcName, name, inputLayout);\n      case 3:\n        return this.getUnpackedSampler3D(funcName, name, inputLayout);\n      case 4:\n        return this.getUnpackedSampler4D(funcName, name, inputLayout);\n      case 5:\n        return this.getUnpackedSampler5D(funcName, name, inputLayout);\n      case 6:\n        return this.getUnpackedSampler6D(funcName, name, inputLayout);\n      default:\n        // TODO support more dimensionalities\n        throw new Error(`Unsupported dimension ${shape.length}-D`);\n    }\n  }\n\n  /**\n   * Packed scalar snippet.\n   */\n  protected getPackedSamplerScalar(funcName: string, name: string): GlslLibRoutine {\n    const glsl = getGlsl(this.context.glContext.version);\n    const source = `\n          vec4 ${funcName}() {\n            return ${glsl.texture2D}(${name}, halfCR);\n          }\n        `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Packed 1D snippet.\n   */\n  protected getPackedSampler1D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const texShape = [inputLayout.width, inputLayout.height];\n    const packedTexShape = [texShape[1], texShape[0]];\n    const glsl = getGlsl(this.context.glContext.version);\n\n    const packedSampler = `vec4 ${funcName}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${packedTexShape[0]}, ${packedTexShape[1]}, index);\n      return ${glsl.texture2D}(${name}, uv);\n    }`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source, ['coordinates.packedUVfrom1D']);\n  }\n\n  /**\n   * Packed 2D snippet.\n   */\n  protected getPackedSampler2D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const texShape = [inputLayout.width, inputLayout.height];\n    const glsl = getGlsl(this.context.glContext.version);\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n\n    if (texShape != null && ArrayUtil.arraysEqual(shape, texShape)) {\n      const packedSampler = `vec4 ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n        return ${glsl.texture2D}(${name}, uv);\n      }`;\n\n      return new GlslLibRoutine(packedSampler);\n    }\n    const packedTexShape = texShape;\n    const valuesPerRow = Math.ceil(shape[1] / 2);\n    const packedSampler = `vec4 ${funcName}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${packedTexShape[1]}, ${packedTexShape[0]}, ${valuesPerRow}, row, col);\n      return ${glsl.texture2D}(${name}, uv);\n    }`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source, ['coordinates.packedUVfrom2D']);\n  }\n\n  /**\n   * Packed 3D snippet.\n   */\n  protected getPackedSampler3D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const texShape = [inputLayout.width, inputLayout.height];\n    const packedTexShape = [texShape[0], texShape[1]];\n    const glsl = getGlsl(this.context.glContext.version);\n\n    if (shape[0] === 1) {\n      const squeezedShape = shape.slice(1);\n      const keptDims = [1, 2];\n      const newInputShape = squeezeInputShape(shape, squeezedShape);\n      const params = ['b', 'row', 'col'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n      const samplerRoutine = this.getPackedSamplerFromInput(funcName, name, newInputLayout);\n      const packedSampler = `${samplerRoutine.routineBody}\n      vec4 ${funcName}(int b, int row, int col) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      } `;\n      const source = packedSampler;\n      return new GlslLibRoutine(source, samplerRoutine.dependencies);\n    }\n    const texNumR = packedTexShape[0];\n    const texNumC = packedTexShape[1];\n\n    const valuesPerRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);\n\n    const packedSampler = `vec4 ${funcName}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${texNumC}, ${texNumR}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);\n      return ${glsl.texture2D}(${name}, uv);}`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source, ['coordinates.packedUVfrom3D']);\n  }\n  /*\n   * Packed ND snippet.\n   */\n  protected getPackedSamplerND(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const rank = shape.length;\n    const texShape = [inputLayout.width, inputLayout.height];\n    const glsl = getGlsl(this.context.glContext.version);\n\n    const packedTexShape = [texShape[0], texShape[1]];\n    const texNumR = packedTexShape[1];\n    const texNumC = packedTexShape[0];\n    const valuesPerRow = Math.ceil(shape[rank - 1] / 2);\n    let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);\n    let params = 'int b, int row, int col';\n    let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;\n    for (let b = 2; b < rank - 1; b++) {\n      params = `int b${b}, ` + params;\n      texelsInBatch *= shape[rank - b - 1];\n      index = `b${b} * ${texelsInBatch} + ` + index;\n    }\n    const packedSampler = `vec4 ${funcName}(${params}) {\n      int index = ${index};\n      int texR = index / ${texNumC};\n      int texC = index - texR * ${texNumC};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});\n      return ${glsl.texture2D}(${name}, uv);\n    }`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked scalar snippet.\n   */\n  protected getUnpackedSamplerScalar(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const [texNumR, texNumC] = [inputLayout.width, inputLayout.height];\n    if (texNumR === 1 && texNumC === 1) {\n      const source = `\n          float ${funcName}() {\n            return sampleTexture(${name}, halfCR);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const source = `\n        float ${funcName}() {\n          int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, offset_${name});\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, [\n      'coordinates.uvFromFlat',\n      'coordinates.sampleTexture',\n      'coordinates.coordsToOffset',\n    ]);\n  }\n\n  /**\n   * Unpacked 1D snippet.\n   */\n  protected getUnpackedSampler1D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const tNumR = inputLayout.width;\n    const tNumC = inputLayout.height;\n\n    if (tNumC === 1 && tNumR === 1) {\n      const source = `\n        float ${funcName}(int index) {\n          return sampleTexture(${name}, halfCR);\n        }\n      `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    if (tNumC === 1) {\n      const source = `\n          float ${funcName}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${tNumR}.0, 0.5);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n    if (tNumR === 1) {\n      const source = `\n          float ${funcName}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${tNumC}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n    const source = `\n        float ${funcName}(int index) {\n          vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture']);\n  }\n\n  /**\n   * Unpacked 2D snippet.\n   */\n\n  protected getUnpackedSampler2D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n\n    // TODO: modify row/col order for other dimensions.\n    const texShape = [inputLayout.height, inputLayout.width];\n\n    if (texShape != null && ArrayUtil.arraysEqual(shape, texShape)) {\n      const texNumR = texShape[1];\n      const texNumC = texShape[0];\n      const source = `\n          float ${funcName}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${texNumR}.0, ${texNumC}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const { newShape, keptDims } = squeezeShape(shape as number[]);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, squeezedShape);\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n\n      const params = ['col', 'row'];\n      const source = `\n          ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n          float ${funcName}(int row, int col) {\n            return ${funcName}(${getSqueezedParams(params, keptDims)});\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const texNumR = texShape[1];\n    const texNumC = texShape[0];\n    if (texNumC === 1) {\n      const source = `\n          float ${funcName}(int row, int col) {\n            int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n            float index = dot(vec3(row, col, offset_${name}), vec3(${shape[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n    }\n\n    if (texNumR === 1) {\n      const source = `\n          float ${funcName}(int row, int col) {\n            int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n            float index = dot(vec3(row, col, offset_${name}), vec3(${shape[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n    }\n\n    const source = `\n        float ${funcName}(int row, int col) {\n          int index = col * ${shape[1]} + row;\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, [\n      'coordinates.uvFromFlat',\n      'coordinates.sampleTexture',\n      'coordinates.coordsToOffset',\n    ]);\n  }\n\n  /**\n   * Unpacked 3D snippet.\n   */\n\n  protected getUnpackedSampler3D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride0 = shape[1] * shape[2];\n    const stride1 = shape[2];\n\n    const { newShape, keptDims } = squeezeShape(shape as number[]);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, squeezedShape);\n      const params = ['batch', 'col', 'row'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n      const routine = this.getUnpackedSamplerFromInput(funcName, name, newInputLayout);\n      // TODO: revisit the logic here to make it simpler\n      const revDims = keptDims.reverse();\n      const source = `\n          ${routine.routineBody}\n          float ${funcName}(int batch, int row, int col) {\n            return ${funcName}(${getSqueezedParams(params, revDims)});\n          }\n        `;\n      return new GlslLibRoutine(source, routine.dependencies);\n    }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n          float ${funcName}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${stride0} + col * ${stride1} + row;\n            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n            return sampleTexture(${name}, uv);\n          }\n      `;\n    return new GlslLibRoutine(source, [\n      'coordinates.uvFromFlat',\n      'coordinates.sampleTexture',\n      'coordinates.coordsToOffset',\n    ]);\n  }\n\n  /**\n   * Unpacked 4D snippet.\n   */\n\n  protected getUnpackedSampler4D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride2 = shape[3];\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n\n    //\n    // TODO: re-enable this shortcut once the index calculation bug is fixed.\n    //\n    // const {newShape, keptDims} = squeezeShape(shape as number[]);\n    // if (newShape.length < shape.length) {\n    //   const newInputShape = squeezeInputShape(shape, newShape);\n    //   const params = ['row', 'col', 'depth', 'depth2'];\n    //   // Deep copy of input texture layout.\n    //   const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n    //   newInputLayout.unpackedShape = newInputShape;\n    //   const source = `\n    //       ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n    //       float ${funcName}(int row, int col, int depth, int depth2) {\n    //         return ${funcName}(${getSqueezedParams(params, keptDims)});\n    //       }\n    //     `;\n    //   return new GlslLibRoutine(\n    //       source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n    // }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n        float ${funcName}(int row, int col, int depth, int depth2) {\n          int index = row * ${stride0} + col * ${stride1} +\n              depth2 * ${stride2} + depth;\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture']);\n  }\n\n  /**\n   * Unpacked 5D snippet.\n   */\n  protected getUnpackedSampler5D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride3 = shape[4];\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n\n    const { newShape, keptDims } = squeezeShape(shape as number[]);\n    if (newShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, newShape);\n      const params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n\n      const source = `\n          ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n          float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n            return ${funcName}(${getSqueezedParams(params, keptDims)});\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);\n    }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth3 * ${stride3} + depth2;\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);\n  }\n\n  /**\n   * Unpacked 6D snippet.\n   */\n  protected getUnpackedSampler6D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride4 = shape[5];\n    const stride3 = shape[4] * stride4;\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n\n    const { newShape, keptDims } = squeezeShape(shape as number[]);\n    if (newShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, newShape);\n      const params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n\n      const source = `\n            ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n            float ${funcName}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${funcName}(${getSqueezedParams(params, keptDims)});\n            }\n          `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);\n    }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n          float ${funcName}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n            depth2 * ${stride3} + depth3 * ${stride4} + depth4;\n            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n    return new GlslLibRoutine(source, [\n      'coordinates.uvFromFlat',\n      'coordinates.sampleTexture',\n      'coordinates.coordsToOffset',\n    ]);\n  }\n\n  /**\n   * This is the main function to map from the given texture coordinates (s,t)\n   * to logical indices for the output\n   * There will only be one single variation of this\n   * Also see coordsToOffset and offsetToIndices for input-specific versions\n   */\n  protected toVec(): { [name: string]: GlslLibRoutine } {\n    const output = this.context.outputTextureLayout;\n    const rank = output.shape.length;\n    const strides = output.strides;\n    const xScale = output.width;\n    const yScale = output.height;\n\n    const stridesBlock = [];\n    for (let i = 0; i < rank - 1; ++i) {\n      stridesBlock.push(`\n        c[${i}] = offset / ${strides[i]};`);\n      stridesBlock.push(`\n        offset -= c[${i}] * ${strides[i]};`);\n    }\n    stridesBlock.push(`\n        c[${rank - 1}] = offset;`);\n    const body = `\n      void toVec(vec2 texCoords, out int c[${rank}]) {\n        int offset = coordsToOffset(texCoords, ${xScale}, ${yScale});\n        ${stridesBlock.join('')}\n      }\n      void toVec(int offset, out int c[${rank}]) {\n        ${stridesBlock.join('')}\n      }\n    `;\n    return { toVec: new GlslLibRoutine(body, ['coordinates.coordsToOffset']) };\n  }\n  /**\n   * These are value getter functions generated for each input\n   * Each function is hardwired to the name and dimensions of the input\n   * An '_T' variation is also produced which accesses values as if the\n   * input was transposed\n   */\n  protected valueFrom(): { [name: string]: GlslLibRoutine } {\n    const result: { [name: string]: GlslLibRoutine } = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const layout = this.context.inputTextureLayouts[i];\n      const shape = layout.unpackedShape.length > 0 ? layout.unpackedShape : layout.shape;\n      const rank = shape.length;\n      let funcName = `_${name}`;\n      result[funcName] = new GlslLibRoutine(this.getValueFromSingle(name, rank, layout.width, layout.height, false), [\n        `shapeUtils.indicesToOffset${funcName}`,\n        'coordinates.offsetToCoords',\n        'fragcolor.getColorAsFloat',\n      ]);\n      funcName = funcName + '_T';\n      result[funcName] = new GlslLibRoutine(this.getValueFromSingle(name, rank, layout.width, layout.height, true), [\n        `shapeUtils.indicesToOffset${funcName}`,\n        'coordinates.offsetToCoords',\n        'fragcolor.getColorAsFloat',\n      ]);\n    });\n    return result;\n  }\n  /**\n   * Produces one value getter function for the name and rank given\n   * If a transpose is set proper offsetToCoords mapping will be used\n   * @param name name of the function\n   * @param rank rank of the input\n   * @param transpose whether or not should generate a transpose variation\n   */\n  protected getValueFromSingle(\n    varName: string,\n    rank: number,\n    width: number,\n    height: number,\n    transpose: boolean,\n  ): string {\n    let name = `_${varName}`;\n    if (transpose) {\n      name = name + '_T';\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    return `\n        float ${name}(int m[${rank}]) {\n          int offset = indicesToOffset${name}(m);\n          vec2 coords = offsetToCoords(offset, ${width}, ${height});\n          float value = getColorAsFloat(${glsl.texture2D}(${varName}, coords));\n          return value;\n        }\n        `;\n  }\n\n  /**\n   * Produces a packed value getter function for the name and rank given\n   * If a transpose is set proper offsetToCoords mapping will be used\n   * @param name name of the function\n   * @param rank rank of the input\n   * @param transpose whether or not should generate a transpose variation\n   */\n  protected getPackedValueFrom(\n    varName: string,\n    rank: number,\n    width: number,\n    height: number,\n    transpose: boolean,\n  ): string {\n    let name = `_${varName}_Pack`;\n    if (transpose) {\n      name = name + '_T';\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    return `\n        vec4 ${name}(int m[${rank}]) {\n          int offset = indicesToOffset_${varName}(m);\n          vec2 coords = offsetToCoords(offset, ${width}, ${height});\n          return ${glsl.texture2D}(${varName}, coords);\n        }\n        `;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { GlslContext, GlslLib, GlslLibRoutine } from './glsl-definitions';\n\n/**\n * This GLSL library handles routines converting\n * float32 to/from Unsigned byte or float 16\n */\nexport class EncodingGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): { [name: string]: GlslLibRoutine } {\n    return { ...this.encodeFloat32(), ...this.decodeFloat32() };\n  }\n  getCustomTypes(): { [name: string]: string } {\n    return {};\n  }\n  protected encodeFloat32(): { [name: string]: GlslLibRoutine } {\n    return {\n      encode: new GlslLibRoutine(`highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        `),\n    };\n  }\n  protected decodeFloat32(): { [name: string]: GlslLibRoutine } {\n    return {\n      decode: new GlslLibRoutine(`highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        `),\n    };\n  }\n  /**\n   * returns the routine to encode encode a 32bit float to a vec4 (of unsigned bytes)\n   * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float\n   */\n  protected encodeUint8(): { [name: string]: GlslLibRoutine } {\n    const endianness = EncodingGlslLib.isLittleEndian() ? 'rgba.rgba=rgba.abgr;' : '';\n    return {\n      encode: new GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${endianness}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `),\n    };\n  }\n  /**\n   * returns the routine to encode a vec4 of unsigned bytes to float32\n   * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float\n   */\n  protected decodeUint8(): { [name: string]: GlslLibRoutine } {\n    const endianness = EncodingGlslLib.isLittleEndian() ? 'rgba.rgba=rgba.abgr;' : '';\n    return {\n      decode: new GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${endianness}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `),\n    };\n  }\n  /**\n   * Determines if the machine is little endian or not\n   * @credit: https://gist.github.com/TooTallNate/4750953\n   */\n  static isLittleEndian(): boolean {\n    const b = new ArrayBuffer(4);\n    const a = new Uint32Array(b);\n    const c = new Uint8Array(b);\n    a[0] = 0xdeadbeef;\n    if (c[0] === 0xef) {\n      return true;\n    }\n    if (c[0] === 0xde) {\n      return false;\n    }\n    throw new Error('unknown endianness');\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { GlslContext, GlslLib, GlslLibRoutine } from './glsl-definitions';\nimport { getGlsl } from './glsl-source';\n\n/**\n * This GLSL library handles routines around reading a texlet and writing to it\n * Reading and writing could be more than just dealing with one channel\n * It may require encoding/decoding to/from 4 channels into one\n */\nexport class FragColorGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): { [name: string]: GlslLibRoutine } {\n    return { ...this.setFragColor(), ...this.getColorAsFloat() };\n  }\n  getCustomTypes(): { [name: string]: string } {\n    return {};\n  }\n  protected setFragColor(): { [name: string]: GlslLibRoutine } {\n    const glsl = getGlsl(this.context.glContext.version);\n    return {\n      setFragColor: new GlslLibRoutine(\n        `\n        void setFragColor(float value) {\n            ${glsl.output} = encode(value);\n        }\n        `,\n        ['encoding.encode'],\n      ),\n    };\n  }\n  protected getColorAsFloat(): { [name: string]: GlslLibRoutine } {\n    return {\n      getColorAsFloat: new GlslLibRoutine(\n        `\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        `,\n        ['encoding.decode'],\n      ),\n    };\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { GlslContext, GlslLib, GlslLibRoutine } from './glsl-definitions';\n\n/**\n * GLSL Library responsible for data types and routines for manipulating\n * coordinates and mapping to/from tensor indices\n */\nexport class ShapeUtilsGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): { [name: string]: GlslLibRoutine } {\n    return {\n      ...this.bcastIndex(),\n      ...this.bcastMatmulIndex(),\n      ...this.offsetToIndices(),\n      ...this.indicesToOffset(),\n      ...this.incrementIndices(),\n    };\n  }\n  getCustomTypes() {\n    return {};\n  }\n  protected bcastIndex(): { [name: string]: GlslLibRoutine } {\n    const outputRank = this.context.outputTextureLayout.shape.length;\n    const result: { [name: string]: GlslLibRoutine } = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].unpackedShape;\n      if (shape.length <= outputRank) {\n        const rank = shape.length;\n        const dimOffset = outputRank - rank;\n        const funcName = `bcastIndices_${name}`;\n        let block = '';\n        for (let i = 0; i < rank; ++i) {\n          block += `\n          realIndices[${i}] = int( mod(float(bcastedIndices[${dimOffset + i}]), ${shape[i]}.0) );\n          `;\n        }\n        const body = `\n        void ${funcName} (int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {\n          ${block}\n        }\n        `;\n        result[funcName] = new GlslLibRoutine(body);\n      }\n    });\n    return result;\n  }\n  protected bcastMatmulIndex(): { [name: string]: GlslLibRoutine } {\n    const outputRank = this.context.outputTextureLayout.shape.length;\n    const result: { [name: string]: GlslLibRoutine } = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      if (!(shape.length < 2 || shape.length > outputRank)) {\n        const rank = shape.length;\n        const dimOffset = outputRank - rank;\n        const funcName = `bcastMatmulIndices_${name}`;\n        let block = '';\n        for (let i = 0; i < rank - 2; ++i) {\n          block += `\n          realIndices[${i}] = int( mod(float(bcastedIndices[${dimOffset + i}]), ${shape[i]}.0) );\n          `;\n        }\n        const body = `\n        void ${funcName}(int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {\n          ${block}\n          realIndices[${rank - 1}] = bcastedIndices[${outputRank - 1}];\n          realIndices[${rank - 2}] = bcastedIndices[${outputRank - 2}];\n        }\n        `;\n        result[funcName] = new GlslLibRoutine(body);\n      }\n    });\n    return result;\n  }\n  protected indicesToOffset(): { [name: string]: GlslLibRoutine } {\n    const result: { [name: string]: GlslLibRoutine } = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      const strides = this.context.inputTextureLayouts[i].strides;\n      const rank = shape.length;\n      let funcName = `indicesToOffset_${name}`;\n      result[funcName] = new GlslLibRoutine(ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides));\n      funcName = `indicesToOffset_${name}_T`;\n      result[funcName] = new GlslLibRoutine(\n        ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides.slice().reverse()),\n      );\n    });\n    return result;\n  }\n  static indexToOffsetSingle(name: string, rank: number, strides: readonly number[]): string {\n    let block = '';\n    for (let i = rank - 1; i >= 0; --i) {\n      block += `\n        offset += indices[${i}] * ${strides[i]};\n        `;\n    }\n    return `\n      int ${name}(int indices[${rank}]) {\n        int offset = 0;\n        ${block}\n        return offset;\n      }\n      `;\n  }\n  protected offsetToIndices(): { [name: string]: GlslLibRoutine } {\n    const result: { [name: string]: GlslLibRoutine } = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      const strides = this.context.inputTextureLayouts[i].strides;\n      const rank = shape.length;\n      let funcName = `offsetToIndices_${name}`;\n      result[funcName] = new GlslLibRoutine(ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides));\n      funcName = `offsetToIndices_${name}_T`;\n      result[funcName] = new GlslLibRoutine(\n        ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides.slice().reverse()),\n      );\n    });\n    return result;\n  }\n  static offsetToIndicesSingle(name: string, rank: number, strides: readonly number[]): string {\n    const stridesBlock = [];\n    for (let i = 0; i < rank - 1; ++i) {\n      stridesBlock.push(`\n      indices[${i}] = offset / ${strides[i]};`);\n      stridesBlock.push(`\n        offset -= indices[${i}] * ${strides[i]};`);\n    }\n    stridesBlock.push(`\n      indices[${rank - 1}] = offset;`);\n    return `\n      void ${name}(int offset, out int indices[${rank}]) {\n        ${stridesBlock.join('')}\n      }\n      `;\n  }\n  protected incrementIndices(): { [name: string]: GlslLibRoutine } {\n    const result: { [name: string]: GlslLibRoutine } = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      const rank = shape.length;\n      const funcName = `incrementIndices_${name}`;\n      let shapeInit = '';\n      for (let i = 0; i < rank; ++i) {\n        shapeInit += `\n        shape[${i}] = ${shape[i]};`;\n      }\n      const body = `\n        void ${funcName}(int axis, out int indices[${rank}]) {\n          int shape[${rank}];\n          ${shapeInit};\n          for(int i = ${rank} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;\n      result[funcName] = new GlslLibRoutine(body);\n    });\n    return result;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { GlslContext, GlslLib, GlslLibRoutine } from './glsl-definitions';\n\n/**\n * GLSL Library responsible for vec routines\n * Vec is an varible length int array. The length is fixed at the time of\n * generating the library functions from the dimensions of the output.\n */\nexport class VecGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getCustomTypes(): { [name: string]: string } {\n    return {};\n  }\n  getFunctions(): { [name: string]: GlslLibRoutine } {\n    return { ...this.binaryVecFunctions(), ...this.copyVec(), ...this.setVecItem(), ...this.getVecItem() };\n  }\n  protected binaryVecFunctions(): { [name: string]: GlslLibRoutine } {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    const nameOp: { [name: string]: string } = { add: '+=', sub: '-=', mul: '*=', div: '/=' };\n    const result: { [name: string]: GlslLibRoutine } = {};\n    for (const name in nameOp) {\n      const fname = `${name}Vec`;\n      let assignmentBlock = '';\n      for (let i = 0; i < rank; ++i) {\n        assignmentBlock += `\n          dest[${i}] ${nameOp[name]} src[${i}];\n          `;\n      }\n      const body = `\n        void ${fname}(int src[${rank}], out int dest[${rank}]) {\n          ${assignmentBlock}\n        }\n        `;\n      result[fname] = new GlslLibRoutine(body);\n    }\n\n    return result;\n  }\n  protected copyVec(): { [name: string]: GlslLibRoutine } {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    let assignmentBlock = '';\n    for (let i = 0; i < rank; ++i) {\n      assignmentBlock += `\n        dest[${i}] = src[${i}];\n        `;\n    }\n    const body = `\n      void copyVec(int src[${rank}], out int dest[${rank}]) {\n        ${assignmentBlock}\n      }\n      `;\n    return { copyVec: new GlslLibRoutine(body) };\n  }\n\n  protected setVecItem(): { [name: string]: GlslLibRoutine } {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    let block = `\n        if(index < 0)\n            index =${rank} + index;\n        if (index == 0)\n            m[0] = value;\n        `;\n    for (let i = 1; i < rank - 1; ++i) {\n      block += `\n        else if (index == ${i})\n            m[${i}] = value;\n            `;\n    }\n    block += `\n        else\n            m[${rank - 1}] = value;\n        `;\n    const body = `\n      void setVecItem(out int m[${rank}], int index, int value) {\n        ${block}\n      }\n        `;\n    return { setVecItem: new GlslLibRoutine(body) };\n  }\n  protected getVecItem(): { [name: string]: GlslLibRoutine } {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    let block = `\n        if(index < 0)\n            index = ${rank} + index;\n        if (index == 0)\n            return m[0];\n      `;\n    for (let i = 1; i < rank - 1; ++i) {\n      block += `\n        else if (index == ${i})\n            return m[${i}];\n      `;\n    }\n    block += `\n        else\n            return m[${rank - 1}];\n        `;\n    const body = `\n      int getVecItem(int m[${rank}], int index) {\n        ${block}\n      }\n    `;\n    return { getVecItem: new GlslLibRoutine(body) };\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { CoordsGlslLib } from './glsl-coordinate-lib';\nimport { GlslContext, GlslLib } from './glsl-definitions';\nimport { EncodingGlslLib } from './glsl-encoding-lib';\nimport { FragColorGlslLib } from './glsl-fragcolor-lib';\nimport { ShapeUtilsGlslLib } from './glsl-shape-utils-lib';\nimport { VecGlslLib } from './glsl-vec-lib';\n\nexport const glslRegistry: { [name: string]: new (context: GlslContext) => GlslLib } = {\n  encoding: EncodingGlslLib,\n  fragcolor: FragColorGlslLib,\n  vec: VecGlslLib,\n  shapeUtils: ShapeUtilsGlslLib,\n  coordinates: CoordsGlslLib,\n  //  'arrays': ArrayGlslSLib\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { GlslContext, GlslLib, GlslLibRoutineNode, TopologicalSortGlslRoutines } from './glsl-definitions';\nimport { replaceInlines } from './glsl-function-inliner';\nimport { glslRegistry } from './glsl-registered-libs';\nimport { getDefaultFragShaderMain, getFragShaderPreamble } from './glsl-source';\nimport { ProgramInfo, TextureLayout, VariableInfo } from './types';\nimport { WebGLContext } from './webgl-context';\n\n/**\n * Preprocessor for the additions to the GLSL language\n * It deals with:\n *  @include directives\n *  @inline\n *  Loop unrolling (not implemented)\n *  Macro resolution (not implemented)\n */\nexport class GlslPreprocessor {\n  readonly context: GlslContext;\n  readonly libs: { [name: string]: GlslLib } = {};\n  readonly glslLibRoutineDependencyGraph: { [routineName: string]: GlslLibRoutineNode } = {};\n\n  constructor(\n    glContext: WebGLContext,\n    programInfo: ProgramInfo,\n    inputTextureLayouts: TextureLayout[],\n    outputTextureLayout: TextureLayout,\n  ) {\n    this.context = new GlslContext(glContext, programInfo, inputTextureLayouts, outputTextureLayout);\n\n    // construct GlslLibs\n    Object.keys(glslRegistry).forEach((name: string) => {\n      const lib = new glslRegistry[name](this.context);\n      this.libs[name] = lib;\n    });\n\n    // construct GlslRoutineDependencyGraph\n    const map = this.glslLibRoutineDependencyGraph;\n    for (const libName in this.libs) {\n      const lib = this.libs[libName];\n      const routinesInLib = lib.getFunctions();\n      for (const routine in routinesInLib) {\n        const key = libName + '.' + routine;\n        let currentNode: GlslLibRoutineNode;\n        if (map[key]) {\n          currentNode = map[key];\n          currentNode.routineBody = routinesInLib[routine].routineBody;\n        } else {\n          currentNode = new GlslLibRoutineNode(key, routinesInLib[routine].routineBody);\n          map[key] = currentNode;\n        }\n        const dependencies = routinesInLib[routine].dependencies;\n        if (dependencies) {\n          for (let i = 0; i < dependencies.length; ++i) {\n            if (!map[dependencies[i]]) {\n              const node = new GlslLibRoutineNode(dependencies[i]);\n              map[dependencies[i]] = node;\n              currentNode.addDependency(node);\n            } else {\n              currentNode.addDependency(map[dependencies[i]]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  preprocess(): string {\n    const programInfo = this.context.programInfo;\n    let source = programInfo.shaderSource;\n\n    // append main() function\n    if (!this.context.programInfo.hasMain) {\n      source = `${source}\n      ${getDefaultFragShaderMain(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`;\n    }\n    // replace inlines\n    source = replaceInlines(source);\n\n    // concat final source string\n    return `${getFragShaderPreamble(this.context.glContext.version)}\n    ${this.getUniforms(programInfo.inputNames, programInfo.variables)}\n    ${this.getImports(source)}\n    ${source}`;\n  }\n\n  protected getImports(script: string): string {\n    const routinesIncluded = this.selectGlslLibRoutinesToBeIncluded(script);\n\n    if (routinesIncluded.length === 0) {\n      return '';\n    }\n\n    let routines = '';\n    for (let i = 0; i < routinesIncluded.length; ++i) {\n      if (routinesIncluded[i].routineBody) {\n        routines += routinesIncluded[i].routineBody + '\\n';\n      } else {\n        throw new Error(`Missing body for the Glsl Library routine: ${routinesIncluded[i].name}`);\n      }\n    }\n\n    return routines;\n  }\n  private selectGlslLibRoutinesToBeIncluded(script: string): GlslLibRoutineNode[] {\n    const nodes: GlslLibRoutineNode[] = [];\n\n    Object.keys(this.glslLibRoutineDependencyGraph).forEach((classAndRoutine) => {\n      const routine = classAndRoutine.split('.')[1];\n      if (script.indexOf(routine) !== -1) {\n        nodes.push(this.glslLibRoutineDependencyGraph[classAndRoutine]);\n      }\n    });\n\n    return TopologicalSortGlslRoutines.returnOrderedNodes(nodes);\n  }\n\n  protected getUniforms(samplers?: string[], variables?: VariableInfo[]): string {\n    const uniformLines: string[] = [];\n    if (samplers) {\n      for (const sampler of samplers) {\n        uniformLines.push(`uniform sampler2D ${sampler};`);\n      }\n    }\n    if (variables) {\n      for (const variable of variables) {\n        uniformLines.push(\n          `uniform ${variable.type} ${variable.name}${variable.arrayLength ? `[${variable.arrayLength}]` : ''};`,\n        );\n      }\n    }\n    return uniformLines.join('\\n');\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { env } from 'onnxruntime-common';\n\nimport { Logger, Profiler } from '../../instrument';\n\nimport { GlslPreprocessor } from './glsl-preprocessor';\nimport { getVertexShaderSource } from './glsl-source';\nimport { TextureLayoutStrategy } from './texture-layout-strategy';\nimport { Artifact, ProgramInfo, ProgramVariable, TextureData, TextureLayout, VariableInfo } from './types';\nimport { WebGLContext } from './webgl-context';\n\n/**\n * ProgramManager is the main class behind running computations\n * It builds ProgramInfo's into Artifacts\n * It compiles given ProgramInfo's into WebGL Prorams (cached as Artifacts)\n * Uses the artifact to run the computation by calling Draw on\n * the WebGL drawing buffer\n * ProgramManager automatically maps (binds) input variables to their\n * corresponding Location's in the binary program\n */\nexport class ProgramManager {\n  repo: Map<unknown, Artifact>; // this should be per-session object\n  vertexShader: WebGLShader;\n  attributesBound: boolean;\n\n  constructor(\n    public profiler: Readonly<Profiler>,\n    public glContext: WebGLContext,\n    public textureLayoutStrategy: TextureLayoutStrategy,\n  ) {\n    this.repo = new Map();\n    this.attributesBound = false;\n  }\n  getArtifact(key: unknown): Artifact | undefined {\n    return this.repo.get(key);\n  }\n  setArtifact(key: unknown, artifact: Artifact): void {\n    this.repo.set(key, artifact);\n  }\n  run(buildArtifact: Artifact, inputs: TextureData[], output: TextureData): void {\n    this.profiler.event(\n      'op',\n      `ProgramManager.run ${buildArtifact.programInfo.name ?? 'unknown kernel'}`,\n      () => {\n        const gl = this.glContext.gl;\n        const program = buildArtifact.program;\n        gl.useProgram(program);\n        try {\n          this.bindOutput(output);\n          if (!this.attributesBound) {\n            this.bindAttributes(buildArtifact.attribLocations);\n          }\n          this.bindUniforms(buildArtifact.uniformLocations, buildArtifact.programInfo.variables ?? [], inputs);\n        } catch (err) {\n          Logger.error('ProgramManager', buildArtifact.programInfo.shaderSource);\n          throw err;\n        }\n        this.profiler.event('backend', 'GlContext.draw()', () => {\n          this.glContext.draw();\n        });\n      },\n      this.glContext,\n    );\n  }\n  dispose(): void {\n    if (this.vertexShader) {\n      this.glContext.deleteShader(this.vertexShader);\n    }\n    this.repo.forEach((a) => this.glContext.deleteProgram(a.program));\n  }\n  build(programInfo: ProgramInfo, inputTextureLayouts: TextureLayout[], outputTextureLayout: TextureLayout): Artifact {\n    return this.profiler.event('backend', 'ProgramManager.build', () => {\n      const preprocessor = new GlslPreprocessor(this.glContext, programInfo, inputTextureLayouts, outputTextureLayout);\n      const fragScript = preprocessor.preprocess();\n      const program = this.compile(fragScript);\n      const artifact = {\n        programInfo,\n        program,\n        uniformLocations: this.getUniformLocations(\n          program,\n          preprocessor.context.programInfo.inputNames,\n          preprocessor.context.programInfo.variables,\n        ),\n        attribLocations: this.getAttribLocations(program),\n      };\n      return artifact;\n    });\n  }\n  protected compile(fragShaderScript: string): WebGLProgram {\n    if (!this.vertexShader) {\n      Logger.verbose('ProrgramManager', 'Compiling and caching Vertex shader for the first time');\n      const vertexShaderScript = getVertexShaderSource(this.glContext.version);\n      this.vertexShader = this.glContext.compileShader(vertexShaderScript, this.glContext.gl.VERTEX_SHADER);\n    }\n    if (env.debug) {\n      Logger.verbose(\n        'ProrgramManager',\n        `FragShader:\n${fragShaderScript}\n`,\n      );\n    }\n    const fragShader = this.glContext.compileShader(fragShaderScript, this.glContext.gl.FRAGMENT_SHADER);\n    const program = this.glContext.createProgram(this.vertexShader, fragShader);\n    this.glContext.deleteShader(fragShader);\n    return program;\n  }\n  bindOutput(td: TextureData): void {\n    const width = td.width;\n    const height = td.height;\n    Logger.verbose(\n      'ProrgramManager',\n      `Binding output texture to Framebuffer: w/h=${width}/${height}, shape=${td.shape}, type=${td.tensor.type}`,\n    );\n    this.glContext.attachFramebuffer(td.texture, width, height);\n  }\n  bindAttributes(attribLocations: Artifact.AttribLocations): void {\n    const positionHandle = attribLocations.position;\n    const textureCoordHandle = attribLocations.textureCoord;\n    this.glContext.setVertexAttributes(positionHandle, textureCoordHandle);\n    this.attributesBound = true;\n  }\n  bindUniforms(\n    uniformLocations: Artifact.UniformLocations,\n    variables: ProgramVariable[],\n    textures: TextureData[],\n  ): void {\n    const gl = this.glContext.gl;\n    let texturePosition = 0;\n    for (const { name, type, location, arrayLength } of uniformLocations) {\n      const value = variables.find((v) => v.name === name)?.data;\n      if (type !== 'sampler2D' && !value) {\n        throw new Error(`variable '${name}' does not have data defined in program info`);\n      }\n      switch (type) {\n        case 'sampler2D':\n          this.bindTexture(textures[texturePosition], location, texturePosition);\n          texturePosition++;\n          break;\n        case 'float':\n          if (arrayLength) {\n            gl.uniform1fv(location, value as number[]);\n          } else {\n            gl.uniform1f(location, value as number);\n          }\n          break;\n        case 'int':\n          if (arrayLength) {\n            gl.uniform1iv(location, value as number[]);\n          } else {\n            gl.uniform1i(location, value as number);\n          }\n          break;\n        default:\n          throw new Error(`Uniform not implemented: ${type}`);\n      }\n    }\n  }\n  bindTexture(td: TextureData, uniformHandle: WebGLUniformLocation, position: number): void {\n    this.glContext.bindTextureToUniform(td.texture, position, uniformHandle);\n  }\n  getAttribLocations(program: WebGLProgram): Artifact.AttribLocations {\n    return {\n      position: this.getAttribLocation(program, 'position'),\n      textureCoord: this.getAttribLocation(program, 'textureCoord'),\n    };\n  }\n  getUniformLocations(\n    program: WebGLProgram,\n    samplers?: string[],\n    variables?: VariableInfo[],\n  ): Artifact.UniformLocations {\n    const uniformLocations: Artifact.UniformLocations = [];\n    if (samplers) {\n      for (const sampler of samplers) {\n        uniformLocations.push({\n          name: sampler,\n          type: 'sampler2D',\n          location: this.getUniformLocation(program, sampler),\n        });\n      }\n    }\n    if (variables) {\n      for (const variable of variables) {\n        uniformLocations.push({ ...variable, location: this.getUniformLocation(program, variable.name) });\n      }\n    }\n    return uniformLocations;\n  }\n  getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation {\n    const gl = this.glContext.gl;\n    const reference = gl.getUniformLocation(program, name);\n    if (reference === null) {\n      throw new Error(`Uniform ${name} not found.`);\n    }\n    return reference;\n  }\n  getAttribLocation(program: WebGLProgram, name: string): number {\n    const gl = this.glContext.gl;\n    const attributeLocation: number = gl.getAttribLocation(program, name);\n    return attributeLocation;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Logger, Profiler } from '../../instrument';\nimport { Tensor } from '../../tensor';\n\nimport { Encoder, EncoderUsage } from './texture-data-encoder';\nimport { TextureLayoutStrategy } from './texture-layout-strategy';\nimport { TextureData, TextureLayout } from './types';\nimport { WebGLContext } from './webgl-context';\n\nexport interface TextureManagerConfig {\n  reuseTextures?: boolean;\n}\n\n/**\n * TextureManager is the mainly responsible for caching Textures\n * Textures are cached in 2 levels:\n *   1. the texures which are associated with a dataId (from Tensor)\n *    Caching these is crucial to performance. These are In-use Textures\n *   2. textures which are not in use by any current ProgramInfo/Tensor\n *     These are called Free Textures\n * TextureManager is also used to help creating textures. For this it\n * uses WebGLContext and TextureLayoutStrategy\n */\nexport class TextureManager {\n  private readonly inUseTextures: Map<string, WebGLTexture[]>;\n  private readonly idleTextures: Map<string, WebGLTexture[]>;\n  private readonly textureLookup: Map<WebGLTexture, string>;\n  private readonly pendingRead: Map<Tensor.Id, Array<(arr: Tensor.NumberType) => void>> = new Map();\n\n  constructor(\n    public glContext: WebGLContext,\n    public layoutStrategy: TextureLayoutStrategy,\n    public profiler: Readonly<Profiler>,\n    private config: TextureManagerConfig,\n  ) {\n    if (config.reuseTextures) {\n      this.inUseTextures = new Map();\n      this.idleTextures = new Map();\n      this.textureLookup = new Map();\n    }\n  }\n  createTextureFromLayout(\n    dataType: Tensor.DataType,\n    layout: TextureLayout,\n    data?: Tensor.NumberType,\n    usage?: EncoderUsage,\n  ) {\n    const textureDataType = this.toEncoderType(dataType);\n\n    const encoder = this.glContext.getEncoder(textureDataType, layout.channels || 1, usage);\n    if (layout.isPacked && usage === EncoderUsage.UploadOnly) {\n      throw new Error('not implemented');\n    }\n    const width = layout.width;\n    const height = layout.height;\n\n    let key: string | undefined;\n    let inUseTextures: WebGLTexture[] | undefined;\n    if (this.config.reuseTextures) {\n      key = `${width}x${height}_${encoder.format}_${encoder.internalFormat}_${encoder.textureType}`;\n      inUseTextures = this.inUseTextures.get(key);\n      if (!inUseTextures) {\n        inUseTextures = [];\n        this.inUseTextures.set(key, inUseTextures);\n      }\n\n      const idleTextures = this.idleTextures.get(key);\n      if (idleTextures && idleTextures.length > 0) {\n        const texture = idleTextures.pop()!;\n        inUseTextures.push(texture);\n        if (usage === EncoderUsage.UploadOnly) {\n          this.glContext.updateTexture(texture, width, height, encoder, this.toTextureData(dataType, data)!);\n        }\n        return texture;\n      }\n    }\n\n    Logger.verbose('TextureManager', `Creating new texture of size ${layout.width}x${layout.height}`);\n    const texture = this.glContext.allocateTexture(width, height, encoder, this.toTextureData(dataType, data));\n\n    if (this.config.reuseTextures) {\n      inUseTextures!.push(texture);\n      this.textureLookup.set(texture, key!);\n    }\n    return texture;\n  }\n  readTexture(td: TextureData, dataType: Tensor.DataType, channels?: number): Tensor.NumberType {\n    if (!channels) {\n      channels = 1;\n    }\n    return this.profiler.event('backend', 'TextureManager.readTexture', () => {\n      const dataSize = td.shape.reduce((a, b) => a * b) * channels!;\n      const data = this.glContext.readTexture(\n        td.texture,\n        td.width,\n        td.height,\n        dataSize,\n        this.toEncoderType(dataType),\n        channels!,\n      );\n      return this.toTensorData(dataType, data);\n    });\n  }\n  async readTextureAsync(td: TextureData, dataType: Tensor.DataType, channels?: number): Promise<Tensor.NumberType> {\n    const dataId = td.tensor.dataId;\n    if (!channels) {\n      channels = 1;\n    }\n    if (this.pendingRead.has(dataId)) {\n      const subscribers = this.pendingRead.get(dataId);\n      return new Promise<Tensor.NumberType>((resolve) => subscribers?.push(resolve));\n    }\n    return this.profiler.event('backend', 'TextureManager.readTextureAsync', async () => {\n      this.pendingRead.set(dataId, []);\n      const dataSize = td.shape.reduce((a, b) => a * b) * channels!;\n      // add a fence waiting for the data to be ready\n      await this.glContext.createAndWaitForFence();\n      const data = this.glContext.readTexture(\n        td.texture,\n        td.width,\n        td.height,\n        dataSize,\n        this.toEncoderType(dataType),\n        channels!,\n      );\n      const tensorData = this.toTensorData(dataType, data);\n      const subscribers = this.pendingRead.get(dataId);\n      this.pendingRead.delete(dataId);\n      subscribers?.forEach((resolve) => resolve(tensorData));\n      return tensorData;\n    });\n  }\n  readUint8TextureAsFloat(td: TextureData): Float32Array {\n    return this.profiler.event('backend', 'TextureManager.readUint8TextureAsFloat', () => {\n      const dataSize = td.shape.reduce((a, b) => a * b);\n      const data = this.glContext.readTexture(td.texture, td.width, td.height, dataSize * 4, 'byte', 4);\n      return new Float32Array(data.buffer, data.byteOffset, dataSize);\n    });\n  }\n  releaseTexture(textureData: TextureData, deleteTexture?: boolean): void {\n    let key: string | undefined;\n    if (this.config.reuseTextures) {\n      key = this.textureLookup.get(textureData.texture);\n      if (key) {\n        if (deleteTexture) {\n          this.textureLookup.delete(key);\n        }\n        const inUseTextures = this.inUseTextures.get(key);\n        if (inUseTextures) {\n          const index = inUseTextures.indexOf(textureData.texture);\n          if (index !== -1) {\n            inUseTextures.splice(index, 1);\n            let idleTextures = this.idleTextures.get(key);\n            if (!idleTextures) {\n              idleTextures = [];\n              this.idleTextures.set(key, idleTextures);\n            }\n            idleTextures.push(textureData.texture);\n          }\n        }\n      }\n    }\n\n    if (!key || deleteTexture) {\n      Logger.verbose('TextureManager', `Deleting texture of size ${textureData.width}x${textureData.height}`);\n      this.glContext.deleteTexture(textureData.texture);\n    }\n  }\n  toTensorData(dataType: Tensor.DataType, data: Encoder.DataArrayType): Tensor.NumberType {\n    switch (dataType) {\n      case 'int16':\n        return data instanceof Int16Array ? data : Int16Array.from(data);\n      case 'int32':\n        return data instanceof Int32Array ? data : Int32Array.from(data);\n      case 'int8':\n        return data instanceof Int8Array ? data : Int8Array.from(data);\n      case 'uint16':\n        return data instanceof Uint16Array ? data : Uint16Array.from(data);\n      case 'uint32':\n        return data instanceof Uint32Array ? data : Uint32Array.from(data);\n      case 'uint8':\n      case 'bool':\n        return data instanceof Uint8Array ? data : Uint8Array.from(data);\n      case 'float32':\n        return data instanceof Float32Array ? data : Float32Array.from(data);\n      case 'float64':\n        return data instanceof Float64Array ? data : Float64Array.from(data);\n      default:\n        throw new Error(`TensorData type ${dataType} is not supported`);\n    }\n  }\n  toTextureData(_dataType: Tensor.DataType, data: Tensor.NumberType | undefined): Encoder.DataArrayType | undefined {\n    if (!data) {\n      return undefined;\n    }\n    return data instanceof Float32Array ? data : new Float32Array(data);\n    /*\n    switch (dataType) {\n      case 'int16':\n      case 'int32':\n      case 'uint16':\n      case 'uint32':\n        return (data.constructor === Uint32Array) ? data as Uint32Array : new Uint32Array(data);\n      case 'int8':\n      case 'uint8':\n      case 'bool':\n        return (data.constructor === Uint8Array) ? data as Uint8Array : new Uint8Array(data);\n      case 'float32':\n      case 'float64':\n        return (data.constructor === Float32Array) ? data as Float32Array : new Float32Array(data);\n      default:\n        throw new Error(`TensorData type ${dataType} is not supported`);\n    }\n    */\n  }\n  toEncoderType(_dataType: Tensor.DataType): Encoder.DataType {\n    return 'float';\n    // switch (dataType) {\n    //   case 'int16':\n    //   case 'int32':\n    //   case 'uint16':\n    //   case 'uint32':\n    //     return 'int';\n    //   case 'uint8':\n    //   case 'bool':\n    //     return 'byte';\n    //   case 'float32':\n    //   case 'float64':\n    //     return 'float';\n    //   default:\n    //     throw new Error(`TensorData type ${dataType} is not supported`);\n    // }\n  }\n  clearActiveTextures(): void {\n    this.glContext.clearActiveTextures();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { SessionHandler } from '../../backend';\nimport { Graph } from '../../graph';\nimport { Logger } from '../../instrument';\nimport { Operator } from '../../operators';\nimport { OpSet, resolveOperator } from '../../opset';\nimport { Session } from '../../session';\nimport { Tensor } from '../../tensor';\nimport { WebGLBackend } from '../backend-webgl';\n\nimport { WebGLInferenceHandler } from './inference-handler';\nimport { WEBGL_OP_RESOLVE_RULES } from './op-resolve-rules';\nimport { ProgramManager } from './program-manager';\nimport { PreferLogicalStrategy, TextureLayoutStrategy } from './texture-layout-strategy';\nimport { TextureManager } from './texture-manager';\nimport { TextureData } from './types';\n\nexport class WebGLSessionHandler implements SessionHandler {\n  programManager: ProgramManager;\n  textureManager: TextureManager;\n  layoutStrategy: TextureLayoutStrategy;\n  packedTextureDataCache: Map<Tensor.Id, TextureData>;\n  unpackedTextureDataCache: Map<Tensor.Id, TextureData>;\n  pack2unpackMap: Map<Tensor.Id, Tensor.Id>;\n  unpack2packMap: Map<Tensor.Id, Tensor.Id>;\n  initializers: Set<Tensor.Id>;\n  pack?: boolean;\n\n  constructor(\n    public readonly backend: WebGLBackend,\n    public readonly context: Session.Context,\n  ) {\n    this.layoutStrategy = new PreferLogicalStrategy(backend.glContext.maxTextureSize);\n    this.programManager = new ProgramManager(this.context.profiler, backend.glContext, this.layoutStrategy);\n    this.textureManager = new TextureManager(backend.glContext, this.layoutStrategy, this.context.profiler, {\n      reuseTextures: backend.textureCacheMode === 'full',\n    });\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache = new Map();\n    this.pack = backend.pack;\n    this.pack2unpackMap = new Map();\n    this.unpack2packMap = new Map();\n  }\n\n  createInferenceHandler() {\n    return new WebGLInferenceHandler(this);\n  }\n  onGraphInitialized(graph: Graph): void {\n    const initializers = graph\n      .getValues()\n      .filter((v) => v.from === -1 && v.tensor)\n      .map((v) => v.tensor!.dataId);\n    this.initializers = new Set(initializers);\n  }\n  isInitializer(tensorId: Tensor.Id): boolean {\n    return this.initializers ? this.initializers.has(tensorId) : false;\n  }\n  addInitializer(tensorId: Tensor.Id): void {\n    this.initializers.add(tensorId);\n  }\n  getTextureData(tensorId: Tensor.Id, isPacked: boolean): TextureData | undefined {\n    if (isPacked) {\n      return this.packedTextureDataCache.get(tensorId);\n    } else {\n      return this.unpackedTextureDataCache.get(tensorId);\n    }\n  }\n  setTextureData(tensorId: Tensor.Id, textureData: TextureData, isPacked = false): void {\n    Logger.verbose('WebGLSessionHandler', 'Storing Texture data in cache');\n    if (isPacked) {\n      this.packedTextureDataCache.set(tensorId, textureData);\n    } else {\n      this.unpackedTextureDataCache.set(tensorId, textureData);\n    }\n  }\n  dispose(): void {\n    this.programManager.dispose();\n    this.textureManager.clearActiveTextures();\n    this.packedTextureDataCache.forEach((td) => this.textureManager.releaseTexture(td, true));\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache.forEach((td) => this.textureManager.releaseTexture(td, true));\n    this.unpackedTextureDataCache = new Map();\n  }\n  resolve(node: Graph.Node, opsets: readonly OpSet[], graph: Graph): Operator {\n    const op = resolveOperator(node, opsets, WEBGL_OP_RESOLVE_RULES);\n    return { impl: op.opImpl, context: op.opInit ? op.opInit(node, graph) : node };\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { env } from 'onnxruntime-common';\n\nimport * as DataEncoders from './texture-data-encoder';\nimport { DataEncoder, Encoder, EncoderUsage } from './texture-data-encoder';\nimport { repeatedTry } from './utils';\n\nexport interface FenceContext {\n  query: WebGLSync | null;\n  isFencePassed(): boolean;\n}\n\ntype PollItem = {\n  isDoneFn: () => boolean;\n  resolveFn: () => void;\n};\n\nexport function linearSearchLastTrue(arr: Array<() => boolean>): number {\n  let i = 0;\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n    if (!isDone) {\n      break;\n    }\n  }\n  return i - 1;\n}\n\n/**\n * Abstraction and wrapper around WebGLRenderingContext and its operations\n */\nexport class WebGLContext {\n  gl: WebGLRenderingContext;\n  version: 1 | 2;\n\n  private vertexbuffer: WebGLBuffer;\n  private framebuffer: WebGLFramebuffer;\n\n  // WebGL flags and vital parameters\n  private isFloatTextureAttachableToFrameBuffer: boolean;\n  isFloat32DownloadSupported: boolean;\n  isRenderFloat32Supported: boolean;\n  isBlendSupported: boolean;\n  maxTextureSize: number;\n  // private maxCombinedTextureImageUnits: number;\n  private maxTextureImageUnits: number;\n  // private maxCubeMapTextureSize: number;\n  // private shadingLanguageVersion: string;\n  // private webglVendor: string;\n  // private webglVersion: string;\n\n  // WebGL2 flags and vital parameters\n  // private max3DTextureSize: number;\n  // private maxArrayTextureLayers: number;\n  // private maxColorAttachments: number;\n  // private maxDrawBuffers: number;\n\n  // WebGL extensions\n  // eslint-disable-next-line camelcase\n  textureFloatExtension: OES_texture_float | null;\n  // eslint-disable-next-line camelcase\n  textureHalfFloatExtension: OES_texture_half_float | null;\n\n  // WebGL2 extensions\n  colorBufferFloatExtension: unknown | null;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  disjointTimerQueryWebgl2Extension: { TIME_ELAPSED_EXT: GLenum; GPU_DISJOINT_EXT: GLenum } | null;\n\n  private disposed: boolean;\n  private frameBufferBound = false;\n\n  constructor(gl: WebGLRenderingContext, version: 1 | 2) {\n    this.gl = gl;\n    this.version = version;\n\n    this.getExtensions();\n    this.vertexbuffer = this.createVertexbuffer();\n    this.framebuffer = this.createFramebuffer();\n    this.queryVitalParameters();\n  }\n\n  allocateTexture(width: number, height: number, encoder: DataEncoder, data?: Encoder.DataArrayType): WebGLTexture {\n    const gl = this.gl;\n    // create the texture\n    const texture = gl.createTexture();\n    // bind the texture so the following methods effect this texture.\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    const buffer = data ? encoder.encode(data, width * height) : null;\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0, // Level of detail.\n      encoder.internalFormat,\n      width,\n      height,\n      0, // Always 0 in OpenGL ES.\n      encoder.format,\n      encoder.textureType,\n      buffer,\n    );\n    this.checkError();\n    return texture as WebGLTexture;\n  }\n  updateTexture(\n    texture: WebGLTexture,\n    width: number,\n    height: number,\n    encoder: DataEncoder,\n    data: Encoder.DataArrayType,\n  ): void {\n    const gl = this.gl;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const buffer = encoder.encode(data, width * height);\n    gl.texSubImage2D(\n      gl.TEXTURE_2D,\n      0, // level\n      0, // xoffset\n      0, // yoffset\n      width,\n      height,\n      encoder.format,\n      encoder.textureType,\n      buffer,\n    );\n    this.checkError();\n  }\n  attachFramebuffer(texture: WebGLTexture, width: number, height: number): void {\n    const gl = this.gl;\n    // Make it the target for framebuffer operations - including rendering.\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); // 0, we aren't using MIPMAPs\n    this.checkError();\n    gl.viewport(0, 0, width, height);\n    gl.scissor(0, 0, width, height);\n  }\n  readTexture(\n    texture: WebGLTexture,\n    width: number,\n    height: number,\n    dataSize: number,\n    dataType: Encoder.DataType,\n    channels: number,\n  ): Encoder.DataArrayType {\n    const gl = this.gl;\n    if (!channels) {\n      channels = 1;\n    }\n    if (!this.frameBufferBound) {\n      this.attachFramebuffer(texture, width, height);\n    }\n    const encoder = this.getEncoder(dataType, channels);\n    const buffer = encoder.allocate(width * height);\n    // bind texture to framebuffer\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); // 0, we aren't using MIPMAPs\n    // TODO: Check if framebuffer is ready\n    gl.readPixels(0, 0, width, height, gl.RGBA, encoder.textureType, buffer);\n    this.checkError();\n    // unbind FB\n    return encoder.decode(buffer, dataSize);\n  }\n\n  isFramebufferReady(): boolean {\n    // TODO: Implement logic to check if the framebuffer is ready\n    return true;\n  }\n  getActiveTexture(): string {\n    const gl = this.gl;\n    const n = gl.getParameter(this.gl.ACTIVE_TEXTURE);\n    return `TEXTURE${n - gl.TEXTURE0}`;\n  }\n  getTextureBinding(): WebGLTexture {\n    return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n  }\n  getFramebufferBinding(): WebGLFramebuffer {\n    return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);\n  }\n  setVertexAttributes(positionHandle: number, textureCoordHandle: number): void {\n    const gl = this.gl;\n    gl.vertexAttribPointer(positionHandle, 3, gl.FLOAT, false, 20, 0);\n    gl.enableVertexAttribArray(positionHandle);\n    if (textureCoordHandle !== -1) {\n      gl.vertexAttribPointer(textureCoordHandle, 2, gl.FLOAT, false, 20, 12);\n      gl.enableVertexAttribArray(textureCoordHandle);\n    }\n    this.checkError();\n  }\n  createProgram(vertexShader: WebGLShader, fragShader: WebGLShader): WebGLProgram {\n    const gl = this.gl;\n    const program = gl.createProgram()!;\n\n    // the program consists of our shaders\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragShader);\n    gl.linkProgram(program);\n    return program;\n  }\n  compileShader(shaderSource: string, shaderType: number): WebGLShader {\n    const gl = this.gl;\n    const shader = gl.createShader(shaderType);\n    if (!shader) {\n      throw new Error(`createShader() returned null with type ${shaderType}`);\n    }\n\n    gl.shaderSource(shader, shaderSource);\n    gl.compileShader(shader);\n    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {\n      throw new Error(`Failed to compile shader: ${gl.getShaderInfoLog(shader)}\nShader source:\n${shaderSource}`);\n    }\n    return shader;\n  }\n  deleteShader(shader: WebGLShader): void {\n    this.gl.deleteShader(shader);\n  }\n  bindTextureToUniform(texture: WebGLTexture, position: number, uniformHandle: WebGLUniformLocation): void {\n    const gl = this.gl;\n    gl.activeTexture(gl.TEXTURE0 + position);\n    this.checkError();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    this.checkError();\n    gl.uniform1i(uniformHandle, position);\n    this.checkError();\n  }\n  draw(): void {\n    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n    this.checkError();\n  }\n  checkError(): void {\n    if (env.debug) {\n      const gl = this.gl;\n      const error = gl.getError();\n      let label = '';\n      switch (error) {\n        case gl.NO_ERROR:\n          return;\n        case gl.INVALID_ENUM:\n          label = 'INVALID_ENUM';\n          break;\n        case gl.INVALID_VALUE:\n          label = 'INVALID_VALUE';\n          break;\n        case gl.INVALID_OPERATION:\n          label = 'INVALID_OPERATION';\n          break;\n        case gl.INVALID_FRAMEBUFFER_OPERATION:\n          label = 'INVALID_FRAMEBUFFER_OPERATION';\n          break;\n        case gl.OUT_OF_MEMORY:\n          label = 'OUT_OF_MEMORY';\n          break;\n        case gl.CONTEXT_LOST_WEBGL:\n          label = 'CONTEXT_LOST_WEBGL';\n          break;\n        default:\n          label = `Unknown WebGL Error: ${error.toString(16)}`;\n      }\n      throw new Error(label);\n    }\n  }\n  deleteTexture(texture: WebGLTexture): void {\n    this.gl.deleteTexture(texture);\n  }\n  deleteProgram(program: WebGLProgram): void {\n    this.gl.deleteProgram(program);\n  }\n  getEncoder(dataType: Encoder.DataType, channels: number, usage: EncoderUsage = EncoderUsage.Default): DataEncoder {\n    if (this.version === 2) {\n      return new DataEncoders.RedFloat32DataEncoder(this.gl as WebGL2RenderingContext, channels);\n    }\n\n    switch (dataType) {\n      case 'float':\n        if (usage === EncoderUsage.UploadOnly || this.isRenderFloat32Supported) {\n          return new DataEncoders.RGBAFloatDataEncoder(this.gl, channels);\n        } else {\n          return new DataEncoders.RGBAFloatDataEncoder(\n            this.gl,\n            channels,\n            this.textureHalfFloatExtension!.HALF_FLOAT_OES,\n          );\n        }\n      case 'int':\n        throw new Error('not implemented');\n      case 'byte':\n        return new DataEncoders.Uint8DataEncoder(this.gl, channels);\n      default:\n        throw new Error(`Invalid dataType: ${dataType}`);\n    }\n  }\n  clearActiveTextures(): void {\n    const gl = this.gl;\n    for (let unit = 0; unit < this.maxTextureImageUnits; ++unit) {\n      gl.activeTexture(gl.TEXTURE0 + unit);\n      gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n  }\n  dispose(): void {\n    if (this.disposed) {\n      return;\n    }\n    const gl = this.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteFramebuffer(this.framebuffer);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.deleteBuffer(this.vertexbuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    gl.finish();\n    this.disposed = true;\n  }\n\n  private createDefaultGeometry(): Float32Array {\n    // Sets of x,y,z(=0),s,t coordinates.\n    return new Float32Array([\n      -1.0,\n      1.0,\n      0.0,\n      0.0,\n      1.0, // upper left\n      -1.0,\n      -1.0,\n      0.0,\n      0.0,\n      0.0, // lower left\n      1.0,\n      1.0,\n      0.0,\n      1.0,\n      1.0, // upper right\n      1.0,\n      -1.0,\n      0.0,\n      1.0,\n      0.0, // lower right\n    ]);\n  }\n  private createVertexbuffer(): WebGLBuffer {\n    const gl = this.gl;\n    const buffer = gl.createBuffer();\n    if (!buffer) {\n      throw new Error('createBuffer() returned null');\n    }\n    const geometry = this.createDefaultGeometry();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, geometry, gl.STATIC_DRAW);\n    this.checkError();\n    return buffer;\n  }\n  private createFramebuffer(): WebGLFramebuffer {\n    const fb = this.gl.createFramebuffer();\n    if (!fb) {\n      throw new Error('createFramebuffer returned null');\n    }\n    return fb;\n  }\n\n  private queryVitalParameters(): void {\n    const gl = this.gl;\n\n    this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer();\n    this.isRenderFloat32Supported = this.checkRenderFloat32();\n    this.isFloat32DownloadSupported = this.checkFloat32Download();\n\n    if (this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) {\n      throw new Error('both float32 and float16 TextureType are not supported');\n    }\n\n    this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend();\n\n    // this.maxCombinedTextureImageUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n    this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    this.maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    // this.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n    // this.shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);\n    // this.webglVendor = gl.getParameter(gl.VENDOR);\n    // this.webglVersion = gl.getParameter(gl.VERSION);\n\n    if (this.version === 2) {\n      // this.max3DTextureSize = gl.getParameter(WebGL2RenderingContext.MAX_3D_TEXTURE_SIZE);\n      // this.maxArrayTextureLayers = gl.getParameter(WebGL2RenderingContext.MAX_ARRAY_TEXTURE_LAYERS);\n      // this.maxColorAttachments = gl.getParameter(WebGL2RenderingContext.MAX_COLOR_ATTACHMENTS);\n      // this.maxDrawBuffers = gl.getParameter(WebGL2RenderingContext.MAX_DRAW_BUFFERS);\n    }\n  }\n  private getExtensions(): void {\n    if (this.version === 2) {\n      this.colorBufferFloatExtension = this.gl.getExtension('EXT_color_buffer_float');\n      this.disjointTimerQueryWebgl2Extension = this.gl.getExtension('EXT_disjoint_timer_query_webgl2');\n    } else {\n      this.textureFloatExtension = this.gl.getExtension('OES_texture_float');\n      this.textureHalfFloatExtension = this.gl.getExtension('OES_texture_half_float');\n    }\n  }\n\n  private checkFloatTextureAttachableToFrameBuffer(): boolean {\n    // test whether Float32 texture is supported:\n    // STEP.1 create a float texture\n    const gl = this.gl;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const internalFormat = this.version === 2 ? (gl as unknown as { RGBA32F: number }).RGBA32F : gl.RGBA;\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);\n    // STEP.2 bind a frame buffer\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    // STEP.3 attach texture to framebuffer\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    // STEP.4 test whether framebuffer is complete\n    const isComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isComplete;\n  }\n\n  private checkRenderFloat32(): boolean {\n    if (this.version === 2) {\n      if (!this.colorBufferFloatExtension) {\n        return false;\n      }\n    } else {\n      if (!this.textureFloatExtension) {\n        return false;\n      }\n    }\n    return this.isFloatTextureAttachableToFrameBuffer;\n  }\n\n  private checkFloat32Download(): boolean {\n    if (this.version === 2) {\n      if (!this.colorBufferFloatExtension) {\n        return false;\n      }\n    } else {\n      if (!this.textureFloatExtension) {\n        return false;\n      }\n      if (!this.gl.getExtension('WEBGL_color_buffer_float')) {\n        return false;\n      }\n    }\n    return this.isFloatTextureAttachableToFrameBuffer;\n  }\n\n  /**\n   * Check whether GL_BLEND is supported\n   */\n  private checkFloat32Blend(): boolean {\n    // it looks like currently (2019-05-08) there is no easy way to detect whether BLEND is supported\n    // https://github.com/microsoft/onnxjs/issues/145\n\n    const gl = this.gl;\n\n    let texture: WebGLTexture | null | undefined;\n    let frameBuffer: WebGLFramebuffer | null | undefined;\n    let vertexShader: WebGLShader | null | undefined;\n    let fragmentShader: WebGLShader | null | undefined;\n    let program: WebGLProgram | null | undefined;\n\n    try {\n      texture = gl.createTexture();\n      frameBuffer = gl.createFramebuffer();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      const internalFormat = this.version === 2 ? (gl as unknown as { RGBA32F: number }).RGBA32F : gl.RGBA;\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n      gl.enable(gl.BLEND);\n\n      vertexShader = gl.createShader(gl.VERTEX_SHADER);\n      if (!vertexShader) {\n        return false;\n      }\n      gl.shaderSource(vertexShader, 'void main(){}');\n      gl.compileShader(vertexShader);\n\n      fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n      if (!fragmentShader) {\n        return false;\n      }\n      gl.shaderSource(fragmentShader, 'precision highp float;void main(){gl_FragColor=vec4(0.5);}');\n      gl.compileShader(fragmentShader);\n\n      program = gl.createProgram();\n      if (!program) {\n        return false;\n      }\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      gl.useProgram(program);\n\n      gl.drawArrays(gl.POINTS, 0, 1);\n      return gl.getError() === gl.NO_ERROR;\n    } finally {\n      gl.disable(gl.BLEND);\n\n      if (program) {\n        gl.deleteProgram(program);\n      }\n      if (vertexShader) {\n        gl.deleteShader(vertexShader);\n      }\n      if (fragmentShader) {\n        gl.deleteShader(fragmentShader);\n      }\n      if (frameBuffer) {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.deleteFramebuffer(frameBuffer);\n      }\n      if (texture) {\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.deleteTexture(texture);\n      }\n    }\n  }\n\n  beginTimer(): WebGLQuery {\n    if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.disjointTimerQueryWebgl2Extension;\n\n      const query = gl2.createQuery() as WebGLQuery;\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported.');\n    }\n  }\n\n  endTimer() {\n    if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.disjointTimerQueryWebgl2Extension;\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported');\n    }\n  }\n\n  isTimerResultAvailable(query: WebGLQuery): boolean {\n    let available = false,\n      disjoint = false;\n    if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.disjointTimerQueryWebgl2Extension;\n\n      available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n      disjoint = gl2.getParameter(ext.GPU_DISJOINT_EXT);\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported');\n    }\n\n    return available && !disjoint;\n  }\n\n  getTimerResult(query: WebGLQuery): number {\n    let timeElapsed = 0;\n    if (this.version === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      timeElapsed = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n      gl2.deleteQuery(query);\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported');\n    }\n    // return miliseconds\n    return timeElapsed / 1000000;\n  }\n\n  async waitForQueryAndGetTime(query: WebGLQuery): Promise<number> {\n    await repeatedTry(() => this.isTimerResultAvailable(query));\n    return this.getTimerResult(query);\n  }\n\n  public async createAndWaitForFence(): Promise<void> {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  private createFence(gl: WebGLRenderingContext): FenceContext {\n    let isFencePassed: () => boolean;\n    const gl2 = gl as WebGL2RenderingContext;\n    const query = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    gl.flush();\n    if (query === null) {\n      isFencePassed = () => true;\n    } else {\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(query, 0, 0);\n        return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;\n      };\n    }\n    return { query, isFencePassed };\n  }\n\n  async pollFence(fenceContext: FenceContext) {\n    return new Promise<void>((resolve) => {\n      void this.addItemToPoll(\n        () => fenceContext.isFencePassed(),\n        () => resolve(),\n      );\n    });\n  }\n\n  private itemsToPoll: PollItem[] = [];\n\n  pollItems(): void {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map((x) => x.isDoneFn));\n    for (let i = 0; i <= index; ++i) {\n      const { resolveFn } = this.itemsToPoll[i];\n      resolveFn();\n    }\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  private async addItemToPoll(isDoneFn: () => boolean, resolveFn: () => void) {\n    this.itemsToPoll.push({ isDoneFn, resolveFn });\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    }\n    // Start a new loop that polls.\n    await repeatedTry(() => {\n      this.pollItems();\n      // End the loop if no more items to poll.\n      return this.itemsToPoll.length === 0;\n    });\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Logger } from '../../instrument';\n\nimport { WebGLContext } from './webgl-context';\n\nconst cache: { [contextId: string]: WebGLContext } = {};\n\n/**\n * This factory function creates proper WebGLRenderingContext based on\n * the current browsers capabilities\n * The order is from higher/most recent versions to most basic\n */\nexport function createWebGLContext(contextId?: 'webgl' | 'webgl2'): WebGLContext {\n  let context: WebGLContext | undefined;\n  if ((!contextId || contextId === 'webgl2') && 'webgl2' in cache) {\n    context = cache.webgl2;\n  } else if ((!contextId || contextId === 'webgl') && 'webgl' in cache) {\n    context = cache.webgl;\n  }\n\n  if (!context) {\n    try {\n      // try to create webgl context from an offscreen canvas\n      const offscreenCanvas = createOffscreenCanvas();\n      context = createNewWebGLContext(offscreenCanvas, contextId);\n    } catch (e) {\n      // if failed, fallback to try to use a normal canvas element\n      const canvas = createCanvas();\n      context = createNewWebGLContext(canvas, contextId);\n    }\n  }\n\n  contextId = contextId || context.version === 1 ? 'webgl' : 'webgl2';\n  const gl = context.gl;\n\n  cache[contextId] = context;\n\n  if (gl.isContextLost()) {\n    delete cache[contextId];\n    return createWebGLContext(contextId);\n  }\n\n  gl.disable(gl.DEPTH_TEST);\n  gl.disable(gl.STENCIL_TEST);\n  gl.disable(gl.BLEND);\n  gl.disable(gl.DITHER);\n  gl.disable(gl.POLYGON_OFFSET_FILL);\n  gl.disable(gl.SAMPLE_COVERAGE);\n  gl.enable(gl.SCISSOR_TEST);\n  gl.enable(gl.CULL_FACE);\n  gl.cullFace(gl.BACK);\n\n  return context;\n}\n\nexport function createNewWebGLContext(canvas: HTMLCanvasElement, contextId?: 'webgl' | 'webgl2'): WebGLContext {\n  const contextAttributes: WebGLContextAttributes = {\n    alpha: false,\n    depth: false,\n    antialias: false,\n    stencil: false,\n    preserveDrawingBuffer: false,\n    premultipliedAlpha: false,\n    failIfMajorPerformanceCaveat: false,\n  };\n  let gl: WebGLRenderingContext | null;\n  const ca = contextAttributes;\n  if (!contextId || contextId === 'webgl2') {\n    gl = canvas.getContext('webgl2', ca);\n    if (gl) {\n      try {\n        return new WebGLContext(gl, 2);\n      } catch (err) {\n        Logger.warning('GlContextFactory', `failed to create WebGLContext using contextId 'webgl2'. Error: ${err}`);\n      }\n    }\n  }\n  if (!contextId || contextId === 'webgl') {\n    gl = canvas.getContext('webgl', ca) || (canvas.getContext('experimental-webgl', ca) as WebGLRenderingContext);\n    if (gl) {\n      try {\n        return new WebGLContext(gl, 1);\n      } catch (err) {\n        Logger.warning(\n          'GlContextFactory',\n          `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${err}`,\n        );\n      }\n    }\n  }\n\n  throw new Error('WebGL is not supported');\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\ndeclare let OffscreenCanvas: { new (width: number, height: number): HTMLCanvasElement };\n\nfunction createCanvas(): HTMLCanvasElement {\n  if (typeof document === 'undefined') {\n    throw new TypeError('failed to create canvas: document is not supported');\n  }\n  const canvas: HTMLCanvasElement = document.createElement('canvas');\n  canvas.width = 1;\n  canvas.height = 1;\n  return canvas;\n}\n\nfunction createOffscreenCanvas(): HTMLCanvasElement {\n  if (typeof OffscreenCanvas === 'undefined') {\n    throw new TypeError('failed to create offscreen canvas: OffscreenCanvas is not supported');\n  }\n  return new OffscreenCanvas(1, 1);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { env } from 'onnxruntime-common';\n\nimport { Backend, SessionHandler } from '../backend';\nimport { Logger } from '../instrument';\nimport { Session } from '../session';\n\nimport { WebGLSessionHandler } from './webgl/session-handler';\nimport { WebGLContext } from './webgl/webgl-context';\nimport { createWebGLContext } from './webgl/webgl-context-factory';\n\n/**\n * WebGLBackend is the entry point for all WebGL opeartions\n * When it starts it created the WebGLRenderingContext\n * and other main framework components such as Program and Texture Managers\n */\nexport class WebGLBackend implements Backend {\n  glContext: WebGLContext;\n\n  get contextId(): 'webgl' | 'webgl2' | undefined {\n    return env.webgl.contextId;\n  }\n  set contextId(value: 'webgl' | 'webgl2' | undefined) {\n    env.webgl.contextId = value;\n  }\n\n  get matmulMaxBatchSize(): number | undefined {\n    return env.webgl.matmulMaxBatchSize;\n  }\n  set matmulMaxBatchSize(value: number | undefined) {\n    env.webgl.matmulMaxBatchSize = value;\n  }\n\n  get textureCacheMode(): 'initializerOnly' | 'full' | undefined {\n    return env.webgl.textureCacheMode;\n  }\n  set textureCacheMode(value: 'initializerOnly' | 'full' | undefined) {\n    env.webgl.textureCacheMode = value;\n  }\n\n  get pack(): boolean | undefined {\n    return env.webgl.pack;\n  }\n  set pack(value: boolean | undefined) {\n    env.webgl.pack = value;\n  }\n\n  get async(): boolean | undefined {\n    return env.webgl.async;\n  }\n  set async(value: boolean | undefined) {\n    env.webgl.async = value;\n  }\n\n  initialize(): boolean {\n    try {\n      this.glContext = createWebGLContext(this.contextId);\n      if (typeof this.matmulMaxBatchSize !== 'number') {\n        this.matmulMaxBatchSize = 16;\n      }\n      if (typeof this.textureCacheMode !== 'string') {\n        this.textureCacheMode = 'full';\n      }\n      if (typeof this.pack !== 'boolean') {\n        this.pack = false;\n      }\n      if (typeof this.async !== 'boolean') {\n        this.async = false;\n      }\n\n      Logger.setWithEnv(env);\n\n      if (!env.webgl.context) {\n        Object.defineProperty(env.webgl, 'context', { value: this.glContext.gl });\n      }\n\n      Logger.verbose(\n        'WebGLBackend',\n        `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${\n          this.matmulMaxBatchSize\n        }; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`,\n      );\n      return true;\n    } catch (e) {\n      Logger.warning('WebGLBackend', `Unable to initialize WebGLBackend. ${e}`);\n      return false;\n    }\n  }\n  createSessionHandler(context: Session.Context): SessionHandler {\n    return new WebGLSessionHandler(this, context);\n  }\n  dispose(): void {\n    this.glContext.dispose();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { WebGLBackend } from './backends/backend-webgl';\nimport { Graph } from './graph';\nimport { Operator } from './operators';\nimport { OpSet } from './opset';\nimport { Session } from './session';\n\nexport interface InferenceHandler {\n  /**\n   * dispose the inference handler. it will be called as the last step in Session.run()\n   */\n  dispose(): void;\n}\n\nexport interface SessionHandler {\n  /**\n   * transform the graph at initialization time\n   * @param graphTransformer the graph transformer to manipulate the model graph\n   */\n  transformGraph?(graphTransformer: Graph.Transformer): void;\n\n  /**\n   * create an instance of InferenceHandler to use in a Session.run() call\n   */\n  createInferenceHandler(): InferenceHandler;\n\n  /**\n   * dispose the session handler. it will be called when a session is being disposed explicitly\n   */\n  dispose(): void;\n\n  /**\n   * Resolves the operator from the name and opset version; backend specific\n   * @param node the node to resolve\n   * @param opsets a list of opsets that exported from the model\n   * @param graph the completely initialized graph\n   */\n  resolve(node: Graph.Node, opsets: readonly OpSet[], graph: Graph): Operator;\n\n  /**\n   * This method let's the sessionHandler know that the graph initialization is complete\n   * @param graph the completely initialized graph\n   */\n  onGraphInitialized?(graph: Graph): void;\n\n  /**\n   * a reference to the corresponding backend\n   */\n  readonly backend: Backend;\n\n  /**\n   * a reference to the session context\n   */\n  readonly context: Session.Context;\n}\n\nexport interface Backend {\n  /**\n   * initialize the backend. will be called only once, when the first time the\n   * backend it to be used\n   */\n  initialize(): boolean | Promise<boolean>;\n\n  /**\n   * create an instance of SessionHandler to use in a Session object's lifecycle\n   */\n  createSessionHandler(context: Session.Context): SessionHandler;\n\n  /**\n   * dispose the backend. currently this will not be called\n   */\n  dispose(): void;\n}\n\n// caches all initialized backend instances\nconst backendsCache: Map<string, Backend> = new Map();\n\nexport const backend: { [name: string]: Backend } = {\n  webgl: new WebGLBackend(),\n};\n\n/**\n * Resolve a reference to the backend. If a hint is specified, the corresponding\n * backend will be used.\n */\nexport async function resolveBackend(hint?: string | readonly string[]): Promise<Backend> {\n  if (!hint) {\n    return resolveBackend(['webgl']);\n  } else {\n    const hints = typeof hint === 'string' ? [hint] : hint;\n\n    for (const backendHint of hints) {\n      const cache = backendsCache.get(backendHint);\n      if (cache) {\n        return cache;\n      }\n\n      const backend = await tryLoadBackend(backendHint);\n      if (backend) {\n        return backend;\n      }\n    }\n  }\n\n  throw new Error('no available backend to use');\n}\n\nasync function tryLoadBackend(backendHint: string): Promise<Backend | undefined> {\n  const backendObj = backend;\n\n  if (typeof backendObj[backendHint] !== 'undefined' && isBackend(backendObj[backendHint])) {\n    const backend = backendObj[backendHint];\n    let init = backend.initialize();\n    if (typeof init === 'object' && 'then' in init) {\n      init = await init;\n    }\n    if (init) {\n      backendsCache.set(backendHint, backend);\n      return backend;\n    }\n  }\n\n  return undefined;\n}\n\nfunction isBackend(obj: unknown) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const o = obj as any;\n\n  // check if an object is a Backend instance\n  if (\n    'initialize' in o &&\n    typeof o.initialize === 'function' && // initialize()\n    'createSessionHandler' in o &&\n    typeof o.createSessionHandler === 'function' && // createSessionHandler()\n    'dispose' in o &&\n    typeof o.dispose === 'function' // dispose()\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nexport type BackendType = Backend;\nexport type SessionHandlerType = ReturnType<BackendType['createSessionHandler']>;\nexport type InferenceHandlerType = ReturnType<SessionHandlerType['createInferenceHandler']>;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { SessionHandler } from './backend';\nimport { Graph } from './graph';\nimport { Logger, Profiler } from './instrument';\nimport { Operator } from './operators';\nimport { Tensor } from './tensor';\n\nclass KernelOp {\n  constructor(\n    public op: Operator,\n    public node: Graph.Node,\n  ) {}\n}\n\nexport class ExecutionPlan {\n  constructor(\n    private graph: Graph,\n    ops: Operator[],\n    private profiler: Readonly<Profiler>,\n  ) {\n    this.initialize(ops);\n  }\n\n  initialize(ops: Operator[]) {\n    this.profiler.event('session', 'ExecutionPlan.initialize', () => {\n      const graphNodes = this.graph.getNodes();\n      if (graphNodes.length !== ops.length) {\n        throw new Error('The size of nodes and OPs do not match.');\n      }\n\n      this._ops = ops.map((op, i) => new KernelOp(op, graphNodes[i]));\n      this.reset();\n\n      // look for starter node(s)\n      this._starter = [];\n      this._ops.forEach((op, i) => {\n        let resolved = true;\n        for (const input of op.node.inputs) {\n          if (\n            !this._values[input] && // not an initialized input\n            this.graph.getInputIndices().indexOf(input) === -1 // not model input\n          ) {\n            resolved = false;\n            break;\n          }\n        }\n        if (resolved) {\n          this._starter.push(i);\n        }\n      });\n    });\n  }\n\n  reset() {\n    this._values = this.graph.getValues().map((i) => i.tensor);\n  }\n\n  async execute(sessionHandler: SessionHandler, modelInputs: Tensor[]): Promise<Tensor[]> {\n    return this.profiler.event('session', 'ExecutionPlan.execute', async () => {\n      // reset mediem result\n      this.reset();\n\n      // create inference handler\n      const inferenceHandler = sessionHandler.createInferenceHandler();\n\n      // populate inputs value\n      const graphInputs = this.graph.getInputIndices();\n      if (modelInputs.length !== graphInputs.length) {\n        throw new Error(\n          `number of input tensors don't match the number of inputs to the model: actual: ${\n            modelInputs.length\n          } expected: ${graphInputs.length}`,\n        );\n      }\n\n      modelInputs.forEach((input, i) => {\n        const index = graphInputs[i];\n        this._values[index] = input;\n      });\n\n      // prepare running sequence\n      const sequence: number[] = this._starter.slice(0);\n\n      // execution iterations\n      const graphValues = this.graph.getValues();\n      const graphNodes = this.graph.getNodes();\n\n      let rear = 0;\n      while (rear < sequence.length) {\n        const thisOpIndex = sequence[rear++];\n        const thisOp = this._ops[thisOpIndex];\n\n        // check input\n        const inputList = thisOp.node.inputs.map((i) => this._values[i]);\n        if (inputList.indexOf(undefined) !== -1) {\n          throw new Error(`unresolved input detected: op: ${thisOp.node}`);\n        }\n\n        // run\n        const inputTensors = inputList as Tensor[];\n        Logger.verbose(\n          'ExecPlan',\n          `Running op:${thisOp.node.name} (${inputTensors\n            .map((t, i) => `'${thisOp.node.inputs[i]}': ${t.type}[${t.dims.join(',')}]`)\n            .join(', ')})`,\n        );\n\n        const outputList = await this.profiler.event('node', thisOp.node.name, async () =>\n          thisOp.op.impl(inferenceHandler, inputTensors, thisOp.op.context),\n        );\n\n        // check output\n        if (outputList.length !== thisOp.node.outputs.length) {\n          throw new Error('the size of output does not match model definition.');\n        }\n\n        // fill value\n        outputList.forEach((output, i) => {\n          const j = thisOp.node.outputs[i];\n          if (this._values[j]) {\n            throw new Error(`output [${j}] already has value: op:${thisOp.node.name}`);\n          }\n          this._values[j] = output;\n        });\n\n        // resolve downstream nodes\n        const downstreamNodes = new Set<number>();\n        outputList.forEach((_output, i) => {\n          const j = thisOp.node.outputs[i];\n          for (const currentDownstreamNodeIndex of graphValues[j].to) {\n            const currentDownstreamNode = graphNodes[currentDownstreamNodeIndex];\n            let resolved = true;\n            for (const k of currentDownstreamNode.inputs) {\n              if (!this._values[k]) {\n                resolved = false;\n                break;\n              }\n            }\n            if (resolved) {\n              downstreamNodes.add(currentDownstreamNodeIndex);\n            }\n          }\n        });\n        sequence.push(...downstreamNodes);\n      }\n\n      const output: Tensor[] = [];\n      for (let i = 0; i < this.graph.getOutputIndices().length; i++) {\n        const outputIndex = this.graph.getOutputIndices()[i];\n        const outputTensor = this._values[outputIndex];\n        if (outputTensor === undefined) {\n          throw new Error(`required output [${outputIndex}] does not have value`);\n        }\n        if (outputIndex === 0) {\n          await outputTensor.getData();\n        } else {\n          // eslint-disable-next-line no-unused-expressions\n          outputTensor.data;\n        }\n        output.push(outputTensor);\n      }\n      Logger.verbose('ExecPlan', 'disposing of inferenceHandler');\n      inferenceHandler.dispose();\n      return output;\n    });\n  }\n\n  _values: Array<Tensor | undefined>;\n  _ops: KernelOp[];\n  _starter: number[];\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport Long from 'long';\n\nimport { onnxruntime } from './ort-schema/flatbuffers/ort-generated';\nimport { onnx } from './ort-schema/protobuf/onnx';\nimport { Tensor } from './tensor';\nimport { decodeUtf8String, LongUtil } from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport declare namespace Attribute {\n  export interface DataTypeMap {\n    float: number;\n    int: number;\n    string: string;\n    tensor: Tensor;\n    floats: number[];\n    ints: number[];\n    strings: string[];\n    tensors: Tensor[];\n  }\n\n  export type DataType = keyof DataTypeMap;\n}\n\ntype ValueTypes = Attribute.DataTypeMap[Attribute.DataType];\n\ntype Value = [ValueTypes, Attribute.DataType];\n\nexport class Attribute {\n  constructor(attributes: onnx.IAttributeProto[] | ortFbs.Attribute[] | null | undefined) {\n    this._attributes = new Map();\n    if (attributes !== null && attributes !== undefined) {\n      for (const attr of attributes) {\n        if (attr instanceof onnx.AttributeProto) {\n          this._attributes.set(attr.name, [Attribute.getValue(attr), Attribute.getType(attr)]);\n        } else if (attr instanceof ortFbs.Attribute) {\n          this._attributes.set(attr.name()!, [Attribute.getValue(attr), Attribute.getType(attr)]);\n        }\n      }\n      if (this._attributes.size < attributes.length) {\n        throw new Error('duplicated attribute names');\n      }\n    }\n  }\n\n  set(key: string, type: Attribute.DataType, value: ValueTypes): void {\n    this._attributes.set(key, [value, type]);\n  }\n  delete(key: string): void {\n    this._attributes.delete(key);\n  }\n  getFloat(key: string, defaultValue?: Attribute.DataTypeMap['float']) {\n    return this.get(key, 'float', defaultValue);\n  }\n\n  getInt(key: string, defaultValue?: Attribute.DataTypeMap['int']) {\n    return this.get(key, 'int', defaultValue);\n  }\n\n  getString(key: string, defaultValue?: Attribute.DataTypeMap['string']) {\n    return this.get(key, 'string', defaultValue);\n  }\n\n  getTensor(key: string, defaultValue?: Attribute.DataTypeMap['tensor']) {\n    return this.get(key, 'tensor', defaultValue);\n  }\n\n  getFloats(key: string, defaultValue?: Attribute.DataTypeMap['floats']) {\n    return this.get(key, 'floats', defaultValue);\n  }\n\n  getInts(key: string, defaultValue?: Attribute.DataTypeMap['ints']) {\n    return this.get(key, 'ints', defaultValue);\n  }\n\n  getStrings(key: string, defaultValue?: Attribute.DataTypeMap['strings']) {\n    return this.get(key, 'strings', defaultValue);\n  }\n\n  getTensors(key: string, defaultValue?: Attribute.DataTypeMap['tensors']) {\n    return this.get(key, 'tensors', defaultValue);\n  }\n\n  private get<V extends Attribute.DataTypeMap[Attribute.DataType]>(\n    key: string,\n    type: Attribute.DataType,\n    defaultValue?: V,\n  ): V {\n    const valueAndType = this._attributes.get(key);\n    if (valueAndType === undefined) {\n      if (defaultValue !== undefined) {\n        return defaultValue;\n      }\n      throw new Error(`required attribute not found: ${key}`);\n    }\n    if (valueAndType[1] !== type) {\n      throw new Error(`type mismatch: expected ${type} but got ${valueAndType[1]}`);\n    }\n    return valueAndType[0] as V;\n  }\n\n  private static getType(attr: onnx.IAttributeProto | ortFbs.Attribute): Attribute.DataType {\n    const type = attr instanceof onnx.AttributeProto ? attr.type : (attr as ortFbs.Attribute).type();\n    switch (type) {\n      case onnx.AttributeProto.AttributeType.FLOAT:\n        return 'float';\n      case onnx.AttributeProto.AttributeType.INT:\n        return 'int';\n      case onnx.AttributeProto.AttributeType.STRING:\n        return 'string';\n      case onnx.AttributeProto.AttributeType.TENSOR:\n        return 'tensor';\n      case onnx.AttributeProto.AttributeType.FLOATS:\n        return 'floats';\n      case onnx.AttributeProto.AttributeType.INTS:\n        return 'ints';\n      case onnx.AttributeProto.AttributeType.STRINGS:\n        return 'strings';\n      case onnx.AttributeProto.AttributeType.TENSORS:\n        return 'tensors';\n      default:\n        throw new Error(`attribute type is not supported yet: ${onnx.AttributeProto.AttributeType[type]}`);\n    }\n  }\n\n  private static getValue(attr: onnx.IAttributeProto | ortFbs.Attribute) {\n    const attrType = attr instanceof onnx.AttributeProto ? attr.type : (attr as ortFbs.Attribute).type();\n    if (attrType === onnx.AttributeProto.AttributeType.GRAPH || attrType === onnx.AttributeProto.AttributeType.GRAPHS) {\n      throw new Error('graph attribute is not supported yet');\n    }\n\n    const value = this.getValueNoCheck(attr);\n\n    // cast LONG to number\n    if (attrType === onnx.AttributeProto.AttributeType.INT && LongUtil.isLong(value)) {\n      return LongUtil.longToNumber(value as Long | flatbuffers.Long);\n    }\n\n    // cast LONG[] to number[]\n    if (attrType === onnx.AttributeProto.AttributeType.INTS) {\n      const arr = value as Array<number | Long | flatbuffers.Long>;\n      const numberValue: number[] = new Array<number>(arr.length);\n\n      for (let i = 0; i < arr.length; i++) {\n        const maybeLong = arr[i];\n        numberValue[i] = LongUtil.longToNumber(maybeLong);\n      }\n\n      return numberValue;\n    }\n\n    // cast onnx.TensorProto to onnxjs.Tensor\n    if (attrType === onnx.AttributeProto.AttributeType.TENSOR) {\n      return attr instanceof onnx.AttributeProto\n        ? Tensor.fromProto(value as onnx.ITensorProto)\n        : Tensor.fromOrtTensor(value as ortFbs.Tensor);\n    }\n\n    // cast onnx.TensorProto[] to onnxjs.Tensor[]\n    if (attrType === onnx.AttributeProto.AttributeType.TENSORS) {\n      if (attr instanceof onnx.AttributeProto) {\n        const tensorProtos = value as onnx.ITensorProto[];\n        return tensorProtos.map((value) => Tensor.fromProto(value));\n      } else if (attr instanceof ortFbs.Attribute) {\n        const tensorProtos = value as ortFbs.Tensor[];\n        return tensorProtos.map((value) => Tensor.fromOrtTensor(value));\n      }\n    }\n\n    // cast Uint8Array to string\n    if (attrType === onnx.AttributeProto.AttributeType.STRING) {\n      // string in onnx attribute is of uint8array type, so we need to convert it to string below. While in ort format,\n      // string attributes are returned as string, so no conversion is needed.\n      if (attr instanceof onnx.AttributeProto) {\n        const utf8String = value as Uint8Array;\n        return decodeUtf8String(utf8String);\n      }\n    }\n\n    // cast Uint8Array[] to string[]\n    if (attrType === onnx.AttributeProto.AttributeType.STRINGS) {\n      // strings in onnx attribute is returned as uint8array[], so we need to convert it to string[] below. While in ort\n      // format strings attributes are returned as string[], so no conversion is needed.\n      if (attr instanceof onnx.AttributeProto) {\n        const utf8Strings = value as Uint8Array[];\n        return utf8Strings.map(decodeUtf8String);\n      }\n    }\n\n    return value as ValueTypes;\n  }\n\n  private static getValueNoCheck(attr: onnx.IAttributeProto | ortFbs.Attribute) {\n    return attr instanceof onnx.AttributeProto\n      ? this.getValueNoCheckFromOnnxFormat(attr)\n      : this.getValueNoCheckFromOrtFormat(attr as ortFbs.Attribute);\n  }\n\n  private static getValueNoCheckFromOnnxFormat(attr: onnx.IAttributeProto) {\n    switch (attr.type!) {\n      case onnx.AttributeProto.AttributeType.FLOAT:\n        return attr.f;\n      case onnx.AttributeProto.AttributeType.INT:\n        return attr.i;\n      case onnx.AttributeProto.AttributeType.STRING:\n        return attr.s;\n      case onnx.AttributeProto.AttributeType.TENSOR:\n        return attr.t;\n      case onnx.AttributeProto.AttributeType.GRAPH:\n        return attr.g;\n      case onnx.AttributeProto.AttributeType.FLOATS:\n        return attr.floats;\n      case onnx.AttributeProto.AttributeType.INTS:\n        return attr.ints;\n      case onnx.AttributeProto.AttributeType.STRINGS:\n        return attr.strings;\n      case onnx.AttributeProto.AttributeType.TENSORS:\n        return attr.tensors;\n      case onnx.AttributeProto.AttributeType.GRAPHS:\n        return attr.graphs;\n      default:\n        throw new Error(`unsupported attribute type: ${onnx.AttributeProto.AttributeType[attr.type!]}`);\n    }\n  }\n\n  private static getValueNoCheckFromOrtFormat(attr: ortFbs.Attribute) {\n    switch (attr.type()) {\n      case ortFbs.AttributeType.FLOAT:\n        return attr.f();\n      case ortFbs.AttributeType.INT:\n        return attr.i();\n      case ortFbs.AttributeType.STRING:\n        return attr.s();\n      case ortFbs.AttributeType.TENSOR:\n        return attr.t();\n      case ortFbs.AttributeType.GRAPH:\n        return attr.g();\n      case ortFbs.AttributeType.FLOATS:\n        return attr.floatsArray();\n      case ortFbs.AttributeType.INTS: {\n        const ints = [];\n        for (let i = 0; i < attr.intsLength(); i++) {\n          ints.push(attr.ints(i)!);\n        }\n        return ints;\n      }\n      case ortFbs.AttributeType.STRINGS: {\n        const strings = [];\n        for (let i = 0; i < attr.stringsLength(); i++) {\n          strings.push(attr.strings(i));\n        }\n        return strings;\n      }\n      case ortFbs.AttributeType.TENSORS: {\n        const tensors = [];\n        for (let i = 0; i < attr.tensorsLength(); i++) {\n          tensors.push(attr.tensors(i)!);\n        }\n        return tensors;\n      }\n      // case ortFbs.AttributeType.GRAPHS:\n      // TODO: Subgraph not supported yet.\n      // const graphs = [];\n      // for (let i = 0; i < attr.graphsLength(); i++) {\n      //   graphs.push(attr.graphs(i)!);\n      // }\n      // return graphs;\n      default:\n        throw new Error(`unsupported attribute type: ${ortFbs.AttributeType[attr.type()]}`);\n    }\n  }\n\n  protected _attributes: Map<string, Value>;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Attribute } from './attribute';\nimport { onnxruntime } from './ort-schema/flatbuffers/ort-generated';\nimport { onnx } from './ort-schema/protobuf/onnx';\nimport { Tensor } from './tensor';\nimport { LongUtil, MAX_CLIP, MIN_CLIP, ProtoUtil } from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport declare namespace Graph {\n  export interface Shape {\n    readonly dims: readonly number[];\n  }\n  export interface ValueType {\n    readonly tensorType: Tensor.DataType;\n    readonly shape: Shape;\n  }\n  export interface Value {\n    // the tensor data. empty for non-initialized inputs\n    readonly tensor?: Tensor;\n\n    // index to the Node where the value comes from. -1 for initializer.\n    readonly from: number;\n\n    // indices to the Nodes where the values go to.\n    readonly to: readonly number[];\n\n    // value type specification. empty for non-input values.\n    readonly type?: ValueType;\n  }\n  export interface Node {\n    // name of the node\n    readonly name: string;\n\n    // the operator type\n    readonly opType: string;\n\n    // indices to the Values where the inputs come from.\n    readonly inputs: readonly number[];\n\n    // indices to the Values where the outpus go to.\n    readonly outputs: readonly number[];\n\n    // the attributes that used by the operator\n    readonly attributes: Attribute;\n  }\n\n  /**\n   * a Transformer is an instance that allows all possible transformation operations that applied to a graph\n   */\n  export interface Transformer {\n    removeAllIdentityNodes(): void;\n    removeAllDropoutNodes(): void;\n    fuseConvActivationNodes(): void;\n    // TODO: add generic functions to manipulate the graph\n  }\n\n  // an initializer can use transformer to transform the graph\n  export interface Initializer {\n    transformGraph(transformer: Transformer): void;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport interface Graph {\n  getInputIndices(): readonly number[];\n  getInputNames(): readonly string[];\n  getOutputIndices(): readonly number[];\n  getOutputNames(): readonly string[];\n  getValues(): readonly Graph.Value[];\n  getNodes(): readonly Graph.Node[];\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-redeclare\nexport const Graph = {\n  /**\n   * construct a graph from a graph protobuf type\n   */\n  from: (graphProto: onnx.IGraphProto | ortFbs.Graph, initializer?: Graph.Initializer) =>\n    new GraphImpl(graphProto, initializer),\n};\n\nclass Value implements Graph.Value {\n  constructor(valueInfo?: onnx.IValueInfoProto) {\n    this._from = undefined;\n    this._to = [];\n    this.tensor = undefined;\n    this.type = undefined;\n\n    if (valueInfo) {\n      this.type = ProtoUtil.tensorValueTypeFromProto(valueInfo.type!.tensorType!);\n    }\n  }\n\n  _from?: number; // -1 represent from initializer\n  get from() {\n    return this._from!;\n  }\n  _to: number[];\n  get to() {\n    return this._to;\n  }\n  type?: Graph.ValueType;\n  tensor?: Tensor;\n}\n\nclass Node implements Graph.Node {\n  constructor(_nodeProto: onnx.INodeProto | ortFbs.Node, name?: string) {\n    if (_nodeProto instanceof onnx.NodeProto) {\n      this.name = _nodeProto.name;\n      this.opType = _nodeProto.opType;\n      this.attributes = new Attribute(_nodeProto.attribute);\n    } else if (_nodeProto instanceof ortFbs.Node) {\n      this.name = name ?? _nodeProto.name()!;\n      this.opType = _nodeProto.opType()!;\n      this.attributes = new Attribute(ProtoUtil.tensorAttributesFromORTFormat(_nodeProto));\n    }\n\n    this.inputs = [];\n    this.outputs = [];\n    this.executeNode = true;\n  }\n\n  name: string;\n  opType: string;\n  inputs: number[];\n  outputs: number[];\n  attributes: Attribute;\n  executeNode: boolean;\n}\n\nclass GraphImpl implements Graph, Graph.Transformer {\n  private _allData: Value[];\n\n  private _allInputIndices: number[];\n  private _allInputNames: string[];\n\n  private _allOutputIndices: number[];\n  private _allOutputNames: string[];\n\n  private _nodes: Node[];\n\n  constructor(graph: onnx.IGraphProto | ortFbs.Graph, graphInitializer?: Graph.Initializer) {\n    if (!graph) {\n      throw new TypeError('graph is empty');\n    }\n\n    // build the graph - will throw exceptions if something fatal is detected\n    this.buildGraph(graph);\n\n    // execute any transformation logic for the graph (if applicable)\n    this.transformGraph(graphInitializer);\n\n    // check for cycles and other inconsistencies - will throw exceptions if something fatal is detected\n    this.checkIsAcyclic();\n  }\n\n  getInputIndices(): readonly number[] {\n    return this._allInputIndices;\n  }\n\n  getInputNames(): readonly string[] {\n    return this._allInputNames;\n  }\n\n  getOutputIndices(): readonly number[] {\n    return this._allOutputIndices;\n  }\n\n  getOutputNames(): readonly string[] {\n    return this._allOutputNames;\n  }\n\n  getValues(): readonly Graph.Value[] {\n    return this._allData;\n  }\n\n  getNodes(): readonly Graph.Node[] {\n    return this._nodes;\n  }\n\n  private buildGraph(graph: onnx.IGraphProto | ortFbs.Graph) {\n    // build the graph - will throw exceptions if something fatal is detected\n    if (graph instanceof onnx.GraphProto) {\n      this.buildGraphFromOnnxFormat(graph);\n    } else if (graph instanceof ortFbs.Graph) {\n      this.buildGraphFromOrtFormat(graph);\n    } else {\n      throw new TypeError('Graph type is not supported.');\n    }\n  }\n  private buildGraphFromOnnxFormat(graph: onnx.IGraphProto) {\n    const dataIndices = new Map<string, number>();\n    this._allData = [];\n\n    this._allInputIndices = [];\n    this._allInputNames = [];\n\n    this._allOutputIndices = [];\n    this._allOutputNames = [];\n\n    this._nodes = [];\n\n    const nodesIndices = new Map<string, number>();\n\n    // scan all inputs\n    if (!graph.input) {\n      throw new Error('missing information in graph: input');\n    }\n    const inputValueNames = [];\n    for (const i of graph.input) {\n      if (dataIndices.has(i.name!)) {\n        throw new Error(`duplicated input name: ${i.name}`);\n      }\n      const currentIndex = this._allData.push(new Value(i)) - 1;\n      dataIndices.set(i.name!, currentIndex);\n      inputValueNames.push(i.name!);\n    }\n\n    // scan all initializers\n    if (!graph.initializer) {\n      throw new Error('missing information in graph: initializer');\n    }\n    for (const i of graph.initializer) {\n      let index = dataIndices.get(i.name!);\n      if (index === undefined) {\n        const value = new Value();\n        value.type = {\n          shape: { dims: ProtoUtil.tensorDimsFromProto(i.dims!) },\n          tensorType: ProtoUtil.tensorDataTypeFromProto(i.dataType!),\n        };\n        index = this._allData.push(value) - 1;\n        dataIndices.set(i.name!, index);\n      }\n      this._allData[index]._from = -1;\n      this._allData[index].tensor = Tensor.fromProto(i);\n    }\n\n    // filter out input indices\n    for (let i = 0; i < this._allData.length; i++) {\n      if (!this._allData[i].tensor) {\n        this._allInputIndices.push(i);\n        this._allInputNames.push(inputValueNames[i]);\n      }\n    }\n\n    // scan all outputs\n    if (!graph.output) {\n      throw new Error('missing information in graph: output');\n    }\n    for (const i of graph.output) {\n      if (dataIndices.has(i.name!)) {\n        throw new Error(`duplicated output name: ${i.name}`);\n      }\n      const currentIndex = this._allData.push(new Value(i)) - 1;\n      dataIndices.set(i.name!, currentIndex);\n      this._allOutputIndices.push(currentIndex);\n      this._allOutputNames.push(i.name!);\n    }\n\n    // scan all nodes\n    if (!graph.node) {\n      throw new Error('missing information in graph: node');\n    }\n    for (const nodeProto of graph.node) {\n      if (!nodeProto.name) {\n        // assign a name to the node if it doesn't have one\n        for (let pick = 0; ; pick++) {\n          const name = `unnamed_${nodeProto.opType}_${pick}`;\n          if (!nodesIndices.has(name)) {\n            nodeProto.name = name;\n            break;\n          }\n        }\n      }\n\n      if (nodesIndices.has(nodeProto.name)) {\n        throw new Error(`duplicated node name: ${nodeProto.name}`);\n      }\n      const currentIndex = this._nodes.push(new Node(nodeProto)) - 1;\n      nodesIndices.set(nodeProto.name, currentIndex);\n    }\n\n    // scan node's outputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.node[i];\n      if (!nodeProto.output) {\n        throw new Error(`missing output for node: ${nodeProto.name}`);\n      }\n      for (const output of nodeProto.output) {\n        let dataIndex = dataIndices.get(output);\n        if (typeof dataIndex === 'undefined') {\n          dataIndex = this._allData.push(new Value()) - 1;\n          dataIndices.set(output, dataIndex);\n        }\n        node.outputs.push(dataIndex);\n\n        if (this._allData[dataIndex]._from !== undefined) {\n          throw new Error(`multiple nodes output to one data value: ${dataIndex}`);\n        }\n        this._allData[dataIndex]._from = i;\n\n        // for the 'Constant' operator, just create a new edge in the graph corresponding to the 'output' of the\n        // operator and ignore the node from the graph\n        if (nodeProto.opType === 'Constant') {\n          if (!nodeProto.attribute || nodeProto.attribute.length !== 1 || !nodeProto.attribute[0].t) {\n            throw new Error('missing attributes or missing tensor value in attributes for this Constant operator');\n          }\n          if (!nodeProto.output || nodeProto.output.length !== 1) {\n            throw new Error('missing output or incorrect number of outputs for this Constant operator');\n          }\n          node.outputs.pop();\n          node.executeNode = false;\n\n          this._allData[dataIndex]._from = -1;\n          this._allData[dataIndex].tensor = Tensor.fromProto(nodeProto.attribute[0].t);\n        }\n      }\n    }\n\n    // scan node's inputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.node[i];\n\n      if (!nodeProto.input) {\n        throw new Error(`missing input for node: ${nodeProto.name}`);\n      }\n      for (const input of nodeProto.input) {\n        const dataIndex = dataIndices.get(input);\n        if (typeof dataIndex === 'undefined') {\n          // handle exception when opset > 9 and roi / scales not given\n          if (\n            input === '' &&\n            (nodeProto.input.length === 3 || nodeProto.input.length === 4) &&\n            nodeProto.opType === 'Resize'\n          ) {\n            continue;\n          }\n          throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name}`);\n        }\n        node.inputs.push(dataIndex);\n\n        this._allData[dataIndex]._to.push(i);\n      }\n    }\n\n    return true;\n  }\n\n  private buildGraphFromOrtFormat(graph: ortFbs.Graph) {\n    const dataIndices = new Map<string, number>();\n    this._allData = [];\n\n    this._allInputIndices = [];\n    this._allInputNames = [];\n\n    this._allOutputIndices = [];\n    this._allOutputNames = [];\n\n    this._nodes = [];\n\n    const nodesIndices = new Map<string, number>();\n\n    // scan all inputs\n    const inputValueNames = [];\n    for (let i = 0; i < graph.inputsLength(); i++) {\n      const inputName = graph.inputs(i);\n      if (dataIndices.has(inputName)) {\n        throw new Error(`duplicated input name: ${inputName}`);\n      }\n      // Find the input typeInfo from nodeargs\n      for (let j = 0; j < graph.nodeArgsLength(); j++) {\n        if (graph.nodeArgs(j)?.name() === inputName) {\n          const value = new Value();\n          const valueType = graph.nodeArgs(j)?.type()?.valueType();\n          if (valueType !== ortFbs.TypeInfoValue.tensor_type) {\n            throw new Error('Unexpected value type for the nodeArg.');\n          }\n          const valueInfo = graph.nodeArgs(j)!.type()!.value(new ortFbs.TensorTypeAndShape())!;\n          const type = ProtoUtil.tensorDataTypeFromProto(valueInfo.elemType());\n          const shape = valueInfo.shape()!;\n          const dims = [];\n          for (let k = 0; k < shape.dimLength()!; k++) {\n            dims.push(LongUtil.longToNumber(shape.dim(k)!.value()!.dimValue()!));\n          }\n          value.type = { shape: { dims }, tensorType: type };\n          const currentIndex = this._allData.push(value) - 1;\n          dataIndices.set(inputName, currentIndex);\n          inputValueNames.push(inputName);\n        }\n      }\n    }\n    // check initializers\n    for (let i = 0; i < graph.initializersLength(); i++) {\n      const initializer = graph.initializers(i)!;\n      let index = dataIndices.get(initializer.name()!);\n      if (index === undefined) {\n        const value = new Value();\n        const dims = ProtoUtil.tensorDimsFromORTFormat(initializer);\n        const type = ProtoUtil.tensorDataTypeFromProto(initializer.dataType());\n        value.type = { shape: { dims }, tensorType: type };\n        index = this._allData.push(value) - 1;\n        dataIndices.set(initializer.name()!, index);\n      }\n      this._allData[index]._from = -1;\n      this._allData[index].tensor = Tensor.fromOrtTensor(initializer);\n    }\n\n    // filter out input indices\n    for (let i = 0; i < this._allData.length; i++) {\n      if (!this._allData[i].tensor) {\n        this._allInputIndices.push(i);\n        this._allInputNames.push(inputValueNames[i]);\n      }\n    }\n\n    // scan all outputs\n    for (let i = 0; i < graph.outputsLength(); i++) {\n      const outputName = graph.outputs(i);\n      if (dataIndices.has(outputName)) {\n        throw new Error(`duplicated output name: ${outputName}`);\n      }\n      const currentIndex = this._allData.push(new Value()) - 1;\n      dataIndices.set(outputName, currentIndex);\n      this._allOutputIndices.push(currentIndex);\n      this._allOutputNames.push(outputName);\n    }\n\n    // scan all nodes\n    if (!graph.nodes) {\n      throw new Error('missing information in graph: node');\n    }\n    for (let i = 0; i < graph.nodesLength(); i++) {\n      const nodeProto = graph.nodes(i);\n      let name = nodeProto!.name();\n      if (!name) {\n        // assign a name to the node if it doesn't have one\n        for (let pick = 0; ; pick++) {\n          name = `unnamed_${nodeProto!.opType()}_${pick}`;\n          if (!nodesIndices.has(name)) {\n            // an unique name is found. break.\n            break;\n          }\n        }\n      }\n\n      if (nodesIndices.has(name)) {\n        throw new Error(`duplicated node name: ${name}`);\n      }\n      const currentIndex = this._nodes.push(new Node(nodeProto!, name)) - 1;\n      nodesIndices.set(name, currentIndex);\n    }\n\n    // scan node's outputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.nodes(i);\n      if (nodeProto == null) {\n        throw new Error(`No node exists at index ${i}`);\n      }\n      if (nodeProto?.outputsLength() === 0) {\n        throw new Error(`missing output for node: ${nodeProto.name}`);\n      }\n      for (let j = 0; j < nodeProto?.outputsLength(); j++) {\n        const output = nodeProto?.outputs(j);\n        let dataIndex = dataIndices.get(output);\n        if (typeof dataIndex === 'undefined') {\n          dataIndex = this._allData.push(new Value()) - 1;\n          dataIndices.set(output, dataIndex);\n        }\n        node.outputs.push(dataIndex);\n\n        if (this._allData[dataIndex]._from !== undefined) {\n          throw new Error(`multiple nodes output to one data value: ${dataIndex}`);\n        }\n        this._allData[dataIndex]._from = i;\n\n        // for the 'Constant' operator, just create a new edge in the graph corresponding to the 'output' of the\n        // operator and ignore the node from the graph\n        if (nodeProto.opType() === 'Constant') {\n          if (nodeProto.attributesLength() !== 1 || !nodeProto.attributes(0)!.t()) {\n            throw new Error('missing attributes or missing tensor value in attributes for this Constant operator');\n          }\n          if (nodeProto.outputsLength() !== 1) {\n            throw new Error('missing output or incorrect number of outputs for this Constant operator');\n          }\n          node.outputs.pop();\n          node.executeNode = false;\n\n          this._allData[dataIndex]._from = -1;\n          this._allData[dataIndex].tensor = Tensor.fromOrtTensor(nodeProto.attributes(0)!.t()!);\n        }\n      }\n    }\n\n    // scan node's inputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.nodes(i)!;\n\n      if (nodeProto.inputsLength() === 0) {\n        throw new Error(`missing input for node: ${nodeProto.name}`);\n      }\n      for (let j = 0; j < nodeProto.inputsLength()!; j++) {\n        const input = nodeProto.inputs(j)!;\n        const dataIndex = dataIndices.get(input);\n        if (typeof dataIndex === 'undefined') {\n          throw new Error(`unrecognized input '${input}' for node: ${nodeProto!.name()}`);\n        }\n        node.inputs.push(dataIndex);\n\n        this._allData[dataIndex]._to.push(i);\n      }\n    }\n  }\n\n  private checkIsAcyclic() {\n    // go through the graph and check for cycles or other fatal inconsistencies\n    const starters: Set<number> = new Set<number>();\n    this._allInputIndices.forEach((i) => {\n      const data = this._allData[i];\n      data._to.forEach((j) => {\n        starters.add(j);\n      });\n    });\n\n    // Iterative DFS to check for cycles\n    const nodesStack = Array.from(starters);\n    const nodesState = new Array<string>(this._nodes.length).fill('white');\n\n    while (nodesStack.length > 0) {\n      const nodeIndex = nodesStack.pop()!;\n      // this node has now been processed completely. Mark this node 'black' to denote this.\n      if (nodesState[nodeIndex] === 'gray') {\n        nodesState[nodeIndex] = 'black';\n      } else {\n        // this node is under processing stage. mark this node 'gray' to denote this.\n        nodesStack.push(nodeIndex);\n        nodesState[nodeIndex] = 'gray';\n\n        this._nodes[nodeIndex].outputs.forEach((outgoingEdgeIndex) => {\n          const data = this._allData[outgoingEdgeIndex];\n          if (typeof data.tensor !== 'undefined') {\n            throw new Error('node outputs should not be initialized');\n          }\n          if (data._from !== nodeIndex) {\n            throw new Error(\"from property of the Value object doesn't match index of Node being processed\");\n          }\n          data._to.forEach((downstreamNodeIndex) => {\n            // back edge found - cyclic\n            if (nodesState[downstreamNodeIndex] === 'gray') {\n              throw new Error('model graph is cyclic');\n            }\n            // tree edge found - continue processing by adding it to stack\n            else if (nodesState[downstreamNodeIndex] === 'white') {\n              nodesStack.push(downstreamNodeIndex);\n            }\n          });\n        });\n      }\n    }\n  }\n\n  private transformGraph(graphInitializer?: Graph.Initializer): void {\n    // apply common transform\n    this.removeAllIdentityNodes();\n    this.removeAllDropoutNodes();\n    this.fuseConvActivationNodes();\n    // apply initializer specific transform\n    if (graphInitializer) {\n      graphInitializer.transformGraph(this);\n    }\n\n    // finalize graph\n    this.finalizeGraph();\n  }\n\n  /**\n   * finalize the graph.\n   *\n   * this function should be called after all the transformation completed.\n   * this function removes all unnecessary nodes and values from the graph\n   */\n  finalizeGraph() {\n    let offset = 0;\n    // delete all nodes that are not being executed\n    // The graph is represented using these two arrays\n    // this._nodes - Array holding the kernels to execute - each entry is a kernel pointing to this._allData\n    // this._allData - hold 2 fields - to [] & from - these feileds hold the graph map for inputs and outputs per node\n    // newIndices - remapping the graph after reading the flag 'executeNode'\n    const newIndices = new Array<number>(this._nodes.length, 0);\n    let nodePossition = 0;\n\n    for (let i = 0; i < this._nodes.length; i++) {\n      // giving new indexes to the nodes based on execution flag\n      newIndices[i] = nodePossition;\n      if (this._nodes[i].executeNode) {\n        if (nodePossition !== i) {\n          this._nodes[nodePossition] = this._nodes[i];\n        }\n        nodePossition++;\n      } else {\n        // delete all output values\n        this._nodes[i].outputs.forEach((ind) => {\n          this._allData[ind]._from = -2;\n        });\n      }\n    }\n\n    // removing the unused nodes\n    this._nodes.splice(nodePossition, this._nodes.length - nodePossition);\n\n    // Updating this._allData according to the new this._nodes\n    for (let i = 0; i < this._allData.length; i++) {\n      const currentData = this._allData[i];\n      if (currentData._from !== undefined && currentData._from !== -1 && currentData._from !== -2) {\n        currentData._from = newIndices[currentData._from];\n      }\n\n      for (let j = 0; j < currentData._to.length; j++) {\n        if (currentData._to[j] >= 0) {\n          currentData._to[j] = newIndices[currentData._to[j]];\n        } else {\n          throw new Error('Trying to update a removed node');\n        }\n      }\n    }\n\n    offset = 0;\n    // delete all values that are not being referenced\n    for (let i = 0; i < this._allData.length; i++) {\n      // if current value is neither linked to next node, nor an output value, remove it.\n      if (this._allData[i].from === -2 && this._allOutputIndices.indexOf(i + offset) === -1) {\n        offset++;\n        this._allData.splice(i, 1);\n        i--;\n        continue;\n      }\n      if (offset > 0) {\n        let ind = -1;\n        // if current value is neither an input value nor an initializer, find the node it's\n        // coming from and update the corresponding node output\n        if (this._allData[i].from !== undefined && this._allData[i].from !== -1) {\n          ind = this._nodes[this._allData[i].from].outputs.indexOf(i + offset);\n          if (ind !== -1) {\n            this._nodes[this._allData[i].from].outputs[ind] = i;\n          }\n        } else {\n          // if current value is an input value, update its reference in inputIndices\n          ind = this._allInputIndices.indexOf(i + offset);\n          if (ind !== -1) {\n            this._allInputIndices[ind] = i;\n          }\n        }\n\n        // find the node that the current value is linking to and update its input reference\n        this._allData[i].to.forEach((node) => {\n          ind = this._nodes[node].inputs.indexOf(i + offset);\n          if (ind !== -1) {\n            this._nodes[node].inputs[ind] = i;\n          }\n        });\n        if (this._allData[i].to.length === 0) {\n          // if current value is a graph output, update its reference in outputIndices\n          ind = this._allOutputIndices.indexOf(i + offset);\n          if (ind !== -1) {\n            this._allOutputIndices[ind] = i;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Delete the specified node. Assume the node has one incoming input and the first output connected to other nodes.\n   * An input validation must be done before calling this function.\n   * @param nodeIndex The index of node to be deleted\n   */\n  private deleteNode(nodeIndex: number) {\n    const node = this._nodes[nodeIndex];\n    if (node.outputs.length > 1) {\n      for (let i = 1; i < node.outputs.length; i++) {\n        if (this._allData[node.outputs[i]].to.length > 0) {\n          throw new Error('Node deletion with more than one output connected to other nodes is not supported. ');\n        }\n      }\n    }\n\n    // this node wil not be executed\n    node.executeNode = false;\n    const inputValueIndex = node.inputs[0];\n    const outputValueIndex = node.outputs[0];\n    const nodesConsumingOutput = this._allData[outputValueIndex].to;\n\n    // remove this node from the to property of the input Value\n    for (let i = 0; i < node.inputs.length; i++) {\n      const delIndex = this._allData[node.inputs[i]].to.indexOf(nodeIndex);\n      // should not happen\n      if (delIndex === -1) {\n        throw new Error(\"The Value object doesn't have the current Node in it's 'to' property \");\n      }\n      this._allData[node.inputs[i]].to.splice(delIndex, 1);\n    }\n\n    // clear node indices consuming this output Value\n    this._allData[outputValueIndex]._to = [];\n\n    // if the output of this node is a graph output, adjust the index appropriately\n    const index = this._allOutputIndices.indexOf(outputValueIndex);\n    if (index !== -1) {\n      this._allOutputIndices[index] = inputValueIndex;\n    }\n\n    // override the inputs for nodes consuming this node's output with the input to this node\n    if (nodesConsumingOutput && nodesConsumingOutput.length > 0) {\n      for (const nodeIndex of nodesConsumingOutput) {\n        const replaceIndex = this._nodes[nodeIndex].inputs.indexOf(outputValueIndex);\n        // should not happen\n        if (replaceIndex === -1) {\n          throw new Error(\"The Node object doesn't have the output Value in it's 'inputs' property \");\n        }\n        this._nodes[nodeIndex].inputs[replaceIndex] = inputValueIndex;\n        this._allData[inputValueIndex].to.push(nodeIndex);\n      }\n    }\n  }\n\n  removeAllDropoutNodes() {\n    let nodeIndex = 0;\n    for (const node of this._nodes) {\n      // weed out 'Dropout' nodes so that no time is wasted in execution\n      if (node.opType === 'Dropout') {\n        // the node should have exactly 1 input and 1 or 2 outputs\n        if (node.inputs.length !== 1) {\n          throw new Error('Dropout nodes should only contain one input. ');\n        }\n        if (node.outputs.length !== 1 && node.outputs.length !== 2) {\n          throw new Error('Dropout nodes should contain either 1 or 2 output(s)');\n        }\n        // the second output should not be referenced by any other node\n        if (node.outputs.length === 2 && this._allData[node.outputs[1]]._to.length !== 0) {\n          throw new Error(\"Dropout nodes's second output should not be referenced by other nodes\");\n        }\n        this.deleteNode(nodeIndex);\n      }\n      nodeIndex++;\n    }\n  }\n\n  removeAllIdentityNodes() {\n    let nodeIndex = 0;\n    for (const node of this._nodes) {\n      // weed out 'Identity' nodes so that no time is wasted in execution\n      if (node.opType === 'Identity') {\n        this.deleteNode(nodeIndex);\n      }\n      nodeIndex++;\n    }\n  }\n\n  isActivation(n: Node): boolean {\n    switch (n.opType) {\n      // TODO: add other activation methods\n      case 'Relu':\n      case 'Sigmoid':\n      case 'Clip':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  fuseConvActivationNodes() {\n    for (const node of this._nodes) {\n      if (node.opType === 'Conv') {\n        const next = this._allData[node.outputs[0]]._to;\n        if (next.length === 1 && this.isActivation(this._nodes[next[0]])) {\n          const child = this._nodes[next[0]];\n          if (child.opType === 'Clip') {\n            if (child.inputs.length === 1) {\n              try {\n                node.attributes.set('activation_params', 'floats', [\n                  child.attributes.getFloat('min'),\n                  child.attributes.getFloat('max'),\n                ]);\n              } catch (e) {\n                node.attributes.set('activation_params', 'floats', [MIN_CLIP, MAX_CLIP]);\n              }\n            } else if (\n              child.inputs.length >= 3 &&\n              this._allData[child.inputs[1]].tensor !== undefined &&\n              this._allData[child.inputs[2]].tensor !== undefined\n            ) {\n              node.attributes.set('activation_params', 'floats', [\n                this._allData[child.inputs[1]].tensor!.floatData[0],\n                this._allData[child.inputs[2]].tensor!.floatData[0],\n              ]);\n            } else {\n              // Skip fusion with clip node since clip min and clip max are not coming from initializer\n              continue;\n            }\n          }\n          node.attributes.set('activation', 'string', child.opType);\n          this.deleteNode(next[0]);\n        }\n      }\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { flatbuffers } from 'flatbuffers';\n\nimport { Graph } from './graph';\nimport { OpSet } from './opset';\nimport { onnxruntime } from './ort-schema/flatbuffers/ort-generated';\nimport { onnx } from './ort-schema/protobuf/onnx';\nimport { LongUtil } from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport class Model {\n  // empty model\n  constructor() {}\n\n  load(buf: Uint8Array, graphInitializer?: Graph.Initializer, isOrtFormat?: boolean): void {\n    let onnxError: Error | undefined;\n    if (!isOrtFormat) {\n      // isOrtFormat === false || isOrtFormat === undefined\n      try {\n        this.loadFromOnnxFormat(buf, graphInitializer);\n        return;\n      } catch (e) {\n        if (isOrtFormat !== undefined) {\n          throw e;\n        }\n        onnxError = e;\n      }\n    }\n\n    try {\n      this.loadFromOrtFormat(buf, graphInitializer);\n    } catch (e) {\n      if (isOrtFormat !== undefined) {\n        throw e;\n      }\n      // Tried both formats and failed (when isOrtFormat === undefined)\n      throw new Error(`Failed to load model as ONNX format: ${onnxError}\\nas ORT format: ${e}`);\n    }\n  }\n\n  private loadFromOnnxFormat(buf: Uint8Array, graphInitializer?: Graph.Initializer): void {\n    const modelProto = onnx.ModelProto.decode(buf);\n    const irVersion = LongUtil.longToNumber(modelProto.irVersion);\n    if (irVersion < 3) {\n      throw new Error('only support ONNX model with IR_VERSION>=3');\n    }\n\n    this._opsets = modelProto.opsetImport.map((i) => ({\n      domain: i.domain as string,\n      version: LongUtil.longToNumber(i.version!),\n    }));\n\n    this._graph = Graph.from(modelProto.graph!, graphInitializer);\n  }\n\n  private loadFromOrtFormat(buf: Uint8Array, graphInitializer?: Graph.Initializer): void {\n    const fb = new flatbuffers.ByteBuffer(buf);\n    const ortModel = ortFbs.InferenceSession.getRootAsInferenceSession(fb).model()!;\n    const irVersion = LongUtil.longToNumber(ortModel.irVersion());\n    if (irVersion < 3) {\n      throw new Error('only support ONNX model with IR_VERSION>=3');\n    }\n    this._opsets = [];\n    for (let i = 0; i < ortModel.opsetImportLength(); i++) {\n      const opsetId = ortModel.opsetImport(i)!;\n      this._opsets.push({ domain: opsetId?.domain() as string, version: LongUtil.longToNumber(opsetId.version()!) });\n    }\n\n    this._graph = Graph.from(ortModel.graph()!, graphInitializer);\n  }\n\n  private _graph: Graph;\n  get graph(): Graph {\n    return this._graph;\n  }\n\n  private _opsets: OpSet[];\n  get opsets(): readonly OpSet[] {\n    return this._opsets;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { resolveBackend, SessionHandlerType } from './backend';\nimport { ExecutionPlan } from './execution-plan';\nimport { Graph } from './graph';\nimport { Profiler } from './instrument';\nimport { Model } from './model';\nimport { Operator } from './operators';\nimport { Tensor } from './tensor';\n\nexport declare namespace Session {\n  export interface Config {\n    backendHint?: string;\n    profiler?: Profiler.Config;\n  }\n\n  export interface Context {\n    profiler: Readonly<Profiler>;\n    graphInputTypes?: Tensor.DataType[];\n    graphInputDims?: Array<readonly number[]>;\n  }\n}\n\nexport class Session {\n  constructor(config: Session.Config = {}) {\n    this._initialized = false;\n    this.backendHint = config.backendHint;\n    this.profiler = Profiler.create(config.profiler);\n    this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };\n  }\n\n  get inputNames(): readonly string[] {\n    return this._model.graph.getInputNames();\n  }\n  get outputNames(): readonly string[] {\n    return this._model.graph.getOutputNames();\n  }\n\n  startProfiling() {\n    this.profiler.start();\n  }\n\n  endProfiling() {\n    this.profiler.stop();\n  }\n\n  async loadModel(uri: string): Promise<void>;\n  async loadModel(buffer: ArrayBuffer, byteOffset?: number, length?: number): Promise<void>;\n  async loadModel(buffer: Uint8Array): Promise<void>;\n  async loadModel(arg: string | ArrayBuffer | Uint8Array, byteOffset?: number, length?: number): Promise<void> {\n    await this.profiler.event('session', 'Session.loadModel', async () => {\n      // resolve backend and session handler\n      const backend = await resolveBackend(this.backendHint);\n      this.sessionHandler = backend.createSessionHandler(this.context);\n\n      this._model = new Model();\n      if (typeof arg === 'string') {\n        const isOrtFormat = arg.endsWith('.ort');\n        if (typeof process !== 'undefined' && process.versions && process.versions.node) {\n          // node\n          const { readFile } = require('node:fs/promises');\n          const buf = await readFile(arg);\n          this.initialize(buf, isOrtFormat);\n        } else {\n          // browser\n          const response = await fetch(arg);\n          const buf = await response.arrayBuffer();\n          this.initialize(new Uint8Array(buf), isOrtFormat);\n        }\n      } else if (!ArrayBuffer.isView(arg)) {\n        // load model from ArrayBuffer\n        const arr = new Uint8Array(arg, byteOffset || 0, length || arg.byteLength);\n        this.initialize(arr);\n      } else {\n        // load model from Uint8array\n        this.initialize(arg);\n      }\n    });\n  }\n\n  private initialize(modelProtoBlob: Uint8Array, isOrtFormat?: boolean): void {\n    if (this._initialized) {\n      throw new Error('already initialized');\n    }\n\n    this.profiler.event('session', 'Session.initialize', () => {\n      // load graph\n      const graphInitializer = this.sessionHandler.transformGraph\n        ? (this.sessionHandler as Graph.Initializer)\n        : undefined;\n      this._model.load(modelProtoBlob, graphInitializer, isOrtFormat);\n\n      // graph is completely initialzied at this stage , let the interested handlers know\n      if (this.sessionHandler.onGraphInitialized) {\n        this.sessionHandler.onGraphInitialized(this._model.graph);\n      }\n      // initialize each operator in the graph\n      this.initializeOps(this._model.graph);\n\n      // instantiate an ExecutionPlan object to be used by the Session object\n      this._executionPlan = new ExecutionPlan(this._model.graph, this._ops, this.profiler);\n    });\n\n    this._initialized = true;\n  }\n\n  async run(inputs: Map<string, Tensor> | Tensor[]): Promise<Map<string, Tensor>> {\n    if (!this._initialized) {\n      throw new Error('session not initialized yet');\n    }\n\n    return this.profiler.event('session', 'Session.run', async () => {\n      const inputTensors = this.normalizeAndValidateInputs(inputs);\n\n      const outputTensors = await this._executionPlan.execute(this.sessionHandler, inputTensors);\n\n      return this.createOutput(outputTensors);\n    });\n  }\n\n  private normalizeAndValidateInputs(inputs: Map<string, Tensor> | Tensor[]): Tensor[] {\n    const modelInputNames = this._model.graph.getInputNames();\n\n    // normalize inputs\n    // inputs: Tensor[]\n    if (Array.isArray(inputs)) {\n      if (inputs.length !== modelInputNames.length) {\n        throw new Error(`incorrect input array length: expected ${modelInputNames.length} but got ${inputs.length}`);\n      }\n    }\n    // convert map to array\n    // inputs: Map<string, Tensor>\n    else {\n      if (inputs.size !== modelInputNames.length) {\n        throw new Error(`incorrect input map size: expected ${modelInputNames.length} but got ${inputs.size}`);\n      }\n\n      const sortedInputs = new Array<Tensor>(inputs.size);\n      let sortedInputsIndex = 0;\n      for (let i = 0; i < modelInputNames.length; ++i) {\n        const tensor = inputs.get(modelInputNames[i]);\n        if (!tensor) {\n          throw new Error(`missing input tensor for: '${name}'`);\n        }\n        sortedInputs[sortedInputsIndex++] = tensor;\n      }\n\n      inputs = sortedInputs;\n    }\n\n    // validate dims requirements\n    // First session run - graph input data is not cached for the session\n    if (\n      !this.context.graphInputTypes ||\n      this.context.graphInputTypes.length === 0 ||\n      !this.context.graphInputDims ||\n      this.context.graphInputDims.length === 0\n    ) {\n      const modelInputIndices = this._model.graph.getInputIndices();\n      const modelValues = this._model.graph.getValues();\n\n      const graphInputDims = new Array<readonly number[]>(modelInputIndices.length);\n\n      for (let i = 0; i < modelInputIndices.length; ++i) {\n        const graphInput = modelValues[modelInputIndices[i]];\n        graphInputDims[i] = graphInput.type!.shape.dims;\n\n        // cached for second and subsequent runs.\n        // Some parts of the framework works on the assumption that the graph and types and shapes are static\n        this.context.graphInputTypes!.push(graphInput.type!.tensorType);\n        this.context.graphInputDims!.push(inputs[i].dims);\n      }\n\n      this.validateInputTensorDims(graphInputDims, inputs, true);\n    }\n\n    // Second and subsequent session runs - graph input data is cached for the session\n    else {\n      this.validateInputTensorDims(this.context.graphInputDims, inputs, false);\n    }\n\n    // validate types requirement\n    this.validateInputTensorTypes(this.context.graphInputTypes!, inputs);\n\n    return inputs;\n  }\n\n  private validateInputTensorTypes(graphInputTypes: Tensor.DataType[], givenInputs: Tensor[]) {\n    for (let i = 0; i < givenInputs.length; i++) {\n      const expectedType = graphInputTypes[i];\n      const actualType = givenInputs[i].type;\n      if (expectedType !== actualType) {\n        throw new Error(`input tensor[${i}] check failed: expected type '${expectedType}' but got ${actualType}`);\n      }\n    }\n  }\n\n  private validateInputTensorDims(\n    graphInputDims: Array<readonly number[]>,\n    givenInputs: Tensor[],\n    noneDimSupported: boolean,\n  ) {\n    for (let i = 0; i < givenInputs.length; i++) {\n      const expectedDims = graphInputDims[i];\n      const actualDims = givenInputs[i].dims;\n      if (!this.compareTensorDims(expectedDims, actualDims, noneDimSupported)) {\n        throw new Error(\n          `input tensor[${i}] check failed: expected shape '[${expectedDims.join(',')}]' but got [${actualDims.join(\n            ',',\n          )}]`,\n        );\n      }\n    }\n  }\n\n  private compareTensorDims(\n    expectedDims: readonly number[],\n    actualDims: readonly number[],\n    noneDimSupported: boolean,\n  ): boolean {\n    if (expectedDims.length !== actualDims.length) {\n      return false;\n    }\n\n    for (let i = 0; i < expectedDims.length; ++i) {\n      if (expectedDims[i] !== actualDims[i] && (!noneDimSupported || expectedDims[i] !== 0)) {\n        // data shape mis-match AND not a 'None' dimension.\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private createOutput(outputTensors: Tensor[]): Map<string, Tensor> {\n    const modelOutputNames = this._model.graph.getOutputNames();\n    if (outputTensors.length !== modelOutputNames.length) {\n      throw new Error('expected number of outputs do not match number of generated outputs');\n    }\n\n    const output = new Map<string, Tensor>();\n    for (let i = 0; i < modelOutputNames.length; ++i) {\n      output.set(modelOutputNames[i], outputTensors[i]);\n    }\n\n    return output;\n  }\n\n  private initializeOps(graph: Graph): void {\n    const nodes = graph.getNodes();\n    this._ops = new Array(nodes.length);\n\n    for (let i = 0; i < nodes.length; i++) {\n      this._ops[i] = this.sessionHandler.resolve(nodes[i], this._model.opsets, graph);\n    }\n  }\n\n  private _model: Model;\n  private _initialized: boolean;\n\n  private _ops: Operator[];\n  private _executionPlan: ExecutionPlan;\n\n  private backendHint?: string;\n\n  private sessionHandler: SessionHandlerType;\n  private context: Session.Context;\n  private profiler: Readonly<Profiler>;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceSession, InferenceSessionHandler, SessionHandler, Tensor } from 'onnxruntime-common';\n\nimport { Session } from './session';\nimport { Tensor as OnnxjsTensor } from './tensor';\n\nexport class OnnxjsSessionHandler implements InferenceSessionHandler {\n  constructor(private session: Session) {\n    this.inputNames = this.session.inputNames;\n    this.outputNames = this.session.outputNames;\n  }\n\n  async dispose(): Promise<void> {}\n  inputNames: readonly string[];\n  outputNames: readonly string[];\n  async run(\n    feeds: SessionHandler.FeedsType,\n    _fetches: SessionHandler.FetchesType,\n    _options: InferenceSession.RunOptions,\n  ): Promise<SessionHandler.ReturnType> {\n    const inputMap = new Map<string, OnnxjsTensor>();\n    for (const name in feeds) {\n      if (Object.hasOwnProperty.call(feeds, name)) {\n        const feed = feeds[name];\n        inputMap.set(\n          name,\n          new OnnxjsTensor(\n            feed.dims,\n            feed.type as OnnxjsTensor.DataType,\n            undefined,\n            undefined,\n            feed.data as OnnxjsTensor.NumberType,\n          ),\n        );\n      }\n    }\n    const outputMap = await this.session.run(inputMap);\n    const output: SessionHandler.ReturnType = {};\n    outputMap.forEach((tensor, name) => {\n      output[name] = new Tensor(tensor.type, tensor.data, tensor.dims);\n    });\n    return output;\n  }\n  startProfiling(): void {\n    this.session.startProfiling();\n  }\n  endProfiling(): void {\n    this.session.endProfiling();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/* eslint-disable import/no-internal-modules */\nimport { Backend, InferenceSession, InferenceSessionHandler } from 'onnxruntime-common';\n\nimport { Session } from './onnxjs/session';\nimport { OnnxjsSessionHandler } from './onnxjs/session-handler-inference';\n\nclass OnnxjsBackend implements Backend {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  async init(): Promise<void> {}\n\n  async createInferenceSessionHandler(\n    pathOrBuffer: string | Uint8Array,\n    options?: InferenceSession.SessionOptions,\n  ): Promise<InferenceSessionHandler> {\n    // NOTE: Session.Config(from onnx.js) is not compatible with InferenceSession.SessionOptions(from\n    // onnxruntime-common).\n    //       In future we should remove Session.Config and use InferenceSession.SessionOptions.\n    //       Currently we allow this to happen to make test runner work.\n    const session = new Session(options as unknown as Session.Config);\n\n    // typescript cannot merge method override correctly (so far in 4.2.3). need if-else to call the method.\n    if (typeof pathOrBuffer === 'string') {\n      await session.loadModel(pathOrBuffer);\n    } else {\n      await session.loadModel(pathOrBuffer);\n    }\n\n    return new OnnxjsSessionHandler(session);\n  }\n}\n\nexport const onnxjsBackend = new OnnxjsBackend();\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nexport const isNode = !!(typeof process !== 'undefined' && process.versions && process.versions.node);\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/// <reference lib=\"webworker\" />\n\n//\n// * type hack for \"HTMLImageElement\"\n//\n// in typescript, the type of \"HTMLImageElement\" is defined in lib.dom.d.ts, which is conflict with lib.webworker.d.ts.\n// when we use webworker, the lib.webworker.d.ts will be used, which does not have HTMLImageElement defined.\n//\n// we will get the following errors complaining that HTMLImageElement is not defined:\n//\n// ====================================================================================================================\n//\n// ../common/dist/cjs/tensor-factory.d.ts:187:29 - error TS2552: Cannot find name 'HTMLImageElement'. Did you mean\n// 'HTMLLIElement'?\n//\n// 187     fromImage(imageElement: HTMLImageElement, options?: TensorFromImageElementOptions):\n// Promise<TypedTensor<'float32'> | TypedTensor<'uint8'>>;\n//                                 ~~~~~~~~~~~~~~~~\n//\n// node_modules/@webgpu/types/dist/index.d.ts:83:7 - error TS2552: Cannot find name 'HTMLImageElement'. Did you mean\n// 'HTMLLIElement'?\n//\n// 83     | HTMLImageElement\n//          ~~~~~~~~~~~~~~~~\n//\n// ====================================================================================================================\n//\n// `HTMLImageElement` is only used in type declaration and not in real code. So we define it as `unknown` here to\n// bypass the type check.\n\n//\n// * type hack for \"document\"\n//\n// in typescript, the type of \"document\" is defined in lib.dom.d.ts, so it's not available in webworker.\n//\n// we will get the following errors complaining that document is not defined:\n//\n// ====================================================================================================================\n//\n// lib/wasm/wasm-utils-import.ts:7:33 - error TS2584: Cannot find name 'document'. Do you need to change your target\n// library? Try changing the 'lib' compiler option to include 'dom'.\n//\n// 7 export const scriptSrc = typeof document !== 'undefined' ? (document?.currentScript as HTMLScriptElement)?.src :\n//                                   ~~~~~~~~\n//\n// lib/wasm/wasm-utils-import.ts:7:61 - error TS2584: Cannot find name 'document'. Do you need to change your target\n// library? Try changing the 'lib' compiler option to include 'dom'.\n//\n// 7 export const scriptSrc = typeof document !== 'undefined' ? (document?.currentScript as HTMLScriptElement)?.src :\n//                                                               ~~~~~~~~\n//\n// lib/wasm/wasm-utils-import.ts:7:88 - error TS2552: Cannot find name 'HTMLScriptElement'. Did you mean\n// 'HTMLLIElement'?\n//\n// 7 export const scriptSrc = typeof document !== 'undefined' ? (document?.currentScript as HTMLScriptElement)?.src :\n//                                                                                          ~~~~~~~~~~~~~~~~~\n// ====================================================================================================================\n//\n// `document` is used to get the current script URL, which is not available in webworker. This file is served as a\n// \"dual\" file for entries of both webworker and the esm module.\n//\ndeclare global {\n  type HTMLImageElement = unknown;\n  type HTMLScriptElement = { src?: string };\n  const document: undefined | { currentScript?: HTMLScriptElement };\n}\n\n/**\n * @summary\n *\n * This file is served as a \"dual\" file for both entries of the following:\n * - The proxy worker itself.\n *   - When used as a worker, it listens to the messages from the main thread and performs the corresponding operations.\n *   - Should be imported directly using `new Worker()` in the main thread.\n *\n * - The ESM module that creates the proxy worker (as a worker launcher).\n *   - When used as a worker launcher, it creates the proxy worker and returns it.\n *   - Should be imported using `import()` in the main thread, with the query parameter `import=1`.\n *\n * This file will be always compiling into ESM format.\n */\n\nimport type { OrtWasmMessage, SerializableTensorMetadata } from '../proxy-messages.js';\nimport {\n  createSession,\n  copyFromExternalBuffer,\n  endProfiling,\n  extractTransferableBuffers,\n  initEp,\n  initRuntime,\n  releaseSession,\n  run,\n} from '../wasm-core-impl.js';\nimport { initializeWebAssembly } from '../wasm-factory.js';\nimport { scriptSrc } from '../wasm-utils-import.js';\n\nconst WORKER_NAME = 'ort-wasm-proxy-worker';\nconst isProxyWorker = globalThis.self?.name === WORKER_NAME;\n\nif (isProxyWorker) {\n  // Worker thread\n  self.onmessage = (ev: MessageEvent<OrtWasmMessage>): void => {\n    const { type, in: message } = ev.data;\n    try {\n      switch (type) {\n        case 'init-wasm':\n          initializeWebAssembly(message!.wasm).then(\n            () => {\n              initRuntime(message!).then(\n                () => {\n                  postMessage({ type });\n                },\n                (err) => {\n                  postMessage({ type, err });\n                },\n              );\n            },\n            (err) => {\n              postMessage({ type, err });\n            },\n          );\n          break;\n        case 'init-ep': {\n          const { epName, env } = message!;\n          initEp(env, epName).then(\n            () => {\n              postMessage({ type });\n            },\n            (err) => {\n              postMessage({ type, err });\n            },\n          );\n          break;\n        }\n        case 'copy-from': {\n          const { buffer } = message!;\n          const bufferData = copyFromExternalBuffer(buffer);\n          postMessage({ type, out: bufferData } as OrtWasmMessage);\n          break;\n        }\n        case 'create': {\n          const { model, options } = message!;\n          createSession(model, options).then(\n            (sessionMetadata) => {\n              postMessage({ type, out: sessionMetadata } as OrtWasmMessage);\n            },\n            (err) => {\n              postMessage({ type, err });\n            },\n          );\n          break;\n        }\n        case 'release':\n          releaseSession(message!);\n          postMessage({ type });\n          break;\n        case 'run': {\n          const { sessionId, inputIndices, inputs, outputIndices, options } = message!;\n          run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(\n            (outputs) => {\n              if (outputs.some((o) => o[3] !== 'cpu')) {\n                postMessage({ type, err: 'Proxy does not support non-cpu tensor location.' });\n              } else {\n                postMessage(\n                  { type, out: outputs } as OrtWasmMessage,\n                  extractTransferableBuffers([...inputs, ...outputs] as SerializableTensorMetadata[]),\n                );\n              }\n            },\n            (err) => {\n              postMessage({ type, err });\n            },\n          );\n          break;\n        }\n        case 'end-profiling':\n          endProfiling(message!);\n          postMessage({ type });\n          break;\n        default:\n      }\n    } catch (err) {\n      postMessage({ type, err } as OrtWasmMessage);\n    }\n  };\n}\n\nexport default isProxyWorker\n  ? null\n  : (urlOverride?: string) =>\n      new Worker(urlOverride ?? scriptSrc!, { type: BUILD_DEFS.IS_ESM ? 'module' : 'classic', name: WORKER_NAME });\n","var e,t=(e=import.meta.url,async function(t={}){function r(){return C.buffer!=R.buffer&&H(),R}function n(){return C.buffer!=R.buffer&&H(),U}function a(){return C.buffer!=R.buffer&&H(),Y}function o(){return C.buffer!=R.buffer&&H(),W}function i(){return C.buffer!=R.buffer&&H(),x}var s,u,f=Object.assign({},t),l=new Promise(((e,t)=>{s=e,u=t})),c=\"object\"==typeof window,d=\"function\"==typeof importScripts,g=d&&\"em-pthread\"==self.name;f.mountExternalData=(e,t)=>{e.startsWith(\"./\")&&(e=e.substring(2)),(f.Ua||(f.Ua=new Map)).set(e,t)},f.unmountExternalData=()=>{delete f.Ua};var h,m,p=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor,b=Object.assign({},f),v=\"./this.program\",w=(e,t)=>{throw t},O=\"\";(c||d)&&(d?O=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(O=document.currentScript.src),e&&(O=e),O=O.startsWith(\"blob:\")?\"\":O.substr(0,O.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1),e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.send(null),t.responseText},d&&(m=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.responseType=\"arraybuffer\",t.send(null),new Uint8Array(t.response)}),h=(e,t,r)=>{var n=new XMLHttpRequest;n.open(\"GET\",e,!0),n.responseType=\"arraybuffer\",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)});var y,_=console.log.bind(console),T=console.error.bind(console),M=_,A=T;if(Object.assign(f,b),b=null,g){var S,E=!1;function rr(e){try{var t=e.data,r=t.cmd;if(\"load\"===r){let e=[];self.onmessage=t=>e.push(t),self.startWorker=()=>{postMessage({cmd:\"loaded\"});for(let t of e)rr(t);self.onmessage=rr};for(const e of t.handlers)f[e]&&!f[e].proxy||(f[e]=(...t)=>{postMessage({Za:\"callHandler\",kb:e,args:t})},\"print\"==e&&(M=f[e]),\"printErr\"==e&&(A=f[e]));C=t.wasmMemory,H(),S(t.wasmModule)}else if(\"run\"===r){Lt(t.pthread_ptr,0,0,1,0,0),Ve(t.pthread_ptr),we(),he(),E||=!0;try{ye(t.start_routine,t.arg)}catch(e){if(\"unwind\"!=e)throw e}}else\"cancel\"===r?Gt()&&Xt(-1):\"setimmediate\"!==t.target&&(\"checkMailbox\"===r?E&&Xe():r&&(A(`worker: received unknown command ${r}`),A(t)))}catch(e){throw zt(),e}}A=function(...e){e=e.join(\" \"),console.error(e)},self.alert=function(...e){postMessage({Za:\"alert\",text:e.join(\" \"),nb:Gt()})},f.instantiateWasm=(e,t)=>new Promise((e=>{S=r=>{r=new WebAssembly.Instance(r,J()),t(r),e()}})),self.onunhandledrejection=e=>{throw e.reason||e},self.onmessage=rr}f.wasmBinary&&(y=f.wasmBinary);var C,D,F,R,U,Y,W,k,x,B=!1;function H(){var e=C.buffer;f.HEAP8=R=new Int8Array(e),f.HEAP16=new Int16Array(e),f.HEAPU8=U=new Uint8Array(e),f.HEAPU16=new Uint16Array(e),f.HEAP32=Y=new Int32Array(e),f.HEAPU32=W=new Uint32Array(e),f.HEAPF32=new Float32Array(e),f.HEAPF64=x=new Float64Array(e),f.HEAP64=k=new BigInt64Array(e),f.HEAPU64=new BigUint64Array(e)}if(!g){if(!((C=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof p))throw A(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),Error(\"bad memory\");H()}var P=[],I=[],N=[],$=0,G=null,j=null;function L(){if(0==--$&&(null!==G&&(clearInterval(G),G=null),j)){var e=j;j=null,e()}}function z(e){throw A(e=\"Aborted(\"+e+\")\"),B=!0,F=1,e=new WebAssembly.RuntimeError(e+\". Build with -sASSERTIONS for more info.\"),u(e),e}var Q,V=e=>e.startsWith(\"data:application/octet-stream;base64,\"),X=e=>e.startsWith(\"file://\");function q(e){if(e==Q&&y)return new Uint8Array(y);if(m)return m(e);throw\"both async and sync fetching of the wasm failed\"}function Z(e,t,r){return function(e){if(!y&&(c||d)){if(\"function\"==typeof fetch&&!X(e))return fetch(e,{credentials:\"same-origin\"}).then((t=>{if(!t.ok)throw`failed to load wasm binary file at '${e}'`;return t.arrayBuffer()})).catch((()=>q(e)));if(h)return new Promise(((t,r)=>{h(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>q(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then(r,(e=>{A(`failed to asynchronously prepare wasm: ${e}`),z(e)}))}function J(){return{a:{j:ee,b:Te,E:Ae,g:De,V:Fe,A:We,C:ke,W:xe,T:Be,L:He,S:Pe,o:Ie,B:Ne,y:$e,U:Ge,z:je,_:Le,Z:ze,P:Qe,w:qe,F:Je,k:Ke,O:Ve,Y:et,I:tt,J:ot,K:it,G:st,H:ut,v:ft,q:ct,l:dt,p:gt,e:ht,X:pt,x:bt,d:mt,f:vt,i:wt,u:Ot,t:Mt,s:At,Q:Dt,R:Ft,D:ue,h:Rt,n:Ut,M:Yt,m:kt,a:C,r:ie,N:Pt,c:It}}}var K={837620:(e,t,r,a,o)=>{if(void 0===f||!f.Ua)return 1;if((e=Ce(e>>>0)).startsWith(\"./\")&&(e=e.substring(2)),!(e=f.Ua.get(e)))return 2;if(a>>>=0,(t>>>=0)+(r>>>=0)>e.byteLength)return 3;try{const i=e.subarray(t,t+r);switch(o){case 0:n().set(i,a>>>0);break;case 1:f.mb(a,i);break;default:return 4}return 0}catch{return 4}},838303:()=>\"undefined\"!=typeof wasmOffsetConverter};function ee(){return\"undefined\"!=typeof wasmOffsetConverter}function te(e){this.name=\"ExitStatus\",this.message=`Program terminated with exit(${e})`,this.status=e}var re=e=>{e.terminate(),e.onmessage=()=>{}},ne=e=>{0==fe.length&&(pe(),me(fe[0]));var t=fe.pop();if(!t)return 6;le.push(t),de[e.Ra]=t,t.Ra=e.Ra;var r={cmd:\"run\",start_routine:e.cb,arg:e.ab,pthread_ptr:e.Ra};return t.postMessage(r,e.ib),0},ae=0,oe=(e,t,...r)=>{for(var n=2*r.length,a=er(),o=Kt(8*n),s=o>>>3,u=0;u<r.length;u++){var f=r[u];\"bigint\"==typeof f?(k[s+2*u]=1n,k[s+2*u+1]=f):(k[s+2*u]=0n,i()[s+2*u+1>>>0]=f)}return e=Qt(e,0,n,o,t),Jt(a),e};function ie(e){if(g)return oe(0,1,e);if(F=e,!(0<ae)){for(var t of le)re(t);for(t of fe)re(t);fe=[],le=[],de=[],B=!0}w(e,new te(e))}function se(e){if(g)return oe(1,0,e);ue(e)}var ue=e=>{if(F=e,g)throw se(e),\"unwind\";ie(e)},fe=[],le=[],ce=[],de={},ge=e=>{var t=e.Ra;delete de[t],fe.push(e),le.splice(le.indexOf(e),1),e.Ra=0,Vt(t)};function he(){ce.forEach((e=>e()))}var me=e=>new Promise((t=>{e.onmessage=r=>{var n=(r=r.data).cmd;if(r.targetThread&&r.targetThread!=Gt()){var a=de[r.targetThread];a?a.postMessage(r,r.transferList):A(`Internal error! Worker sent a message \"${n}\" to target pthread ${r.targetThread}, but that thread no longer exists!`)}else\"checkMailbox\"===n?Xe():\"spawnThread\"===n?ne(r):\"cleanupThread\"===n?ge(de[r.thread]):\"killThread\"===n?(r=r.thread,n=de[r],delete de[r],re(n),Vt(r),le.splice(le.indexOf(n),1),n.Ra=0):\"cancelThread\"===n?de[r.thread].postMessage({cmd:\"cancel\"}):\"loaded\"===n?(e.loaded=!0,t(e)):\"alert\"===n?alert(`Thread ${r.threadId}: ${r.text}`):\"setimmediate\"===r.target?e.postMessage(r):\"callHandler\"===n?f[r.handler](...r.args):n&&A(`worker sent an unknown command ${n}`)},e.onerror=e=>{throw A(`worker sent an error! ${e.filename}:${e.lineno}: ${e.message}`),e};var r,n=[];for(r of[])f.hasOwnProperty(r)&&n.push(r);e.postMessage({cmd:\"load\",handlers:n,wasmMemory:C,wasmModule:D})}));function pe(){var e=new Worker(new URL(import.meta.url),{type:\"module\",workerData:\"em-pthread\",name:\"em-pthread\"});fe.push(e)}var be,ve=e=>{for(;0<e.length;)e.shift()(f)},we=()=>{var e=Gt(),t=o()[e+52>>>2>>>0];e=o()[e+56>>>2>>>0],Zt(t,t-e),Jt(t)},Oe=[],ye=(e,t)=>{ae=0;var r=Oe[e];r||(e>=Oe.length&&(Oe.length=e+1),Oe[e]=r=be.get(e)),e=r(t),0<ae?F=e:Xt(e)};class _e{constructor(e){this.Xa=e-24}}function Te(e,t,r){var n=new _e(e>>>=0);throw t>>>=0,r>>>=0,o()[n.Xa+16>>>2>>>0]=0,o()[n.Xa+4>>>2>>>0]=t,o()[n.Xa+8>>>2>>>0]=r,e}function Me(e,t,r,n){return g?oe(2,1,e,t,r,n):Ae(e,t,r,n)}function Ae(e,t,r,n){if(e>>>=0,t>>>=0,r>>>=0,n>>>=0,void 0===p)return A(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var a=[];return g&&0===a.length?Me(e,t,r,n):(e={cb:r,Ra:e,ab:n,ib:a},g?(e.Za=\"spawnThread\",postMessage(e,a),0):ne(e))}var Se=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0,Ee=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&Se)return Se.decode(e.buffer instanceof p?e.slice(t,r):e.subarray(t,r));for(n=\"\";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},Ce=(e,t)=>(e>>>=0)?Ee(n(),e,t):\"\";function De(e,t,r){return g?oe(3,1,e,t,r):0}function Fe(e,t){if(g)return oe(4,1,e,t)}var Re=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},Ue=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Ye=(e,t,r)=>Ue(e,n(),t,r);function We(e,t){if(g)return oe(5,1,e,t)}function ke(e,t,r){if(g)return oe(6,1,e,t,r)}function xe(e,t,r){return g?oe(7,1,e,t,r):0}function Be(e,t){if(g)return oe(8,1,e,t)}function He(e,t,r){if(g)return oe(9,1,e,t,r)}function Pe(e,t,r,n){if(g)return oe(10,1,e,t,r,n)}function Ie(e,t,r,n){if(g)return oe(11,1,e,t,r,n)}function Ne(e,t,r,n){if(g)return oe(12,1,e,t,r,n)}function $e(e){if(g)return oe(13,1,e)}function Ge(e,t){if(g)return oe(14,1,e,t)}function je(e,t,r){if(g)return oe(15,1,e,t,r)}var Le=()=>{z(\"\")},ze=()=>1;function Qe(e){Lt(e>>>0,!d,1,!c,131072,!1),he()}function Ve(e){e>>>=0,\"function\"==typeof Atomics.jb&&(Atomics.jb(a(),e>>>2,e).value.then(Xe),e+=128,Atomics.store(a(),e>>>2,1))}var Xe=()=>{var e=Gt();if(e&&(Ve(e),e=qt,!B))try{if(e(),!(0<ae))try{g?Xt(F):ue(F)}catch(e){e instanceof te||\"unwind\"==e||w(1,e)}}catch(e){e instanceof te||\"unwind\"==e||w(1,e)}};function qe(e,t){(e>>>=0)==t>>>0?setTimeout(Xe):g?postMessage({targetThread:e,cmd:\"checkMailbox\"}):(e=de[e])&&e.postMessage({cmd:\"checkMailbox\"})}var Ze=[];function Je(e,t,r,n,a){for(t>>>=0,n/=2,Ze.length=n,r=a>>>0>>>3,a=0;a<n;a++)Ze[a]=k[r+2*a]?k[r+2*a+1]:i()[r+2*a+1>>>0];return(t?K[t]:Nt[e])(...Ze)}function Ke(e){e>>>=0,g?postMessage({cmd:\"cleanupThread\",thread:e}):ge(de[e])}function et(e){}function tt(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),a()[t>>>2>>>0]=e.getUTCSeconds(),a()[t+4>>>2>>>0]=e.getUTCMinutes(),a()[t+8>>>2>>>0]=e.getUTCHours(),a()[t+12>>>2>>>0]=e.getUTCDate(),a()[t+16>>>2>>>0]=e.getUTCMonth(),a()[t+20>>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>>2>>>0]=e}var rt=e=>0==e%4&&(0!=e%100||0==e%400),nt=[0,31,60,91,121,152,182,213,244,274,305,335],at=[0,31,59,90,120,151,181,212,243,273,304,334];function ot(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),a()[t>>>2>>>0]=e.getSeconds(),a()[t+4>>>2>>>0]=e.getMinutes(),a()[t+8>>>2>>>0]=e.getHours(),a()[t+12>>>2>>>0]=e.getDate(),a()[t+16>>>2>>>0]=e.getMonth(),a()[t+20>>>2>>>0]=e.getFullYear()-1900,a()[t+24>>>2>>>0]=e.getDay();var r=(rt(e.getFullYear())?nt:at)[e.getMonth()]+e.getDate()-1|0;a()[t+28>>>2>>>0]=r,a()[t+36>>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>>2>>>0]=e}function it(e){e>>>=0;var t=new Date(a()[e+20>>>2>>>0]+1900,a()[e+16>>>2>>>0],a()[e+12>>>2>>>0],a()[e+8>>>2>>>0],a()[e+4>>>2>>>0],a()[e>>>2>>>0],0),r=a()[e+32>>>2>>>0],n=t.getTimezoneOffset(),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(i,o);return 0>r?a()[e+32>>>2>>>0]=Number(o!=i&&s==n):0<r!=(s==n)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<r?s:o)-n))),a()[e+24>>>2>>>0]=t.getDay(),r=(rt(t.getFullYear())?nt:at)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>>2>>>0]=r,a()[e>>>2>>>0]=t.getSeconds(),a()[e+4>>>2>>>0]=t.getMinutes(),a()[e+8>>>2>>>0]=t.getHours(),a()[e+12>>>2>>>0]=t.getDate(),a()[e+16>>>2>>>0]=t.getMonth(),a()[e+20>>>2>>>0]=t.getYear(),e=t.getTime(),BigInt(isNaN(e)?-1:e/1e3)}function st(e,t,r,n,a,o,i){return g?oe(16,1,e,t,r,n,a,o,i):-52}function ut(e,t,r,n,a,o){if(g)return oe(17,1,e,t,r,n,a,o)}function ft(e,t,r,n){e>>>=0,t>>>=0,r>>>=0,n>>>=0;var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var f=u.getTimezoneOffset(),l=Math.max(i,f);o()[e>>>2>>>0]=60*l,a()[t>>>2>>>0]=Number(i!=f),s=(e=e=>e.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:\"short\"}).split(\" \")[1])(s),u=e(u),f<i?(Ye(s,r,17),Ye(u,n,17)):(Ye(s,n,17),Ye(u,r,17))}var lt=[];function ct(e,t,r){e>>>=0,t>>>=0,r>>>=0,lt.length=0;for(var s;s=n()[t++>>>0];){var u=105!=s;r+=(u&=112!=s)&&r%8?4:0,lt.push(112==s?o()[r>>>2>>>0]:106==s?k[r>>>3]:105==s?a()[r>>>2>>>0]:i()[r>>>3>>>0]),r+=u?8:4}return K[e](...lt)}var dt=()=>{},gt=()=>Date.now();function ht(e,t){return A(Ce(e>>>0,t>>>0))}var mt,pt=()=>{throw ae+=1,\"unwind\"};function bt(){return 4294901760}mt=()=>performance.timeOrigin+performance.now();var vt=()=>navigator.hardwareConcurrency;function wt(){return z(\"Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER\"),0}function Ot(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a);e:{o=(o.min.call(o,4294901760,a+(65536-a%65536)%65536)-C.buffer.byteLength+65535)/65536;try{C.grow(o),H();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1}var yt=()=>(z(\"Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER\"),0),_t={},Tt=e=>{e.forEach((e=>{var t=yt();t&&(_t[t]=e)}))};function Mt(){var e=Error().stack.toString().split(\"\\n\");return\"Error\"==e[0]&&e.shift(),Tt(e),_t.$a=yt(),_t.bb=e,_t.$a}function At(e,t,r){if(e>>>=0,t>>>=0,_t.$a==e)var n=_t.bb;else\"Error\"==(n=Error().stack.toString().split(\"\\n\"))[0]&&n.shift(),Tt(n);for(var o=3;n[o]&&yt()!=e;)++o;for(e=0;e<r&&n[e+o];++e)a()[t+4*e>>>2>>>0]=yt();return e}var St,Et={},Ct=()=>{if(!St){var e,t={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:v||\"./this.program\"};for(e in Et)void 0===Et[e]?delete t[e]:t[e]=Et[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);St=r}return St};function Dt(e,t){if(g)return oe(18,1,e,t);e>>>=0,t>>>=0;var n=0;return Ct().forEach(((a,i)=>{var s=t+n;for(i=o()[e+4*i>>>2>>>0]=s,s=0;s<a.length;++s)r()[i++>>>0]=a.charCodeAt(s);r()[i>>>0]=0,n+=a.length+1})),0}function Ft(e,t){if(g)return oe(19,1,e,t);e>>>=0,t>>>=0;var r=Ct();o()[e>>>2>>>0]=r.length;var n=0;return r.forEach((e=>n+=e.length+1)),o()[t>>>2>>>0]=n,0}function Rt(e){return g?oe(20,1,e):52}function Ut(e,t,r,n){return g?oe(21,1,e,t,r,n):52}function Yt(e,t,r,n){return g?oe(22,1,e,t,r,n):70}var Wt=[null,[],[]];function kt(e,t,r,a){if(g)return oe(23,1,e,t,r,a);t>>>=0,r>>>=0,a>>>=0;for(var i=0,s=0;s<r;s++){var u=o()[t>>>2>>>0],f=o()[t+4>>>2>>>0];t+=8;for(var l=0;l<f;l++){var c=n()[u+l>>>0],d=Wt[e];0===c||10===c?((1===e?M:A)(Ee(d,0)),d.length=0):d.push(c)}i+=f}return o()[a>>>2>>>0]=i,0}var xt=[31,29,31,30,31,30,31,31,30,31,30,31],Bt=[31,28,31,30,31,30,31,31,30,31,30,31],Ht=(e,t)=>{r().set(e,t>>>0)};function Pt(e,t,r,n){function i(e,t,r){for(e=\"number\"==typeof e?e.toString():e||\"\";e.length<t;)e=r[0]+e;return e}function s(e,t){return i(e,t,\"0\")}function u(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function f(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Sa;for(e=new Date(new Date(e.Ta+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(rt(e.getFullYear())?xt:Bt)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=f(new Date(e.getFullYear(),0,4)),r=f(r),0>=u(t,e)?0>=u(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0,n>>>=0;var c=o()[n+40>>>2>>>0];for(var d in n={gb:a()[n>>>2>>>0],fb:a()[n+4>>>2>>>0],Va:a()[n+8>>>2>>>0],Ya:a()[n+12>>>2>>>0],Wa:a()[n+16>>>2>>>0],Ta:a()[n+20>>>2>>>0],Qa:a()[n+24>>>2>>>0],Sa:a()[n+28>>>2>>>0],ob:a()[n+32>>>2>>>0],eb:a()[n+36>>>2>>>0],hb:c?Ce(c):\"\"},r=Ce(r),c={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})r=r.replace(new RegExp(d,\"g\"),c[d]);var g=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),h=\"January February March April May June July August September October November December\".split(\" \");for(d in c={\"%a\":e=>g[e.Qa].substring(0,3),\"%A\":e=>g[e.Qa],\"%b\":e=>h[e.Wa].substring(0,3),\"%B\":e=>h[e.Wa],\"%C\":e=>s((e.Ta+1900)/100|0,2),\"%d\":e=>s(e.Ya,2),\"%e\":e=>i(e.Ya,2,\" \"),\"%g\":e=>l(e).toString().substring(2),\"%G\":l,\"%H\":e=>s(e.Va,2),\"%I\":e=>(0==(e=e.Va)?e=12:12<e&&(e-=12),s(e,2)),\"%j\":e=>{for(var t=0,r=0;r<=e.Wa-1;t+=(rt(e.Ta+1900)?xt:Bt)[r++]);return s(e.Ya+t,3)},\"%m\":e=>s(e.Wa+1,2),\"%M\":e=>s(e.fb,2),\"%n\":()=>\"\\n\",\"%p\":e=>0<=e.Va&&12>e.Va?\"AM\":\"PM\",\"%S\":e=>s(e.gb,2),\"%t\":()=>\"\\t\",\"%u\":e=>e.Qa||7,\"%U\":e=>s(Math.floor((e.Sa+7-e.Qa)/7),2),\"%V\":e=>{var t=Math.floor((e.Sa+7-(e.Qa+6)%7)/7);if(2>=(e.Qa+371-e.Sa-2)%7&&t++,t)53==t&&(4==(r=(e.Qa+371-e.Sa)%7)||3==r&&rt(e.Ta)||(t=1));else{t=52;var r=(e.Qa+7-e.Sa-1)%7;(4==r||5==r&&rt(e.Ta%400-1))&&t++}return s(t,2)},\"%w\":e=>e.Qa,\"%W\":e=>s(Math.floor((e.Sa+7-(e.Qa+6)%7)/7),2),\"%y\":e=>(e.Ta+1900).toString().substring(2),\"%Y\":e=>e.Ta+1900,\"%z\":e=>{var t=0<=(e=e.eb);return e=Math.abs(e)/60,(t?\"+\":\"-\")+String(\"0000\"+(e/60*100+e%60)).slice(-4)},\"%Z\":e=>e.hb,\"%%\":()=>\"%\"},r=r.replace(/%%/g,\"\\0\\0\"),c)r.includes(d)&&(r=r.replace(new RegExp(d,\"g\"),c[d](n)));return d=function(e){var t=Array(Re(e)+1);return Ue(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,\"%\")),d.length>t?0:(Ht(d,e),d.length-1)}function It(e,t,r,n){return Pt(e>>>0,t>>>0,r>>>0,n>>>0)}g||function(){for(var e=f.numThreads-1;e--;)pe();P.unshift((()=>{$++,function(e){g?e():Promise.all(fe.map(me)).then(e)}((()=>L()))}))}();var Nt=[ie,se,Me,De,Fe,We,ke,xe,Be,He,Pe,Ie,Ne,$e,Ge,je,st,ut,Dt,Ft,Rt,Ut,Yt,kt],$t=function(){function e(e,t){return $t=e.exports,$t=function(){var e=$t,t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).Ba=t(e.Ba),e.Ca=r(e.Ca),e.emscripten_main_runtime_thread_id=t(e.emscripten_main_runtime_thread_id),e.Oa=r(e.Oa),e.Pa=t(e.Pa),e}(),ce.push($t.Ea),be=$t.Fa,I.unshift($t.$),D=t,L(),$t}var t=J();if($++,f.instantiateWasm)try{return f.instantiateWasm(t,e)}catch(e){A(`Module.instantiateWasm callback failed with error: ${e}`),u(e)}return Q||=f.locateFile?V(\"ort-wasm-simd-threaded.wasm\")?\"ort-wasm-simd-threaded.wasm\":f.locateFile?f.locateFile(\"ort-wasm-simd-threaded.wasm\",O):O+\"ort-wasm-simd-threaded.wasm\":new URL(\"ort-wasm-simd-threaded.wasm\",import.meta.url).href,function(e,t){var r=Q;return y||\"function\"!=typeof WebAssembly.instantiateStreaming||V(r)||X(r)||\"function\"!=typeof fetch?Z(r,e,t):fetch(r,{credentials:\"same-origin\"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return A(`wasm streaming compile failed: ${n}`),A(\"falling back to ArrayBuffer instantiation\"),Z(r,e,t)}))))}(t,(function(t){e(t.instance,t.module)})).catch(u),{}}();f._OrtInit=(e,t)=>(f._OrtInit=$t.aa)(e,t),f._OrtGetLastError=(e,t)=>(f._OrtGetLastError=$t.ba)(e,t),f._OrtCreateSessionOptions=(e,t,r,n,a,o,i,s,u,l)=>(f._OrtCreateSessionOptions=$t.ca)(e,t,r,n,a,o,i,s,u,l),f._OrtAppendExecutionProvider=(e,t)=>(f._OrtAppendExecutionProvider=$t.da)(e,t),f._OrtAddFreeDimensionOverride=(e,t,r)=>(f._OrtAddFreeDimensionOverride=$t.ea)(e,t,r),f._OrtAddSessionConfigEntry=(e,t,r)=>(f._OrtAddSessionConfigEntry=$t.fa)(e,t,r),f._OrtReleaseSessionOptions=e=>(f._OrtReleaseSessionOptions=$t.ga)(e),f._OrtCreateSession=(e,t,r)=>(f._OrtCreateSession=$t.ha)(e,t,r),f._OrtReleaseSession=e=>(f._OrtReleaseSession=$t.ia)(e),f._OrtGetInputOutputCount=(e,t,r)=>(f._OrtGetInputOutputCount=$t.ja)(e,t,r),f._OrtGetInputName=(e,t)=>(f._OrtGetInputName=$t.ka)(e,t),f._OrtGetOutputName=(e,t)=>(f._OrtGetOutputName=$t.la)(e,t),f._OrtFree=e=>(f._OrtFree=$t.ma)(e),f._OrtCreateTensor=(e,t,r,n,a,o)=>(f._OrtCreateTensor=$t.na)(e,t,r,n,a,o),f._OrtGetTensorData=(e,t,r,n,a)=>(f._OrtGetTensorData=$t.oa)(e,t,r,n,a),f._OrtReleaseTensor=e=>(f._OrtReleaseTensor=$t.pa)(e),f._OrtCreateRunOptions=(e,t,r,n)=>(f._OrtCreateRunOptions=$t.qa)(e,t,r,n),f._OrtAddRunConfigEntry=(e,t,r)=>(f._OrtAddRunConfigEntry=$t.ra)(e,t,r),f._OrtReleaseRunOptions=e=>(f._OrtReleaseRunOptions=$t.sa)(e),f._OrtCreateBinding=e=>(f._OrtCreateBinding=$t.ta)(e),f._OrtBindInput=(e,t,r)=>(f._OrtBindInput=$t.ua)(e,t,r),f._OrtBindOutput=(e,t,r,n)=>(f._OrtBindOutput=$t.va)(e,t,r,n),f._OrtClearBoundOutputs=e=>(f._OrtClearBoundOutputs=$t.wa)(e),f._OrtReleaseBinding=e=>(f._OrtReleaseBinding=$t.xa)(e),f._OrtRunWithBinding=(e,t,r,n,a)=>(f._OrtRunWithBinding=$t.ya)(e,t,r,n,a),f._OrtRun=(e,t,r,n,a,o,i,s)=>(f._OrtRun=$t.za)(e,t,r,n,a,o,i,s),f._OrtEndProfiling=e=>(f._OrtEndProfiling=$t.Aa)(e);var Gt=()=>(Gt=$t.Ba)();f._malloc=e=>(f._malloc=$t.Ca)(e),f._free=e=>(f._free=$t.Da)(e);var jt,Lt=(e,t,r,n,a,o)=>(Lt=$t.Ga)(e,t,r,n,a,o),zt=()=>(zt=$t.Ha)(),Qt=(e,t,r,n,a)=>(Qt=$t.Ia)(e,t,r,n,a),Vt=e=>(Vt=$t.Ja)(e),Xt=e=>(Xt=$t.Ka)(e),qt=()=>(qt=$t.La)(),Zt=(e,t)=>(Zt=$t.Ma)(e,t),Jt=e=>(Jt=$t.Na)(e),Kt=e=>(Kt=$t.Oa)(e),er=()=>(er=$t.Pa)();function tr(){0<$||(g?(s(f),g||ve(I),startWorker(f)):(ve(P),0<$||jt||(jt=!0,f.calledRun=!0,B||(g||ve(I),s(f),g||ve(N)))))}return f.___start_em_js=838360,f.___stop_em_js=838421,f.stackSave=()=>er(),f.stackRestore=e=>Jt(e),f.stackAlloc=e=>Kt(e),f.UTF8ToString=Ce,f.stringToUTF8=Ye,f.lengthBytesUTF8=Re,j=function e(){jt||tr(),jt||(j=e)},tr(),l});export default t;\"em-pthread\"===globalThis.self?.name&&t();","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport type { OrtWasmModule } from './wasm-types';\nimport { isNode } from './wasm-utils-env';\n\n/**\n * The classic script source URL. This is not always available in non ESModule environments.\n *\n * In Node.js, this is undefined.\n */\nexport const scriptSrc =\n  // if Nodejs, return undefined\n  isNode\n    ? undefined\n    : // if It's ESM, use import.meta.url\n      (BUILD_DEFS.ESM_IMPORT_META_URL ??\n      // use `document.currentScript.src` if available\n      (typeof document !== 'undefined'\n        ? (document.currentScript as HTMLScriptElement)?.src\n        : // use `self.location.href` if available\n          typeof self !== 'undefined'\n          ? self.location?.href\n          : undefined));\n\n/**\n * The origin of the current location.\n *\n * In Node.js, this is undefined.\n */\nconst origin = isNode || typeof location === 'undefined' ? undefined : location.origin;\n\n/**\n * Check if the given filename with prefix is from the same origin.\n */\nconst isSameOrigin = (filename: string, prefixOverride?: string) => {\n  try {\n    const baseUrl = prefixOverride ?? scriptSrc;\n    const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);\n    return url.origin === origin;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Normalize the inputs to an absolute URL with the given prefix override. If failed, return undefined.\n */\nconst normalizeUrl = (filename: string, prefixOverride?: string) => {\n  const baseUrl = prefixOverride ?? scriptSrc;\n  try {\n    const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);\n    return url.href;\n  } catch {\n    return undefined;\n  }\n};\n\n/**\n * Create a fallback URL if an absolute URL cannot be created by the normalizeUrl function.\n */\nconst fallbackUrl = (filename: string, prefixOverride?: string) => `${prefixOverride ?? './'}${filename}`;\n\n/**\n * This helper function is used to preload a module from a URL.\n *\n * If the origin of the worker URL is different from the current origin, the worker cannot be loaded directly.\n * See discussions in https://github.com/webpack-contrib/worker-loader/issues/154\n *\n * In this case, we will fetch the worker URL and create a new Blob URL with the same origin as a workaround.\n *\n * @param absoluteUrl - The absolute URL to preload.\n *\n * @returns - A promise that resolves to a new Blob URL\n */\nconst preload = async (absoluteUrl: string): Promise<string> => {\n  const response = await fetch(absoluteUrl, { credentials: 'same-origin' });\n  const blob = await response.blob();\n  return URL.createObjectURL(blob);\n};\n\n/**\n * This helper function is used to dynamically import a module from a URL.\n *\n * The build script has special handling for this function to ensure that the URL is not bundled into the final output.\n *\n * @param url - The URL to import.\n *\n * @returns - A promise that resolves to the default export of the module.\n */\nconst dynamicImportDefault = async <T>(url: string): Promise<T> =>\n  (await import(/* webpackIgnore: true */ url)).default;\n\n/**\n * The proxy worker factory imported from the proxy worker module.\n *\n * This is only available when the WebAssembly proxy is not disabled.\n */\nconst createProxyWorker: ((urlOverride?: string) => Worker) | undefined =\n  // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\n  BUILD_DEFS.DISABLE_WASM_PROXY ? undefined : require('./proxy-worker/main').default;\n\n/**\n * Import the proxy worker.\n *\n * This function will perform the following steps:\n * 1. If a preload is needed, it will preload the module and return the object URL.\n * 2. Use the proxy worker factory to create the proxy worker.\n *\n * @returns - A promise that resolves to a tuple of 2 elements:\n *            - The object URL of the preloaded module, or undefined if no preload is needed.\n *            - The proxy worker.\n */\nexport const importProxyWorker = async (): Promise<[undefined | string, Worker]> => {\n  if (!scriptSrc) {\n    throw new Error('Failed to load proxy worker: cannot determine the script source URL.');\n  }\n\n  // If the script source is from the same origin, we can use the embedded proxy module directly.\n  if (isSameOrigin(scriptSrc)) {\n    return [undefined, createProxyWorker!()];\n  }\n\n  // Otherwise, need to preload\n  const url = await preload(scriptSrc);\n  return [url, createProxyWorker!(url)];\n};\n\n/**\n * The embedded WebAssembly module.\n *\n * This is only available in ESM and when embedding is not disabled.\n */\nconst embeddedWasmModule: EmscriptenModuleFactory<OrtWasmModule> | undefined =\n  BUILD_DEFS.IS_ESM && BUILD_DEFS.DISABLE_DYNAMIC_IMPORT\n    ? // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\n      require(\n        !BUILD_DEFS.DISABLE_JSEP\n          ? '../../dist/ort-wasm-simd-threaded.jsep.mjs'\n          : '../../dist/ort-wasm-simd-threaded.mjs',\n      ).default\n    : undefined;\n\n/**\n * Import the WebAssembly module.\n *\n * This function will perform the following steps:\n * 1. If BUILD_DEFS.DISABLE_DYNAMIC_IMPORT is true, use the embedded module.\n * 2. If a preload is needed, it will preload the module and return the object URL.\n * 3. Otherwise, it will perform a dynamic import of the module.\n *\n * @returns - A promise that resolves to a tuple of 2 elements:\n *            - The object URL of the preloaded module, or undefined if no preload is needed.\n *            - The default export of the module, which is a factory function to create the WebAssembly module.\n */\nexport const importWasmModule = async (\n  urlOverride: string | undefined,\n  prefixOverride: string | undefined,\n  isMultiThreaded: boolean,\n): Promise<[undefined | string, EmscriptenModuleFactory<OrtWasmModule>]> => {\n  if (BUILD_DEFS.DISABLE_DYNAMIC_IMPORT) {\n    return [undefined, embeddedWasmModule!];\n  } else {\n    const wasmModuleFilename = !BUILD_DEFS.DISABLE_JSEP\n      ? 'ort-wasm-simd-threaded.jsep.mjs'\n      : 'ort-wasm-simd-threaded.mjs';\n    const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);\n    // need to preload if all of the following conditions are met:\n    // 1. not in Node.js.\n    //    - Node.js does not have the same origin policy for creating workers.\n    // 2. multi-threaded is enabled.\n    //    - If multi-threaded is disabled, no worker will be created. So we don't need to preload the module.\n    // 3. the absolute URL is available.\n    //    - If the absolute URL is failed to be created, the origin cannot be determined. In this case, we will not\n    //    preload the module.\n    // 4. the worker URL is not from the same origin.\n    //    - If the worker URL is from the same origin, we can create the worker directly.\n    const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);\n    const url = needPreload\n      ? await preload(wasmModuleUrl)\n      : (wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride));\n    return [needPreload ? url : undefined, await dynamicImportDefault<EmscriptenModuleFactory<OrtWasmModule>>(url)];\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Env } from 'onnxruntime-common';\n\nimport type { OrtWasmModule } from './wasm-types';\nimport { importWasmModule } from './wasm-utils-import';\n\nlet wasm: OrtWasmModule | undefined;\nlet initialized = false;\nlet initializing = false;\nlet aborted = false;\n\nconst isMultiThreadSupported = (): boolean => {\n  // If 'SharedArrayBuffer' is not available, WebAssembly threads will not work.\n  if (typeof SharedArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  try {\n    // Test for transferability of SABs (for browsers. needed for Firefox)\n    // https://groups.google.com/forum/#!msg/mozilla.dev.platform/IHkBZlHETpA/dwsMNchWEQAJ\n    if (typeof MessageChannel !== 'undefined') {\n      new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));\n    }\n\n    // Test for WebAssembly threads capability (for both browsers and Node.js)\n    // This typed array is a WebAssembly program containing threaded instructions.\n    return WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16,\n        2, 0, 26, 11,\n      ]),\n    );\n  } catch (e) {\n    return false;\n  }\n};\n\nconst isSimdSupported = (): boolean => {\n  try {\n    // Test for WebAssembly SIMD capability (for both browsers and Node.js)\n    // This typed array is a WebAssembly program containing SIMD instructions.\n\n    // The binary data is generated from the following code by wat2wasm:\n    //\n    // (module\n    //   (type $t0 (func))\n    //   (func $f0 (type $t0)\n    //     (drop\n    //       (i32x4.dot_i16x8_s\n    //         (i8x16.splat\n    //           (i32.const 0))\n    //         (v128.const i32x4 0x00000000 0x00000000 0x00000000 0x00000000)))))\n\n    return WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11,\n      ]),\n    );\n  } catch (e) {\n    return false;\n  }\n};\n\nexport const initializeWebAssembly = async (flags: Env.WebAssemblyFlags): Promise<void> => {\n  if (initialized) {\n    return Promise.resolve();\n  }\n  if (initializing) {\n    throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");\n  }\n  if (aborted) {\n    throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");\n  }\n\n  initializing = true;\n\n  // wasm flags are already initialized\n  const timeout = flags.initTimeout!;\n  let numThreads = flags.numThreads!;\n\n  // ensure SIMD is supported\n  if (!isSimdSupported()) {\n    throw new Error('WebAssembly SIMD is not supported in the current environment.');\n  }\n\n  // check if multi-threading is supported\n  const multiThreadSupported = isMultiThreadSupported();\n  if (numThreads > 1 && !multiThreadSupported) {\n    if (typeof self !== 'undefined' && !self.crossOriginIsolated) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'env.wasm.numThreads is set to ' +\n          numThreads +\n          ', but this will not work unless you enable crossOriginIsolated mode. ' +\n          'See https://web.dev/cross-origin-isolation-guide/ for more info.',\n      );\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn(\n      'WebAssembly multi-threading is not supported in the current environment. ' + 'Falling back to single-threading.',\n    );\n\n    // set flags.numThreads to 1 so that OrtInit() will not create a global thread pool.\n    flags.numThreads = numThreads = 1;\n  }\n\n  const wasmPaths = flags.wasmPaths;\n  const wasmPrefixOverride = typeof wasmPaths === 'string' ? wasmPaths : undefined;\n  const mjsPathOverrideFlag = (wasmPaths as Env.WasmFilePaths)?.mjs;\n  const mjsPathOverride = (mjsPathOverrideFlag as URL)?.href ?? mjsPathOverrideFlag;\n  const wasmPathOverrideFlag = (wasmPaths as Env.WasmFilePaths)?.wasm;\n  const wasmPathOverride = (wasmPathOverrideFlag as URL)?.href ?? wasmPathOverrideFlag;\n  const wasmBinaryOverride = flags.wasmBinary;\n\n  const [objectUrl, ortWasmFactory] = await importWasmModule(mjsPathOverride, wasmPrefixOverride, numThreads > 1);\n\n  let isTimeout = false;\n\n  const tasks: Array<Promise<void>> = [];\n\n  // promise for timeout\n  if (timeout > 0) {\n    tasks.push(\n      new Promise((resolve) => {\n        setTimeout(() => {\n          isTimeout = true;\n          resolve();\n        }, timeout);\n      }),\n    );\n  }\n\n  // promise for module initialization\n  tasks.push(\n    new Promise((resolve, reject) => {\n      const config: Partial<OrtWasmModule> = {\n        /**\n         * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be\n         * created.\n         */\n        numThreads,\n      };\n\n      if (wasmBinaryOverride) {\n        /**\n         * Set a custom buffer which contains the WebAssembly binary. This will skip the wasm file fetching.\n         */\n        config.wasmBinary = wasmBinaryOverride;\n      } else if (wasmPathOverride || wasmPrefixOverride) {\n        /**\n         * A callback function to locate the WebAssembly file. The function should return the full path of the file.\n         *\n         * Since Emscripten 3.1.58, this function is only called for the .wasm file.\n         */\n        config.locateFile = (fileName, scriptDirectory) =>\n          wasmPathOverride ?? (wasmPrefixOverride ?? scriptDirectory) + fileName;\n      }\n\n      ortWasmFactory(config).then(\n        // wasm module initialized successfully\n        (module) => {\n          initializing = false;\n          initialized = true;\n          wasm = module;\n          resolve();\n          if (objectUrl) {\n            URL.revokeObjectURL(objectUrl);\n          }\n        },\n        // wasm module failed to initialize\n        (what) => {\n          initializing = false;\n          aborted = true;\n          reject(what);\n        },\n      );\n    }),\n  );\n\n  await Promise.race(tasks);\n\n  if (isTimeout) {\n    throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);\n  }\n};\n\nexport const getInstance = (): OrtWasmModule => {\n  if (initialized && wasm) {\n    return wasm;\n  }\n\n  throw new Error('WebAssembly is not initialized yet.');\n};\n\nexport const dispose = (): void => {\n  if (initialized && !initializing && !aborted) {\n    // TODO: currently \"PThread.terminateAllThreads()\" is not exposed in the wasm module.\n    //       And this function is not yet called by any code.\n    //       If it is needed in the future, we should expose it in the wasm module and uncomment the following line.\n\n    // wasm?.PThread?.terminateAllThreads();\n    wasm = undefined;\n\n    initializing = false;\n    initialized = false;\n    aborted = true;\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { getInstance } from './wasm-factory';\n\nexport const allocWasmString = (data: string, allocs: number[]): number => {\n  const wasm = getInstance();\n\n  const dataLength = wasm.lengthBytesUTF8(data) + 1;\n  const dataOffset = wasm._malloc(dataLength);\n  wasm.stringToUTF8(data, dataOffset, dataLength);\n  allocs.push(dataOffset);\n\n  return dataOffset;\n};\n\ninterface ExtraOptionsHandler {\n  (name: string, value: string): void;\n}\n\nexport const iterateExtraOptions = (\n  options: Record<string, unknown>,\n  prefix: string,\n  seen: WeakSet<Record<string, unknown>>,\n  handler: ExtraOptionsHandler,\n): void => {\n  if (typeof options == 'object' && options !== null) {\n    if (seen.has(options)) {\n      throw new Error('Circular reference in options');\n    } else {\n      seen.add(options);\n    }\n  }\n\n  Object.entries(options).forEach(([key, value]) => {\n    const name = prefix ? prefix + key : key;\n    if (typeof value === 'object') {\n      iterateExtraOptions(value as Record<string, unknown>, name + '.', seen, handler);\n    } else if (typeof value === 'string' || typeof value === 'number') {\n      handler(name, value.toString());\n    } else if (typeof value === 'boolean') {\n      handler(name, value ? '1' : '0');\n    } else {\n      throw new Error(`Can't handle extra config type: ${typeof value}`);\n    }\n  });\n};\n\n/**\n * check web assembly API's last error and throw error if any error occurred.\n * @param message a message used when an error occurred.\n */\nexport const checkLastError = (message: string): void => {\n  const wasm = getInstance();\n\n  const stack = wasm.stackSave();\n  try {\n    const paramsOffset = wasm.stackAlloc(8);\n    wasm._OrtGetLastError(paramsOffset, paramsOffset + 4);\n    const errorCode = wasm.HEAP32[paramsOffset / 4];\n    const errorMessagePointer = wasm.HEAPU32[paramsOffset / 4 + 1];\n    const errorMessage = errorMessagePointer ? wasm.UTF8ToString(errorMessagePointer) : '';\n    throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);\n  } finally {\n    wasm.stackRestore(stack);\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceSession } from 'onnxruntime-common';\n\nimport { getInstance } from './wasm-factory';\nimport { allocWasmString, checkLastError, iterateExtraOptions } from './wasm-utils';\n\nexport const setRunOptions = (options: InferenceSession.RunOptions): [number, number[]] => {\n  const wasm = getInstance();\n  let runOptionsHandle = 0;\n  const allocs: number[] = [];\n\n  const runOptions: InferenceSession.RunOptions = options || {};\n\n  try {\n    if (options?.logSeverityLevel === undefined) {\n      runOptions.logSeverityLevel = 2; // Default to warning\n    } else if (\n      typeof options.logSeverityLevel !== 'number' ||\n      !Number.isInteger(options.logSeverityLevel) ||\n      options.logSeverityLevel < 0 ||\n      options.logSeverityLevel > 4\n    ) {\n      throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);\n    }\n\n    if (options?.logVerbosityLevel === undefined) {\n      runOptions.logVerbosityLevel = 0; // Default to 0\n    } else if (typeof options.logVerbosityLevel !== 'number' || !Number.isInteger(options.logVerbosityLevel)) {\n      throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);\n    }\n\n    if (options?.terminate === undefined) {\n      runOptions.terminate = false;\n    }\n\n    let tagDataOffset = 0;\n    if (options?.tag !== undefined) {\n      tagDataOffset = allocWasmString(options.tag, allocs);\n    }\n\n    runOptionsHandle = wasm._OrtCreateRunOptions(\n      runOptions.logSeverityLevel!,\n      runOptions.logVerbosityLevel!,\n      !!runOptions.terminate!,\n      tagDataOffset,\n    );\n    if (runOptionsHandle === 0) {\n      checkLastError(\"Can't create run options.\");\n    }\n\n    if (options?.extra !== undefined) {\n      iterateExtraOptions(options.extra, '', new WeakSet<Record<string, unknown>>(), (key, value) => {\n        const keyDataOffset = allocWasmString(key, allocs);\n        const valueDataOffset = allocWasmString(value, allocs);\n\n        if (wasm._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n          checkLastError(`Can't set a run config entry: ${key} - ${value}.`);\n        }\n      });\n    }\n\n    return [runOptionsHandle, allocs];\n  } catch (e) {\n    if (runOptionsHandle !== 0) {\n      wasm._OrtReleaseRunOptions(runOptionsHandle);\n    }\n    allocs.forEach((alloc) => wasm._free(alloc));\n    throw e;\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceSession } from 'onnxruntime-common';\n\nimport { getInstance } from './wasm-factory';\nimport { allocWasmString, checkLastError, iterateExtraOptions } from './wasm-utils';\n\nconst getGraphOptimzationLevel = (graphOptimizationLevel: string | unknown): number => {\n  switch (graphOptimizationLevel) {\n    case 'disabled':\n      return 0;\n    case 'basic':\n      return 1;\n    case 'extended':\n      return 2;\n    case 'all':\n      return 99;\n    default:\n      throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);\n  }\n};\n\nconst getExecutionMode = (executionMode: 'sequential' | 'parallel'): number => {\n  switch (executionMode) {\n    case 'sequential':\n      return 0;\n    case 'parallel':\n      return 1;\n    default:\n      throw new Error(`unsupported execution mode: ${executionMode}`);\n  }\n};\n\nconst appendDefaultOptions = (options: InferenceSession.SessionOptions): void => {\n  if (!options.extra) {\n    options.extra = {};\n  }\n  if (!options.extra.session) {\n    options.extra.session = {};\n  }\n  const session = options.extra.session as Record<string, string>;\n  if (!session.use_ort_model_bytes_directly) {\n    // eslint-disable-next-line camelcase\n    session.use_ort_model_bytes_directly = '1';\n  }\n\n  // if using JSEP with WebGPU, always disable memory pattern\n  if (\n    options.executionProviders &&\n    options.executionProviders.some((ep) => (typeof ep === 'string' ? ep : ep.name) === 'webgpu')\n  ) {\n    options.enableMemPattern = false;\n  }\n};\n\nconst setExecutionProviders = (\n  sessionOptionsHandle: number,\n  executionProviders: readonly InferenceSession.ExecutionProviderConfig[],\n  allocs: number[],\n): void => {\n  for (const ep of executionProviders) {\n    let epName = typeof ep === 'string' ? ep : ep.name;\n\n    // check EP name\n    switch (epName) {\n      case 'webnn':\n        epName = 'WEBNN';\n        if (typeof ep !== 'string') {\n          const webnnOptions = ep as InferenceSession.WebNNExecutionProviderOption;\n          // const context = (webnnOptions as InferenceSession.WebNNOptionsWithMLContext)?.context;\n          const deviceType = (webnnOptions as InferenceSession.WebNNContextOptions)?.deviceType;\n          if (deviceType) {\n            const keyDataOffset = allocWasmString('deviceType', allocs);\n            const valueDataOffset = allocWasmString(deviceType, allocs);\n            if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n              checkLastError(`Can't set a session config entry: 'deviceType' - ${deviceType}.`);\n            }\n          }\n        }\n        break;\n      case 'webgpu':\n        epName = 'JS';\n        if (typeof ep !== 'string') {\n          const webgpuOptions = ep as InferenceSession.WebGpuExecutionProviderOption;\n          if (webgpuOptions?.preferredLayout) {\n            if (webgpuOptions.preferredLayout !== 'NCHW' && webgpuOptions.preferredLayout !== 'NHWC') {\n              throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);\n            }\n            const keyDataOffset = allocWasmString('preferredLayout', allocs);\n            const valueDataOffset = allocWasmString(webgpuOptions.preferredLayout, allocs);\n            if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n              checkLastError(`Can't set a session config entry: 'preferredLayout' - ${webgpuOptions.preferredLayout}.`);\n            }\n          }\n        }\n        break;\n      case 'wasm':\n      case 'cpu':\n        continue;\n      default:\n        throw new Error(`not supported execution provider: ${epName}`);\n    }\n\n    const epNameDataOffset = allocWasmString(epName, allocs);\n    if (getInstance()._OrtAppendExecutionProvider(sessionOptionsHandle, epNameDataOffset) !== 0) {\n      checkLastError(`Can't append execution provider: ${epName}.`);\n    }\n  }\n};\n\nexport const setSessionOptions = (options?: InferenceSession.SessionOptions): [number, number[]] => {\n  const wasm = getInstance();\n  let sessionOptionsHandle = 0;\n  const allocs: number[] = [];\n\n  const sessionOptions: InferenceSession.SessionOptions = options || {};\n  appendDefaultOptions(sessionOptions);\n\n  try {\n    const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? 'all');\n    const executionMode = getExecutionMode(sessionOptions.executionMode ?? 'sequential');\n    const logIdDataOffset =\n      typeof sessionOptions.logId === 'string' ? allocWasmString(sessionOptions.logId, allocs) : 0;\n\n    const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2; // Default to 2 - warning\n    if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {\n      throw new Error(`log serverity level is not valid: ${logSeverityLevel}`);\n    }\n\n    const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0; // Default to 0 - verbose\n    if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {\n      throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);\n    }\n\n    const optimizedModelFilePathOffset =\n      typeof sessionOptions.optimizedModelFilePath === 'string'\n        ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs)\n        : 0;\n\n    sessionOptionsHandle = wasm._OrtCreateSessionOptions(\n      graphOptimizationLevel,\n      !!sessionOptions.enableCpuMemArena,\n      !!sessionOptions.enableMemPattern,\n      executionMode,\n      !!sessionOptions.enableProfiling,\n      0,\n      logIdDataOffset,\n      logSeverityLevel,\n      logVerbosityLevel,\n      optimizedModelFilePathOffset,\n    );\n    if (sessionOptionsHandle === 0) {\n      checkLastError(\"Can't create session options.\");\n    }\n\n    if (sessionOptions.executionProviders) {\n      setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);\n    }\n\n    if (sessionOptions.enableGraphCapture !== undefined) {\n      if (typeof sessionOptions.enableGraphCapture !== 'boolean') {\n        throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);\n      }\n      const keyDataOffset = allocWasmString('enableGraphCapture', allocs);\n      const valueDataOffset = allocWasmString(sessionOptions.enableGraphCapture.toString(), allocs);\n      if (wasm._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n        checkLastError(\n          `Can't set a session config entry: 'enableGraphCapture' - ${sessionOptions.enableGraphCapture}.`,\n        );\n      }\n    }\n\n    if (sessionOptions.freeDimensionOverrides) {\n      for (const [name, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {\n        if (typeof name !== 'string') {\n          throw new Error(`free dimension override name must be a string: ${name}`);\n        }\n        if (typeof value !== 'number' || !Number.isInteger(value) || value < 0) {\n          throw new Error(`free dimension override value must be a non-negative integer: ${value}`);\n        }\n        const nameOffset = allocWasmString(name, allocs);\n        if (wasm._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {\n          checkLastError(`Can't set a free dimension override: ${name} - ${value}.`);\n        }\n      }\n    }\n\n    if (sessionOptions.extra !== undefined) {\n      iterateExtraOptions(sessionOptions.extra, '', new WeakSet<Record<string, unknown>>(), (key, value) => {\n        const keyDataOffset = allocWasmString(key, allocs);\n        const valueDataOffset = allocWasmString(value, allocs);\n\n        if (wasm._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n          checkLastError(`Can't set a session config entry: ${key} - ${value}.`);\n        }\n      });\n    }\n\n    return [sessionOptionsHandle, allocs];\n  } catch (e) {\n    if (sessionOptionsHandle !== 0) {\n      wasm._OrtReleaseSessionOptions(sessionOptionsHandle);\n    }\n    allocs.forEach((alloc) => wasm._free(alloc));\n    throw e;\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from 'onnxruntime-common';\n\n// a dummy type declaration for Float16Array in case any polyfill is available.\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-explicit-any\n  const Float16Array: any;\n}\n\n// This file includes common definitions. They do NOT have dependency on the WebAssembly instance.\n\n/**\n * Copied from ONNX definition. Use this to drop dependency 'onnx_proto' to decrease compiled .js file size.\n */\nexport const enum DataType {\n  undefined = 0,\n  float = 1,\n  uint8 = 2,\n  int8 = 3,\n  uint16 = 4,\n  int16 = 5,\n  int32 = 6,\n  int64 = 7,\n  string = 8,\n  bool = 9,\n  float16 = 10,\n  double = 11,\n  uint32 = 12,\n  uint64 = 13,\n  complex64 = 14,\n  complex128 = 15,\n  bfloat16 = 16,\n\n  // 4-bit data-types\n  uint4 = 21,\n  int4 = 22,\n}\n\n/**\n * Map string tensor data to enum value\n */\nexport const tensorDataTypeStringToEnum = (type: string): DataType => {\n  switch (type) {\n    case 'int8':\n      return DataType.int8;\n    case 'uint8':\n      return DataType.uint8;\n    case 'bool':\n      return DataType.bool;\n    case 'int16':\n      return DataType.int16;\n    case 'uint16':\n      return DataType.uint16;\n    case 'int32':\n      return DataType.int32;\n    case 'uint32':\n      return DataType.uint32;\n    case 'float16':\n      return DataType.float16;\n    case 'float32':\n      return DataType.float;\n    case 'float64':\n      return DataType.double;\n    case 'string':\n      return DataType.string;\n    case 'int64':\n      return DataType.int64;\n    case 'uint64':\n      return DataType.uint64;\n    case 'int4':\n      return DataType.int4;\n    case 'uint4':\n      return DataType.uint4;\n\n    default:\n      throw new Error(`unsupported data type: ${type}`);\n  }\n};\n\n/**\n * Map enum value to string tensor data\n */\nexport const tensorDataTypeEnumToString = (typeProto: DataType): Tensor.Type => {\n  switch (typeProto) {\n    case DataType.int8:\n      return 'int8';\n    case DataType.uint8:\n      return 'uint8';\n    case DataType.bool:\n      return 'bool';\n    case DataType.int16:\n      return 'int16';\n    case DataType.uint16:\n      return 'uint16';\n    case DataType.int32:\n      return 'int32';\n    case DataType.uint32:\n      return 'uint32';\n    case DataType.float16:\n      return 'float16';\n    case DataType.float:\n      return 'float32';\n    case DataType.double:\n      return 'float64';\n    case DataType.string:\n      return 'string';\n    case DataType.int64:\n      return 'int64';\n    case DataType.uint64:\n      return 'uint64';\n    case DataType.int4:\n      return 'int4';\n    case DataType.uint4:\n      return 'uint4';\n\n    default:\n      throw new Error(`unsupported data type: ${typeProto}`);\n  }\n};\n\n/**\n * get tensor size in bytes by the given data type and dimensions\n * @returns size in integer or undefined if the data type is not supported\n */\nexport const calculateTensorSizeInBytes = (\n  dateType: number,\n  dimsOrSize: readonly number[] | number,\n): number | undefined => {\n  const elementSize = [\n    -1, // undefined = 0\n    4, // float = 1\n    1, // uint8 = 2\n    1, // int8 = 3\n    2, // uint16 = 4\n    2, // int16 = 5\n    4, // int32 = 6\n    8, // int64 = 7\n    -1, // string = 8\n    1, // bool = 9\n    2, // float16 = 10\n    8, // double = 11\n    4, // uint32 = 12\n    8, // uint64 = 13\n    -1, // complex64 = 14\n    -1, // complex128 = 15\n    -1, // bfloat16 = 16\n    -1, // FLOAT8E4M3FN = 17\n    -1, // FLOAT8E4M3FNUZ = 18\n    -1, // FLOAT8E5M2 = 19\n    -1, // FLOAT8E5M2FNUZ = 20\n    0.5, // uint4 = 21\n    0.5, // int4 = 22\n  ][dateType];\n\n  const size = typeof dimsOrSize === 'number' ? dimsOrSize : dimsOrSize.reduce((a, b) => a * b, 1);\n  return elementSize > 0 ? Math.ceil(size * elementSize) : undefined;\n};\n\n/**\n * get typed array constructor by the given tensor type\n */\nexport const tensorTypeToTypedArrayConstructor = (\n  type: Tensor.Type,\n):\n  | Float32ArrayConstructor\n  | Uint8ArrayConstructor\n  | Int8ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int16ArrayConstructor\n  | Int32ArrayConstructor\n  | BigInt64ArrayConstructor\n  | Uint8ArrayConstructor\n  | Float64ArrayConstructor\n  | Uint32ArrayConstructor\n  | BigUint64ArrayConstructor => {\n  switch (type) {\n    case 'float16':\n      // allow Float16Array polyfill.\n      return typeof Float16Array !== 'undefined' && Float16Array.from ? Float16Array : Uint16Array;\n    case 'float32':\n      return Float32Array;\n    case 'uint8':\n      return Uint8Array;\n    case 'int8':\n      return Int8Array;\n    case 'uint16':\n      return Uint16Array;\n    case 'int16':\n      return Int16Array;\n    case 'int32':\n      return Int32Array;\n    case 'bool':\n      return Uint8Array;\n    case 'float64':\n      return Float64Array;\n    case 'uint32':\n      return Uint32Array;\n    case 'int64':\n      return BigInt64Array;\n    case 'uint64':\n      return BigUint64Array;\n    default:\n      throw new Error(`unsupported type: ${type}`);\n  }\n};\n\n/**\n * Map string log level to integer value\n */\nexport const logLevelStringToEnum = (logLevel?: 'verbose' | 'info' | 'warning' | 'error' | 'fatal'): number => {\n  switch (logLevel) {\n    case 'verbose':\n      return 0;\n    case 'info':\n      return 1;\n    case 'warning':\n      return 2;\n    case 'error':\n      return 3;\n    case 'fatal':\n      return 4;\n    default:\n      throw new Error(`unsupported logging level: ${logLevel}`);\n  }\n};\n\n/**\n * Check whether the given tensor type is supported by GPU buffer\n */\nexport const isGpuBufferSupportedType = (type: Tensor.Type): type is Tensor.GpuBufferDataTypes =>\n  type === 'float32' ||\n  type === 'float16' ||\n  type === 'int32' ||\n  type === 'int64' ||\n  type === 'uint32' ||\n  type === 'uint8' ||\n  type === 'bool' ||\n  type === 'uint4' ||\n  type === 'int4';\n\n/**\n * Check whether the given tensor type is supported by WebNN MLTensor\n */\nexport const isMLTensorSupportedType = (type: Tensor.Type): type is Tensor.MLTensorDataTypes =>\n  type === 'float32' ||\n  type === 'float16' ||\n  type === 'int32' ||\n  type === 'int64' ||\n  type === 'uint32' ||\n  type === 'uint64' ||\n  type === 'int8' ||\n  type === 'uint8' ||\n  type === 'bool';\n\n/**\n * Map string data location to integer value\n */\nexport const dataLocationStringToEnum = (location: Tensor.DataLocation): number => {\n  switch (location) {\n    case 'none':\n      return 0;\n    case 'cpu':\n      return 1;\n    case 'cpu-pinned':\n      return 2;\n    case 'texture':\n      return 3;\n    case 'gpu-buffer':\n      return 4;\n    case 'ml-tensor':\n      return 5;\n    default:\n      throw new Error(`unsupported data location: ${location}`);\n  }\n};\n\n/**\n * Map integer data location to string value\n */\nexport const dataLocationEnumToString = (location: number): Tensor.DataLocation | undefined =>\n  (['none', 'cpu', 'cpu-pinned', 'texture', 'gpu-buffer', 'ml-tensor'] as const)[location];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { isNode } from './wasm-utils-env';\n\n/**\n * Load a file into a Uint8Array.\n *\n * @param file - the file to load. Can be a URL/path, a Blob, an ArrayBuffer, or a Uint8Array.\n * @returns a Uint8Array containing the file data.\n */\nexport const loadFile = async (file: string | Blob | ArrayBufferLike | Uint8Array): Promise<Uint8Array> => {\n  if (typeof file === 'string') {\n    if (isNode) {\n      // load file into ArrayBuffer in Node.js\n      try {\n        const { readFile } = require('node:fs/promises');\n        return new Uint8Array(await readFile(file));\n      } catch (e) {\n        if (e.code === 'ERR_FS_FILE_TOO_LARGE') {\n          // file is too large, use fs.createReadStream instead\n          const { createReadStream } = require('node:fs');\n          const stream = createReadStream(file);\n          const chunks: Uint8Array[] = [];\n          for await (const chunk of stream) {\n            chunks.push(chunk);\n          }\n          return new Uint8Array(Buffer.concat(chunks));\n        }\n        throw e;\n      }\n    } else {\n      // load file into ArrayBuffer in browsers\n      const response = await fetch(file);\n      if (!response.ok) {\n        throw new Error(`failed to load external data file: ${file}`);\n      }\n      const contentLengthHeader = response.headers.get('Content-Length');\n      const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;\n      if (fileSize < 1073741824 /* 1GB */) {\n        // when Content-Length header is not set, we cannot determine the file size. We assume it is small enough to\n        // load into memory.\n        return new Uint8Array(await response.arrayBuffer());\n      } else {\n        // file is too large, use stream instead\n        if (!response.body) {\n          throw new Error(`failed to load external data file: ${file}, no response body.`);\n        }\n        const reader = response.body.getReader();\n\n        let buffer;\n        try {\n          // try to create ArrayBuffer directly\n          buffer = new ArrayBuffer(fileSize);\n        } catch (e) {\n          if (e instanceof RangeError) {\n            // use WebAssembly Memory to allocate larger ArrayBuffer\n            const pages = Math.ceil(fileSize / 65536);\n            buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;\n          } else {\n            throw e;\n          }\n        }\n\n        let offset = 0;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            break;\n          }\n          const chunkSize = value.byteLength;\n          const chunk = new Uint8Array(buffer, offset, chunkSize);\n          chunk.set(value);\n          offset += chunkSize;\n        }\n        return new Uint8Array(buffer, 0, fileSize);\n      }\n    }\n  } else if (file instanceof Blob) {\n    return new Uint8Array(await file.arrayBuffer());\n  } else if (file instanceof Uint8Array) {\n    return file;\n  } else {\n    return new Uint8Array(file);\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// WebNN API currently does not have a TypeScript definition file. This file is a workaround with types generated from\n// WebNN API specification.\n// https://github.com/webmachinelearning/webnn/issues/677\n/// <reference path=\"jsep/webnn/webnn.d.ts\" />\n\nimport { Env, InferenceSession, Tensor } from 'onnxruntime-common';\n\nimport {\n  SerializableInternalBuffer,\n  SerializableSessionMetadata,\n  SerializableTensorMetadata,\n  TensorMetadata,\n} from './proxy-messages';\nimport { setRunOptions } from './run-options';\nimport { setSessionOptions } from './session-options';\nimport {\n  calculateTensorSizeInBytes,\n  dataLocationStringToEnum,\n  isGpuBufferSupportedType,\n  isMLTensorSupportedType,\n  logLevelStringToEnum,\n  tensorDataTypeEnumToString,\n  tensorDataTypeStringToEnum,\n  tensorTypeToTypedArrayConstructor,\n} from './wasm-common';\nimport { getInstance } from './wasm-factory';\nimport { allocWasmString, checkLastError } from './wasm-utils';\nimport { loadFile } from './wasm-utils-load-file';\n\n// #region Initializations\n\n/**\n * There are 4 different \"initialization\" steps for ORT. They happen in different places and different time.\n *\n * 1. JavaScript initialization for onnxruntime-common and onnxruntime-web.\n *    This is the first initialization step. In this step, onnxruntime-web calls onnxruntime-common's registerBackend()\n * function multiple times to register all the available backends. The backend registration is very fast. It only\n * registers the backend name with the uninitialized backend object. No heavy initialization is done in this step.\n *    Refer to web/lib/index.ts for the backend registration.\n *\n * 2. WebAssembly artifact initialization.\n *    This happens when any registered wasm backend is used for the first time (ie. `ort.InferenceSession.create()` is\n * called). In this step, onnxruntime-web does the followings:\n *     - create a proxy worker and make sure the proxy worker is ready to receive messages, if proxy is enabled.\n *     - perform feature detection, locate correct WebAssembly artifact path and call the Emscripten generated\n * JavaScript code to initialize the WebAssembly runtime.\n *         - if proxy is enabled, this step happens in the proxy worker using message 'init-wasm'.\n *         - downloading the 'ort-wasm{...}.wasm' file is done in this step.\n *         - if multi-thread is enabled, one or more webworker will be created to initialize the PThread threadpool.\n *\n * 3. ORT environment initialization.\n *    This happens after step 2. In this step, onnxruntime-web performs ONNX Runtime environment initialization.\n * Function `_OrtInit()` is called in this step.\n *     - if proxy is enabled, this step happens in the proxy worker using message 'init-ort'.\n *     - logging level (ort.env.logLevel) and thread number (ort.env.wasm.numThreads) are set in this step.\n *\n * 4. Session initialization.\n *    This happens when `ort.InferenceSession.create()` is called. Unlike the first 3 steps (they only called once),\n * this step will be done for each session. In this step, onnxruntime-web does the followings:\n *    If the parameter is a URL:\n *    - download the model data from the URL.\n *    - copy the model data to the WASM heap. (proxy: 'copy-from')\n *    - dereference the model buffer. This step allows the original ArrayBuffer to be garbage collected.\n *    - call `_OrtCreateSession()` to create the session. (proxy: 'create')\n *\n *    If the parameter is a Uint8Array object:\n *    - copy the model data to the WASM heap. (proxy: 'copy-from')\n *    - call `_OrtCreateSession()` to create the session. (proxy: 'create')\n *\n *\n */\n\n/**\n * initialize ORT environment.\n *\n * @param numThreads SetGlobalIntraOpNumThreads(numThreads)\n * @param loggingLevel CreateEnv(static_cast<OrtLoggingLevel>(logging_level))\n */\nconst initOrt = (numThreads: number, loggingLevel: number): void => {\n  const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);\n  if (errorCode !== 0) {\n    checkLastError(\"Can't initialize onnxruntime.\");\n  }\n};\n\n/**\n * initialize runtime environment.\n * @param env passed in the environment config object.\n */\nexport const initRuntime = async (env: Env): Promise<void> => {\n  // init ORT\n  initOrt(env.wasm.numThreads!, logLevelStringToEnum(env.logLevel));\n};\n\n/**\n * perform EP specific initialization.\n *\n * @param env\n * @param epName\n */\nexport const initEp = async (env: Env, epName: string): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_JSEP) {\n    // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\n    const initJsep = require('./jsep/init').init;\n\n    if (epName === 'webgpu') {\n      // perform WebGPU availability check\n      if (typeof navigator === 'undefined' || !navigator.gpu) {\n        throw new Error('WebGPU is not supported in current environment');\n      }\n\n      let adapter = env.webgpu.adapter as GPUAdapter | null;\n      if (!adapter) {\n        // if adapter is not set, request a new adapter.\n        const powerPreference = env.webgpu.powerPreference;\n        if (\n          powerPreference !== undefined &&\n          powerPreference !== 'low-power' &&\n          powerPreference !== 'high-performance'\n        ) {\n          throw new Error(`Invalid powerPreference setting: \"${powerPreference}\"`);\n        }\n        const forceFallbackAdapter = env.webgpu.forceFallbackAdapter;\n        if (forceFallbackAdapter !== undefined && typeof forceFallbackAdapter !== 'boolean') {\n          throw new Error(`Invalid forceFallbackAdapter setting: \"${forceFallbackAdapter}\"`);\n        }\n        adapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });\n        if (!adapter) {\n          throw new Error(\n            'Failed to get GPU adapter. ' +\n              'You may need to enable flag \"--enable-unsafe-webgpu\" if you are using Chrome.',\n          );\n        }\n      } else {\n        // if adapter is set, validate it.\n        if (\n          typeof adapter.limits !== 'object' ||\n          typeof adapter.features !== 'object' ||\n          typeof adapter.requestDevice !== 'function'\n        ) {\n          throw new Error('Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.');\n        }\n      }\n\n      await initJsep('webgpu', getInstance(), env, adapter);\n    }\n    if (epName === 'webnn') {\n      // perform WebNN availability check\n      if (typeof navigator === 'undefined' || !(navigator as unknown as { ml: unknown }).ml) {\n        throw new Error('WebNN is not supported in current environment');\n      }\n\n      await initJsep('webnn', getInstance(), env);\n    }\n  }\n};\n\n// #endregion Initializations\n\n/**\n * valid data locations for input/output tensors.\n */\ntype SupportedTensorDataLocationForInputOutput = 'cpu' | 'cpu-pinned' | 'gpu-buffer' | 'ml-tensor';\n\ntype IOBindingState = {\n  /**\n   * the handle of IO binding.\n   */\n  readonly handle: number;\n\n  /**\n   * the preferred location for each output tensor.\n   *\n   * value is one of 'cpu', 'cpu-pinned', 'gpu-buffer', 'ml-tensor'.\n   */\n  readonly outputPreferredLocations: readonly SupportedTensorDataLocationForInputOutput[];\n\n  /**\n   * enum value of the preferred location for each output tensor.\n   */\n  readonly outputPreferredLocationsEncoded: readonly number[];\n};\n\n/**\n *  tuple elements are: InferenceSession ID; inputNamesUTF8Encoded; outputNamesUTF8Encoded; bindingState\n */\ntype SessionMetadata = [\n  inferenceSessionId: number,\n  inputNamesUTF8Encoded: number[],\n  outputNamesUTF8Encoded: number[],\n  bindingState: IOBindingState | null,\n  enableGraphCapture: boolean,\n  inputOutputBound: boolean,\n];\n\nconst activeSessions = new Map<number, SessionMetadata>();\n\n/**\n * get the input/output count of the session.\n * @param sessionHandle the handle representing the session. should be non-zero.\n * @returns a tuple including 2 numbers, representing the input count and output count.\n */\nconst getSessionInputOutputCount = (sessionHandle: number): [number, number] => {\n  const wasm = getInstance();\n  const stack = wasm.stackSave();\n  try {\n    const dataOffset = wasm.stackAlloc(8);\n    const errorCode = wasm._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + 4);\n    if (errorCode !== 0) {\n      checkLastError(\"Can't get session input/output count.\");\n    }\n    return [wasm.HEAP32[dataOffset / 4], wasm.HEAP32[dataOffset / 4 + 1]];\n  } finally {\n    wasm.stackRestore(stack);\n  }\n};\n\n/**\n * allocate the memory and memcpy the external buffer.\n *\n * @param model - the external buffer containing the model data. Must not be the same buffer as the WASM heap.\n * @returns a 2-elements tuple - the pointer and size of the allocated buffer\n */\nexport const copyFromExternalBuffer = (model: Uint8Array): [number, number] => {\n  const wasm = getInstance();\n  const modelDataOffset = wasm._malloc(model.byteLength);\n  if (modelDataOffset === 0) {\n    throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);\n  }\n  wasm.HEAPU8.set(model, modelDataOffset);\n  return [modelDataOffset, model.byteLength];\n};\n\n/**\n * create an inference session from a model data buffer.\n *\n * @param modelData - either a Uint8Array object representing the model data, or a 2-elements tuple containing the\n *     pointer and size of the model data buffer.\n * @param options an optional session options object.\n * @returns a 3-elements tuple containing [session handle, input names, output names]\n */\nexport const createSession = async (\n  modelData: Uint8Array | SerializableInternalBuffer,\n  options?: InferenceSession.SessionOptions,\n): Promise<SerializableSessionMetadata> => {\n  let modelDataOffset: number, modelDataLength: number;\n  const wasm = getInstance();\n\n  if (Array.isArray(modelData)) {\n    // if model data is an array, it must be a 2-elements tuple containing the pointer and size of the model data\n    [modelDataOffset, modelDataLength] = modelData;\n  } else if (modelData.buffer === wasm.HEAPU8.buffer) {\n    // if model data uses the same buffer as the WASM heap, we don't need to copy it.\n    [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];\n  } else {\n    // otherwise, copy the model data to the WASM heap.\n    [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);\n  }\n\n  let sessionHandle = 0;\n  let sessionOptionsHandle = 0;\n  let ioBindingHandle = 0;\n  let allocs: number[] = [];\n  const inputNamesUTF8Encoded = [];\n  const outputNamesUTF8Encoded = [];\n\n  try {\n    [sessionOptionsHandle, allocs] = setSessionOptions(options);\n\n    if (options?.externalData && wasm.mountExternalData) {\n      const loadingPromises = [];\n      for (const file of options.externalData) {\n        const path = typeof file === 'string' ? file : file.path;\n        loadingPromises.push(\n          loadFile(typeof file === 'string' ? file : file.data).then((data) => {\n            wasm.mountExternalData!(path, data);\n          }),\n        );\n      }\n\n      // wait for all external data files to be loaded\n      await Promise.all(loadingPromises);\n    }\n\n    for (const provider of options?.executionProviders ?? []) {\n      const providerName = typeof provider === 'string' ? provider : provider.name;\n      if (providerName === 'webnn') {\n        wasm.shouldTransferToMLTensor = false;\n        if (wasm.currentContext) {\n          throw new Error('WebNN execution provider is already set.');\n        }\n        if (typeof provider !== 'string') {\n          const webnnOptions = provider as InferenceSession.WebNNExecutionProviderOption;\n          const context = (webnnOptions as InferenceSession.WebNNOptionsWithMLContext)?.context;\n          const gpuDevice = (webnnOptions as InferenceSession.WebNNOptionsWebGpu)?.gpuDevice;\n          const deviceType = (webnnOptions as InferenceSession.WebNNContextOptions)?.deviceType;\n          const numThreads = (webnnOptions as InferenceSession.WebNNContextOptions)?.numThreads;\n          const powerPreference = (webnnOptions as InferenceSession.WebNNContextOptions)?.powerPreference;\n          if (context) {\n            wasm.currentContext = context as MLContext;\n          } else if (gpuDevice) {\n            wasm.currentContext = await navigator.ml.createContext(gpuDevice);\n          } else {\n            wasm.currentContext = await navigator.ml.createContext({ deviceType, numThreads, powerPreference });\n          }\n        } else {\n          wasm.currentContext = await navigator.ml.createContext();\n        }\n        break;\n      }\n    }\n\n    sessionHandle = await wasm._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);\n    if (sessionHandle === 0) {\n      checkLastError(\"Can't create a session.\");\n    }\n\n    // clear current MLContext after session creation\n    if (wasm.currentContext) {\n      wasm.jsepRegisterMLContext!(sessionHandle, wasm.currentContext);\n      wasm.currentContext = undefined;\n      wasm.shouldTransferToMLTensor = true;\n    }\n\n    const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);\n\n    const enableGraphCapture = !!options?.enableGraphCapture;\n\n    const inputNames = [];\n    const outputNames = [];\n    const outputPreferredLocations: SupportedTensorDataLocationForInputOutput[] = [];\n    for (let i = 0; i < inputCount; i++) {\n      const name = wasm._OrtGetInputName(sessionHandle, i);\n      if (name === 0) {\n        checkLastError(\"Can't get an input name.\");\n      }\n      inputNamesUTF8Encoded.push(name);\n      inputNames.push(wasm.UTF8ToString(name));\n    }\n    for (let i = 0; i < outputCount; i++) {\n      const name = wasm._OrtGetOutputName(sessionHandle, i);\n      if (name === 0) {\n        checkLastError(\"Can't get an output name.\");\n      }\n      outputNamesUTF8Encoded.push(name);\n      const nameString = wasm.UTF8ToString(name);\n      outputNames.push(nameString);\n\n      if (!BUILD_DEFS.DISABLE_JSEP) {\n        if (enableGraphCapture && options?.preferredOutputLocation === undefined) {\n          outputPreferredLocations.push('gpu-buffer');\n          continue;\n        }\n        const location =\n          typeof options?.preferredOutputLocation === 'string'\n            ? options.preferredOutputLocation\n            : (options?.preferredOutputLocation?.[nameString] ?? 'cpu');\n        if (location !== 'cpu' && location !== 'cpu-pinned' && location !== 'gpu-buffer' && location !== 'ml-tensor') {\n          throw new Error(`Not supported preferred output location: ${location}.`);\n        }\n        if (enableGraphCapture && location !== 'gpu-buffer') {\n          throw new Error(\n            `Not supported preferred output location: ${location}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`,\n          );\n        }\n        outputPreferredLocations.push(location);\n      }\n    }\n\n    // use IO binding only when at least one output is preferred to be on GPU.\n    let bindingState: IOBindingState | null = null;\n    if (!BUILD_DEFS.DISABLE_JSEP && outputPreferredLocations.some((l) => l === 'gpu-buffer' || l === 'ml-tensor')) {\n      ioBindingHandle = wasm._OrtCreateBinding(sessionHandle);\n      if (ioBindingHandle === 0) {\n        checkLastError(\"Can't create IO binding.\");\n      }\n\n      bindingState = {\n        handle: ioBindingHandle,\n        outputPreferredLocations,\n        outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => dataLocationStringToEnum(l)),\n      };\n    }\n\n    activeSessions.set(sessionHandle, [\n      sessionHandle,\n      inputNamesUTF8Encoded,\n      outputNamesUTF8Encoded,\n      bindingState,\n      enableGraphCapture,\n      false,\n    ]);\n    return [sessionHandle, inputNames, outputNames];\n  } catch (e) {\n    inputNamesUTF8Encoded.forEach((buf) => wasm._OrtFree(buf));\n    outputNamesUTF8Encoded.forEach((buf) => wasm._OrtFree(buf));\n\n    if (ioBindingHandle !== 0) {\n      wasm._OrtReleaseBinding(ioBindingHandle);\n    }\n\n    if (sessionHandle !== 0) {\n      wasm._OrtReleaseSession(sessionHandle);\n    }\n    throw e;\n  } finally {\n    wasm._free(modelDataOffset);\n    if (sessionOptionsHandle !== 0) {\n      wasm._OrtReleaseSessionOptions(sessionOptionsHandle);\n    }\n    allocs.forEach((alloc) => wasm._free(alloc));\n\n    // unmount external data if necessary\n    wasm.unmountExternalData?.();\n  }\n};\n\nexport const releaseSession = (sessionId: number): void => {\n  const wasm = getInstance();\n  const session = activeSessions.get(sessionId);\n  if (!session) {\n    throw new Error(`cannot release session. invalid session id: ${sessionId}`);\n  }\n  const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;\n\n  if (ioBindingState) {\n    if (enableGraphCapture) {\n      wasm._OrtClearBoundOutputs(ioBindingState.handle);\n    }\n    wasm._OrtReleaseBinding(ioBindingState.handle);\n  }\n\n  wasm.jsepOnReleaseSession?.(sessionId);\n\n  inputNamesUTF8Encoded.forEach((buf) => wasm._OrtFree(buf));\n  outputNamesUTF8Encoded.forEach((buf) => wasm._OrtFree(buf));\n  wasm._OrtReleaseSession(sessionHandle);\n  activeSessions.delete(sessionId);\n};\n\nexport const prepareInputOutputTensor = (\n  tensor: TensorMetadata | null,\n  tensorHandles: number[],\n  allocs: number[],\n  sessionId: number,\n  index: number,\n  enableGraphCapture = false,\n): void => {\n  if (!tensor) {\n    tensorHandles.push(0);\n    return;\n  }\n\n  const wasm = getInstance();\n\n  const dataType = tensor[0];\n  const dims = tensor[1];\n  const location = tensor[3];\n\n  let rawData: number;\n  let dataByteLength: number;\n\n  if (dataType === 'string' && (location === 'gpu-buffer' || location === 'ml-tensor')) {\n    throw new Error('String tensor is not supported on GPU.');\n  }\n\n  if (enableGraphCapture && location !== 'gpu-buffer') {\n    throw new Error(\n      `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`,\n    );\n  }\n\n  if (location === 'gpu-buffer') {\n    const gpuBuffer = tensor[2].gpuBuffer as GPUBuffer;\n    dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims)!;\n\n    const registerBuffer = wasm.jsepRegisterBuffer;\n    if (!registerBuffer) {\n      throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');\n    }\n    rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);\n  } else if (location === 'ml-tensor') {\n    const mlTensor = tensor[2].mlTensor as MLTensor;\n    dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims)!;\n\n    const registerMLTensor = wasm.jsepRegisterMLTensor;\n    if (!registerMLTensor) {\n      throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');\n    }\n    rawData = registerMLTensor(mlTensor, tensorDataTypeStringToEnum(dataType), dims);\n  } else {\n    const data = tensor[2];\n\n    if (Array.isArray(data)) {\n      // string tensor\n      dataByteLength = 4 * data.length;\n      rawData = wasm._malloc(dataByteLength);\n      allocs.push(rawData);\n      let dataIndex = rawData / 4;\n      for (let i = 0; i < data.length; i++) {\n        if (typeof data[i] !== 'string') {\n          throw new TypeError(`tensor data at index ${i} is not a string`);\n        }\n        wasm.HEAPU32[dataIndex++] = allocWasmString(data[i], allocs);\n      }\n    } else {\n      dataByteLength = data.byteLength;\n      rawData = wasm._malloc(dataByteLength);\n      allocs.push(rawData);\n      wasm.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);\n    }\n  }\n\n  const stack = wasm.stackSave();\n  const dimsOffset = wasm.stackAlloc(4 * dims.length);\n  try {\n    let dimIndex = dimsOffset / 4;\n    dims.forEach((d) => (wasm.HEAP32[dimIndex++] = d));\n    const tensor = wasm._OrtCreateTensor(\n      tensorDataTypeStringToEnum(dataType),\n      rawData,\n      dataByteLength,\n      dimsOffset,\n      dims.length,\n      dataLocationStringToEnum(location),\n    );\n    if (tensor === 0) {\n      checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);\n    }\n    tensorHandles.push(tensor);\n  } finally {\n    wasm.stackRestore(stack);\n  }\n};\n\n/**\n * perform inference run\n */\nexport const run = async (\n  sessionId: number,\n  inputIndices: number[],\n  inputTensors: TensorMetadata[],\n  outputIndices: number[],\n  outputTensors: Array<TensorMetadata | null>,\n  options: InferenceSession.RunOptions,\n): Promise<TensorMetadata[]> => {\n  const wasm = getInstance();\n  const session = activeSessions.get(sessionId);\n  if (!session) {\n    throw new Error(`cannot run inference. invalid session id: ${sessionId}`);\n  }\n  const sessionHandle = session[0];\n  const inputNamesUTF8Encoded = session[1];\n  const outputNamesUTF8Encoded = session[2];\n  const ioBindingState = session[3];\n  const enableGraphCapture = session[4];\n  const inputOutputBound = session[5];\n\n  const inputCount = inputIndices.length;\n  const outputCount = outputIndices.length;\n\n  let runOptionsHandle = 0;\n  let runOptionsAllocs: number[] = [];\n\n  const inputTensorHandles: number[] = [];\n  const outputTensorHandles: number[] = [];\n  const inputOutputAllocs: number[] = [];\n\n  const beforeRunStack = wasm.stackSave();\n  const inputValuesOffset = wasm.stackAlloc(inputCount * 4);\n  const inputNamesOffset = wasm.stackAlloc(inputCount * 4);\n  const outputValuesOffset = wasm.stackAlloc(outputCount * 4);\n  const outputNamesOffset = wasm.stackAlloc(outputCount * 4);\n\n  try {\n    // WebNN backend needs the active session to check MLTensors with the current context.\n    wasm.jsepOnRunStart?.(sessionHandle);\n\n    [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);\n\n    // create input tensors\n    for (let i = 0; i < inputCount; i++) {\n      prepareInputOutputTensor(\n        inputTensors[i],\n        inputTensorHandles,\n        inputOutputAllocs,\n        sessionId,\n        inputIndices[i],\n        enableGraphCapture,\n      );\n    }\n\n    // create output tensors\n    for (let i = 0; i < outputCount; i++) {\n      prepareInputOutputTensor(\n        outputTensors[i],\n        outputTensorHandles,\n        inputOutputAllocs,\n        sessionId,\n        inputCount + outputIndices[i],\n        enableGraphCapture,\n      );\n    }\n\n    let inputValuesIndex = inputValuesOffset / 4;\n    let inputNamesIndex = inputNamesOffset / 4;\n    let outputValuesIndex = outputValuesOffset / 4;\n    let outputNamesIndex = outputNamesOffset / 4;\n    for (let i = 0; i < inputCount; i++) {\n      wasm.HEAPU32[inputValuesIndex++] = inputTensorHandles[i];\n      wasm.HEAPU32[inputNamesIndex++] = inputNamesUTF8Encoded[inputIndices[i]];\n    }\n    for (let i = 0; i < outputCount; i++) {\n      wasm.HEAPU32[outputValuesIndex++] = outputTensorHandles[i];\n      wasm.HEAPU32[outputNamesIndex++] = outputNamesUTF8Encoded[outputIndices[i]];\n    }\n\n    if (!BUILD_DEFS.DISABLE_JSEP && ioBindingState && !inputOutputBound) {\n      const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;\n\n      if (inputNamesUTF8Encoded.length !== inputCount) {\n        throw new Error(\n          `input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`,\n        );\n      }\n\n      // process inputs\n      for (let i = 0; i < inputCount; i++) {\n        const index = inputIndices[i];\n        const errorCode = await wasm._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);\n        if (errorCode !== 0) {\n          checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);\n        }\n      }\n\n      // process pre-allocated outputs\n      for (let i = 0; i < outputCount; i++) {\n        const index = outputIndices[i];\n        const location = outputTensors[i]?.[3]; // undefined means output is not pre-allocated.\n\n        if (location) {\n          // output is pre-allocated. bind the tensor.\n          const errorCode = wasm._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);\n          if (errorCode !== 0) {\n            checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);\n          }\n        } else {\n          // output is not pre-allocated. reset preferred location.\n          const errorCode = wasm._OrtBindOutput(\n            handle,\n            outputNamesUTF8Encoded[index],\n            0,\n            outputPreferredLocationsEncoded[index],\n          );\n          if (errorCode !== 0) {\n            checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);\n          }\n        }\n      }\n      activeSessions.set(sessionId, [\n        sessionHandle,\n        inputNamesUTF8Encoded,\n        outputNamesUTF8Encoded,\n        ioBindingState,\n        enableGraphCapture,\n        true,\n      ]);\n    }\n\n    let errorCode: number;\n    if (!BUILD_DEFS.DISABLE_JSEP && ioBindingState) {\n      errorCode = await wasm._OrtRunWithBinding(\n        sessionHandle,\n        ioBindingState.handle,\n        outputCount,\n        outputValuesOffset,\n        runOptionsHandle,\n      );\n    } else {\n      errorCode = await wasm._OrtRun(\n        sessionHandle,\n        inputNamesOffset,\n        inputValuesOffset,\n        inputCount,\n        outputNamesOffset,\n        outputCount,\n        outputValuesOffset,\n        runOptionsHandle,\n      );\n    }\n\n    if (errorCode !== 0) {\n      checkLastError('failed to call OrtRun().');\n    }\n\n    const output: TensorMetadata[] = [];\n\n    for (let i = 0; i < outputCount; i++) {\n      const tensor = wasm.HEAPU32[outputValuesOffset / 4 + i];\n      if (tensor === outputTensorHandles[i]) {\n        // output tensor is pre-allocated. no need to copy data.\n        output.push(outputTensors[i]!);\n        continue;\n      }\n\n      const beforeGetTensorDataStack = wasm.stackSave();\n      // stack allocate 4 pointer value\n      const tensorDataOffset = wasm.stackAlloc(4 * 4);\n\n      let keepOutputTensor = false;\n      let type: Tensor.Type | undefined,\n        dataOffset = 0;\n      try {\n        const errorCode = wasm._OrtGetTensorData(\n          tensor,\n          tensorDataOffset,\n          tensorDataOffset + 4,\n          tensorDataOffset + 8,\n          tensorDataOffset + 12,\n        );\n        if (errorCode !== 0) {\n          checkLastError(`Can't access output tensor data on index ${i}.`);\n        }\n        let tensorDataIndex = tensorDataOffset / 4;\n        const dataType = wasm.HEAPU32[tensorDataIndex++];\n        dataOffset = wasm.HEAPU32[tensorDataIndex++];\n        const dimsOffset = wasm.HEAPU32[tensorDataIndex++];\n        const dimsLength = wasm.HEAPU32[tensorDataIndex++];\n        const dims = [];\n        for (let i = 0; i < dimsLength; i++) {\n          dims.push(wasm.HEAPU32[dimsOffset / 4 + i]);\n        }\n        wasm._OrtFree(dimsOffset);\n\n        const size = dims.reduce((a, b) => a * b, 1);\n        type = tensorDataTypeEnumToString(dataType);\n\n        const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];\n\n        if (type === 'string') {\n          if (preferredLocation === 'gpu-buffer' || preferredLocation === 'ml-tensor') {\n            throw new Error('String tensor is not supported on GPU.');\n          }\n          const stringData: string[] = [];\n          let dataIndex = dataOffset / 4;\n          for (let i = 0; i < size; i++) {\n            const offset = wasm.HEAPU32[dataIndex++];\n            const maxBytesToRead = i === size - 1 ? undefined : wasm.HEAPU32[dataIndex] - offset;\n            stringData.push(wasm.UTF8ToString(offset, maxBytesToRead));\n          }\n          output.push([type, dims, stringData, 'cpu']);\n        } else {\n          // If a certain output's preferred location is GPU but the tensor is empty, we still need to create a CPU\n          // tensor for it. There is no mapping GPU buffer for an empty tensor.\n          if (preferredLocation === 'gpu-buffer' && size > 0) {\n            const getBuffer = wasm.jsepGetBuffer;\n            if (!getBuffer) {\n              throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');\n            }\n            const gpuBuffer = getBuffer(dataOffset);\n            const bufferSize = calculateTensorSizeInBytes(dataType, size);\n            if (bufferSize === undefined || !isGpuBufferSupportedType(type)) {\n              throw new Error(`Unsupported data type: ${type}`);\n            }\n\n            // do not release the tensor right now. it will be released when user calls tensor.dispose().\n            keepOutputTensor = true;\n\n            output.push([\n              type,\n              dims,\n              {\n                gpuBuffer,\n                download: wasm.jsepCreateDownloader!(gpuBuffer, bufferSize, type),\n                dispose: () => {\n                  wasm._OrtReleaseTensor(tensor);\n                },\n              },\n              'gpu-buffer',\n            ]);\n          } else if (preferredLocation === 'ml-tensor' && size > 0) {\n            const ensureTensor = wasm.jsepEnsureTensor;\n            if (!ensureTensor) {\n              throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');\n            }\n            const tensorSize = calculateTensorSizeInBytes(dataType, size);\n            if (tensorSize === undefined || !isMLTensorSupportedType(type)) {\n              throw new Error(`Unsupported data type: ${type}`);\n            }\n\n            // If the graph has been partitioned, the output tensor may have not been created. For this reason, we use\n            // ensureTensor to get/create the MLTensor. In which case, we don't need to copy the data if a new tensor\n            // has been created.\n            const mlTensor = await ensureTensor(dataOffset, dataType, dims, false);\n\n            // do not release the tensor right now. it will be released when user calls tensor.dispose().\n            keepOutputTensor = true;\n\n            output.push([\n              type,\n              dims,\n              {\n                mlTensor,\n                download: wasm.jsepCreateMLTensorDownloader!(dataOffset, type),\n                dispose: () => {\n                  wasm.jsepReleaseTensorId!(dataOffset);\n                  wasm._OrtReleaseTensor(tensor);\n                },\n              },\n              'ml-tensor',\n            ]);\n          } else {\n            const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);\n            const data = new typedArrayConstructor(size);\n            new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(\n              wasm.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength),\n            );\n            output.push([type, dims, data, 'cpu']);\n          }\n        }\n      } finally {\n        wasm.stackRestore(beforeGetTensorDataStack);\n        if (type === 'string' && dataOffset) {\n          wasm._free(dataOffset);\n        }\n        if (!keepOutputTensor) {\n          wasm._OrtReleaseTensor(tensor);\n        }\n      }\n    }\n\n    if (ioBindingState && !enableGraphCapture) {\n      wasm._OrtClearBoundOutputs(ioBindingState.handle);\n      activeSessions.set(sessionId, [\n        sessionHandle,\n        inputNamesUTF8Encoded,\n        outputNamesUTF8Encoded,\n        ioBindingState,\n        enableGraphCapture,\n        false,\n      ]);\n    }\n    return output;\n  } finally {\n    wasm.stackRestore(beforeRunStack);\n\n    inputTensorHandles.forEach((v) => wasm._OrtReleaseTensor(v));\n    outputTensorHandles.forEach((v) => wasm._OrtReleaseTensor(v));\n    inputOutputAllocs.forEach((p) => wasm._free(p));\n\n    if (runOptionsHandle !== 0) {\n      wasm._OrtReleaseRunOptions(runOptionsHandle);\n    }\n    runOptionsAllocs.forEach((p) => wasm._free(p));\n  }\n};\n\n/**\n * end profiling\n */\nexport const endProfiling = (sessionId: number): void => {\n  const wasm = getInstance();\n  const session = activeSessions.get(sessionId);\n  if (!session) {\n    throw new Error('invalid session id');\n  }\n  const sessionHandle = session[0];\n\n  // profile file name is not used yet, but it must be freed.\n  const profileFileName = wasm._OrtEndProfiling(sessionHandle);\n  if (profileFileName === 0) {\n    checkLastError(\"Can't get an profile file name.\");\n  }\n  wasm._OrtFree(profileFileName);\n};\n\nexport const extractTransferableBuffers = (tensors: readonly SerializableTensorMetadata[]): ArrayBufferLike[] => {\n  const buffers: ArrayBufferLike[] = [];\n  for (const tensor of tensors) {\n    const data = tensor[2];\n    if (!Array.isArray(data) && 'buffer' in data) {\n      buffers.push(data.buffer);\n    }\n  }\n  return buffers;\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { env, InferenceSession } from 'onnxruntime-common';\n\nimport {\n  OrtWasmMessage,\n  SerializableInternalBuffer,\n  SerializableSessionMetadata,\n  SerializableTensorMetadata,\n  TensorMetadata,\n} from './proxy-messages';\nimport * as core from './wasm-core-impl';\nimport { initializeWebAssembly } from './wasm-factory';\nimport { importProxyWorker } from './wasm-utils-import';\n\nconst isProxy = (): boolean => !!env.wasm.proxy && typeof document !== 'undefined';\nlet proxyWorker: Worker | undefined;\nlet initializing = false;\nlet initialized = false;\nlet aborted = false;\nlet temporaryObjectUrl: string | undefined;\n\ntype PromiseCallbacks<T = void> = [resolve: (result: T) => void, reject: (reason: unknown) => void];\nlet initWasmCallbacks: PromiseCallbacks;\nconst queuedCallbacks: Map<OrtWasmMessage['type'], Array<PromiseCallbacks<unknown>>> = new Map();\n\nconst enqueueCallbacks = (type: OrtWasmMessage['type'], callbacks: PromiseCallbacks<unknown>): void => {\n  const queue = queuedCallbacks.get(type);\n  if (queue) {\n    queue.push(callbacks);\n  } else {\n    queuedCallbacks.set(type, [callbacks]);\n  }\n};\n\nconst ensureWorker = (): void => {\n  if (initializing || !initialized || aborted || !proxyWorker) {\n    throw new Error('worker not ready');\n  }\n};\n\nconst onProxyWorkerMessage = (ev: MessageEvent<OrtWasmMessage>): void => {\n  switch (ev.data.type) {\n    case 'init-wasm':\n      initializing = false;\n      if (ev.data.err) {\n        aborted = true;\n        initWasmCallbacks[1](ev.data.err);\n      } else {\n        initialized = true;\n        initWasmCallbacks[0]();\n      }\n      if (temporaryObjectUrl) {\n        URL.revokeObjectURL(temporaryObjectUrl);\n        temporaryObjectUrl = undefined;\n      }\n      break;\n    case 'init-ep':\n    case 'copy-from':\n    case 'create':\n    case 'release':\n    case 'run':\n    case 'end-profiling': {\n      const callbacks = queuedCallbacks.get(ev.data.type)!;\n      if (ev.data.err) {\n        callbacks.shift()![1](ev.data.err);\n      } else {\n        callbacks.shift()![0](ev.data.out!);\n      }\n      break;\n    }\n    default:\n  }\n};\n\nexport const initializeWebAssemblyAndOrtRuntime = async (): Promise<void> => {\n  if (initialized) {\n    return;\n  }\n  if (initializing) {\n    throw new Error(\"multiple calls to 'initWasm()' detected.\");\n  }\n  if (aborted) {\n    throw new Error(\"previous call to 'initWasm()' failed.\");\n  }\n\n  initializing = true;\n\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    return new Promise<void>((resolve, reject) => {\n      proxyWorker?.terminate();\n\n      void importProxyWorker().then(([objectUrl, worker]) => {\n        try {\n          proxyWorker = worker;\n          proxyWorker.onerror = (ev: ErrorEvent) => reject(ev);\n          proxyWorker.onmessage = onProxyWorkerMessage;\n          initWasmCallbacks = [resolve, reject];\n          const message: OrtWasmMessage = { type: 'init-wasm', in: env };\n          proxyWorker.postMessage(message);\n          temporaryObjectUrl = objectUrl;\n        } catch (e) {\n          reject(e);\n        }\n      }, reject);\n    });\n  } else {\n    try {\n      await initializeWebAssembly(env.wasm);\n      await core.initRuntime(env);\n      initialized = true;\n    } catch (e) {\n      aborted = true;\n      throw e;\n    } finally {\n      initializing = false;\n    }\n  }\n};\n\nexport const initializeOrtEp = async (epName: string): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<void>((resolve, reject) => {\n      enqueueCallbacks('init-ep', [resolve, reject]);\n      const message: OrtWasmMessage = { type: 'init-ep', in: { epName, env } };\n      proxyWorker!.postMessage(message);\n    });\n  } else {\n    await core.initEp(env, epName);\n  }\n};\n\nexport const copyFromExternalBuffer = async (buffer: Uint8Array): Promise<SerializableInternalBuffer> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<SerializableInternalBuffer>((resolve, reject) => {\n      enqueueCallbacks('copy-from', [resolve, reject]);\n      const message: OrtWasmMessage = { type: 'copy-from', in: { buffer } };\n      proxyWorker!.postMessage(message, [buffer.buffer]);\n    });\n  } else {\n    return core.copyFromExternalBuffer(buffer);\n  }\n};\n\nexport const createSession = async (\n  model: SerializableInternalBuffer | Uint8Array,\n  options?: InferenceSession.SessionOptions,\n): Promise<SerializableSessionMetadata> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    // check unsupported options\n    if (options?.preferredOutputLocation) {\n      throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');\n    }\n    ensureWorker();\n    return new Promise<SerializableSessionMetadata>((resolve, reject) => {\n      enqueueCallbacks('create', [resolve, reject]);\n      const message: OrtWasmMessage = { type: 'create', in: { model, options: { ...options } } };\n      const transferable: Transferable[] = [];\n      if (model instanceof Uint8Array) {\n        transferable.push(model.buffer);\n      }\n      proxyWorker!.postMessage(message, transferable);\n    });\n  } else {\n    return core.createSession(model, options);\n  }\n};\n\nexport const releaseSession = async (sessionId: number): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<void>((resolve, reject) => {\n      enqueueCallbacks('release', [resolve, reject]);\n      const message: OrtWasmMessage = { type: 'release', in: sessionId };\n      proxyWorker!.postMessage(message);\n    });\n  } else {\n    core.releaseSession(sessionId);\n  }\n};\n\nexport const run = async (\n  sessionId: number,\n  inputIndices: number[],\n  inputs: TensorMetadata[],\n  outputIndices: number[],\n  outputs: Array<TensorMetadata | null>,\n  options: InferenceSession.RunOptions,\n): Promise<TensorMetadata[]> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    // check inputs location\n    if (inputs.some((t) => t[3] !== 'cpu')) {\n      throw new Error('input tensor on GPU is not supported for proxy.');\n    }\n    // check outputs location\n    if (outputs.some((t) => t)) {\n      throw new Error('pre-allocated output tensor is not supported for proxy.');\n    }\n    ensureWorker();\n    return new Promise<SerializableTensorMetadata[]>((resolve, reject) => {\n      enqueueCallbacks('run', [resolve, reject]);\n      const serializableInputs = inputs as SerializableTensorMetadata[]; // every input is on CPU.\n      const message: OrtWasmMessage = {\n        type: 'run',\n        in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options },\n      };\n      proxyWorker!.postMessage(message, core.extractTransferableBuffers(serializableInputs));\n    });\n  } else {\n    return core.run(sessionId, inputIndices, inputs, outputIndices, outputs, options);\n  }\n};\n\nexport const endProfiling = async (sessionId: number): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<void>((resolve, reject) => {\n      enqueueCallbacks('end-profiling', [resolve, reject]);\n      const message: OrtWasmMessage = { type: 'end-profiling', in: sessionId };\n      proxyWorker!.postMessage(message);\n    });\n  } else {\n    core.endProfiling(sessionId);\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {\n  InferenceSession,\n  InferenceSessionHandler,\n  SessionHandler,\n  Tensor,\n  TRACE_FUNC_BEGIN,\n  TRACE_FUNC_END,\n} from 'onnxruntime-common';\n\nimport { SerializableInternalBuffer, TensorMetadata } from './proxy-messages';\nimport { copyFromExternalBuffer, createSession, endProfiling, releaseSession, run } from './proxy-wrapper';\nimport { isGpuBufferSupportedType, isMLTensorSupportedType } from './wasm-common';\nimport { isNode } from './wasm-utils-env';\nimport { loadFile } from './wasm-utils-load-file';\n\nexport const encodeTensorMetadata = (tensor: Tensor, getName: () => string): TensorMetadata => {\n  switch (tensor.location) {\n    case 'cpu':\n      return [tensor.type, tensor.dims, tensor.data, 'cpu'];\n    case 'gpu-buffer':\n      return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, 'gpu-buffer'];\n    case 'ml-tensor':\n      return [tensor.type, tensor.dims, { mlTensor: tensor.mlTensor }, 'ml-tensor'];\n    default:\n      throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);\n  }\n};\n\nexport const decodeTensorMetadata = (tensor: TensorMetadata): Tensor => {\n  switch (tensor[3]) {\n    case 'cpu':\n      return new Tensor(tensor[0], tensor[2], tensor[1]);\n    case 'gpu-buffer': {\n      const dataType = tensor[0];\n      if (!isGpuBufferSupportedType(dataType)) {\n        throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);\n      }\n      const { gpuBuffer, download, dispose } = tensor[2];\n      return Tensor.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });\n    }\n    case 'ml-tensor': {\n      const dataType = tensor[0];\n      if (!isMLTensorSupportedType(dataType)) {\n        throw new Error(`not supported data type: ${dataType} for deserializing MLTensor tensor`);\n      }\n      const { mlTensor, download, dispose } = tensor[2];\n      return Tensor.fromMLTensor(mlTensor, { dataType, dims: tensor[1], download, dispose });\n    }\n    default:\n      throw new Error(`invalid data location: ${tensor[3]}`);\n  }\n};\n\nexport class OnnxruntimeWebAssemblySessionHandler implements InferenceSessionHandler {\n  private sessionId: number;\n\n  inputNames: string[];\n  outputNames: string[];\n\n  async fetchModelAndCopyToWasmMemory(path: string): Promise<SerializableInternalBuffer> {\n    // fetch model from url and move to wasm heap.\n    return copyFromExternalBuffer(await loadFile(path));\n  }\n\n  async loadModel(pathOrBuffer: string | Uint8Array, options?: InferenceSession.SessionOptions): Promise<void> {\n    TRACE_FUNC_BEGIN();\n    let model: Parameters<typeof createSession>[0];\n\n    if (typeof pathOrBuffer === 'string') {\n      if (isNode) {\n        // node\n        model = await loadFile(pathOrBuffer);\n      } else {\n        // browser\n        // fetch model and copy to wasm heap.\n        model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);\n      }\n    } else {\n      model = pathOrBuffer;\n    }\n\n    [this.sessionId, this.inputNames, this.outputNames] = await createSession(model, options);\n    TRACE_FUNC_END();\n  }\n\n  async dispose(): Promise<void> {\n    return releaseSession(this.sessionId);\n  }\n\n  async run(\n    feeds: SessionHandler.FeedsType,\n    fetches: SessionHandler.FetchesType,\n    options: InferenceSession.RunOptions,\n  ): Promise<SessionHandler.ReturnType> {\n    TRACE_FUNC_BEGIN();\n    const inputArray: Tensor[] = [];\n    const inputIndices: number[] = [];\n    Object.entries(feeds).forEach((kvp) => {\n      const name = kvp[0];\n      const tensor = kvp[1];\n      const index = this.inputNames.indexOf(name);\n      if (index === -1) {\n        throw new Error(`invalid input '${name}'`);\n      }\n      inputArray.push(tensor);\n      inputIndices.push(index);\n    });\n\n    const outputArray: Array<Tensor | null> = [];\n    const outputIndices: number[] = [];\n    Object.entries(fetches).forEach((kvp) => {\n      const name = kvp[0];\n      const tensor = kvp[1];\n      const index = this.outputNames.indexOf(name);\n      if (index === -1) {\n        throw new Error(`invalid output '${name}'`);\n      }\n      outputArray.push(tensor);\n      outputIndices.push(index);\n    });\n\n    const inputs = inputArray.map((t, i) =>\n      encodeTensorMetadata(t, () => `input \"${this.inputNames[inputIndices[i]]}\"`),\n    );\n    const outputs = outputArray.map((t, i) =>\n      t ? encodeTensorMetadata(t, () => `output \"${this.outputNames[outputIndices[i]]}\"`) : null,\n    );\n\n    const results = await run(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);\n\n    const resultMap: SessionHandler.ReturnType = {};\n    for (let i = 0; i < results.length; i++) {\n      resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);\n    }\n    TRACE_FUNC_END();\n    return resultMap;\n  }\n\n  startProfiling(): void {\n    // TODO: implement profiling\n  }\n\n  endProfiling(): void {\n    void endProfiling(this.sessionId);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Backend, env, InferenceSession, InferenceSessionHandler } from 'onnxruntime-common';\n\nimport { initializeOrtEp, initializeWebAssemblyAndOrtRuntime } from './wasm/proxy-wrapper';\nimport { OnnxruntimeWebAssemblySessionHandler } from './wasm/session-handler-inference';\nimport { scriptSrc } from './wasm/wasm-utils-import';\n\n/**\n * This function initializes all flags for WebAssembly.\n *\n * Those flags are accessible from `ort.env.wasm`. Users are allow to set those flags before the first inference session\n * being created, to override default value.\n */\nexport const initializeFlags = (): void => {\n  if (typeof env.wasm.initTimeout !== 'number' || env.wasm.initTimeout < 0) {\n    env.wasm.initTimeout = 0;\n  }\n\n  if (env.wasm.simd === false) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'Deprecated property \"env.wasm.simd\" is set to false. ' +\n        'non-SIMD build is no longer provided, and this setting will be ignored.',\n    );\n  }\n\n  if (typeof env.wasm.proxy !== 'boolean') {\n    env.wasm.proxy = false;\n  }\n\n  if (typeof env.wasm.trace !== 'boolean') {\n    env.wasm.trace = false;\n  }\n\n  if (typeof env.wasm.numThreads !== 'number' || !Number.isInteger(env.wasm.numThreads) || env.wasm.numThreads <= 0) {\n    // The following logic only applies when `ort.env.wasm.numThreads` is not set by user. We will always honor user's\n    // setting if it is provided.\n\n    // Browser: when crossOriginIsolated is false, SharedArrayBuffer is not available so WebAssembly threads will not\n    // work. In this case, we will set numThreads to 1.\n    //\n    // There is an exception: when the browser is configured to force-enable SharedArrayBuffer (e.g. Chromuim with\n    // --enable-features=SharedArrayBuffer), it is possible that `self.crossOriginIsolated` is false and\n    // SharedArrayBuffer is available at the same time. This is usually for testing. In this case,  we will still set\n    // numThreads to 1 here. If we want to enable multi-threading in test, we should set `ort.env.wasm.numThreads` to a\n    // value greater than 1.\n    if (typeof self !== 'undefined' && !self.crossOriginIsolated) {\n      env.wasm.numThreads = 1;\n    } else {\n      const numCpuLogicalCores =\n        typeof navigator === 'undefined' ? require('node:os').cpus().length : navigator.hardwareConcurrency;\n      env.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));\n    }\n  }\n\n  if (!BUILD_DEFS.DISABLE_DYNAMIC_IMPORT) {\n    // overwrite wasm paths override if not set\n    if (env.wasm.wasmPaths === undefined && scriptSrc && scriptSrc.indexOf('blob:') !== 0) {\n      env.wasm.wasmPaths = scriptSrc.substring(0, scriptSrc.lastIndexOf('/') + 1);\n    }\n  }\n};\n\nexport class OnnxruntimeWebAssemblyBackend implements Backend {\n  /**\n   * This function initializes the WebAssembly backend.\n   *\n   * This function will be called only once for each backend name. It will be called the first time when\n   * `ort.InferenceSession.create()` is called with a registered backend name.\n   *\n   * @param backendName - the registered backend name.\n   */\n  async init(backendName: string): Promise<void> {\n    // populate wasm flags\n    initializeFlags();\n\n    // init wasm\n    await initializeWebAssemblyAndOrtRuntime();\n\n    // performe EP specific initialization\n    await initializeOrtEp(backendName);\n  }\n  createInferenceSessionHandler(\n    path: string,\n    options?: InferenceSession.SessionOptions,\n  ): Promise<InferenceSessionHandler>;\n  createInferenceSessionHandler(\n    buffer: Uint8Array,\n    options?: InferenceSession.SessionOptions,\n  ): Promise<InferenceSessionHandler>;\n  async createInferenceSessionHandler(\n    pathOrBuffer: string | Uint8Array,\n    options?: InferenceSession.SessionOptions,\n  ): Promise<InferenceSessionHandler> {\n    const handler = new OnnxruntimeWebAssemblySessionHandler();\n    await handler.loadModel(pathOrBuffer, options);\n    return Promise.resolve(handler);\n  }\n}\n\nexport const wasmBackend = new OnnxruntimeWebAssemblyBackend();\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/* eslint-disable @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports */\n\n// We use \"require\" instead of \"import\" here because import statement must be put in top level. Our current code does\n// not allow bundler to tree-shaking code as expected because some codes are treated as having side effects.\n// So we import code inside the if-clause to allow bundler remove the code safely.\n\nexport * from 'onnxruntime-common';\nimport * as ort from 'onnxruntime-common';\nexport default ort;\n\nimport { registerBackend, env } from 'onnxruntime-common';\nimport { version } from './version';\n\nif (!BUILD_DEFS.DISABLE_WEBGL) {\n  const onnxjsBackend = require('./backend-onnxjs').onnxjsBackend;\n  registerBackend('webgl', onnxjsBackend, -10);\n}\n\nif (!BUILD_DEFS.DISABLE_WASM) {\n  const wasmBackend = require('./backend-wasm').wasmBackend;\n  if (!BUILD_DEFS.DISABLE_JSEP) {\n    registerBackend('webgpu', wasmBackend, 5);\n    registerBackend('webnn', wasmBackend, 5);\n  }\n  registerBackend('cpu', wasmBackend, 10);\n  registerBackend('wasm', wasmBackend, 10);\n}\n\nObject.defineProperty(env.versions, 'web', { value: version, enumerable: true });\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// This file is generated by /js/scripts/update-version.ts\n// Do not modify file content manually.\n\nexport const version = '1.20.1';\n"],"mappings":"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,KAAK,IAAI,KAAK,GAAG,GAAG,GAAG,KAAK,KAAK,KAAK,IAAI,KAAK,GAAG,GAAG,GAAG,KAAK,KAAK,KAAK,IAAI,KAAK,GAAG,GAAG,GAAG,KAAK,KAAK,KAAK,IAAI,KAAK,GAAG,GAAG,GAAG,KAAK,KAAK,KAAK,IAAI,KAAK,KAAK,KAAK,KAAK,GAAG,GAAG,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,KAAK,EAC5nC,CAAC,CAAC,GAAG,CAAC,CAAC,EA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}